{"version":3,"names":[],"mappings":"","sources":["app.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],2:[function(require,module,exports){\n/*\n * Copyright 2012-2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define, location) {\n\t'use strict';\n\n\tvar undef;\n\n\tdefine(function (require) {\n\n\t\tvar mixin, origin, urlRE, absoluteUrlRE, fullyQualifiedUrlRE;\n\n\t\tmixin = require('./util/mixin');\n\n\t\turlRE = /([a-z][a-z0-9\\+\\-\\.]*:)\\/\\/([^@]+@)?(([^:\\/]+)(:([0-9]+))?)?(\\/[^?#]*)?(\\?[^#]*)?(#\\S*)?/i;\n\t\tabsoluteUrlRE = /^([a-z][a-z0-9\\-\\+\\.]*:\\/\\/|\\/)/i;\n\t\tfullyQualifiedUrlRE = /([a-z][a-z0-9\\+\\-\\.]*:)\\/\\/([^@]+@)?(([^:\\/]+)(:([0-9]+))?)?\\//i;\n\n\t\t/**\n\t\t * Apply params to the template to create a URL.\n\t\t *\n\t\t * Parameters that are not applied directly to the template, are appended\n\t\t * to the URL as query string parameters.\n\t\t *\n\t\t * @param {string} template the URI template\n\t\t * @param {Object} params parameters to apply to the template\n\t\t * @return {string} the resulting URL\n\t\t */\n\t\tfunction buildUrl(template, params) {\n\t\t\t// internal builder to convert template with params.\n\t\t\tvar url, name, queryStringParams, re;\n\n\t\t\turl = template;\n\t\t\tqueryStringParams = {};\n\n\t\t\tif (params) {\n\t\t\t\tfor (name in params) {\n\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\tre = new RegExp('\\\\{' + name + '\\\\}');\n\t\t\t\t\tif (re.test(url)) {\n\t\t\t\t\t\turl = url.replace(re, encodeURIComponent(params[name]), 'g');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tqueryStringParams[name] = params[name];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (name in queryStringParams) {\n\t\t\t\t\turl += url.indexOf('?') === -1 ? '?' : '&';\n\t\t\t\t\turl += encodeURIComponent(name);\n\t\t\t\t\tif (queryStringParams[name] !== null && queryStringParams[name] !== undefined) {\n\t\t\t\t\t\turl += '=';\n\t\t\t\t\t\turl += encodeURIComponent(queryStringParams[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\n\t\tfunction startsWith(str, test) {\n\t\t\treturn str.indexOf(test) === 0;\n\t\t}\n\n\t\t/**\n\t\t * Create a new URL Builder\n\t\t *\n\t\t * @param {string|UrlBuilder} template the base template to build from, may be another UrlBuilder\n\t\t * @param {Object} [params] base parameters\n\t\t * @constructor\n\t\t */\n\t\tfunction UrlBuilder(template, params) {\n\t\t\tif (!(this instanceof UrlBuilder)) {\n\t\t\t\t// invoke as a constructor\n\t\t\t\treturn new UrlBuilder(template, params);\n\t\t\t}\n\n\t\t\tif (template instanceof UrlBuilder) {\n\t\t\t\tthis._template = template.template;\n\t\t\t\tthis._params = mixin({}, this._params, params);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._template = (template || '').toString();\n\t\t\t\tthis._params = params || {};\n\t\t\t}\n\t\t}\n\n\t\tUrlBuilder.prototype = {\n\n\t\t\t/**\n\t\t\t * Create a new UrlBuilder instance that extends the current builder.\n\t\t\t * The current builder is unmodified.\n\t\t\t *\n\t\t\t * @param {string} [template] URL template to append to the current template\n\t\t\t * @param {Object} [params] params to combine with current params.  New params override existing params\n\t\t\t * @return {UrlBuilder} the new builder\n\t\t\t */\n\t\t\tappend: function (template,  params) {\n\t\t\t\t// TODO consider query strings and fragments\n\t\t\t\treturn new UrlBuilder(this._template + template, mixin({}, this._params, params));\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Create a new UrlBuilder with a fully qualified URL based on the\n\t\t\t * window's location or base href and the current templates relative URL.\n\t\t\t *\n\t\t\t * Path variables are preserved.\n\t\t\t *\n\t\t\t * *Browser only*\n\t\t\t *\n\t\t\t * @return {UrlBuilder} the fully qualified URL template\n\t\t\t */\n\t\t\tfullyQualify: function () {\n\t\t\t\tif (!location) { return this; }\n\t\t\t\tif (this.isFullyQualified()) { return this; }\n\n\t\t\t\tvar template = this._template;\n\n\t\t\t\tif (startsWith(template, '//')) {\n\t\t\t\t\ttemplate = origin.protocol + template;\n\t\t\t\t}\n\t\t\t\telse if (startsWith(template, '/')) {\n\t\t\t\t\ttemplate = origin.origin + template;\n\t\t\t\t}\n\t\t\t\telse if (!this.isAbsolute()) {\n\t\t\t\t\ttemplate = origin.origin + origin.pathname.substring(0, origin.pathname.lastIndexOf('/') + 1);\n\t\t\t\t}\n\n\t\t\t\tif (template.indexOf('/', 8) === -1) {\n\t\t\t\t\t// default the pathname to '/'\n\t\t\t\t\ttemplate = template + '/';\n\t\t\t\t}\n\n\t\t\t\treturn new UrlBuilder(template, this._params);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * True if the URL is absolute\n\t\t\t *\n\t\t\t * @return {boolean}\n\t\t\t */\n\t\t\tisAbsolute: function () {\n\t\t\t\treturn absoluteUrlRE.test(this.build());\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * True if the URL is fully qualified\n\t\t\t *\n\t\t\t * @return {boolean}\n\t\t\t */\n\t\t\tisFullyQualified: function () {\n\t\t\t\treturn fullyQualifiedUrlRE.test(this.build());\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * True if the URL is cross origin. The protocol, host and port must not be\n\t\t\t * the same in order to be cross origin,\n\t\t\t *\n\t\t\t * @return {boolean}\n\t\t\t */\n\t\t\tisCrossOrigin: function () {\n\t\t\t\tif (!origin) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar url = this.parts();\n\t\t\t\treturn url.protocol !== origin.protocol ||\n\t\t\t\t       url.hostname !== origin.hostname ||\n\t\t\t\t       url.port !== origin.port;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Split a URL into its consituent parts following the naming convention of\n\t\t\t * 'window.location'. One difference is that the port will contain the\n\t\t\t * protocol default if not specified.\n\t\t\t *\n\t\t\t * @see https://developer.mozilla.org/en-US/docs/DOM/window.location\n\t\t\t *\n\t\t\t * @returns {Object} a 'window.location'-like object\n\t\t\t */\n\t\t\tparts: function () {\n\t\t\t\t/*jshint maxcomplexity:20 */\n\t\t\t\tvar url, parts;\n\t\t\t\turl = this.fullyQualify().build().match(urlRE);\n\t\t\t\tparts = {\n\t\t\t\t\thref: url[0],\n\t\t\t\t\tprotocol: url[1],\n\t\t\t\t\thost: url[3] || '',\n\t\t\t\t\thostname: url[4] || '',\n\t\t\t\t\tport: url[6],\n\t\t\t\t\tpathname: url[7] || '',\n\t\t\t\t\tsearch: url[8] || '',\n\t\t\t\t\thash: url[9] || ''\n\t\t\t\t};\n\t\t\t\tparts.origin = parts.protocol + '//' + parts.host;\n\t\t\t\tparts.port = parts.port || (parts.protocol === 'https:' ? '443' : parts.protocol === 'http:' ? '80' : '');\n\t\t\t\treturn parts;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Expand the template replacing path variables with parameters\n\t\t\t *\n\t\t\t * @param {Object} [params] params to combine with current params.  New params override existing params\n\t\t\t * @return {string} the expanded URL\n\t\t\t */\n\t\t\tbuild: function (params) {\n\t\t\t\treturn buildUrl(this._template, mixin({}, this._params, params));\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @see build\n\t\t\t */\n\t\t\ttoString: function () {\n\t\t\t\treturn this.build();\n\t\t\t}\n\n\t\t};\n\n\t\torigin = location ? new UrlBuilder(location.href).parts() : undef;\n\n\t\treturn UrlBuilder;\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); },\n\ttypeof window !== 'undefined' ? window.location : void 0\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./util/mixin\":22}],3:[function(require,module,exports){\n/*\n * Copyright 2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar rest = require('./client/default'),\n\t\t    browser = require('./client/xhr');\n\n\t\trest.setPlatformDefaultClient(browser);\n\n\t\treturn rest;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./client/default\":5,\"./client/xhr\":6}],4:[function(require,module,exports){\n/*\n * Copyright 2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\t/**\n\t\t * Add common helper methods to a client impl\n\t\t *\n\t\t * @param {function} impl the client implementation\n\t\t * @param {Client} [target] target of this client, used when wrapping other clients\n\t\t * @returns {Client} the client impl with additional methods\n\t\t */\n\t\treturn function client(impl, target) {\n\n\t\t\tif (target) {\n\n\t\t\t\t/**\n\t\t\t\t * @returns {Client} the target client\n\t\t\t\t */\n\t\t\t\timpl.skip = function skip() {\n\t\t\t\t\treturn target;\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Allow a client to easily be wrapped by an interceptor\n\t\t\t *\n\t\t\t * @param {Interceptor} interceptor the interceptor to wrap this client with\n\t\t\t * @param [config] configuration for the interceptor\n\t\t\t * @returns {Client} the newly wrapped client\n\t\t\t */\n\t\t\timpl.wrap = function wrap(interceptor, config) {\n\t\t\t\treturn interceptor(impl, config);\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * @deprecated\n\t\t\t */\n\t\t\timpl.chain = function chain() {\n\t\t\t\tif (typeof console !== 'undefined') {\n\t\t\t\t\tconsole.log('rest.js: client.chain() is deprecated, use client.wrap() instead');\n\t\t\t\t}\n\n\t\t\t\treturn impl.wrap.apply(this, arguments);\n\t\t\t};\n\n\t\t\treturn impl;\n\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],5:[function(require,module,exports){\n/*\n * Copyright 2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tvar undef;\n\n\tdefine(function (require) {\n\n\t\t/**\n\t\t * Plain JS Object containing properties that represent an HTTP request.\n\t\t *\n\t\t * Depending on the capabilities of the underlying client, a request\n\t\t * may be cancelable. If a request may be canceled, the client will add\n\t\t * a canceled flag and cancel function to the request object. Canceling\n\t\t * the request will put the response into an error state.\n\t\t *\n\t\t * @field {string} [method='GET'] HTTP method, commonly GET, POST, PUT, DELETE or HEAD\n\t\t * @field {string|UrlBuilder} [path=''] path template with optional path variables\n\t\t * @field {Object} [params] parameters for the path template and query string\n\t\t * @field {Object} [headers] custom HTTP headers to send, in addition to the clients default headers\n\t\t * @field [entity] the HTTP entity, common for POST or PUT requests\n\t\t * @field {boolean} [canceled] true if the request has been canceled, set by the client\n\t\t * @field {Function} [cancel] cancels the request if invoked, provided by the client\n\t\t * @field {Client} [originator] the client that first handled this request, provided by the interceptor\n\t\t *\n\t\t * @class Request\n\t\t */\n\n\t\t/**\n\t\t * Plain JS Object containing properties that represent an HTTP response\n\t\t *\n\t\t * @field {Object} [request] the request object as received by the root client\n\t\t * @field {Object} [raw] the underlying request object, like XmlHttpRequest in a browser\n\t\t * @field {number} [status.code] status code of the response (i.e. 200, 404)\n\t\t * @field {string} [status.text] status phrase of the response\n\t\t * @field {Object] [headers] response headers hash of normalized name, value pairs\n\t\t * @field [entity] the response body\n\t\t *\n\t\t * @class Response\n\t\t */\n\n\t\t/**\n\t\t * HTTP client particularly suited for RESTful operations.\n\t\t *\n\t\t * @field {function} wrap wraps this client with a new interceptor returning the wrapped client\n\t\t *\n\t\t * @param {Request} the HTTP request\n\t\t * @returns {ResponsePromise<Response>} a promise the resolves to the HTTP response\n\t\t *\n\t\t * @class Client\n\t\t */\n\n\t\t /**\n\t\t  * Extended when.js Promises/A+ promise with HTTP specific helpers\n\t\t  *q\n\t\t  * @method entity promise for the HTTP entity\n\t\t  * @method status promise for the HTTP status code\n\t\t  * @method headers promise for the HTTP response headers\n\t\t  * @method header promise for a specific HTTP response header\n\t\t  *\n\t\t  * @class ResponsePromise\n\t\t  * @extends Promise\n\t\t  */\n\n\t\tvar client, target, platformDefault;\n\n\t\tclient = require('../client');\n\n\t\t/**\n\t\t * Make a request with the default client\n\t\t * @param {Request} the HTTP request\n\t\t * @returns {Promise<Response>} a promise the resolves to the HTTP response\n\t\t */\n\t\tfunction defaultClient() {\n\t\t\treturn target.apply(undef, arguments);\n\t\t}\n\n\t\t/**\n\t\t * Change the default client\n\t\t * @param {Client} client the new default client\n\t\t */\n\t\tdefaultClient.setDefaultClient = function setDefaultClient(client) {\n\t\t\ttarget = client;\n\t\t};\n\n\t\t/**\n\t\t * Obtain a direct reference to the current default client\n\t\t * @returns {Client} the default client\n\t\t */\n\t\tdefaultClient.getDefaultClient = function getDefaultClient() {\n\t\t\treturn target;\n\t\t};\n\n\t\t/**\n\t\t * Reset the default client to the platform default\n\t\t */\n\t\tdefaultClient.resetDefaultClient = function resetDefaultClient() {\n\t\t\ttarget = platformDefault;\n\t\t};\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdefaultClient.setPlatformDefaultClient = function setPlatformDefaultClient(client) {\n\t\t\tif (platformDefault) {\n\t\t\t\tthrow new Error('Unable to redefine platformDefaultClient');\n\t\t\t}\n\t\t\ttarget = platformDefault = client;\n\t\t};\n\n\t\treturn client(defaultClient);\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../client\":4}],6:[function(require,module,exports){\n/*\n * Copyright 2012-2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define, global) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar when, UrlBuilder, normalizeHeaderName, responsePromise, client, headerSplitRE;\n\n\t\twhen = require('when');\n\t\tUrlBuilder = require('../UrlBuilder');\n\t\tnormalizeHeaderName = require('../util/normalizeHeaderName');\n\t\tresponsePromise = require('../util/responsePromise');\n\t\tclient = require('../client');\n\n\t\t// according to the spec, the line break is '\\r\\n', but doesn't hold true in practice\n\t\theaderSplitRE = /[\\r|\\n]+/;\n\n\t\tfunction parseHeaders(raw) {\n\t\t\t// Note: Set-Cookie will be removed by the browser\n\t\t\tvar headers = {};\n\n\t\t\tif (!raw) { return headers; }\n\n\t\t\traw.trim().split(headerSplitRE).forEach(function (header) {\n\t\t\t\tvar boundary, name, value;\n\t\t\t\tboundary = header.indexOf(':');\n\t\t\t\tname = normalizeHeaderName(header.substring(0, boundary).trim());\n\t\t\t\tvalue = header.substring(boundary + 1).trim();\n\t\t\t\tif (headers[name]) {\n\t\t\t\t\tif (Array.isArray(headers[name])) {\n\t\t\t\t\t\t// add to an existing array\n\t\t\t\t\t\theaders[name].push(value);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// convert single value to array\n\t\t\t\t\t\theaders[name] = [headers[name], value];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// new, single value\n\t\t\t\t\theaders[name] = value;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn headers;\n\t\t}\n\n\t\tfunction safeMixin(target, source) {\n\t\t\tObject.keys(source || {}).forEach(function (prop) {\n\t\t\t\t// make sure the property already exists as\n\t\t\t\t// IE 6 will blow up if we add a new prop\n\t\t\t\tif (source.hasOwnProperty(prop) && prop in target) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttarget[prop] = source[prop];\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t// ignore, expected for some properties at some points in the request lifecycle\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn target;\n\t\t}\n\n\t\treturn client(function xhr(request) {\n\t\t\treturn responsePromise.promise(function (resolve, reject) {\n\t\t\t\t/*jshint maxcomplexity:20 */\n\n\t\t\t\tvar client, method, url, headers, entity, headerName, response, XMLHttpRequest;\n\n\t\t\t\trequest = typeof request === 'string' ? { path: request } : request || {};\n\t\t\t\tresponse = { request: request };\n\n\t\t\t\tif (request.canceled) {\n\t\t\t\t\tresponse.error = 'precanceled';\n\t\t\t\t\treject(response);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tXMLHttpRequest = request.engine || global.XMLHttpRequest;\n\t\t\t\tif (!XMLHttpRequest) {\n\t\t\t\t\treject({ request: request, error: 'xhr-not-available' });\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tentity = request.entity;\n\t\t\t\trequest.method = request.method || (entity ? 'POST' : 'GET');\n\t\t\t\tmethod = request.method;\n\t\t\t\turl = new UrlBuilder(request.path || '', request.params).build();\n\n\t\t\t\ttry {\n\t\t\t\t\tclient = response.raw = new XMLHttpRequest();\n\n\t\t\t\t\t// mixin extra request properties before and after opening the request as some properties require being set at different phases of the request\n\t\t\t\t\tsafeMixin(client, request.mixin);\n\t\t\t\t\tclient.open(method, url, true);\n\t\t\t\t\tsafeMixin(client, request.mixin);\n\n\t\t\t\t\theaders = request.headers;\n\t\t\t\t\tfor (headerName in headers) {\n\t\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\t\tif (headerName === 'Content-Type' && headers[headerName] === 'multipart/form-data') {\n\t\t\t\t\t\t\t// XMLHttpRequest generates its own Content-Type header with the\n\t\t\t\t\t\t\t// appropriate multipart boundary when sending multipart/form-data.\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclient.setRequestHeader(headerName, headers[headerName]);\n\t\t\t\t\t}\n\n\t\t\t\t\trequest.canceled = false;\n\t\t\t\t\trequest.cancel = function cancel() {\n\t\t\t\t\t\trequest.canceled = true;\n\t\t\t\t\t\tclient.abort();\n\t\t\t\t\t\treject(response);\n\t\t\t\t\t};\n\n\t\t\t\t\tclient.onreadystatechange = function (/* e */) {\n\t\t\t\t\t\tif (request.canceled) { return; }\n\t\t\t\t\t\tif (client.readyState === (XMLHttpRequest.DONE || 4)) {\n\t\t\t\t\t\t\tresponse.status = {\n\t\t\t\t\t\t\t\tcode: client.status,\n\t\t\t\t\t\t\t\ttext: client.statusText\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tresponse.headers = parseHeaders(client.getAllResponseHeaders());\n\t\t\t\t\t\t\tresponse.entity = client.responseText;\n\n\t\t\t\t\t\t\tif (response.status.code > 0) {\n\t\t\t\t\t\t\t\t// check status code as readystatechange fires before error event\n\t\t\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// give the error callback a chance to fire before resolving\n\t\t\t\t\t\t\t\t// requests for file:// URLs do not have a status code\n\t\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t\t\t\t}, 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tclient.onerror = function (/* e */) {\n\t\t\t\t\t\t\tresponse.error = 'loaderror';\n\t\t\t\t\t\t\treject(response);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t// IE 6 will not support error handling\n\t\t\t\t\t}\n\n\t\t\t\t\tclient.send(entity);\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tresponse.error = 'loaderror';\n\t\t\t\t\treject(response);\n\t\t\t\t}\n\n\t\t\t});\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); },\n\ttypeof window !== 'undefined' ? window : void 0\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../UrlBuilder\":2,\"../client\":4,\"../util/normalizeHeaderName\":23,\"../util/responsePromise\":24,\"when\":122}],7:[function(require,module,exports){\n/*\n * Copyright 2012-2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar defaultClient, mixin, responsePromise, client, when;\n\n\t\tdefaultClient = require('./client/default');\n\t\tmixin = require('./util/mixin');\n\t\tresponsePromise = require('./util/responsePromise');\n\t\tclient = require('./client');\n\t\twhen = require('when');\n\n\t\t/**\n\t\t * Interceptors have the ability to intercept the request and/org response\n\t\t * objects.  They may augment, prune, transform or replace the\n\t\t * request/response as needed.  Clients may be composed by wrapping\n\t\t * together multiple interceptors.\n\t\t *\n\t\t * Configured interceptors are functional in nature.  Wrapping a client in\n\t\t * an interceptor will not affect the client, merely the data that flows in\n\t\t * and out of that client.  A common configuration can be created once and\n\t\t * shared; specialization can be created by further wrapping that client\n\t\t * with custom interceptors.\n\t\t *\n\t\t * @param {Client} [target] client to wrap\n\t\t * @param {Object} [config] configuration for the interceptor, properties will be specific to the interceptor implementation\n\t\t * @returns {Client} A client wrapped with the interceptor\n\t\t *\n\t\t * @class Interceptor\n\t\t */\n\n\t\tfunction defaultInitHandler(config) {\n\t\t\treturn config;\n\t\t}\n\n\t\tfunction defaultRequestHandler(request /*, config, meta */) {\n\t\t\treturn request;\n\t\t}\n\n\t\tfunction defaultResponseHandler(response /*, config, meta */) {\n\t\t\treturn response;\n\t\t}\n\n\t\tfunction race(promisesOrValues) {\n\t\t\t// this function is different than when.any as the first to reject also wins\n\t\t\treturn when.promise(function (resolve, reject) {\n\t\t\t\tpromisesOrValues.forEach(function (promiseOrValue) {\n\t\t\t\t\twhen(promiseOrValue, resolve, reject);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Alternate return type for the request handler that allows for more complex interactions.\n\t\t *\n\t\t * @param properties.request the traditional request return object\n\t\t * @param {Promise} [properties.abort] promise that resolves if/when the request is aborted\n\t\t * @param {Client} [properties.client] override the defined client with an alternate client\n\t\t * @param [properties.response] response for the request, short circuit the request\n\t\t */\n\t\tfunction ComplexRequest(properties) {\n\t\t\tif (!(this instanceof ComplexRequest)) {\n\t\t\t\t// in case users forget the 'new' don't mix into the interceptor\n\t\t\t\treturn new ComplexRequest(properties);\n\t\t\t}\n\t\t\tmixin(this, properties);\n\t\t}\n\n\t\t/**\n\t\t * Create a new interceptor for the provided handlers.\n\t\t *\n\t\t * @param {Function} [handlers.init] one time intialization, must return the config object\n\t\t * @param {Function} [handlers.request] request handler\n\t\t * @param {Function} [handlers.response] response handler regardless of error state\n\t\t * @param {Function} [handlers.success] response handler when the request is not in error\n\t\t * @param {Function} [handlers.error] response handler when the request is in error, may be used to 'unreject' an error state\n\t\t * @param {Function} [handlers.client] the client to use if otherwise not specified, defaults to platform default client\n\t\t *\n\t\t * @returns {Interceptor}\n\t\t */\n\t\tfunction interceptor(handlers) {\n\n\t\t\tvar initHandler, requestHandler, successResponseHandler, errorResponseHandler;\n\n\t\t\thandlers = handlers || {};\n\n\t\t\tinitHandler            = handlers.init    || defaultInitHandler;\n\t\t\trequestHandler         = handlers.request || defaultRequestHandler;\n\t\t\tsuccessResponseHandler = handlers.success || handlers.response || defaultResponseHandler;\n\t\t\terrorResponseHandler   = handlers.error   || function () {\n\t\t\t\t// Propagate the rejection, with the result of the handler\n\t\t\t\treturn when((handlers.response || defaultResponseHandler).apply(this, arguments), when.reject, when.reject);\n\t\t\t};\n\n\t\t\treturn function (target, config) {\n\n\t\t\t\tif (typeof target === 'object') {\n\t\t\t\t\tconfig = target;\n\t\t\t\t}\n\t\t\t\tif (typeof target !== 'function') {\n\t\t\t\t\ttarget = handlers.client || defaultClient;\n\t\t\t\t}\n\n\t\t\t\tconfig = initHandler(config || {});\n\n\t\t\t\tfunction interceptedClient(request) {\n\t\t\t\t\tvar context, meta;\n\t\t\t\t\tcontext = {};\n\t\t\t\t\tmeta = { 'arguments': Array.prototype.slice.call(arguments), client: interceptedClient };\n\t\t\t\t\trequest = typeof request === 'string' ? { path: request } : request || {};\n\t\t\t\t\trequest.originator = request.originator || interceptedClient;\n\t\t\t\t\treturn responsePromise(\n\t\t\t\t\t\trequestHandler.call(context, request, config, meta),\n\t\t\t\t\t\tfunction (request) {\n\t\t\t\t\t\t\tvar response, abort, next;\n\t\t\t\t\t\t\tnext = target;\n\t\t\t\t\t\t\tif (request instanceof ComplexRequest) {\n\t\t\t\t\t\t\t\t// unpack request\n\t\t\t\t\t\t\t\tabort = request.abort;\n\t\t\t\t\t\t\t\tnext = request.client || next;\n\t\t\t\t\t\t\t\tresponse = request.response;\n\t\t\t\t\t\t\t\t// normalize request, must be last\n\t\t\t\t\t\t\t\trequest = request.request;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresponse = response || when(request, function (request) {\n\t\t\t\t\t\t\t\treturn when(\n\t\t\t\t\t\t\t\t\tnext(request),\n\t\t\t\t\t\t\t\t\tfunction (response) {\n\t\t\t\t\t\t\t\t\t\treturn successResponseHandler.call(context, response, config, meta);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfunction (response) {\n\t\t\t\t\t\t\t\t\t\treturn errorResponseHandler.call(context, response, config, meta);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn abort ? race([response, abort]) : response;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (error) {\n\t\t\t\t\t\t\treturn when.reject({ request: request, error: error });\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn client(interceptedClient, target);\n\t\t\t};\n\t\t}\n\n\t\tinterceptor.ComplexRequest = ComplexRequest;\n\n\t\treturn interceptor;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./client\":4,\"./client/default\":5,\"./util/mixin\":22,\"./util/responsePromise\":24,\"when\":122}],8:[function(require,module,exports){\n/*\n * Copyright 2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, mixinUtil, defaulter;\n\n\t\tinterceptor = require('../interceptor');\n\t\tmixinUtil = require('../util/mixin');\n\n\t\tdefaulter = (function () {\n\n\t\t\tfunction mixin(prop, target, defaults) {\n\t\t\t\tif (prop in target || prop in defaults) {\n\t\t\t\t\ttarget[prop] = mixinUtil({}, defaults[prop], target[prop]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction copy(prop, target, defaults) {\n\t\t\t\tif (prop in defaults && !(prop in target)) {\n\t\t\t\t\ttarget[prop] = defaults[prop];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar mappings = {\n\t\t\t\tmethod: copy,\n\t\t\t\tpath: copy,\n\t\t\t\tparams: mixin,\n\t\t\t\theaders: mixin,\n\t\t\t\tentity: copy,\n\t\t\t\tmixin: mixin\n\t\t\t};\n\n\t\t\treturn function (target, defaults) {\n\t\t\t\tfor (var prop in mappings) {\n\t\t\t\t\t/*jshint forin: false */\n\t\t\t\t\tmappings[prop](prop, target, defaults);\n\t\t\t\t}\n\t\t\t\treturn target;\n\t\t\t};\n\n\t\t}());\n\n\t\t/**\n\t\t * Provide default values for a request. These values will be applied to the\n\t\t * request if the request object does not already contain an explicit value.\n\t\t *\n\t\t * For 'params', 'headers', and 'mixin', individual values are mixed in with the\n\t\t * request's values. The result is a new object representiing the combined\n\t\t * request and config values. Neither input object is mutated.\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {string} [config.method] the default method\n\t\t * @param {string} [config.path] the default path\n\t\t * @param {Object} [config.params] the default params, mixed with the request's existing params\n\t\t * @param {Object} [config.headers] the default headers, mixed with the request's existing headers\n\t\t * @param {Object} [config.mixin] the default \"mixins\" (http/https options), mixed with the request's existing \"mixins\"\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\trequest: function handleRequest(request, config) {\n\t\t\t\treturn defaulter(request, config);\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../interceptor\":7,\"../util/mixin\":22}],9:[function(require,module,exports){\n/*\n * Copyright 2012-2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, when;\n\n\t\tinterceptor = require('../interceptor');\n\t\twhen = require('when');\n\n\t\t/**\n\t\t * Rejects the response promise based on the status code.\n\t\t *\n\t\t * Codes greater than or equal to the provided value are rejected.  Default\n\t\t * value 400.\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {number} [config.code=400] code to indicate a rejection\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\tinit: function (config) {\n\t\t\t\tconfig.code = config.code || 400;\n\t\t\t\treturn config;\n\t\t\t},\n\t\t\tresponse: function (response, config) {\n\t\t\t\tif (response.status && response.status.code >= config.code) {\n\t\t\t\t\treturn when.reject(response);\n\t\t\t\t}\n\t\t\t\treturn response;\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../interceptor\":7,\"when\":122}],10:[function(require,module,exports){\n/*\n * Copyright 2012-2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, mime, registry, noopConverter, when;\n\n\t\tinterceptor = require('../interceptor');\n\t\tmime = require('../mime');\n\t\tregistry = require('../mime/registry');\n\t\twhen = require('when');\n\n\t\tnoopConverter = {\n\t\t\tread: function (obj) { return obj; },\n\t\t\twrite: function (obj) { return obj; }\n\t\t};\n\n\t\t/**\n\t\t * MIME type support for request and response entities.  Entities are\n\t\t * (de)serialized using the converter for the MIME type.\n\t\t *\n\t\t * Request entities are converted using the desired converter and the\n\t\t * 'Accept' request header prefers this MIME.\n\t\t *\n\t\t * Response entities are converted based on the Content-Type response header.\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {string} [config.mime='text/plain'] MIME type to encode the request\n\t\t *   entity\n\t\t * @param {string} [config.accept] Accept header for the request\n\t\t * @param {Client} [config.client=<request.originator>] client passed to the\n\t\t *   converter, defaults to the client originating the request\n\t\t * @param {Registry} [config.registry] MIME registry, defaults to the root\n\t\t *   registry\n\t\t * @param {boolean} [config.permissive] Allow an unkown request MIME type\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\tinit: function (config) {\n\t\t\t\tconfig.registry = config.registry || registry;\n\t\t\t\treturn config;\n\t\t\t},\n\t\t\trequest: function (request, config) {\n\t\t\t\tvar type, headers;\n\n\t\t\t\theaders = request.headers || (request.headers = {});\n\t\t\t\ttype = mime.parse(headers['Content-Type'] = headers['Content-Type'] || config.mime || 'text/plain');\n\t\t\t\theaders.Accept = headers.Accept || config.accept || type.raw + ', application/json;q=0.8, text/plain;q=0.5, */*;q=0.2';\n\n\t\t\t\tif (!('entity' in request)) {\n\t\t\t\t\treturn request;\n\t\t\t\t}\n\n\t\t\t\treturn config.registry.lookup(type).otherwise(function () {\n\t\t\t\t\t// failed to resolve converter\n\t\t\t\t\tif (config.permissive) {\n\t\t\t\t\t\treturn noopConverter;\n\t\t\t\t\t}\n\t\t\t\t\tthrow 'mime-unknown';\n\t\t\t\t}).then(function (converter) {\n\t\t\t\t\tvar client = config.client || request.originator;\n\n\t\t\t\t\treturn when.attempt(converter.write, request.entity, { client: client, request: request, mime: type, registry: config.registry })\n\t\t\t\t\t\t.otherwise(function() {\n\t\t\t\t\t\t\tthrow 'mime-serialization';\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(function(entity) {\n\t\t\t\t\t\t\trequest.entity = entity;\n\t\t\t\t\t\t\treturn request;\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t\tresponse: function (response, config) {\n\t\t\t\tif (!(response.headers && response.headers['Content-Type'] && response.entity)) {\n\t\t\t\t\treturn response;\n\t\t\t\t}\n\n\t\t\t\tvar type = mime.parse(response.headers['Content-Type']);\n\n\t\t\t\treturn config.registry.lookup(type).otherwise(function () { return noopConverter; }).then(function (converter) {\n\t\t\t\t\tvar client = config.client || response.request && response.request.originator;\n\n\t\t\t\t\treturn when.attempt(converter.read, response.entity, { client: client, response: response, mime: type, registry: config.registry })\n\t\t\t\t\t\t.otherwise(function (e) {\n\t\t\t\t\t\t\tresponse.error = 'mime-deserialization';\n\t\t\t\t\t\t\tresponse.cause = e;\n\t\t\t\t\t\t\tthrow response;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(function (entity) {\n\t\t\t\t\t\t\tresponse.entity = entity;\n\t\t\t\t\t\t\treturn response;\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../interceptor\":7,\"../mime\":13,\"../mime/registry\":14,\"when\":122}],11:[function(require,module,exports){\n/*\n * Copyright 2012-2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, UrlBuilder;\n\n\t\tinterceptor = require('../interceptor');\n\t\tUrlBuilder = require('../UrlBuilder');\n\n\t\tfunction startsWith(str, prefix) {\n\t\t\treturn str.indexOf(prefix) === 0;\n\t\t}\n\n\t\tfunction endsWith(str, suffix) {\n\t\t\treturn str.lastIndexOf(suffix) + suffix.length === str.length;\n\t\t}\n\n\t\t/**\n\t\t * Prefixes the request path with a common value.\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {number} [config.prefix] path prefix\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\trequest: function (request, config) {\n\t\t\t\tvar path;\n\n\t\t\t\tif (config.prefix && !(new UrlBuilder(request.path).isFullyQualified())) {\n\t\t\t\t\tpath = config.prefix;\n\t\t\t\t\tif (request.path) {\n\t\t\t\t\t\tif (!endsWith(path, '/') && !startsWith(request.path, '/')) {\n\t\t\t\t\t\t\t// add missing '/' between path sections\n\t\t\t\t\t\t\tpath += '/';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpath += request.path;\n\t\t\t\t\t}\n\t\t\t\t\trequest.path = path;\n\t\t\t\t}\n\n\t\t\t\treturn request;\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../UrlBuilder\":2,\"../interceptor\":7}],12:[function(require,module,exports){\n/*\n * Copyright 2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, uriTemplate, mixin;\n\n\t\tinterceptor = require('../interceptor');\n\t\turiTemplate = require('../util/uriTemplate');\n\t\tmixin = require('../util/mixin');\n\n\t\t/**\n\t\t * Applies request params to the path as a URI Template\n\t\t *\n\t\t * Params are removed from the request object, as they have been consumed.\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {Object} [config.params] default param values\n\t\t * @param {string} [config.template] default template\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\tinit: function (config) {\n\t\t\t\tconfig.params = config.params || {};\n\t\t\t\tconfig.template = config.template || '';\n\t\t\t\treturn config;\n\t\t\t},\n\t\t\trequest: function (request, config) {\n\t\t\t\tvar template, params;\n\n\t\t\t\ttemplate = request.path || config.template;\n\t\t\t\tparams = mixin({}, request.params, config.params);\n\n\t\t\t\trequest.path = uriTemplate.expand(template, params);\n\t\t\t\tdelete request.params;\n\n\t\t\t\treturn request;\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../interceptor\":7,\"../util/mixin\":22,\"../util/uriTemplate\":26}],13:[function(require,module,exports){\n/*\n* Copyright 2014 the original author or authors\n* @license MIT, see LICENSE.txt for details\n*\n* @author Scott Andrews\n*/\n\n(function (define) {\n\t'use strict';\n\n\tvar undef;\n\n\tdefine(function (/* require */) {\n\n\t\t/**\n\t\t * Parse a MIME type into it's constituent parts\n\t\t *\n\t\t * @param {string} mime MIME type to parse\n\t\t * @return {{\n\t\t *   {string} raw the original MIME type\n\t\t *   {string} type the type and subtype\n\t\t *   {string} [suffix] mime suffix, including the plus, if any\n\t\t *   {Object} params key/value pair of attributes\n\t\t * }}\n\t\t */\n\t\tfunction parse(mime) {\n\t\t\tvar params, type;\n\n\t\t\tparams = mime.split(';');\n\t\t\ttype = params[0].trim().split('+');\n\n\t\t\treturn {\n\t\t\t\traw: mime,\n\t\t\t\ttype: type[0],\n\t\t\t\tsuffix: type[1] ? '+' + type[1] : '',\n\t\t\t\tparams: params.slice(1).reduce(function (params, pair) {\n\t\t\t\t\tpair = pair.split('=');\n\t\t\t\t\tparams[pair[0].trim()] = pair[1] ? pair[1].trim() : undef;\n\t\t\t\t\treturn params;\n\t\t\t\t}, {})\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tparse: parse\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],14:[function(require,module,exports){\n/*\n * Copyright 2012-2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar mime, when, registry;\n\n\t\tmime = require('../mime');\n\t\twhen = require('when');\n\n\t\tfunction Registry(mimes) {\n\n\t\t\t/**\n\t\t\t * Lookup the converter for a MIME type\n\t\t\t *\n\t\t\t * @param {string} type the MIME type\n\t\t\t * @return a promise for the converter\n\t\t\t */\n\t\t\tthis.lookup = function lookup(type) {\n\t\t\t\tvar parsed;\n\n\t\t\t\tparsed = typeof type === 'string' ? mime.parse(type) : type;\n\n\t\t\t\tif (mimes[parsed.raw]) {\n\t\t\t\t\treturn mimes[parsed.raw];\n\t\t\t\t}\n\t\t\t\tif (mimes[parsed.type + parsed.suffix]) {\n\t\t\t\t\treturn mimes[parsed.type + parsed.suffix];\n\t\t\t\t}\n\t\t\t\tif (mimes[parsed.type]) {\n\t\t\t\t\treturn mimes[parsed.type];\n\t\t\t\t}\n\t\t\t\tif (mimes[parsed.suffix]) {\n\t\t\t\t\treturn mimes[parsed.suffix];\n\t\t\t\t}\n\n\t\t\t\treturn when.reject(new Error('Unable to locate converter for mime \"' + parsed.raw + '\"'));\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Create a late dispatched proxy to the target converter.\n\t\t\t *\n\t\t\t * Common when a converter is registered under multiple names and\n\t\t\t * should be kept in sync if updated.\n\t\t\t *\n\t\t\t * @param {string} type mime converter to dispatch to\n\t\t\t * @returns converter whose read/write methods target the desired mime converter\n\t\t\t */\n\t\t\tthis.delegate = function delegate(type) {\n\t\t\t\treturn {\n\t\t\t\t\tread: function () {\n\t\t\t\t\t\tvar args = arguments;\n\t\t\t\t\t\treturn this.lookup(type).then(function (converter) {\n\t\t\t\t\t\t\treturn converter.read.apply(this, args);\n\t\t\t\t\t\t}.bind(this));\n\t\t\t\t\t}.bind(this),\n\t\t\t\t\twrite: function () {\n\t\t\t\t\t\tvar args = arguments;\n\t\t\t\t\t\treturn this.lookup(type).then(function (converter) {\n\t\t\t\t\t\t\treturn converter.write.apply(this, args);\n\t\t\t\t\t\t}.bind(this));\n\t\t\t\t\t}.bind(this)\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Register a custom converter for a MIME type\n\t\t\t *\n\t\t\t * @param {string} type the MIME type\n\t\t\t * @param converter the converter for the MIME type\n\t\t\t * @return a promise for the converter\n\t\t\t */\n\t\t\tthis.register = function register(type, converter) {\n\t\t\t\tmimes[type] = when(converter);\n\t\t\t\treturn mimes[type];\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Create a child registry whoes registered converters remain local, while\n\t\t\t * able to lookup converters from its parent.\n\t\t\t *\n\t\t\t * @returns child MIME registry\n\t\t\t */\n\t\t\tthis.child = function child() {\n\t\t\t\treturn new Registry(Object.create(mimes));\n\t\t\t};\n\n\t\t}\n\n\t\tregistry = new Registry({});\n\n\t\t// include provided serializers\n\t\tregistry.register('application/hal', require('./type/application/hal'));\n\t\tregistry.register('application/json', require('./type/application/json'));\n\t\tregistry.register('application/x-www-form-urlencoded', require('./type/application/x-www-form-urlencoded'));\n\t\tregistry.register('multipart/form-data', require('./type/multipart/form-data'));\n\t\tregistry.register('text/plain', require('./type/text/plain'));\n\n\t\tregistry.register('+json', registry.delegate('application/json'));\n\n\t\treturn registry;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../mime\":13,\"./type/application/hal\":15,\"./type/application/json\":16,\"./type/application/x-www-form-urlencoded\":17,\"./type/multipart/form-data\":18,\"./type/text/plain\":19,\"when\":122}],15:[function(require,module,exports){\n/*\n * Copyright 2013-2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar pathPrefix, template, find, lazyPromise, responsePromise, when;\n\n\t\tpathPrefix = require('../../../interceptor/pathPrefix');\n\t\ttemplate = require('../../../interceptor/template');\n\t\tfind = require('../../../util/find');\n\t\tlazyPromise = require('../../../util/lazyPromise');\n\t\tresponsePromise = require('../../../util/responsePromise');\n\t\twhen = require('when');\n\n\t\tfunction defineProperty(obj, name, value) {\n\t\t\tObject.defineProperty(obj, name, {\n\t\t\t\tvalue: value,\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\twriteable: true\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Hypertext Application Language serializer\n\t\t *\n\t\t * Implemented to https://tools.ietf.org/html/draft-kelly-json-hal-06\n\t\t *\n\t\t * As the spec is still a draft, this implementation will be updated as the\n\t\t * spec evolves\n\t\t *\n\t\t * Objects are read as HAL indexing links and embedded objects on to the\n\t\t * resource. Objects are written as plain JSON.\n\t\t *\n\t\t * Embedded relationships are indexed onto the resource by the relationship\n\t\t * as a promise for the related resource.\n\t\t *\n\t\t * Links are indexed onto the resource as a lazy promise that will GET the\n\t\t * resource when a handler is first registered on the promise.\n\t\t *\n\t\t * A `requestFor` method is added to the entity to make a request for the\n\t\t * relationship.\n\t\t *\n\t\t * A `clientFor` method is added to the entity to get a full Client for a\n\t\t * relationship.\n\t\t *\n\t\t * The `_links` and `_embedded` properties on the resource are made\n\t\t * non-enumerable.\n\t\t */\n\t\treturn {\n\n\t\t\tread: function (str, opts) {\n\t\t\t\tvar client, console;\n\n\t\t\t\topts = opts || {};\n\t\t\t\tclient = opts.client;\n\t\t\t\tconsole = opts.console || console;\n\n\t\t\t\tfunction deprecationWarning(relationship, deprecation) {\n\t\t\t\t\tif (deprecation && console && console.warn || console.log) {\n\t\t\t\t\t\t(console.warn || console.log).call(console, 'Relationship \\'' + relationship + '\\' is deprecated, see ' + deprecation);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn opts.registry.lookup(opts.mime.suffix).then(function (converter) {\n\t\t\t\t\treturn when(converter.read(str, opts)).then(function (root) {\n\n\t\t\t\t\t\tfind.findProperties(root, '_embedded', function (embedded, resource, name) {\n\t\t\t\t\t\t\tObject.keys(embedded).forEach(function (relationship) {\n\t\t\t\t\t\t\t\tif (relationship in resource) { return; }\n\t\t\t\t\t\t\t\tvar related = responsePromise({\n\t\t\t\t\t\t\t\t\tentity: embedded[relationship]\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tdefineProperty(resource, relationship, related);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdefineProperty(resource, name, embedded);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfind.findProperties(root, '_links', function (links, resource, name) {\n\t\t\t\t\t\t\tObject.keys(links).forEach(function (relationship) {\n\t\t\t\t\t\t\t\tvar link = links[relationship];\n\t\t\t\t\t\t\t\tif (relationship in resource) { return; }\n\t\t\t\t\t\t\t\tdefineProperty(resource, relationship, responsePromise.make(lazyPromise(function () {\n\t\t\t\t\t\t\t\t\tif (link.deprecation) { deprecationWarning(relationship, link.deprecation); }\n\t\t\t\t\t\t\t\t\tif (link.templated === true) {\n\t\t\t\t\t\t\t\t\t\treturn template(client)({ path: link.href });\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn client({ path: link.href });\n\t\t\t\t\t\t\t\t})));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdefineProperty(resource, name, links);\n\t\t\t\t\t\t\tdefineProperty(resource, 'clientFor', function (relationship, clientOverride) {\n\t\t\t\t\t\t\t\tvar link = links[relationship];\n\t\t\t\t\t\t\t\tif (!link) {\n\t\t\t\t\t\t\t\t\tthrow new Error('Unknown relationship: ' + relationship);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (link.deprecation) { deprecationWarning(relationship, link.deprecation); }\n\t\t\t\t\t\t\t\tif (link.templated === true) {\n\t\t\t\t\t\t\t\t\treturn template(\n\t\t\t\t\t\t\t\t\t\tclientOverride || client,\n\t\t\t\t\t\t\t\t\t\t{ template: link.href }\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn pathPrefix(\n\t\t\t\t\t\t\t\t\tclientOverride || client,\n\t\t\t\t\t\t\t\t\t{ prefix: link.href }\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdefineProperty(resource, 'requestFor', function (relationship, request, clientOverride) {\n\t\t\t\t\t\t\t\tvar client = this.clientFor(relationship, clientOverride);\n\t\t\t\t\t\t\t\treturn client(request);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn root;\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t},\n\n\t\t\twrite: function (obj, opts) {\n\t\t\t\treturn opts.registry.lookup(opts.mime.suffix).then(function (converter) {\n\t\t\t\t\treturn converter.write(obj, opts);\n\t\t\t\t});\n\t\t\t}\n\n\t\t};\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../../../interceptor/pathPrefix\":11,\"../../../interceptor/template\":12,\"../../../util/find\":20,\"../../../util/lazyPromise\":21,\"../../../util/responsePromise\":24,\"when\":122}],16:[function(require,module,exports){\n/*\n * Copyright 2012-2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\t/**\n\t\t * Create a new JSON converter with custom reviver/replacer.\n\t\t *\n\t\t * The extended converter must be published to a MIME registry in order\n\t\t * to be used. The existing converter will not be modified.\n\t\t *\n\t\t * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON\n\t\t *\n\t\t * @param {function} [reviver=undefined] custom JSON.parse reviver\n\t\t * @param {function|Array} [replacer=undefined] custom JSON.stringify replacer\n\t\t */\n\t\tfunction createConverter(reviver, replacer) {\n\t\t\treturn {\n\n\t\t\t\tread: function (str) {\n\t\t\t\t\treturn JSON.parse(str, reviver);\n\t\t\t\t},\n\n\t\t\t\twrite: function (obj) {\n\t\t\t\t\treturn JSON.stringify(obj, replacer);\n\t\t\t\t},\n\n\t\t\t\textend: createConverter\n\n\t\t\t};\n\t\t}\n\n\t\treturn createConverter();\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],17:[function(require,module,exports){\n/*\n * Copyright 2012 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\tvar encodedSpaceRE, urlEncodedSpaceRE;\n\n\t\tencodedSpaceRE = /%20/g;\n\t\turlEncodedSpaceRE = /\\+/g;\n\n\t\tfunction urlEncode(str) {\n\t\t\tstr = encodeURIComponent(str);\n\t\t\t// spec says space should be encoded as '+'\n\t\t\treturn str.replace(encodedSpaceRE, '+');\n\t\t}\n\n\t\tfunction urlDecode(str) {\n\t\t\t// spec says space should be encoded as '+'\n\t\t\tstr = str.replace(urlEncodedSpaceRE, ' ');\n\t\t\treturn decodeURIComponent(str);\n\t\t}\n\n\t\tfunction append(str, name, value) {\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue.forEach(function (value) {\n\t\t\t\t\tstr = append(str, name, value);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (str.length > 0) {\n\t\t\t\t\tstr += '&';\n\t\t\t\t}\n\t\t\t\tstr += urlEncode(name);\n\t\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\t\tstr += '=' + urlEncode(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\treturn {\n\n\t\t\tread: function (str) {\n\t\t\t\tvar obj = {};\n\t\t\t\tstr.split('&').forEach(function (entry) {\n\t\t\t\t\tvar pair, name, value;\n\t\t\t\t\tpair = entry.split('=');\n\t\t\t\t\tname = urlDecode(pair[0]);\n\t\t\t\t\tif (pair.length === 2) {\n\t\t\t\t\t\tvalue = urlDecode(pair[1]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = null;\n\t\t\t\t\t}\n\t\t\t\t\tif (name in obj) {\n\t\t\t\t\t\tif (!Array.isArray(obj[name])) {\n\t\t\t\t\t\t\t// convert to an array, perserving currnent value\n\t\t\t\t\t\t\tobj[name] = [obj[name]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobj[name].push(value);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tobj[name] = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn obj;\n\t\t\t},\n\n\t\t\twrite: function (obj) {\n\t\t\t\tvar str = '';\n\t\t\t\tObject.keys(obj).forEach(function (name) {\n\t\t\t\t\tstr = append(str, name, obj[name]);\n\t\t\t\t});\n\t\t\t\treturn str;\n\t\t\t}\n\n\t\t};\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],18:[function(require,module,exports){\n/*\n * Copyright 2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Michael Jackson\n */\n\n/* global FormData, File, Blob */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\tfunction isFormElement(object) {\n\t\t\treturn object &&\n\t\t\t\tobject.nodeType === 1 && // Node.ELEMENT_NODE\n\t\t\t\tobject.tagName === 'FORM';\n\t\t}\n\n\t\tfunction createFormDataFromObject(object) {\n\t\t\tvar formData = new FormData();\n\n\t\t\tvar value;\n\t\t\tfor (var property in object) {\n\t\t\t\tif (object.hasOwnProperty(property)) {\n\t\t\t\t\tvalue = object[property];\n\n\t\t\t\t\tif (value instanceof File) {\n\t\t\t\t\t\tformData.append(property, value, value.name);\n\t\t\t\t\t} else if (value instanceof Blob) {\n\t\t\t\t\t\tformData.append(property, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tformData.append(property, String(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn formData;\n\t\t}\n\n\t\treturn {\n\n\t\t\twrite: function (object) {\n\t\t\t\tif (typeof FormData === 'undefined') {\n\t\t\t\t\tthrow new Error('The multipart/form-data mime serializer requires FormData support');\n\t\t\t\t}\n\n\t\t\t\t// Support FormData directly.\n\t\t\t\tif (object instanceof FormData) {\n\t\t\t\t\treturn object;\n\t\t\t\t}\n\n\t\t\t\t// Support <form> elements.\n\t\t\t\tif (isFormElement(object)) {\n\t\t\t\t\treturn new FormData(object);\n\t\t\t\t}\n\n\t\t\t\t// Support plain objects, may contain File/Blob as value.\n\t\t\t\tif (typeof object === 'object' && object !== null) {\n\t\t\t\t\treturn createFormDataFromObject(object);\n\t\t\t\t}\n\n\t\t\t\tthrow new Error('Unable to create FormData from object ' + object);\n\t\t\t}\n\n\t\t};\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],19:[function(require,module,exports){\n/*\n * Copyright 2012 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\treturn {\n\n\t\t\tread: function (str) {\n\t\t\t\treturn str;\n\t\t\t},\n\n\t\t\twrite: function (obj) {\n\t\t\t\treturn obj.toString();\n\t\t\t}\n\n\t\t};\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],20:[function(require,module,exports){\n/*\n * Copyright 2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\treturn {\n\n\t\t\t/**\n\t\t\t * Find objects within a graph the contain a property of a certain name.\n\t\t\t *\n\t\t\t * NOTE: this method will not discover object graph cycles.\n\t\t\t *\n\t\t\t * @param {*} obj object to search on\n\t\t\t * @param {string} prop name of the property to search for\n\t\t\t * @param {Function} callback function to receive the found properties and their parent\n\t\t\t */\n\t\t\tfindProperties: function findProperties(obj, prop, callback) {\n\t\t\t\tif (typeof obj !== 'object' || obj === null) { return; }\n\t\t\t\tif (prop in obj) {\n\t\t\t\t\tcallback(obj[prop], obj, prop);\n\t\t\t\t}\n\t\t\t\tObject.keys(obj).forEach(function (key) {\n\t\t\t\t\tfindProperties(obj[key], prop, callback);\n\t\t\t\t});\n\t\t\t}\n\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],21:[function(require,module,exports){\n/*\n * Copyright 2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar when;\n\n\t\twhen = require('when');\n\n\t\t/**\n\t\t * Create a promise whose work is started only when a handler is registered.\n\t\t *\n\t\t * The work function will be invoked at most once. Thrown values will result\n\t\t * in promise rejection.\n\t\t *\n\t\t * @param {Function} work function whose ouput is used to resolve the\n\t\t *   returned promise.\n\t\t * @returns {Promise} a lazy promise\n\t\t */\n\t\tfunction lazyPromise(work) {\n\t\t\tvar defer, started, resolver, promise, then;\n\n\t\t\tdefer = when.defer();\n\t\t\tstarted = false;\n\n\t\t\tresolver = defer.resolver;\n\t\t\tpromise = defer.promise;\n\t\t\tthen = promise.then;\n\n\t\t\tpromise.then = function () {\n\t\t\t\tif (!started) {\n\t\t\t\t\tstarted = true;\n\t\t\t\t\twhen.attempt(work).then(resolver.resolve, resolver.reject);\n\t\t\t\t}\n\t\t\t\treturn then.apply(promise, arguments);\n\t\t\t};\n\n\t\t\treturn promise;\n\t\t}\n\n\t\treturn lazyPromise;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"when\":122}],22:[function(require,module,exports){\n/*\n * Copyright 2012-2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\t// derived from dojo.mixin\n\tdefine(function (/* require */) {\n\n\t\tvar empty = {};\n\n\t\t/**\n\t\t * Mix the properties from the source object into the destination object.\n\t\t * When the same property occurs in more then one object, the right most\n\t\t * value wins.\n\t\t *\n\t\t * @param {Object} dest the object to copy properties to\n\t\t * @param {Object} sources the objects to copy properties from.  May be 1 to N arguments, but not an Array.\n\t\t * @return {Object} the destination object\n\t\t */\n\t\tfunction mixin(dest /*, sources... */) {\n\t\t\tvar i, l, source, name;\n\n\t\t\tif (!dest) { dest = {}; }\n\t\t\tfor (i = 1, l = arguments.length; i < l; i += 1) {\n\t\t\t\tsource = arguments[i];\n\t\t\t\tfor (name in source) {\n\t\t\t\t\tif (!(name in dest) || (dest[name] !== source[name] && (!(name in empty) || empty[name] !== source[name]))) {\n\t\t\t\t\t\tdest[name] = source[name];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dest; // Object\n\t\t}\n\n\t\treturn mixin;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],23:[function(require,module,exports){\n/*\n * Copyright 2012 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\t/**\n\t\t * Normalize HTTP header names using the pseudo camel case.\n\t\t *\n\t\t * For example:\n\t\t *   content-type         -> Content-Type\n\t\t *   accepts              -> Accepts\n\t\t *   x-custom-header-name -> X-Custom-Header-Name\n\t\t *\n\t\t * @param {string} name the raw header name\n\t\t * @return {string} the normalized header name\n\t\t */\n\t\tfunction normalizeHeaderName(name) {\n\t\t\treturn name.toLowerCase()\n\t\t\t\t.split('-')\n\t\t\t\t.map(function (chunk) { return chunk.charAt(0).toUpperCase() + chunk.slice(1); })\n\t\t\t\t.join('-');\n\t\t}\n\n\t\treturn normalizeHeaderName;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],24:[function(require,module,exports){\n/*\n * Copyright 2014-2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar when = require('when'),\n\t\t\tnormalizeHeaderName = require('./normalizeHeaderName');\n\n\t\tfunction property(promise, name) {\n\t\t\treturn promise.then(\n\t\t\t\tfunction (value) {\n\t\t\t\t\treturn value && value[name];\n\t\t\t\t},\n\t\t\t\tfunction (value) {\n\t\t\t\t\treturn when.reject(value && value[name]);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * Obtain the response entity\n\t\t *\n\t\t * @returns {Promise} for the response entity\n\t\t */\n\t\tfunction entity() {\n\t\t\t/*jshint validthis:true */\n\t\t\treturn property(this, 'entity');\n\t\t}\n\n\t\t/**\n\t\t * Obtain the response status\n\t\t *\n\t\t * @returns {Promise} for the response status\n\t\t */\n\t\tfunction status() {\n\t\t\t/*jshint validthis:true */\n\t\t\treturn property(property(this, 'status'), 'code');\n\t\t}\n\n\t\t/**\n\t\t * Obtain the response headers map\n\t\t *\n\t\t * @returns {Promise} for the response headers map\n\t\t */\n\t\tfunction headers() {\n\t\t\t/*jshint validthis:true */\n\t\t\treturn property(this, 'headers');\n\t\t}\n\n\t\t/**\n\t\t * Obtain a specific response header\n\t\t *\n\t\t * @param {String} headerName the header to retrieve\n\t\t * @returns {Promise} for the response header's value\n\t\t */\n\t\tfunction header(headerName) {\n\t\t\t/*jshint validthis:true */\n\t\t\theaderName = normalizeHeaderName(headerName);\n\t\t\treturn property(this.headers(), headerName);\n\t\t}\n\n\t\t/**\n\t\t * Follow a related resource\n\t\t *\n\t\t * The relationship to follow may be define as a plain string, an object\n\t\t * with the rel and params, or an array containing one or more entries\n\t\t * with the previous forms.\n\t\t *\n\t\t * Examples:\n\t\t *   response.follow('next')\n\t\t *\n\t\t *   response.follow({ rel: 'next', params: { pageSize: 100 } })\n\t\t *\n\t\t *   response.follow([\n\t\t *       { rel: 'items', params: { projection: 'noImages' } },\n\t\t *       'search',\n\t\t *       { rel: 'findByGalleryIsNull', params: { projection: 'noImages' } },\n\t\t *       'items'\n\t\t *   ])\n\t\t *\n\t\t * @param {String|Object|Array} rels one, or more, relationships to follow\n\t\t * @returns ResponsePromise<Response> related resource\n\t\t */\n\t\tfunction follow(rels) {\n\t\t\t/*jshint validthis:true */\n\t\t\trels = [].concat(rels);\n\t\t\treturn make(when.reduce(rels, function (response, rel) {\n\t\t\t\tif (typeof rel === 'string') {\n\t\t\t\t\trel = { rel: rel };\n\t\t\t\t}\n\t\t\t\tif (typeof response.entity.clientFor !== 'function') {\n\t\t\t\t\tthrow new Error('Hypermedia response expected');\n\t\t\t\t}\n\t\t\t\tvar client = response.entity.clientFor(rel.rel);\n\t\t\t\treturn client({ params: rel.params });\n\t\t\t}, this));\n\t\t}\n\n\t\t/**\n\t\t * Wrap a Promise as an ResponsePromise\n\t\t *\n\t\t * @param {Promise<Response>} promise the promise for an HTTP Response\n\t\t * @returns {ResponsePromise<Response>} wrapped promise for Response with additional helper methods\n\t\t */\n\t\tfunction make(promise) {\n\t\t\tpromise.status = status;\n\t\t\tpromise.headers = headers;\n\t\t\tpromise.header = header;\n\t\t\tpromise.entity = entity;\n\t\t\tpromise.follow = follow;\n\t\t\treturn promise;\n\t\t}\n\n\t\tfunction responsePromise() {\n\t\t\treturn make(when.apply(when, arguments));\n\t\t}\n\n\t\tresponsePromise.make = make;\n\t\tresponsePromise.reject = function (val) {\n\t\t\treturn make(when.reject(val));\n\t\t};\n\t\tresponsePromise.promise = function (func) {\n\t\t\treturn make(when.promise(func));\n\t\t};\n\n\t\treturn responsePromise;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./normalizeHeaderName\":23,\"when\":122}],25:[function(require,module,exports){\n/*\n * Copyright 2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\tvar charMap;\n\n\t\tcharMap = (function () {\n\t\t\tvar strings = {\n\t\t\t\talpha: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\t\t\t\tdigit: '0123456789'\n\t\t\t};\n\n\t\t\tstrings.genDelims = ':/?#[]@';\n\t\t\tstrings.subDelims = '!$&\\'()*+,;=';\n\t\t\tstrings.reserved = strings.genDelims + strings.subDelims;\n\t\t\tstrings.unreserved = strings.alpha + strings.digit + '-._~';\n\t\t\tstrings.url = strings.reserved + strings.unreserved;\n\t\t\tstrings.scheme = strings.alpha + strings.digit + '+-.';\n\t\t\tstrings.userinfo = strings.unreserved + strings.subDelims + ':';\n\t\t\tstrings.host = strings.unreserved + strings.subDelims;\n\t\t\tstrings.port = strings.digit;\n\t\t\tstrings.pchar = strings.unreserved + strings.subDelims + ':@';\n\t\t\tstrings.segment = strings.pchar;\n\t\t\tstrings.path = strings.segment + '/';\n\t\t\tstrings.query = strings.pchar + '/?';\n\t\t\tstrings.fragment = strings.pchar + '/?';\n\n\t\t\treturn Object.keys(strings).reduce(function (charMap, set) {\n\t\t\t\tcharMap[set] = strings[set].split('').reduce(function (chars, myChar) {\n\t\t\t\t\tchars[myChar] = true;\n\t\t\t\t\treturn chars;\n\t\t\t\t}, {});\n\t\t\t\treturn charMap;\n\t\t\t}, {});\n\t\t}());\n\n\t\tfunction encode(str, allowed) {\n\t\t\tif (typeof str !== 'string') {\n\t\t\t\tthrow new Error('String required for URL encoding');\n\t\t\t}\n\t\t\treturn str.split('').map(function (myChar) {\n\t\t\t\tif (allowed.hasOwnProperty(myChar)) {\n\t\t\t\t\treturn myChar;\n\t\t\t\t}\n\t\t\t\tvar code = myChar.charCodeAt(0);\n\t\t\t\tif (code <= 127) {\n\t\t\t\t\treturn '%' + code.toString(16).toUpperCase();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn encodeURIComponent(myChar).toUpperCase();\n\t\t\t\t}\n\t\t\t}).join('');\n\t\t}\n\n\t\tfunction makeEncoder(allowed) {\n\t\t\tallowed = allowed || charMap.unreserved;\n\t\t\treturn function (str) {\n\t\t\t\treturn encode(str, allowed);\n\t\t\t};\n\t\t}\n\n\t\tfunction decode(str) {\n\t\t\treturn decodeURIComponent(str);\n\t\t}\n\n\t\treturn {\n\n\t\t\t/*\n\t\t\t * Decode URL encoded strings\n\t\t\t *\n\t\t\t * @param {string} URL encoded string\n\t\t\t * @returns {string} URL decoded string\n\t\t\t */\n\t\t\tdecode: decode,\n\n\t\t\t/*\n\t\t\t * URL encode a string\n\t\t\t *\n\t\t\t * All but alpha-numerics and a very limited set of punctuation - . _ ~ are\n\t\t\t * encoded.\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencode: makeEncoder(),\n\n\t\t\t/*\n\t\t\t* URL encode a URL\n\t\t\t*\n\t\t\t* All character permitted anywhere in a URL are left unencoded even\n\t\t\t* if that character is not permitted in that portion of a URL.\n\t\t\t*\n\t\t\t* Note: This method is typically not what you want.\n\t\t\t*\n\t\t\t* @param {string} string to encode\n\t\t\t* @returns {string} URL encoded string\n\t\t\t*/\n\t\t\tencodeURL: makeEncoder(charMap.url),\n\n\t\t\t/*\n\t\t\t * URL encode the scheme portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeScheme: makeEncoder(charMap.scheme),\n\n\t\t\t/*\n\t\t\t * URL encode the user info portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeUserInfo: makeEncoder(charMap.userinfo),\n\n\t\t\t/*\n\t\t\t * URL encode the host portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeHost: makeEncoder(charMap.host),\n\n\t\t\t/*\n\t\t\t * URL encode the port portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodePort: makeEncoder(charMap.port),\n\n\t\t\t/*\n\t\t\t * URL encode a path segment portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodePathSegment: makeEncoder(charMap.segment),\n\n\t\t\t/*\n\t\t\t * URL encode the path portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodePath: makeEncoder(charMap.path),\n\n\t\t\t/*\n\t\t\t * URL encode the query portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeQuery: makeEncoder(charMap.query),\n\n\t\t\t/*\n\t\t\t * URL encode the fragment portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeFragment: makeEncoder(charMap.fragment)\n\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],26:[function(require,module,exports){\n/*\n * Copyright 2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tvar undef;\n\n\tdefine(function (require) {\n\n\t\tvar uriEncoder, operations, prefixRE;\n\n\t\turiEncoder = require('./uriEncoder');\n\n\t\tprefixRE = /^([^:]*):([0-9]+)$/;\n\t\toperations = {\n\t\t\t'':  { first: '',  separator: ',', named: false, empty: '',  encoder: uriEncoder.encode },\n\t\t\t'+': { first: '',  separator: ',', named: false, empty: '',  encoder: uriEncoder.encodeURL },\n\t\t\t'#': { first: '#', separator: ',', named: false, empty: '',  encoder: uriEncoder.encodeURL },\n\t\t\t'.': { first: '.', separator: '.', named: false, empty: '',  encoder: uriEncoder.encode },\n\t\t\t'/': { first: '/', separator: '/', named: false, empty: '',  encoder: uriEncoder.encode },\n\t\t\t';': { first: ';', separator: ';', named: true,  empty: '',  encoder: uriEncoder.encode },\n\t\t\t'?': { first: '?', separator: '&', named: true,  empty: '=', encoder: uriEncoder.encode },\n\t\t\t'&': { first: '&', separator: '&', named: true,  empty: '=', encoder: uriEncoder.encode },\n\t\t\t'=': { reserved: true },\n\t\t\t',': { reserved: true },\n\t\t\t'!': { reserved: true },\n\t\t\t'@': { reserved: true },\n\t\t\t'|': { reserved: true }\n\t\t};\n\n\t\tfunction apply(operation, expression, params) {\n\t\t\t/*jshint maxcomplexity:11 */\n\t\t\treturn expression.split(',').reduce(function (result, variable) {\n\t\t\t\tvar opts, value;\n\n\t\t\t\topts = {};\n\t\t\t\tif (variable.slice(-1) === '*') {\n\t\t\t\t\tvariable = variable.slice(0, -1);\n\t\t\t\t\topts.explode = true;\n\t\t\t\t}\n\t\t\t\tif (prefixRE.test(variable)) {\n\t\t\t\t\tvar prefix = prefixRE.exec(variable);\n\t\t\t\t\tvariable = prefix[1];\n\t\t\t\t\topts.maxLength = parseInt(prefix[2]);\n\t\t\t\t}\n\n\t\t\t\tvariable = uriEncoder.decode(variable);\n\t\t\t\tvalue = params[variable];\n\n\t\t\t\tif (value === undef || value === null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tresult += value.reduce(function (result, value) {\n\t\t\t\t\t\tif (result.length) {\n\t\t\t\t\t\t\tresult += opts.explode ? operation.separator : ',';\n\t\t\t\t\t\t\tif (operation.named && opts.explode) {\n\t\t\t\t\t\t\t\tresult += operation.encoder(variable);\n\t\t\t\t\t\t\t\tresult += value.length ? '=' : operation.empty;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresult += operation.first;\n\t\t\t\t\t\t\tif (operation.named) {\n\t\t\t\t\t\t\t\tresult += operation.encoder(variable);\n\t\t\t\t\t\t\t\tresult += value.length ? '=' : operation.empty;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult += operation.encoder(value);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}, '');\n\t\t\t\t}\n\t\t\t\telse if (typeof value === 'object') {\n\t\t\t\t\tresult += Object.keys(value).reduce(function (result, name) {\n\t\t\t\t\t\tif (result.length) {\n\t\t\t\t\t\t\tresult += opts.explode ? operation.separator : ',';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresult += operation.first;\n\t\t\t\t\t\t\tif (operation.named && !opts.explode) {\n\t\t\t\t\t\t\t\tresult += operation.encoder(variable);\n\t\t\t\t\t\t\t\tresult += value[name].length ? '=' : operation.empty;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult += operation.encoder(name);\n\t\t\t\t\t\tresult += opts.explode ? '=' : ',';\n\t\t\t\t\t\tresult += operation.encoder(value[name]);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}, '');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = String(value);\n\t\t\t\t\tif (opts.maxLength) {\n\t\t\t\t\t\tvalue = value.slice(0, opts.maxLength);\n\t\t\t\t\t}\n\t\t\t\t\tresult += result.length ? operation.separator : operation.first;\n\t\t\t\t\tif (operation.named) {\n\t\t\t\t\t\tresult += operation.encoder(variable);\n\t\t\t\t\t\tresult += value.length ? '=' : operation.empty;\n\t\t\t\t\t}\n\t\t\t\t\tresult += operation.encoder(value);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, '');\n\t\t}\n\n\t\tfunction expandExpression(expression, params) {\n\t\t\tvar operation;\n\n\t\t\toperation = operations[expression.slice(0,1)];\n\t\t\tif (operation) {\n\t\t\t\texpression = expression.slice(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\toperation = operations[''];\n\t\t\t}\n\n\t\t\tif (operation.reserved) {\n\t\t\t\tthrow new Error('Reserved expression operations are not supported');\n\t\t\t}\n\n\t\t\treturn apply(operation, expression, params);\n\t\t}\n\n\t\tfunction expandTemplate(template, params) {\n\t\t\tvar start, end, uri;\n\n\t\t\turi = '';\n\t\t\tend = 0;\n\t\t\twhile (true) {\n\t\t\t\tstart = template.indexOf('{', end);\n\t\t\t\tif (start === -1) {\n\t\t\t\t\t// no more expressions\n\t\t\t\t\turi += template.slice(end);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\turi += template.slice(end, start);\n\t\t\t\tend = template.indexOf('}', start) + 1;\n\t\t\t\turi += expandExpression(template.slice(start + 1, end - 1), params);\n\t\t\t}\n\n\t\t\treturn uri;\n\t\t}\n\n\t\treturn {\n\n\t\t\t/**\n\t\t\t * Expand a URI Template with parameters to form a URI.\n\t\t\t *\n\t\t\t * Full implementation (level 4) of rfc6570.\n\t\t\t * @see https://tools.ietf.org/html/rfc6570\n\t\t\t *\n\t\t\t * @param {string} template URI template\n\t\t\t * @param {Object} [params] params to apply to the template durring expantion\n\t\t\t * @returns {string} expanded URI\n\t\t\t */\n\t\t\texpand: expandTemplate\n\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./uriEncoder\":25}],27:[function(require,module,exports){\nvar Vue // late bind\nvar map = Object.create(null)\nvar shimmed = false\nvar isBrowserify = false\n\n/**\n * Determine compatibility and apply patch.\n *\n * @param {Function} vue\n * @param {Boolean} browserify\n */\n\nexports.install = function (vue, browserify) {\n  if (shimmed) return\n  shimmed = true\n\n  Vue = vue\n  isBrowserify = browserify\n\n  exports.compatible = !!Vue.internalDirectives\n  if (!exports.compatible) {\n    console.warn(\n      '[HMR] vue-loader hot reload is only compatible with ' +\n      'Vue.js 1.0.0+.'\n    )\n    return\n  }\n\n  // patch view directive\n  patchView(Vue.internalDirectives.component)\n  console.log('[HMR] Vue component hot reload shim applied.')\n  // shim router-view if present\n  var routerView = Vue.elementDirective('router-view')\n  if (routerView) {\n    patchView(routerView)\n    console.log('[HMR] vue-router <router-view> hot reload shim applied.')\n  }\n}\n\n/**\n * Shim the view directive (component or router-view).\n *\n * @param {Object} View\n */\n\nfunction patchView (View) {\n  var unbuild = View.unbuild\n  View.unbuild = function (defer) {\n    if (!this.hotUpdating) {\n      var prevComponent = this.childVM && this.childVM.constructor\n      removeView(prevComponent, this)\n      // defer = true means we are transitioning to a new\n      // Component. Register this new component to the list.\n      if (defer) {\n        addView(this.Component, this)\n      }\n    }\n    // call original\n    return unbuild.call(this, defer)\n  }\n}\n\n/**\n * Add a component view to a Component's hot list\n *\n * @param {Function} Component\n * @param {Directive} view - view directive instance\n */\n\nfunction addView (Component, view) {\n  var id = Component && Component.options.hotID\n  if (id) {\n    if (!map[id]) {\n      map[id] = {\n        Component: Component,\n        views: [],\n        instances: []\n      }\n    }\n    map[id].views.push(view)\n  }\n}\n\n/**\n * Remove a component view from a Component's hot list\n *\n * @param {Function} Component\n * @param {Directive} view - view directive instance\n */\n\nfunction removeView (Component, view) {\n  var id = Component && Component.options.hotID\n  if (id) {\n    map[id].views.$remove(view)\n  }\n}\n\n/**\n * Create a record for a hot module, which keeps track of its construcotr,\n * instnaces and views (component directives or router-views).\n *\n * @param {String} id\n * @param {Object} options\n */\n\nexports.createRecord = function (id, options) {\n  if (typeof options === 'function') {\n    options = options.options\n  }\n  if (typeof options.el !== 'string' && typeof options.data !== 'object') {\n    makeOptionsHot(id, options)\n    map[id] = {\n      Component: null,\n      views: [],\n      instances: []\n    }\n  }\n}\n\n/**\n * Make a Component options object hot.\n *\n * @param {String} id\n * @param {Object} options\n */\n\nfunction makeOptionsHot (id, options) {\n  options.hotID = id\n  injectHook(options, 'created', function () {\n    var record = map[id]\n    if (!record.Component) {\n      record.Component = this.constructor\n    }\n    record.instances.push(this)\n  })\n  injectHook(options, 'beforeDestroy', function () {\n    map[id].instances.$remove(this)\n  })\n}\n\n/**\n * Inject a hook to a hot reloadable component so that\n * we can keep track of it.\n *\n * @param {Object} options\n * @param {String} name\n * @param {Function} hook\n */\n\nfunction injectHook (options, name, hook) {\n  var existing = options[name]\n  options[name] = existing\n    ? Array.isArray(existing)\n      ? existing.concat(hook)\n      : [existing, hook]\n    : [hook]\n}\n\n/**\n * Update a hot component.\n *\n * @param {String} id\n * @param {Object|null} newOptions\n * @param {String|null} newTemplate\n */\n\nexports.update = function (id, newOptions, newTemplate) {\n  var record = map[id]\n  // force full-reload if an instance of the component is active but is not\n  // managed by a view\n  if (!record || (record.instances.length && !record.views.length)) {\n    console.log('[HMR] Root or manually-mounted instance modified. Full reload may be required.')\n    if (!isBrowserify) {\n      window.location.reload()\n    } else {\n      // browserify-hmr somehow sends incomplete bundle if we reload here\n      return\n    }\n  }\n  if (!isBrowserify) {\n    // browserify-hmr already logs this\n    console.log('[HMR] Updating component: ' + format(id))\n  }\n  var Component = record.Component\n  // update constructor\n  if (newOptions) {\n    // in case the user exports a constructor\n    Component = record.Component = typeof newOptions === 'function'\n      ? newOptions\n      : Vue.extend(newOptions)\n    makeOptionsHot(id, Component.options)\n  }\n  if (newTemplate) {\n    Component.options.template = newTemplate\n  }\n  // handle recursive lookup\n  if (Component.options.name) {\n    Component.options.components[Component.options.name] = Component\n  }\n  // reset constructor cached linker\n  Component.linker = null\n  // reload all views\n  record.views.forEach(function (view) {\n    updateView(view, Component)\n  })\n}\n\n/**\n * Update a component view instance\n *\n * @param {Directive} view\n * @param {Function} Component\n */\n\nfunction updateView (view, Component) {\n  if (!view._bound) {\n    return\n  }\n  view.Component = Component\n  view.hotUpdating = true\n  // disable transitions\n  view.vm._isCompiled = false\n  // save state\n  var state = view.childVM.$data\n  // remount, make sure to disable keep-alive\n  var keepAlive = view.keepAlive\n  view.keepAlive = false\n  view.mountComponent()\n  view.keepAlive = keepAlive\n  // restore state\n  view.childVM.$data = state\n  // re-eanble transitions\n  view.vm._isCompiled = true\n  view.hotUpdating = false\n}\n\nfunction format (id) {\n  return id.match(/[^\\/]+\\.vue$/)[0]\n}\n\n},{}],28:[function(require,module,exports){\n/**\n * Service for sending network requests.\n */\n\nvar xhr = require('./lib/xhr');\nvar jsonp = require('./lib/jsonp');\nvar Promise = require('./lib/promise');\n\nmodule.exports = function (_) {\n\n    var originUrl = _.url.parse(location.href);\n    var jsonType = {'Content-Type': 'application/json;charset=utf-8'};\n\n    function Http(url, options) {\n\n        var promise;\n\n        if (_.isPlainObject(url)) {\n            options = url;\n            url = '';\n        }\n\n        options = _.extend({url: url}, options);\n        options = _.extend(true, {},\n            Http.options, this.options, options\n        );\n\n        if (options.crossOrigin === null) {\n            options.crossOrigin = crossOrigin(options.url);\n        }\n\n        options.method = options.method.toUpperCase();\n        options.headers = _.extend({}, Http.headers.common,\n            !options.crossOrigin ? Http.headers.custom : {},\n            Http.headers[options.method.toLowerCase()],\n            options.headers\n        );\n\n        if (_.isPlainObject(options.data) && /^(GET|JSONP)$/i.test(options.method)) {\n            _.extend(options.params, options.data);\n            delete options.data;\n        }\n\n        if (options.emulateHTTP && !options.crossOrigin && /^(PUT|PATCH|DELETE)$/i.test(options.method)) {\n            options.headers['X-HTTP-Method-Override'] = options.method;\n            options.method = 'POST';\n        }\n\n        if (options.emulateJSON && _.isPlainObject(options.data)) {\n            options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n            options.data = _.url.params(options.data);\n        }\n\n        if (_.isObject(options.data) && /FormData/i.test(options.data.toString())) {\n            delete options.headers['Content-Type'];\n        }\n\n        if (_.isPlainObject(options.data)) {\n            options.data = JSON.stringify(options.data);\n        }\n\n        promise = (options.method == 'JSONP' ? jsonp : xhr).call(this.vm, _, options);\n        promise = extendPromise(promise.then(transformResponse, transformResponse), this.vm);\n\n        if (options.success) {\n            promise = promise.success(options.success);\n        }\n\n        if (options.error) {\n            promise = promise.error(options.error);\n        }\n\n        return promise;\n    }\n\n    function extendPromise(promise, vm) {\n\n        promise.success = function (fn) {\n\n            return extendPromise(promise.then(function (response) {\n                return fn.call(vm, response.data, response.status, response) || response;\n            }), vm);\n\n        };\n\n        promise.error = function (fn) {\n\n            return extendPromise(promise.then(undefined, function (response) {\n                return fn.call(vm, response.data, response.status, response) || response;\n            }), vm);\n\n        };\n\n        promise.always = function (fn) {\n\n            var cb = function (response) {\n                return fn.call(vm, response.data, response.status, response) || response;\n            };\n\n            return extendPromise(promise.then(cb, cb), vm);\n        };\n\n        return promise;\n    }\n\n    function transformResponse(response) {\n\n        try {\n            response.data = JSON.parse(response.responseText);\n        } catch (e) {\n            response.data = response.responseText;\n        }\n\n        return response.ok ? response : Promise.reject(response);\n    }\n\n    function crossOrigin(url) {\n\n        var requestUrl = _.url.parse(url);\n\n        return (requestUrl.protocol !== originUrl.protocol || requestUrl.host !== originUrl.host);\n    }\n\n    Http.options = {\n        method: 'get',\n        params: {},\n        data: '',\n        xhr: null,\n        jsonp: 'callback',\n        beforeSend: null,\n        crossOrigin: null,\n        emulateHTTP: false,\n        emulateJSON: false\n    };\n\n    Http.headers = {\n        put: jsonType,\n        post: jsonType,\n        patch: jsonType,\n        delete: jsonType,\n        common: {'Accept': 'application/json, text/plain, */*'},\n        custom: {'X-Requested-With': 'XMLHttpRequest'}\n    };\n\n    ['get', 'put', 'post', 'patch', 'delete', 'jsonp'].forEach(function (method) {\n\n        Http[method] = function (url, data, success, options) {\n\n            if (_.isFunction(data)) {\n                options = success;\n                success = data;\n                data = undefined;\n            }\n\n            return this(url, _.extend({method: method, data: data, success: success}, options));\n        };\n    });\n\n    return _.http = Http;\n};\n\n},{\"./lib/jsonp\":30,\"./lib/promise\":31,\"./lib/xhr\":33}],29:[function(require,module,exports){\n/**\n * Install plugin.\n */\n\nfunction install(Vue) {\n\n    var _ = require('./lib/util')(Vue);\n\n    Vue.url = require('./url')(_);\n    Vue.http = require('./http')(_);\n    Vue.resource = require('./resource')(_);\n\n    Object.defineProperties(Vue.prototype, {\n\n        $url: {\n            get: function () {\n                return _.options(Vue.url, this, this.$options.url);\n            }\n        },\n\n        $http: {\n            get: function () {\n                return _.options(Vue.http, this, this.$options.http);\n            }\n        },\n\n        $resource: {\n            get: function () {\n                return Vue.resource.bind(this);\n            }\n        }\n\n    });\n}\n\nif (window.Vue) {\n    Vue.use(install);\n}\n\nmodule.exports = install;\n},{\"./http\":28,\"./lib/util\":32,\"./resource\":34,\"./url\":35}],30:[function(require,module,exports){\n/**\n * JSONP request.\n */\n\nvar Promise = require('./promise');\n\nmodule.exports = function (_, options) {\n\n    var callback = '_jsonp' + Math.random().toString(36).substr(2), response = {}, script, body;\n\n    options.params[options.jsonp] = callback;\n\n    if (_.isFunction(options.beforeSend)) {\n        options.beforeSend.call(this, {}, options);\n    }\n\n    return new Promise(function (resolve, reject) {\n\n        script = document.createElement('script');\n        script.src = _.url(options);\n        script.type = 'text/javascript';\n        script.async = true;\n\n        window[callback] = function (data) {\n            body = data;\n        };\n\n        var handler = function (event) {\n\n            delete window[callback];\n            document.body.removeChild(script);\n\n            if (event.type === 'load' && !body) {\n                event.type = 'error';\n            }\n\n            response.ok = event.type !== 'error';\n            response.status = response.ok ? 200 : 404;\n            response.responseText = body ? body : event.type;\n\n            (response.ok ? resolve : reject)(response);\n        };\n\n        script.onload = handler;\n        script.onerror = handler;\n\n        document.body.appendChild(script);\n    });\n\n};\n\n},{\"./promise\":31}],31:[function(require,module,exports){\n/**\n * Promises/A+ polyfill v1.1.0 (https://github.com/bramstein/promis)\n */\n\nvar RESOLVED = 0;\nvar REJECTED = 1;\nvar PENDING  = 2;\n\nfunction Promise(executor) {\n\n    this.state = PENDING;\n    this.value = undefined;\n    this.deferred = [];\n\n    var promise = this;\n\n    try {\n        executor(function (x) {\n            promise.resolve(x);\n        }, function (r) {\n            promise.reject(r);\n        });\n    } catch (e) {\n        promise.reject(e);\n    }\n}\n\nPromise.reject = function (r) {\n    return new Promise(function (resolve, reject) {\n        reject(r);\n    });\n};\n\nPromise.resolve = function (x) {\n    return new Promise(function (resolve, reject) {\n        resolve(x);\n    });\n};\n\nPromise.all = function all(iterable) {\n    return new Promise(function (resolve, reject) {\n        var count = 0,\n            result = [];\n\n        if (iterable.length === 0) {\n            resolve(result);\n        }\n\n        function resolver(i) {\n            return function (x) {\n                result[i] = x;\n                count += 1;\n\n                if (count === iterable.length) {\n                    resolve(result);\n                }\n            };\n        }\n\n        for (var i = 0; i < iterable.length; i += 1) {\n            iterable[i].then(resolver(i), reject);\n        }\n    });\n};\n\nPromise.race = function race(iterable) {\n    return new Promise(function (resolve, reject) {\n        for (var i = 0; i < iterable.length; i += 1) {\n            iterable[i].then(resolve, reject);\n        }\n    });\n};\n\nvar p = Promise.prototype;\n\np.resolve = function resolve(x) {\n    var promise = this;\n\n    if (promise.state === PENDING) {\n        if (x === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        var called = false;\n\n        try {\n            var then = x && x['then'];\n\n            if (x !== null && typeof x === 'object' && typeof then === 'function') {\n                then.call(x, function (x) {\n                    if (!called) {\n                        promise.resolve(x);\n                    }\n                    called = true;\n\n                }, function (r) {\n                    if (!called) {\n                        promise.reject(r);\n                    }\n                    called = true;\n                });\n                return;\n            }\n        } catch (e) {\n            if (!called) {\n                promise.reject(e);\n            }\n            return;\n        }\n        promise.state = RESOLVED;\n        promise.value = x;\n        promise.notify();\n    }\n};\n\np.reject = function reject(reason) {\n    var promise = this;\n\n    if (promise.state === PENDING) {\n        if (reason === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        promise.state = REJECTED;\n        promise.value = reason;\n        promise.notify();\n    }\n};\n\np.notify = function notify() {\n    var promise = this;\n\n    async(function () {\n        if (promise.state !== PENDING) {\n            while (promise.deferred.length) {\n                var deferred = promise.deferred.shift(),\n                    onResolved = deferred[0],\n                    onRejected = deferred[1],\n                    resolve = deferred[2],\n                    reject = deferred[3];\n\n                try {\n                    if (promise.state === RESOLVED) {\n                        if (typeof onResolved === 'function') {\n                            resolve(onResolved.call(undefined, promise.value));\n                        } else {\n                            resolve(promise.value);\n                        }\n                    } else if (promise.state === REJECTED) {\n                        if (typeof onRejected === 'function') {\n                            resolve(onRejected.call(undefined, promise.value));\n                        } else {\n                            reject(promise.value);\n                        }\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            }\n        }\n    });\n};\n\np.catch = function (onRejected) {\n    return this.then(undefined, onRejected);\n};\n\np.then = function then(onResolved, onRejected) {\n    var promise = this;\n\n    return new Promise(function (resolve, reject) {\n        promise.deferred.push([onResolved, onRejected, resolve, reject]);\n        promise.notify();\n    });\n};\n\nvar queue = [];\nvar async = function (callback) {\n    queue.push(callback);\n\n    if (queue.length === 1) {\n        async.async();\n    }\n};\n\nasync.run = function () {\n    while (queue.length) {\n        queue[0]();\n        queue.shift();\n    }\n};\n\nif (window.MutationObserver) {\n    var el = document.createElement('div');\n    var mo = new MutationObserver(async.run);\n\n    mo.observe(el, {\n        attributes: true\n    });\n\n    async.async = function () {\n        el.setAttribute(\"x\", 0);\n    };\n} else {\n    async.async = function () {\n        setTimeout(async.run);\n    };\n}\n\nmodule.exports = window.Promise || Promise;\n\n},{}],32:[function(require,module,exports){\n/**\n * Utility functions.\n */\n\nmodule.exports = function (Vue) {\n\n    var _ = Vue.util.extend({}, Vue.util);\n\n    _.isString = function (value) {\n        return typeof value === 'string';\n    };\n\n    _.isFunction = function (value) {\n        return typeof value === 'function';\n    };\n\n    _.options = function (fn, obj, options) {\n\n        options = options || {};\n\n        if (_.isFunction(options)) {\n            options = options.call(obj);\n        }\n\n        return _.extend(fn.bind({vm: obj, options: options}), fn, {options: options});\n    };\n\n    _.each = function (obj, iterator) {\n\n        var i, key;\n\n        if (typeof obj.length == 'number') {\n            for (i = 0; i < obj.length; i++) {\n                iterator.call(obj[i], obj[i], i);\n            }\n        } else if (_.isObject(obj)) {\n            for (key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    iterator.call(obj[key], obj[key], key);\n                }\n            }\n        }\n\n        return obj;\n    };\n\n    _.extend = function (target) {\n\n        var array = [], args = array.slice.call(arguments, 1), deep;\n\n        if (typeof target == 'boolean') {\n            deep = target;\n            target = args.shift();\n        }\n\n        args.forEach(function (arg) {\n            extend(target, arg, deep);\n        });\n\n        return target;\n    };\n\n    function extend(target, source, deep) {\n        for (var key in source) {\n            if (deep && (_.isPlainObject(source[key]) || _.isArray(source[key]))) {\n                if (_.isPlainObject(source[key]) && !_.isPlainObject(target[key])) {\n                    target[key] = {};\n                }\n                if (_.isArray(source[key]) && !_.isArray(target[key])) {\n                    target[key] = [];\n                }\n                extend(target[key], source[key], deep);\n            } else if (source[key] !== undefined) {\n                target[key] = source[key];\n            }\n        }\n    }\n\n    return _;\n};\n\n},{}],33:[function(require,module,exports){\n/**\n * XMLHttp request.\n */\n\nvar Promise = require('./promise');\nvar XDomain = window.XDomainRequest;\n\nmodule.exports = function (_, options) {\n\n    var request = new XMLHttpRequest(), promise;\n\n    if (XDomain && options.crossOrigin) {\n        request = new XDomainRequest(); options.headers = {};\n    }\n\n    if (_.isPlainObject(options.xhr)) {\n        _.extend(request, options.xhr);\n    }\n\n    if (_.isFunction(options.beforeSend)) {\n        options.beforeSend.call(this, request, options);\n    }\n\n    promise = new Promise(function (resolve, reject) {\n\n        request.open(options.method, _.url(options), true);\n\n        _.each(options.headers, function (value, header) {\n            request.setRequestHeader(header, value);\n        });\n\n        var handler = function (event) {\n\n            request.ok = event.type === 'load';\n\n            if (request.ok && request.status) {\n                request.ok = request.status >= 200 && request.status < 300;\n            }\n\n            (request.ok ? resolve : reject)(request);\n        };\n\n        request.onload = handler;\n        request.onabort = handler;\n        request.onerror = handler;\n\n        request.send(options.data);\n    });\n\n    return promise;\n};\n\n},{\"./promise\":31}],34:[function(require,module,exports){\n/**\n * Service for interacting with RESTful services.\n */\n\nmodule.exports = function (_) {\n\n    function Resource(url, params, actions, options) {\n\n        var self = this, resource = {};\n\n        actions = _.extend({},\n            Resource.actions,\n            actions\n        );\n\n        _.each(actions, function (action, name) {\n\n            action = _.extend(true, {url: url, params: params || {}}, options, action);\n\n            resource[name] = function () {\n                return (self.$http || _.http)(opts(action, arguments));\n            };\n        });\n\n        return resource;\n    }\n\n    function opts(action, args) {\n\n        var options = _.extend({}, action), params = {}, data, success, error;\n\n        switch (args.length) {\n\n            case 4:\n\n                error = args[3];\n                success = args[2];\n\n            case 3:\n            case 2:\n\n                if (_.isFunction(args[1])) {\n\n                    if (_.isFunction(args[0])) {\n\n                        success = args[0];\n                        error = args[1];\n\n                        break;\n                    }\n\n                    success = args[1];\n                    error = args[2];\n\n                } else {\n\n                    params = args[0];\n                    data = args[1];\n                    success = args[2];\n\n                    break;\n                }\n\n            case 1:\n\n                if (_.isFunction(args[0])) {\n                    success = args[0];\n                } else if (/^(POST|PUT|PATCH)$/i.test(options.method)) {\n                    data = args[0];\n                } else {\n                    params = args[0];\n                }\n\n                break;\n\n            case 0:\n\n                break;\n\n            default:\n\n                throw 'Expected up to 4 arguments [params, data, success, error], got ' + args.length + ' arguments';\n        }\n\n        options.data = data;\n        options.params = _.extend({}, options.params, params);\n\n        if (success) {\n            options.success = success;\n        }\n\n        if (error) {\n            options.error = error;\n        }\n\n        return options;\n    }\n\n    Resource.actions = {\n\n        get: {method: 'GET'},\n        save: {method: 'POST'},\n        query: {method: 'GET'},\n        update: {method: 'PUT'},\n        remove: {method: 'DELETE'},\n        delete: {method: 'DELETE'}\n\n    };\n\n    return _.resource = Resource;\n};\n\n},{}],35:[function(require,module,exports){\n/**\n * Service for URL templating.\n */\n\nvar ie = document.documentMode;\nvar el = document.createElement('a');\n\nmodule.exports = function (_) {\n\n    function Url(url, params) {\n\n        var urlParams = {}, queryParams = {}, options = url, query;\n\n        if (!_.isPlainObject(options)) {\n            options = {url: url, params: params};\n        }\n\n        options = _.extend(true, {},\n            Url.options, this.options, options\n        );\n\n        url = options.url.replace(/(\\/?):([a-z]\\w*)/gi, function (match, slash, name) {\n\n            if (options.params[name]) {\n                urlParams[name] = true;\n                return slash + encodeUriSegment(options.params[name]);\n            }\n\n            return '';\n        });\n\n        if (_.isString(options.root) && !url.match(/^(https?:)?\\//)) {\n            url = options.root + '/' + url;\n        }\n\n        _.each(options.params, function (value, key) {\n            if (!urlParams[key]) {\n                queryParams[key] = value;\n            }\n        });\n\n        query = Url.params(queryParams);\n\n        if (query) {\n            url += (url.indexOf('?') == -1 ? '?' : '&') + query;\n        }\n\n        return url;\n    }\n\n    /**\n     * Url options.\n     */\n\n    Url.options = {\n        url: '',\n        root: null,\n        params: {}\n    };\n\n    /**\n     * Encodes a Url parameter string.\n     *\n     * @param {Object} obj\n     */\n\n    Url.params = function (obj) {\n\n        var params = [];\n\n        params.add = function (key, value) {\n\n            if (_.isFunction (value)) {\n                value = value();\n            }\n\n            if (value === null) {\n                value = '';\n            }\n\n            this.push(encodeUriSegment(key) + '=' + encodeUriSegment(value));\n        };\n\n        serialize(params, obj);\n\n        return params.join('&');\n    };\n\n    /**\n     * Parse a URL and return its components.\n     *\n     * @param {String} url\n     */\n\n    Url.parse = function (url) {\n\n        if (ie) {\n            el.href = url;\n            url = el.href;\n        }\n\n        el.href = url;\n\n        return {\n            href: el.href,\n            protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',\n            port: el.port,\n            host: el.host,\n            hostname: el.hostname,\n            pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,\n            search: el.search ? el.search.replace(/^\\?/, '') : '',\n            hash: el.hash ? el.hash.replace(/^#/, '') : ''\n        };\n    };\n\n    function serialize(params, obj, scope) {\n\n        var array = _.isArray(obj), plain = _.isPlainObject(obj), hash;\n\n        _.each(obj, function (value, key) {\n\n            hash = _.isObject(value) || _.isArray(value);\n\n            if (scope) {\n                key = scope + '[' + (plain || hash ? key : '') + ']';\n            }\n\n            if (!scope && array) {\n                params.add(value.name, value.value);\n            } else if (hash) {\n                serialize(params, value, key);\n            } else {\n                params.add(key, value);\n            }\n        });\n    }\n\n    function encodeUriSegment(value) {\n\n        return encodeUriQuery(value, true).\n            replace(/%26/gi, '&').\n            replace(/%3D/gi, '=').\n            replace(/%2B/gi, '+');\n    }\n\n    function encodeUriQuery(value, spaces) {\n\n        return encodeURIComponent(value).\n            replace(/%40/gi, '@').\n            replace(/%3A/gi, ':').\n            replace(/%24/g, '$').\n            replace(/%2C/gi, ',').\n            replace(/%20/g, (spaces ? '%20' : '+'));\n    }\n\n    return _.url = Url;\n};\n\n},{}],36:[function(require,module,exports){\n'use strict';\n\nvar babelHelpers = {};\n\nbabelHelpers.classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\nfunction Target(path, matcher, delegate) {\n  this.path = path;\n  this.matcher = matcher;\n  this.delegate = delegate;\n}\n\nTarget.prototype = {\n  to: function to(target, callback) {\n    var delegate = this.delegate;\n\n    if (delegate && delegate.willAddRoute) {\n      target = delegate.willAddRoute(this.matcher.target, target);\n    }\n\n    this.matcher.add(this.path, target);\n\n    if (callback) {\n      if (callback.length === 0) {\n        throw new Error(\"You must have an argument in the function passed to `to`\");\n      }\n      this.matcher.addChild(this.path, target, callback, this.delegate);\n    }\n    return this;\n  }\n};\n\nfunction Matcher(target) {\n  this.routes = {};\n  this.children = {};\n  this.target = target;\n}\n\nMatcher.prototype = {\n  add: function add(path, handler) {\n    this.routes[path] = handler;\n  },\n\n  addChild: function addChild(path, target, callback, delegate) {\n    var matcher = new Matcher(target);\n    this.children[path] = matcher;\n\n    var match = generateMatch(path, matcher, delegate);\n\n    if (delegate && delegate.contextEntered) {\n      delegate.contextEntered(target, match);\n    }\n\n    callback(match);\n  }\n};\n\nfunction generateMatch(startingPath, matcher, delegate) {\n  return function (path, nestedCallback) {\n    var fullPath = startingPath + path;\n\n    if (nestedCallback) {\n      nestedCallback(generateMatch(fullPath, matcher, delegate));\n    } else {\n      return new Target(startingPath + path, matcher, delegate);\n    }\n  };\n}\n\nfunction addRoute(routeArray, path, handler) {\n  var len = 0;\n  for (var i = 0, l = routeArray.length; i < l; i++) {\n    len += routeArray[i].path.length;\n  }\n\n  path = path.substr(len);\n  var route = { path: path, handler: handler };\n  routeArray.push(route);\n}\n\nfunction eachRoute(baseRoute, matcher, callback, binding) {\n  var routes = matcher.routes;\n\n  for (var path in routes) {\n    if (routes.hasOwnProperty(path)) {\n      var routeArray = baseRoute.slice();\n      addRoute(routeArray, path, routes[path]);\n\n      if (matcher.children[path]) {\n        eachRoute(routeArray, matcher.children[path], callback, binding);\n      } else {\n        callback.call(binding, routeArray);\n      }\n    }\n  }\n}\n\nfunction map (callback, addRouteCallback) {\n  var matcher = new Matcher();\n\n  callback(generateMatch(\"\", matcher, this.delegate));\n\n  eachRoute([], matcher, function (route) {\n    if (addRouteCallback) {\n      addRouteCallback(this, route);\n    } else {\n      this.add(route);\n    }\n  }, this);\n}\n\nvar specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\'];\n\nvar escapeRegex = new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'g');\n\nfunction isArray(test) {\n  return Object.prototype.toString.call(test) === \"[object Array]\";\n}\n\n// A Segment represents a segment in the original route description.\n// Each Segment type provides an `eachChar` and `regex` method.\n//\n// The `eachChar` method invokes the callback with one or more character\n// specifications. A character specification consumes one or more input\n// characters.\n//\n// The `regex` method returns a regex fragment for the segment. If the\n// segment is a dynamic of star segment, the regex fragment also includes\n// a capture.\n//\n// A character specification contains:\n//\n// * `validChars`: a String with a list of all valid characters, or\n// * `invalidChars`: a String with a list of all invalid characters\n// * `repeat`: true if the character specification can repeat\n\nfunction StaticSegment(string) {\n  this.string = string;\n}\nStaticSegment.prototype = {\n  eachChar: function eachChar(callback) {\n    var string = this.string,\n        ch;\n\n    for (var i = 0, l = string.length; i < l; i++) {\n      ch = string.charAt(i);\n      callback({ validChars: ch });\n    }\n  },\n\n  regex: function regex() {\n    return this.string.replace(escapeRegex, '\\\\$1');\n  },\n\n  generate: function generate() {\n    return this.string;\n  }\n};\n\nfunction DynamicSegment(name) {\n  this.name = name;\n}\nDynamicSegment.prototype = {\n  eachChar: function eachChar(callback) {\n    callback({ invalidChars: \"/\", repeat: true });\n  },\n\n  regex: function regex() {\n    return \"([^/]+)\";\n  },\n\n  generate: function generate(params) {\n    return params[this.name];\n  }\n};\n\nfunction StarSegment(name) {\n  this.name = name;\n}\nStarSegment.prototype = {\n  eachChar: function eachChar(callback) {\n    callback({ invalidChars: \"\", repeat: true });\n  },\n\n  regex: function regex() {\n    return \"(.+)\";\n  },\n\n  generate: function generate(params) {\n    return params[this.name];\n  }\n};\n\nfunction EpsilonSegment() {}\nEpsilonSegment.prototype = {\n  eachChar: function eachChar() {},\n  regex: function regex() {\n    return \"\";\n  },\n  generate: function generate() {\n    return \"\";\n  }\n};\n\nfunction parse(route, names, specificity) {\n  // normalize route as not starting with a \"/\". Recognition will\n  // also normalize.\n  if (route.charAt(0) === \"/\") {\n    route = route.substr(1);\n  }\n\n  var segments = route.split(\"/\"),\n      results = [];\n\n  // A routes has specificity determined by the order that its different segments\n  // appear in. This system mirrors how the magnitude of numbers written as strings\n  // works.\n  // Consider a number written as: \"abc\". An example would be \"200\". Any other number written\n  // \"xyz\" will be smaller than \"abc\" so long as `a > z`. For instance, \"199\" is smaller\n  // then \"200\", even though \"y\" and \"z\" (which are both 9) are larger than \"0\" (the value\n  // of (`b` and `c`). This is because the leading symbol, \"2\", is larger than the other\n  // leading symbol, \"1\".\n  // The rule is that symbols to the left carry more weight than symbols to the right\n  // when a number is written out as a string. In the above strings, the leading digit\n  // represents how many 100's are in the number, and it carries more weight than the middle\n  // number which represents how many 10's are in the number.\n  // This system of number magnitude works well for route specificity, too. A route written as\n  // `a/b/c` will be more specific than `x/y/z` as long as `a` is more specific than\n  // `x`, irrespective of the other parts.\n  // Because of this similarity, we assign each type of segment a number value written as a\n  // string. We can find the specificity of compound routes by concatenating these strings\n  // together, from left to right. After we have looped through all of the segments,\n  // we convert the string to a number.\n  specificity.val = '';\n\n  for (var i = 0, l = segments.length; i < l; i++) {\n    var segment = segments[i],\n        match;\n\n    if (match = segment.match(/^:([^\\/]+)$/)) {\n      results.push(new DynamicSegment(match[1]));\n      names.push(match[1]);\n      specificity.val += '3';\n    } else if (match = segment.match(/^\\*([^\\/]+)$/)) {\n      results.push(new StarSegment(match[1]));\n      specificity.val += '2';\n      names.push(match[1]);\n    } else if (segment === \"\") {\n      results.push(new EpsilonSegment());\n      specificity.val += '1';\n    } else {\n      results.push(new StaticSegment(segment));\n      specificity.val += '4';\n    }\n  }\n\n  specificity.val = +specificity.val;\n\n  return results;\n}\n\n// A State has a character specification and (`charSpec`) and a list of possible\n// subsequent states (`nextStates`).\n//\n// If a State is an accepting state, it will also have several additional\n// properties:\n//\n// * `regex`: A regular expression that is used to extract parameters from paths\n//   that reached this accepting state.\n// * `handlers`: Information on how to convert the list of captures into calls\n//   to registered handlers with the specified parameters\n// * `types`: How many static, dynamic or star segments in this route. Used to\n//   decide which route to use if multiple registered routes match a path.\n//\n// Currently, State is implemented naively by looping over `nextStates` and\n// comparing a character specification against a character. A more efficient\n// implementation would use a hash of keys pointing at one or more next states.\n\nfunction State(charSpec) {\n  this.charSpec = charSpec;\n  this.nextStates = [];\n}\n\nState.prototype = {\n  get: function get(charSpec) {\n    var nextStates = this.nextStates;\n\n    for (var i = 0, l = nextStates.length; i < l; i++) {\n      var child = nextStates[i];\n\n      var isEqual = child.charSpec.validChars === charSpec.validChars;\n      isEqual = isEqual && child.charSpec.invalidChars === charSpec.invalidChars;\n\n      if (isEqual) {\n        return child;\n      }\n    }\n  },\n\n  put: function put(charSpec) {\n    var state;\n\n    // If the character specification already exists in a child of the current\n    // state, just return that state.\n    if (state = this.get(charSpec)) {\n      return state;\n    }\n\n    // Make a new state for the character spec\n    state = new State(charSpec);\n\n    // Insert the new state as a child of the current state\n    this.nextStates.push(state);\n\n    // If this character specification repeats, insert the new state as a child\n    // of itself. Note that this will not trigger an infinite loop because each\n    // transition during recognition consumes a character.\n    if (charSpec.repeat) {\n      state.nextStates.push(state);\n    }\n\n    // Return the new state\n    return state;\n  },\n\n  // Find a list of child states matching the next character\n  match: function match(ch) {\n    // DEBUG \"Processing `\" + ch + \"`:\"\n    var nextStates = this.nextStates,\n        child,\n        charSpec,\n        chars;\n\n    // DEBUG \"  \" + debugState(this)\n    var returned = [];\n\n    for (var i = 0, l = nextStates.length; i < l; i++) {\n      child = nextStates[i];\n\n      charSpec = child.charSpec;\n\n      if (typeof (chars = charSpec.validChars) !== 'undefined') {\n        if (chars.indexOf(ch) !== -1) {\n          returned.push(child);\n        }\n      } else if (typeof (chars = charSpec.invalidChars) !== 'undefined') {\n        if (chars.indexOf(ch) === -1) {\n          returned.push(child);\n        }\n      }\n    }\n\n    return returned;\n  }\n\n  /** IF DEBUG\n  , debug: function() {\n    var charSpec = this.charSpec,\n        debug = \"[\",\n        chars = charSpec.validChars || charSpec.invalidChars;\n     if (charSpec.invalidChars) { debug += \"^\"; }\n    debug += chars;\n    debug += \"]\";\n     if (charSpec.repeat) { debug += \"+\"; }\n     return debug;\n  }\n  END IF **/\n};\n\n/** IF DEBUG\nfunction debug(log) {\n  console.log(log);\n}\n\nfunction debugState(state) {\n  return state.nextStates.map(function(n) {\n    if (n.nextStates.length === 0) { return \"( \" + n.debug() + \" [accepting] )\"; }\n    return \"( \" + n.debug() + \" <then> \" + n.nextStates.map(function(s) { return s.debug() }).join(\" or \") + \" )\";\n  }).join(\", \")\n}\nEND IF **/\n\n// Sort the routes by specificity\nfunction sortSolutions(states) {\n  return states.sort(function (a, b) {\n    return b.specificity.val - a.specificity.val;\n  });\n}\n\nfunction recognizeChar(states, ch) {\n  var nextStates = [];\n\n  for (var i = 0, l = states.length; i < l; i++) {\n    var state = states[i];\n\n    nextStates = nextStates.concat(state.match(ch));\n  }\n\n  return nextStates;\n}\n\nvar oCreate = Object.create || function (proto) {\n  function F() {}\n  F.prototype = proto;\n  return new F();\n};\n\nfunction RecognizeResults(queryParams) {\n  this.queryParams = queryParams || {};\n}\nRecognizeResults.prototype = oCreate({\n  splice: Array.prototype.splice,\n  slice: Array.prototype.slice,\n  push: Array.prototype.push,\n  length: 0,\n  queryParams: null\n});\n\nfunction findHandler(state, path, queryParams) {\n  var handlers = state.handlers,\n      regex = state.regex;\n  var captures = path.match(regex),\n      currentCapture = 1;\n  var result = new RecognizeResults(queryParams);\n\n  for (var i = 0, l = handlers.length; i < l; i++) {\n    var handler = handlers[i],\n        names = handler.names,\n        params = {};\n\n    for (var j = 0, m = names.length; j < m; j++) {\n      params[names[j]] = captures[currentCapture++];\n    }\n\n    result.push({ handler: handler.handler, params: params, isDynamic: !!names.length });\n  }\n\n  return result;\n}\n\nfunction addSegment(currentState, segment) {\n  segment.eachChar(function (ch) {\n    var state;\n\n    currentState = currentState.put(ch);\n  });\n\n  return currentState;\n}\n\nfunction decodeQueryParamPart(part) {\n  // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n  part = part.replace(/\\+/gm, '%20');\n  return decodeURIComponent(part);\n}\n\n// The main interface\n\nvar RouteRecognizer = function RouteRecognizer() {\n  this.rootState = new State();\n  this.names = {};\n};\n\nRouteRecognizer.prototype = {\n  add: function add(routes, options) {\n    var currentState = this.rootState,\n        regex = \"^\",\n        specificity = {},\n        handlers = [],\n        allSegments = [],\n        name;\n\n    var isEmpty = true;\n\n    for (var i = 0, l = routes.length; i < l; i++) {\n      var route = routes[i],\n          names = [];\n\n      var segments = parse(route.path, names, specificity);\n\n      allSegments = allSegments.concat(segments);\n\n      for (var j = 0, m = segments.length; j < m; j++) {\n        var segment = segments[j];\n\n        if (segment instanceof EpsilonSegment) {\n          continue;\n        }\n\n        isEmpty = false;\n\n        // Add a \"/\" for the new segment\n        currentState = currentState.put({ validChars: \"/\" });\n        regex += \"/\";\n\n        // Add a representation of the segment to the NFA and regex\n        currentState = addSegment(currentState, segment);\n        regex += segment.regex();\n      }\n\n      var handler = { handler: route.handler, names: names };\n      handlers.push(handler);\n    }\n\n    if (isEmpty) {\n      currentState = currentState.put({ validChars: \"/\" });\n      regex += \"/\";\n    }\n\n    currentState.handlers = handlers;\n    currentState.regex = new RegExp(regex + \"$\");\n    currentState.specificity = specificity;\n\n    if (name = options && options.as) {\n      this.names[name] = {\n        segments: allSegments,\n        handlers: handlers\n      };\n    }\n  },\n\n  handlersFor: function handlersFor(name) {\n    var route = this.names[name],\n        result = [];\n    if (!route) {\n      throw new Error(\"There is no route named \" + name);\n    }\n\n    for (var i = 0, l = route.handlers.length; i < l; i++) {\n      result.push(route.handlers[i]);\n    }\n\n    return result;\n  },\n\n  hasRoute: function hasRoute(name) {\n    return !!this.names[name];\n  },\n\n  generate: function generate(name, params) {\n    var route = this.names[name],\n        output = \"\";\n    if (!route) {\n      throw new Error(\"There is no route named \" + name);\n    }\n\n    var segments = route.segments;\n\n    for (var i = 0, l = segments.length; i < l; i++) {\n      var segment = segments[i];\n\n      if (segment instanceof EpsilonSegment) {\n        continue;\n      }\n\n      output += \"/\";\n      output += segment.generate(params);\n    }\n\n    if (output.charAt(0) !== '/') {\n      output = '/' + output;\n    }\n\n    if (params && params.queryParams) {\n      output += this.generateQueryString(params.queryParams);\n    }\n\n    return output;\n  },\n\n  generateQueryString: function generateQueryString(params) {\n    var pairs = [];\n    var keys = [];\n    for (var key in params) {\n      if (params.hasOwnProperty(key)) {\n        keys.push(key);\n      }\n    }\n    keys.sort();\n    for (var i = 0, len = keys.length; i < len; i++) {\n      key = keys[i];\n      var value = params[key];\n      if (value == null) {\n        continue;\n      }\n      var pair = encodeURIComponent(key);\n      if (isArray(value)) {\n        for (var j = 0, l = value.length; j < l; j++) {\n          var arrayPair = key + '[]' + '=' + encodeURIComponent(value[j]);\n          pairs.push(arrayPair);\n        }\n      } else {\n        pair += \"=\" + encodeURIComponent(value);\n        pairs.push(pair);\n      }\n    }\n\n    if (pairs.length === 0) {\n      return '';\n    }\n\n    return \"?\" + pairs.join(\"&\");\n  },\n\n  parseQueryString: function parseQueryString(queryString) {\n    var pairs = queryString.split(\"&\"),\n        queryParams = {};\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i].split('='),\n          key = decodeQueryParamPart(pair[0]),\n          keyLength = key.length,\n          isArray = false,\n          value;\n      if (pair.length === 1) {\n        value = 'true';\n      } else {\n        //Handle arrays\n        if (keyLength > 2 && key.slice(keyLength - 2) === '[]') {\n          isArray = true;\n          key = key.slice(0, keyLength - 2);\n          if (!queryParams[key]) {\n            queryParams[key] = [];\n          }\n        }\n        value = pair[1] ? decodeQueryParamPart(pair[1]) : '';\n      }\n      if (isArray) {\n        queryParams[key].push(value);\n      } else {\n        queryParams[key] = value;\n      }\n    }\n    return queryParams;\n  },\n\n  recognize: function recognize(path) {\n    var states = [this.rootState],\n        pathLen,\n        i,\n        l,\n        queryStart,\n        queryParams = {},\n        isSlashDropped = false;\n\n    queryStart = path.indexOf('?');\n    if (queryStart !== -1) {\n      var queryString = path.substr(queryStart + 1, path.length);\n      path = path.substr(0, queryStart);\n      queryParams = this.parseQueryString(queryString);\n    }\n\n    path = decodeURI(path);\n\n    // DEBUG GROUP path\n\n    if (path.charAt(0) !== \"/\") {\n      path = \"/\" + path;\n    }\n\n    pathLen = path.length;\n    if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n      path = path.substr(0, pathLen - 1);\n      isSlashDropped = true;\n    }\n\n    for (i = 0, l = path.length; i < l; i++) {\n      states = recognizeChar(states, path.charAt(i));\n      if (!states.length) {\n        break;\n      }\n    }\n\n    // END DEBUG GROUP\n\n    var solutions = [];\n    for (i = 0, l = states.length; i < l; i++) {\n      if (states[i].handlers) {\n        solutions.push(states[i]);\n      }\n    }\n\n    states = sortSolutions(solutions);\n\n    var state = solutions[0];\n\n    if (state && state.handlers) {\n      // if a trailing slash was dropped and a star segment is the last segment\n      // specified, put the trailing slash back\n      if (isSlashDropped && state.regex.source.slice(-5) === \"(.+)$\") {\n        path = path + \"/\";\n      }\n      return findHandler(state, path, queryParams);\n    }\n  }\n};\n\nRouteRecognizer.prototype.map = map;\n\nRouteRecognizer.VERSION = '0.1.9';\n\nvar genQuery = RouteRecognizer.prototype.generateQueryString;\n\n// export default for holding the Vue reference\nvar exports$1 = {};\n/**\n * Warn stuff.\n *\n * @param {String} msg\n */\n\nfunction warn(msg) {\n  /* istanbul ignore next */\n  if (window.console) {\n    console.warn('[vue-router] ' + msg);\n    /* istanbul ignore if */\n    if (!exports$1.Vue || exports$1.Vue.config.debug) {\n      console.warn(new Error('warning stack trace:').stack);\n    }\n  }\n}\n\n/**\n * Resolve a relative path.\n *\n * @param {String} base\n * @param {String} relative\n * @param {Boolean} append\n * @return {String}\n */\n\nfunction resolvePath(base, relative, append) {\n  var query = base.match(/(\\?.*)$/);\n  if (query) {\n    query = query[1];\n    base = base.slice(0, -query.length);\n  }\n  // a query!\n  if (relative.charAt(0) === '?') {\n    return base + relative;\n  }\n  var stack = base.split('/');\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '.') {\n      continue;\n    } else if (segment === '..') {\n      stack.pop();\n    } else {\n      stack.push(segment);\n    }\n  }\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n  return stack.join('/');\n}\n\n/**\n * Forgiving check for a promise\n *\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction isPromise(p) {\n  return p && typeof p.then === 'function';\n}\n\n/**\n * Retrive a route config field from a component instance\n * OR a component contructor.\n *\n * @param {Function|Vue} component\n * @param {String} name\n * @return {*}\n */\n\nfunction getRouteConfig(component, name) {\n  var options = component && (component.$options || component.options);\n  return options && options.route && options.route[name];\n}\n\n/**\n * Resolve an async component factory. Have to do a dirty\n * mock here because of Vue core's internal API depends on\n * an ID check.\n *\n * @param {Object} handler\n * @param {Function} cb\n */\n\nvar resolver = undefined;\n\nfunction resolveAsyncComponent(handler, cb) {\n  if (!resolver) {\n    resolver = {\n      resolve: exports$1.Vue.prototype._resolveComponent,\n      $options: {\n        components: {\n          _: handler.component\n        }\n      }\n    };\n  } else {\n    resolver.$options.components._ = handler.component;\n  }\n  resolver.resolve('_', function (Component) {\n    handler.component = Component;\n    cb(Component);\n  });\n}\n\n/**\n * Map the dynamic segments in a path to params.\n *\n * @param {String} path\n * @param {Object} params\n * @param {Object} query\n */\n\nfunction mapParams(path, params, query) {\n  if (params === undefined) params = {};\n\n  path = path.replace(/:([^\\/]+)/g, function (_, key) {\n    var val = params[key];\n    if (!val) {\n      warn('param \"' + key + '\" not found when generating ' + 'path for \"' + path + '\" with params ' + JSON.stringify(params));\n    }\n    return val || '';\n  });\n  if (query) {\n    path += genQuery(query);\n  }\n  return path;\n}\n\nvar hashRE = /#.*$/;\n\nvar HTML5History = (function () {\n  function HTML5History(_ref) {\n    var root = _ref.root;\n    var onChange = _ref.onChange;\n    babelHelpers.classCallCheck(this, HTML5History);\n\n    if (root) {\n      // make sure there's the starting slash\n      if (root.charAt(0) !== '/') {\n        root = '/' + root;\n      }\n      // remove trailing slash\n      this.root = root.replace(/\\/$/, '');\n      this.rootRE = new RegExp('^\\\\' + this.root);\n    } else {\n      this.root = null;\n    }\n    this.onChange = onChange;\n    // check base tag\n    var baseEl = document.querySelector('base');\n    this.base = baseEl && baseEl.getAttribute('href');\n  }\n\n  HTML5History.prototype.start = function start() {\n    var _this = this;\n\n    this.listener = function (e) {\n      var url = decodeURI(location.pathname + location.search);\n      if (_this.root) {\n        url = url.replace(_this.rootRE, '');\n      }\n      _this.onChange(url, e && e.state, location.hash);\n    };\n    window.addEventListener('popstate', this.listener);\n    this.listener();\n  };\n\n  HTML5History.prototype.stop = function stop() {\n    window.removeEventListener('popstate', this.listener);\n  };\n\n  HTML5History.prototype.go = function go(path, replace, append) {\n    var url = this.formatPath(path, append);\n    if (replace) {\n      history.replaceState({}, '', url);\n    } else {\n      // record scroll position by replacing current state\n      history.replaceState({\n        pos: {\n          x: window.pageXOffset,\n          y: window.pageYOffset\n        }\n      }, '');\n      // then push new state\n      history.pushState({}, '', url);\n    }\n    var hashMatch = path.match(hashRE);\n    var hash = hashMatch && hashMatch[0];\n    path = url\n    // strip hash so it doesn't mess up params\n    .replace(hashRE, '')\n    // remove root before matching\n    .replace(this.rootRE, '');\n    this.onChange(path, null, hash);\n  };\n\n  HTML5History.prototype.formatPath = function formatPath(path, append) {\n    return path.charAt(0) === '/'\n    // absolute path\n    ? this.root ? this.root + '/' + path.replace(/^\\//, '') : path : resolvePath(this.base || location.pathname, path, append);\n  };\n\n  return HTML5History;\n})();\n\nvar HashHistory = (function () {\n  function HashHistory(_ref) {\n    var hashbang = _ref.hashbang;\n    var onChange = _ref.onChange;\n    babelHelpers.classCallCheck(this, HashHistory);\n\n    this.hashbang = hashbang;\n    this.onChange = onChange;\n  }\n\n  HashHistory.prototype.start = function start() {\n    var self = this;\n    this.listener = function () {\n      var path = location.hash;\n      var raw = path.replace(/^#!?/, '');\n      // always\n      if (raw.charAt(0) !== '/') {\n        raw = '/' + raw;\n      }\n      var formattedPath = self.formatPath(raw);\n      if (formattedPath !== path) {\n        location.replace(formattedPath);\n        return;\n      }\n      // determine query\n      // note it's possible to have queries in both the actual URL\n      // and the hash fragment itself.\n      var query = location.search && path.indexOf('?') > -1 ? '&' + location.search.slice(1) : location.search;\n      self.onChange(decodeURI(path.replace(/^#!?/, '') + query));\n    };\n    window.addEventListener('hashchange', this.listener);\n    this.listener();\n  };\n\n  HashHistory.prototype.stop = function stop() {\n    window.removeEventListener('hashchange', this.listener);\n  };\n\n  HashHistory.prototype.go = function go(path, replace, append) {\n    path = this.formatPath(path, append);\n    if (replace) {\n      location.replace(path);\n    } else {\n      location.hash = path;\n    }\n  };\n\n  HashHistory.prototype.formatPath = function formatPath(path, append) {\n    var isAbsoloute = path.charAt(0) === '/';\n    var prefix = '#' + (this.hashbang ? '!' : '');\n    return isAbsoloute ? prefix + path : prefix + resolvePath(location.hash.replace(/^#!?/, ''), path, append);\n  };\n\n  return HashHistory;\n})();\n\nvar AbstractHistory = (function () {\n  function AbstractHistory(_ref) {\n    var onChange = _ref.onChange;\n    babelHelpers.classCallCheck(this, AbstractHistory);\n\n    this.onChange = onChange;\n    this.currentPath = '/';\n  }\n\n  AbstractHistory.prototype.start = function start() {\n    this.onChange('/');\n  };\n\n  AbstractHistory.prototype.stop = function stop() {\n    // noop\n  };\n\n  AbstractHistory.prototype.go = function go(path, replace, append) {\n    path = this.currentPath = this.formatPath(path, append);\n    this.onChange(path);\n  };\n\n  AbstractHistory.prototype.formatPath = function formatPath(path, append) {\n    return path.charAt(0) === '/' ? path : resolvePath(this.currentPath, path, append);\n  };\n\n  return AbstractHistory;\n})();\n\n/**\n * Determine the reusability of an existing router view.\n *\n * @param {Directive} view\n * @param {Object} handler\n * @param {Transition} transition\n */\n\nfunction canReuse(view, handler, transition) {\n  var component = view.childVM;\n  if (!component || !handler) {\n    return false;\n  }\n  // important: check view.Component here because it may\n  // have been changed in activate hook\n  if (view.Component !== handler.component) {\n    return false;\n  }\n  var canReuseFn = getRouteConfig(component, 'canReuse');\n  return typeof canReuseFn === 'boolean' ? canReuseFn : canReuseFn ? canReuseFn.call(component, {\n    to: transition.to,\n    from: transition.from\n  }) : true; // defaults to true\n}\n\n/**\n * Check if a component can deactivate.\n *\n * @param {Directive} view\n * @param {Transition} transition\n * @param {Function} next\n */\n\nfunction canDeactivate(view, transition, next) {\n  var fromComponent = view.childVM;\n  var hook = getRouteConfig(fromComponent, 'canDeactivate');\n  if (!hook) {\n    next();\n  } else {\n    transition.callHook(hook, fromComponent, next, {\n      expectBoolean: true\n    });\n  }\n}\n\n/**\n * Check if a component can activate.\n *\n * @param {Object} handler\n * @param {Transition} transition\n * @param {Function} next\n */\n\nfunction canActivate(handler, transition, next) {\n  resolveAsyncComponent(handler, function (Component) {\n    // have to check due to async-ness\n    if (transition.aborted) {\n      return;\n    }\n    // determine if this component can be activated\n    var hook = getRouteConfig(Component, 'canActivate');\n    if (!hook) {\n      next();\n    } else {\n      transition.callHook(hook, null, next, {\n        expectBoolean: true\n      });\n    }\n  });\n}\n\n/**\n * Call deactivate hooks for existing router-views.\n *\n * @param {Directive} view\n * @param {Transition} transition\n * @param {Function} next\n */\n\nfunction deactivate(view, transition, next) {\n  var component = view.childVM;\n  var hook = getRouteConfig(component, 'deactivate');\n  if (!hook) {\n    next();\n  } else {\n    transition.callHooks(hook, component, next);\n  }\n}\n\n/**\n * Activate / switch component for a router-view.\n *\n * @param {Directive} view\n * @param {Transition} transition\n * @param {Number} depth\n * @param {Function} [cb]\n */\n\nfunction activate(view, transition, depth, cb, reuse) {\n  var handler = transition.activateQueue[depth];\n  if (!handler) {\n    // fix 1.0.0-alpha.3 compat\n    if (view._bound) {\n      view.setComponent(null);\n    }\n    cb && cb();\n    return;\n  }\n\n  var Component = view.Component = handler.component;\n  var activateHook = getRouteConfig(Component, 'activate');\n  var dataHook = getRouteConfig(Component, 'data');\n  var waitForData = getRouteConfig(Component, 'waitForData');\n\n  view.depth = depth;\n  view.activated = false;\n\n  var component = undefined;\n  var loading = !!(dataHook && !waitForData);\n\n  // \"reuse\" is a flag passed down when the parent view is\n  // either reused via keep-alive or as a child of a kept-alive view.\n  // of course we can only reuse if the current kept-alive instance\n  // is of the correct type.\n  reuse = reuse && view.childVM && view.childVM.constructor === Component;\n\n  if (reuse) {\n    // just reuse\n    component = view.childVM;\n    component.$loadingRouteData = loading;\n  } else {\n    // unbuild current component. this step also destroys\n    // and removes all nested child views.\n    view.unbuild(true);\n    // handle keep-alive.\n    // if the view has keep-alive, the child vm is not actually\n    // destroyed - its nested views will still be in router's\n    // view list. We need to removed these child views and\n    // cache them on the child vm.\n    if (view.keepAlive) {\n      var views = transition.router._views;\n      var i = views.indexOf(view);\n      if (i > 0) {\n        transition.router._views = views.slice(i);\n        if (view.childVM) {\n          view.childVM._routerViews = views.slice(0, i);\n        }\n      }\n    }\n\n    // build the new component. this will also create the\n    // direct child view of the current one. it will register\n    // itself as view.childView.\n    component = view.build({\n      _meta: {\n        $loadingRouteData: loading\n      }\n    });\n    // handle keep-alive.\n    // when a kept-alive child vm is restored, we need to\n    // add its cached child views into the router's view list,\n    // and also properly update current view's child view.\n    if (view.keepAlive) {\n      component.$loadingRouteData = loading;\n      var cachedViews = component._routerViews;\n      if (cachedViews) {\n        transition.router._views = cachedViews.concat(transition.router._views);\n        view.childView = cachedViews[cachedViews.length - 1];\n        component._routerViews = null;\n      }\n    }\n  }\n\n  // cleanup the component in case the transition is aborted\n  // before the component is ever inserted.\n  var cleanup = function cleanup() {\n    component.$destroy();\n  };\n\n  // actually insert the component and trigger transition\n  var insert = function insert() {\n    if (reuse) {\n      cb && cb();\n      return;\n    }\n    var router = transition.router;\n    if (router._rendered || router._transitionOnLoad) {\n      view.transition(component);\n    } else {\n      // no transition on first render, manual transition\n      /* istanbul ignore if */\n      if (view.setCurrent) {\n        // 0.12 compat\n        view.setCurrent(component);\n      } else {\n        // 1.0\n        view.childVM = component;\n      }\n      component.$before(view.anchor, null, false);\n    }\n    cb && cb();\n  };\n\n  // called after activation hook is resolved\n  var afterActivate = function afterActivate() {\n    view.activated = true;\n    // activate the child view\n    if (view.childView) {\n      activate(view.childView, transition, depth + 1, null, reuse || view.keepAlive);\n    }\n    if (dataHook && waitForData) {\n      // wait until data loaded to insert\n      loadData(component, transition, dataHook, insert, cleanup);\n    } else {\n      // load data and insert at the same time\n      if (dataHook) {\n        loadData(component, transition, dataHook);\n      }\n      insert();\n    }\n  };\n\n  if (activateHook) {\n    transition.callHooks(activateHook, component, afterActivate, {\n      cleanup: cleanup\n    });\n  } else {\n    afterActivate();\n  }\n}\n\n/**\n * Reuse a view, just reload data if necessary.\n *\n * @param {Directive} view\n * @param {Transition} transition\n */\n\nfunction reuse(view, transition) {\n  var component = view.childVM;\n  var dataHook = getRouteConfig(component, 'data');\n  if (dataHook) {\n    loadData(component, transition, dataHook);\n  }\n}\n\n/**\n * Asynchronously load and apply data to component.\n *\n * @param {Vue} component\n * @param {Transition} transition\n * @param {Function} hook\n * @param {Function} cb\n * @param {Function} cleanup\n */\n\nfunction loadData(component, transition, hook, cb, cleanup) {\n  component.$loadingRouteData = true;\n  transition.callHooks(hook, component, function (data, onError) {\n    // merge data from multiple data hooks\n    if (Array.isArray(data) && data._needMerge) {\n      data = data.reduce(function (res, obj) {\n        if (isPlainObject(obj)) {\n          Object.keys(obj).forEach(function (key) {\n            res[key] = obj[key];\n          });\n        }\n        return res;\n      }, Object.create(null));\n    }\n    // handle promise sugar syntax\n    var promises = [];\n    if (isPlainObject(data)) {\n      Object.keys(data).forEach(function (key) {\n        var val = data[key];\n        if (isPromise(val)) {\n          promises.push(val.then(function (resolvedVal) {\n            component.$set(key, resolvedVal);\n          }));\n        } else {\n          component.$set(key, val);\n        }\n      });\n    }\n    if (!promises.length) {\n      component.$loadingRouteData = false;\n      cb && cb();\n    } else {\n      promises[0].constructor.all(promises).then(function (_) {\n        component.$loadingRouteData = false;\n        cb && cb();\n      }, onError);\n    }\n  }, {\n    cleanup: cleanup,\n    expectData: true\n  });\n}\n\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n\n/**\n * A RouteTransition object manages the pipeline of a\n * router-view switching process. This is also the object\n * passed into user route hooks.\n *\n * @param {Router} router\n * @param {Route} to\n * @param {Route} from\n */\n\nvar RouteTransition = (function () {\n  function RouteTransition(router, to, from) {\n    babelHelpers.classCallCheck(this, RouteTransition);\n\n    this.router = router;\n    this.to = to;\n    this.from = from;\n    this.next = null;\n    this.aborted = false;\n    this.done = false;\n\n    // start by determine the queues\n\n    // the deactivate queue is an array of router-view\n    // directive instances that need to be deactivated,\n    // deepest first.\n    this.deactivateQueue = router._views;\n\n    // check the default handler of the deepest match\n    var matched = to.matched ? Array.prototype.slice.call(to.matched) : [];\n\n    // the activate queue is an array of route handlers\n    // that need to be activated\n    this.activateQueue = matched.map(function (match) {\n      return match.handler;\n    });\n  }\n\n  /**\n   * Abort current transition and return to previous location.\n   */\n\n  RouteTransition.prototype.abort = function abort() {\n    if (!this.aborted) {\n      this.aborted = true;\n      // if the root path throws an error during validation\n      // on initial load, it gets caught in an infinite loop.\n      var abortingOnLoad = !this.from.path && this.to.path === '/';\n      if (!abortingOnLoad) {\n        this.router.replace(this.from.path || '/');\n      }\n    }\n  };\n\n  /**\n   * Abort current transition and redirect to a new location.\n   *\n   * @param {String} path\n   */\n\n  RouteTransition.prototype.redirect = function redirect(path) {\n    if (!this.aborted) {\n      this.aborted = true;\n      if (typeof path === 'string') {\n        path = mapParams(path, this.to.params, this.to.query);\n      } else {\n        path.params = path.params || this.to.params;\n        path.query = path.query || this.to.query;\n      }\n      this.router.replace(path);\n    }\n  };\n\n  /**\n   * A router view transition's pipeline can be described as\n   * follows, assuming we are transitioning from an existing\n   * <router-view> chain [Component A, Component B] to a new\n   * chain [Component A, Component C]:\n   *\n   *  A    A\n   *  | => |\n   *  B    C\n   *\n   * 1. Reusablity phase:\n   *   -> canReuse(A, A)\n   *   -> canReuse(B, C)\n   *   -> determine new queues:\n   *      - deactivation: [B]\n   *      - activation: [C]\n   *\n   * 2. Validation phase:\n   *   -> canDeactivate(B)\n   *   -> canActivate(C)\n   *\n   * 3. Activation phase:\n   *   -> deactivate(B)\n   *   -> activate(C)\n   *\n   * Each of these steps can be asynchronous, and any\n   * step can potentially abort the transition.\n   *\n   * @param {Function} cb\n   */\n\n  RouteTransition.prototype.start = function start(cb) {\n    var transition = this;\n    var daq = this.deactivateQueue;\n    var aq = this.activateQueue;\n    var rdaq = daq.slice().reverse();\n    var reuseQueue = undefined;\n\n    // 1. Reusability phase\n    var i = undefined;\n    for (i = 0; i < rdaq.length; i++) {\n      if (!canReuse(rdaq[i], aq[i], transition)) {\n        break;\n      }\n    }\n    if (i > 0) {\n      reuseQueue = rdaq.slice(0, i);\n      daq = rdaq.slice(i).reverse();\n      aq = aq.slice(i);\n    }\n\n    // 2. Validation phase\n    transition.runQueue(daq, canDeactivate, function () {\n      transition.runQueue(aq, canActivate, function () {\n        transition.runQueue(daq, deactivate, function () {\n          // 3. Activation phase\n\n          // Update router current route\n          transition.router._onTransitionValidated(transition);\n\n          // trigger reuse for all reused views\n          reuseQueue && reuseQueue.forEach(function (view) {\n            reuse(view, transition);\n          });\n\n          // the root of the chain that needs to be replaced\n          // is the top-most non-reusable view.\n          if (daq.length) {\n            var view = daq[daq.length - 1];\n            var depth = reuseQueue ? reuseQueue.length : 0;\n            activate(view, transition, depth, cb);\n          } else {\n            cb();\n          }\n        });\n      });\n    });\n  };\n\n  /**\n   * Asynchronously and sequentially apply a function to a\n   * queue.\n   *\n   * @param {Array} queue\n   * @param {Function} fn\n   * @param {Function} cb\n   */\n\n  RouteTransition.prototype.runQueue = function runQueue(queue, fn, cb) {\n    var transition = this;\n    step(0);\n    function step(index) {\n      if (index >= queue.length) {\n        cb();\n      } else {\n        fn(queue[index], transition, function () {\n          step(index + 1);\n        });\n      }\n    }\n  };\n\n  /**\n   * Call a user provided route transition hook and handle\n   * the response (e.g. if the user returns a promise).\n   *\n   * If the user neither expects an argument nor returns a\n   * promise, the hook is assumed to be synchronous.\n   *\n   * @param {Function} hook\n   * @param {*} [context]\n   * @param {Function} [cb]\n   * @param {Object} [options]\n   *                 - {Boolean} expectBoolean\n   *                 - {Boolean} expectData\n   *                 - {Function} cleanup\n   */\n\n  RouteTransition.prototype.callHook = function callHook(hook, context, cb) {\n    var _ref = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n    var _ref$expectBoolean = _ref.expectBoolean;\n    var expectBoolean = _ref$expectBoolean === undefined ? false : _ref$expectBoolean;\n    var _ref$expectData = _ref.expectData;\n    var expectData = _ref$expectData === undefined ? false : _ref$expectData;\n    var cleanup = _ref.cleanup;\n\n    var transition = this;\n    var nextCalled = false;\n\n    // abort the transition\n    var abort = function abort() {\n      cleanup && cleanup();\n      transition.abort();\n    };\n\n    // handle errors\n    var onError = function onError(err) {\n      // cleanup indicates an after-activation hook,\n      // so instead of aborting we just let the transition\n      // finish.\n      cleanup ? next() : abort();\n      if (err && !transition.router._suppress) {\n        warn('Uncaught error during transition: ');\n        throw err instanceof Error ? err : new Error(err);\n      }\n    };\n\n    // advance the transition to the next step\n    var next = function next(data) {\n      if (nextCalled) {\n        warn('transition.next() should be called only once.');\n        return;\n      }\n      nextCalled = true;\n      if (transition.aborted) {\n        cleanup && cleanup();\n        return;\n      }\n      cb && cb(data, onError);\n    };\n\n    // expose a clone of the transition object, so that each\n    // hook gets a clean copy and prevent the user from\n    // messing with the internals.\n    var exposed = {\n      to: transition.to,\n      from: transition.from,\n      abort: abort,\n      next: next,\n      redirect: function redirect() {\n        transition.redirect.apply(transition, arguments);\n      }\n    };\n\n    // actually call the hook\n    var res = undefined;\n    try {\n      res = hook.call(context, exposed);\n    } catch (err) {\n      return onError(err);\n    }\n\n    // handle boolean/promise return values\n    var resIsPromise = isPromise(res);\n    if (expectBoolean) {\n      if (typeof res === 'boolean') {\n        res ? next() : abort();\n      } else if (resIsPromise) {\n        res.then(function (ok) {\n          ok ? next() : abort();\n        }, onError);\n      } else if (!hook.length) {\n        next(res);\n      }\n    } else if (resIsPromise) {\n      res.then(next, onError);\n    } else if (expectData && isPlainOjbect(res) || !hook.length) {\n      next(res);\n    }\n  };\n\n  /**\n   * Call a single hook or an array of async hooks in series.\n   *\n   * @param {Array} hooks\n   * @param {*} context\n   * @param {Function} cb\n   * @param {Object} [options]\n   */\n\n  RouteTransition.prototype.callHooks = function callHooks(hooks, context, cb, options) {\n    var _this = this;\n\n    if (Array.isArray(hooks)) {\n      (function () {\n        var res = [];\n        res._needMerge = true;\n        var onError = undefined;\n        _this.runQueue(hooks, function (hook, _, next) {\n          if (!_this.aborted) {\n            _this.callHook(hook, context, function (r, onError) {\n              if (r) res.push(r);\n              onError = onError;\n              next();\n            }, options);\n          }\n        }, function () {\n          cb(res, onError);\n        });\n      })();\n    } else {\n      this.callHook(hooks, context, cb, options);\n    }\n  };\n\n  return RouteTransition;\n})();\n\nfunction isPlainOjbect(val) {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n\nvar internalKeysRE = /^(component|subRoutes)$/;\n\n/**\n * Route Context Object\n *\n * @param {String} path\n * @param {Router} router\n */\n\nvar Route = function Route(path, router) {\n  var _this = this;\n\n  babelHelpers.classCallCheck(this, Route);\n\n  var matched = router._recognizer.recognize(path);\n  if (matched) {\n    // copy all custom fields from route configs\n    [].forEach.call(matched, function (match) {\n      for (var key in match.handler) {\n        if (!internalKeysRE.test(key)) {\n          _this[key] = match.handler[key];\n        }\n      }\n    });\n    // set query and params\n    this.query = matched.queryParams;\n    this.params = [].reduce.call(matched, function (prev, cur) {\n      if (cur.params) {\n        for (var key in cur.params) {\n          prev[key] = cur.params[key];\n        }\n      }\n      return prev;\n    }, {});\n  }\n  // expose path and router\n  this.path = path;\n  this.router = router;\n  // for internal use\n  this.matched = matched || router._notFoundHandler;\n  // Important: freeze self to prevent observation\n  Object.freeze(this);\n};\n\nfunction applyOverride (Vue) {\n\n  var _ = Vue.util;\n\n  // override Vue's init and destroy process to keep track of router instances\n  var init = Vue.prototype._init;\n  Vue.prototype._init = function (options) {\n    var root = options._parent || options.parent || this;\n    var route = root.$route;\n    if (route) {\n      route.router._children.push(this);\n      if (!this.$route) {\n        /* istanbul ignore if */\n        if (this._defineMeta) {\n          // 0.12\n          this._defineMeta('$route', route);\n        } else {\n          // 1.0\n          _.defineReactive(this, '$route', route);\n        }\n      }\n    }\n    init.call(this, options);\n  };\n\n  var destroy = Vue.prototype._destroy;\n  Vue.prototype._destroy = function () {\n    if (!this._isBeingDestroyed) {\n      var route = this.$root.$route;\n      if (route) {\n        route.router._children.$remove(this);\n      }\n      destroy.apply(this, arguments);\n    }\n  };\n\n  // 1.0 only: enable route mixins\n  var strats = Vue.config.optionMergeStrategies;\n  var hooksToMergeRE = /^(data|activate|deactivate)$/;\n\n  if (strats) {\n    strats.route = function (parentVal, childVal) {\n      if (!childVal) return parentVal;\n      if (!parentVal) return childVal;\n      var ret = {};\n      _.extend(ret, parentVal);\n      for (var key in childVal) {\n        var a = ret[key];\n        var b = childVal[key];\n        // for data, activate and deactivate, we need to merge them into\n        // arrays similar to lifecycle hooks.\n        if (a && hooksToMergeRE.test(key)) {\n          ret[key] = (_.isArray(a) ? a : [a]).concat(b);\n        } else {\n          ret[key] = b;\n        }\n      }\n      return ret;\n    };\n  }\n}\n\nfunction View (Vue) {\n\n  var _ = Vue.util;\n  var componentDef =\n  // 0.12\n  Vue.directive('_component') ||\n  // 1.0\n  Vue.internalDirectives.component;\n  // <router-view> extends the internal component directive\n  var viewDef = _.extend({}, componentDef);\n\n  // with some overrides\n  _.extend(viewDef, {\n\n    _isRouterView: true,\n\n    bind: function bind() {\n      var route = this.vm.$route;\n      /* istanbul ignore if */\n      if (!route) {\n        warn('<router-view> can only be used inside a ' + 'router-enabled app.');\n        return;\n      }\n      // force dynamic directive so v-component doesn't\n      // attempt to build right now\n      this._isDynamicLiteral = true;\n      // finally, init by delegating to v-component\n      componentDef.bind.call(this);\n\n      // all we need to do here is registering this view\n      // in the router. actual component switching will be\n      // managed by the pipeline.\n      var router = this.router = route.router;\n      router._views.unshift(this);\n\n      // note the views are in reverse order.\n      var parentView = router._views[1];\n      if (parentView) {\n        // register self as a child of the parent view,\n        // instead of activating now. This is so that the\n        // child's activate hook is called after the\n        // parent's has resolved.\n        parentView.childView = this;\n      }\n\n      // handle late-rendered view\n      // two possibilities:\n      // 1. root view rendered after transition has been\n      //    validated;\n      // 2. child view rendered after parent view has been\n      //    activated.\n      var transition = route.router._currentTransition;\n      if (!parentView && transition.done || parentView && parentView.activated) {\n        var depth = parentView ? parentView.depth + 1 : 0;\n        activate(this, transition, depth);\n      }\n    },\n\n    unbind: function unbind() {\n      this.router._views.$remove(this);\n      componentDef.unbind.call(this);\n    }\n  });\n\n  Vue.elementDirective('router-view', viewDef);\n}\n\nvar trailingSlashRE = /\\/$/;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\nvar queryStringRE = /\\?.*$/;\n\n// install v-link, which provides navigation support for\n// HTML5 history mode\nfunction Link (Vue) {\n\n  var _ = Vue.util;\n\n  Vue.directive('link', {\n\n    bind: function bind() {\n      var _this = this;\n\n      var vm = this.vm;\n      /* istanbul ignore if */\n      if (!vm.$route) {\n        warn('v-link can only be used inside a ' + 'router-enabled app.');\n        return;\n      }\n      // no need to handle click if link expects to be opened\n      // in a new window/tab.\n      /* istanbul ignore if */\n      if (this.el.tagName === 'A' && this.el.getAttribute('target') === '_blank') {\n        return;\n      }\n      // handle click\n      var router = vm.$route.router;\n      this.handler = function (e) {\n        // don't redirect with control keys\n        if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n        // don't redirect when preventDefault called\n        if (e.defaultPrevented) return;\n        // don't redirect on right click\n        if (e.button !== 0) return;\n\n        var target = _this.target;\n        var go = function go(target) {\n          e.preventDefault();\n          if (target != null) {\n            router.go(target);\n          }\n        };\n\n        if (_this.el.tagName === 'A' || e.target === _this.el) {\n          // v-link on <a v-link=\"'path'\">\n          go(target);\n        } else {\n          // v-link delegate on <div v-link>\n          var el = e.target;\n          while (el && el.tagName !== 'A' && el !== _this.el) {\n            el = el.parentNode;\n          }\n          if (!el) return;\n          if (el.tagName !== 'A' || !el.href) {\n            // allow not anchor\n            go(target);\n          } else if (sameOrigin(el)) {\n            go({\n              path: el.pathname,\n              replace: target && target.replace,\n              append: target && target.append\n            });\n          }\n        }\n      };\n      this.el.addEventListener('click', this.handler);\n      // manage active link class\n      this.unwatch = vm.$watch('$route.path', _.bind(this.updateClasses, this));\n    },\n\n    update: function update(path) {\n      var router = this.vm.$route.router;\n      var append = undefined;\n      this.target = path;\n      if (_.isObject(path)) {\n        append = path.append;\n        this.exact = path.exact;\n        this.prevActiveClass = this.activeClass;\n        this.activeClass = path.activeClass;\n      }\n      path = this.path = router._stringifyPath(path);\n      this.activeRE = path && !this.exact ? new RegExp('^' + path.replace(/\\/$/, '').replace(regexEscapeRE, '\\\\$&') + '(\\\\/|$)') : null;\n      this.updateClasses(this.vm.$route.path);\n      var isAbsolute = path.charAt(0) === '/';\n      // do not format non-hash relative paths\n      var href = path && (router.mode === 'hash' || isAbsolute) ? router.history.formatPath(path, append) : path;\n      if (this.el.tagName === 'A') {\n        if (href) {\n          this.el.href = href;\n        } else {\n          this.el.removeAttribute('href');\n        }\n      }\n    },\n\n    updateClasses: function updateClasses(path) {\n      var el = this.el;\n      var router = this.vm.$route.router;\n      var activeClass = this.activeClass || router._linkActiveClass;\n      // clear old class\n      if (this.prevActiveClass !== activeClass) {\n        _.removeClass(el, this.prevActiveClass);\n      }\n      // remove query string before matching\n      var dest = this.path.replace(queryStringRE, '');\n      path = path.replace(queryStringRE, '');\n      // add new class\n      if (this.exact) {\n        if (dest === path ||\n        // also allow additional trailing slash\n        dest.charAt(dest.length - 1) !== '/' && dest === path.replace(trailingSlashRE, '')) {\n          _.addClass(el, activeClass);\n        } else {\n          _.removeClass(el, activeClass);\n        }\n      } else {\n        if (this.activeRE && this.activeRE.test(path)) {\n          _.addClass(el, activeClass);\n        } else {\n          _.removeClass(el, activeClass);\n        }\n      }\n    },\n\n    unbind: function unbind() {\n      this.el.removeEventListener('click', this.handler);\n      this.unwatch && this.unwatch();\n    }\n  });\n\n  function sameOrigin(link) {\n    return link.protocol === location.protocol && link.hostname === location.hostname && link.port === location.port;\n  }\n}\n\nvar historyBackends = {\n  abstract: AbstractHistory,\n  hash: HashHistory,\n  html5: HTML5History\n};\n\n// late bind during install\nvar Vue = undefined;\n\n/**\n * Router constructor\n *\n * @param {Object} [options]\n */\n\nvar Router = (function () {\n  function Router() {\n    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    var _ref$hashbang = _ref.hashbang;\n    var hashbang = _ref$hashbang === undefined ? true : _ref$hashbang;\n    var _ref$abstract = _ref.abstract;\n    var abstract = _ref$abstract === undefined ? false : _ref$abstract;\n    var _ref$history = _ref.history;\n    var history = _ref$history === undefined ? false : _ref$history;\n    var _ref$saveScrollPosition = _ref.saveScrollPosition;\n    var saveScrollPosition = _ref$saveScrollPosition === undefined ? false : _ref$saveScrollPosition;\n    var _ref$transitionOnLoad = _ref.transitionOnLoad;\n    var transitionOnLoad = _ref$transitionOnLoad === undefined ? false : _ref$transitionOnLoad;\n    var _ref$suppressTransitionError = _ref.suppressTransitionError;\n    var suppressTransitionError = _ref$suppressTransitionError === undefined ? false : _ref$suppressTransitionError;\n    var _ref$root = _ref.root;\n    var root = _ref$root === undefined ? null : _ref$root;\n    var _ref$linkActiveClass = _ref.linkActiveClass;\n    var linkActiveClass = _ref$linkActiveClass === undefined ? 'v-link-active' : _ref$linkActiveClass;\n    babelHelpers.classCallCheck(this, Router);\n\n    /* istanbul ignore if */\n    if (!Router.installed) {\n      throw new Error('Please install the Router with Vue.use() before ' + 'creating an instance.');\n    }\n\n    // Vue instances\n    this.app = null;\n    this._views = [];\n    this._children = [];\n\n    // route recognizer\n    this._recognizer = new RouteRecognizer();\n    this._guardRecognizer = new RouteRecognizer();\n\n    // state\n    this._started = false;\n    this._startCb = null;\n    this._currentRoute = {};\n    this._currentTransition = null;\n    this._previousTransition = null;\n    this._notFoundHandler = null;\n    this._notFoundRedirect = null;\n    this._beforeEachHooks = [];\n    this._afterEachHooks = [];\n\n    // feature detection\n    this._hasPushState = typeof window !== 'undefined' && window.history && window.history.pushState;\n\n    // trigger transition on initial render?\n    this._rendered = false;\n    this._transitionOnLoad = transitionOnLoad;\n\n    // history mode\n    this._abstract = abstract;\n    this._hashbang = hashbang;\n    this._history = this._hasPushState && history;\n\n    // other options\n    this._saveScrollPosition = saveScrollPosition;\n    this._linkActiveClass = linkActiveClass;\n    this._suppress = suppressTransitionError;\n\n    // create history object\n    var inBrowser = Vue.util.inBrowser;\n    this.mode = !inBrowser || this._abstract ? 'abstract' : this._history ? 'html5' : 'hash';\n\n    var History = historyBackends[this.mode];\n    var self = this;\n    this.history = new History({\n      root: root,\n      hashbang: this._hashbang,\n      onChange: function onChange(path, state, anchor) {\n        self._match(path, state, anchor);\n      }\n    });\n  }\n\n  /**\n   * Allow directly passing components to a route\n   * definition.\n   *\n   * @param {String} path\n   * @param {Object} handler\n   */\n\n  // API ===================================================\n\n  /**\n  * Register a map of top-level paths.\n  *\n  * @param {Object} map\n  */\n\n  Router.prototype.map = function map(_map) {\n    for (var route in _map) {\n      this.on(route, _map[route]);\n    }\n  };\n\n  /**\n   * Register a single root-level path\n   *\n   * @param {String} rootPath\n   * @param {Object} handler\n   *                 - {String} component\n   *                 - {Object} [subRoutes]\n   *                 - {Boolean} [forceRefresh]\n   *                 - {Function} [before]\n   *                 - {Function} [after]\n   */\n\n  Router.prototype.on = function on(rootPath, handler) {\n    if (rootPath === '*') {\n      this._notFound(handler);\n    } else {\n      this._addRoute(rootPath, handler, []);\n    }\n  };\n\n  /**\n   * Set redirects.\n   *\n   * @param {Object} map\n   */\n\n  Router.prototype.redirect = function redirect(map) {\n    for (var path in map) {\n      this._addRedirect(path, map[path]);\n    }\n  };\n\n  /**\n   * Set aliases.\n   *\n   * @param {Object} map\n   */\n\n  Router.prototype.alias = function alias(map) {\n    for (var path in map) {\n      this._addAlias(path, map[path]);\n    }\n  };\n\n  /**\n   * Set global before hook.\n   *\n   * @param {Function} fn\n   */\n\n  Router.prototype.beforeEach = function beforeEach(fn) {\n    this._beforeEachHooks.push(fn);\n  };\n\n  /**\n   * Set global after hook.\n   *\n   * @param {Function} fn\n   */\n\n  Router.prototype.afterEach = function afterEach(fn) {\n    this._afterEachHooks.push(fn);\n  };\n\n  /**\n   * Navigate to a given path.\n   * The path can be an object describing a named path in\n   * the format of { name: '...', params: {}, query: {}}\n   * The path is assumed to be already decoded, and will\n   * be resolved against root (if provided)\n   *\n   * @param {String|Object} path\n   * @param {Boolean} [replace]\n   */\n\n  Router.prototype.go = function go(path) {\n    var replace = false;\n    var append = false;\n    if (Vue.util.isObject(path)) {\n      replace = path.replace;\n      append = path.append;\n    }\n    path = this._stringifyPath(path);\n    if (path) {\n      this.history.go(path, replace, append);\n    }\n  };\n\n  /**\n   * Short hand for replacing current path\n   *\n   * @param {String} path\n   */\n\n  Router.prototype.replace = function replace(path) {\n    if (typeof path === 'string') {\n      path = { path: path };\n    }\n    path.replace = true;\n    this.go(path);\n  };\n\n  /**\n   * Start the router.\n   *\n   * @param {VueConstructor} App\n   * @param {String|Element} container\n   * @param {Function} [cb]\n   */\n\n  Router.prototype.start = function start(App, container, cb) {\n    /* istanbul ignore if */\n    if (this._started) {\n      warn('already started.');\n      return;\n    }\n    this._started = true;\n    this._startCb = cb;\n    if (!this.app) {\n      /* istanbul ignore if */\n      if (!App || !container) {\n        throw new Error('Must start vue-router with a component and a ' + 'root container.');\n      }\n      this._appContainer = container;\n      var Ctor = this._appConstructor = typeof App === 'function' ? App : Vue.extend(App);\n      // give it a name for better debugging\n      Ctor.options.name = Ctor.options.name || 'RouterApp';\n    }\n    this.history.start();\n  };\n\n  /**\n   * Stop listening to route changes.\n   */\n\n  Router.prototype.stop = function stop() {\n    this.history.stop();\n    this._started = false;\n  };\n\n  // Internal methods ======================================\n\n  /**\n  * Add a route containing a list of segments to the internal\n  * route recognizer. Will be called recursively to add all\n  * possible sub-routes.\n  *\n  * @param {String} path\n  * @param {Object} handler\n  * @param {Array} segments\n  */\n\n  Router.prototype._addRoute = function _addRoute(path, handler, segments) {\n    guardComponent(path, handler);\n    handler.path = path;\n    handler.fullPath = (segments.reduce(function (path, segment) {\n      return path + segment.path;\n    }, '') + path).replace('//', '/');\n    segments.push({\n      path: path,\n      handler: handler\n    });\n    this._recognizer.add(segments, {\n      as: handler.name\n    });\n    // add sub routes\n    if (handler.subRoutes) {\n      for (var subPath in handler.subRoutes) {\n        // recursively walk all sub routes\n        this._addRoute(subPath, handler.subRoutes[subPath],\n        // pass a copy in recursion to avoid mutating\n        // across branches\n        segments.slice());\n      }\n    }\n  };\n\n  /**\n   * Set the notFound route handler.\n   *\n   * @param {Object} handler\n   */\n\n  Router.prototype._notFound = function _notFound(handler) {\n    guardComponent('*', handler);\n    this._notFoundHandler = [{ handler: handler }];\n  };\n\n  /**\n   * Add a redirect record.\n   *\n   * @param {String} path\n   * @param {String} redirectPath\n   */\n\n  Router.prototype._addRedirect = function _addRedirect(path, redirectPath) {\n    if (path === '*') {\n      this._notFoundRedirect = redirectPath;\n    } else {\n      this._addGuard(path, redirectPath, this.replace);\n    }\n  };\n\n  /**\n   * Add an alias record.\n   *\n   * @param {String} path\n   * @param {String} aliasPath\n   */\n\n  Router.prototype._addAlias = function _addAlias(path, aliasPath) {\n    this._addGuard(path, aliasPath, this._match);\n  };\n\n  /**\n   * Add a path guard.\n   *\n   * @param {String} path\n   * @param {String} mappedPath\n   * @param {Function} handler\n   */\n\n  Router.prototype._addGuard = function _addGuard(path, mappedPath, _handler) {\n    var _this = this;\n\n    this._guardRecognizer.add([{\n      path: path,\n      handler: function handler(match, query) {\n        var realPath = mapParams(mappedPath, match.params, query);\n        _handler.call(_this, realPath);\n      }\n    }]);\n  };\n\n  /**\n   * Check if a path matches any redirect records.\n   *\n   * @param {String} path\n   * @return {Boolean} - if true, will skip normal match.\n   */\n\n  Router.prototype._checkGuard = function _checkGuard(path) {\n    var matched = this._guardRecognizer.recognize(path);\n    if (matched) {\n      matched[0].handler(matched[0], matched.queryParams);\n      return true;\n    } else if (this._notFoundRedirect) {\n      matched = this._recognizer.recognize(path);\n      if (!matched) {\n        this.replace(this._notFoundRedirect);\n        return true;\n      }\n    }\n  };\n\n  /**\n   * Match a URL path and set the route context on vm,\n   * triggering view updates.\n   *\n   * @param {String} path\n   * @param {Object} [state]\n   * @param {String} [anchor]\n   */\n\n  Router.prototype._match = function _match(path, state, anchor) {\n    var _this2 = this;\n\n    if (this._checkGuard(path)) {\n      return;\n    }\n\n    var currentRoute = this._currentRoute;\n    var currentTransition = this._currentTransition;\n\n    if (currentTransition) {\n      if (currentTransition.to.path === path) {\n        // do nothing if we have an active transition going to the same path\n        return;\n      } else if (currentRoute.path === path) {\n        // We are going to the same path, but we also have an ongoing but\n        // not-yet-validated transition. Abort that transition and reset to\n        // prev transition.\n        currentTransition.aborted = true;\n        this._currentTransition = this._prevTransition;\n        return;\n      } else {\n        // going to a totally different path. abort ongoing transition.\n        currentTransition.aborted = true;\n      }\n    }\n\n    // construct new route and transition context\n    var route = new Route(path, this);\n    var transition = new RouteTransition(this, route, currentRoute);\n\n    // current transition is updated right now.\n    // however, current route will only be updated after the transition has\n    // been validated.\n    this._prevTransition = currentTransition;\n    this._currentTransition = transition;\n\n    if (!this.app) {\n      // initial render\n      this.app = new this._appConstructor({\n        el: this._appContainer,\n        _meta: {\n          $route: route\n        }\n      });\n    }\n\n    // check global before hook\n    var beforeHooks = this._beforeEachHooks;\n    var startTransition = function startTransition() {\n      transition.start(function () {\n        _this2._postTransition(route, state, anchor);\n      });\n    };\n\n    if (beforeHooks.length) {\n      transition.runQueue(beforeHooks, function (hook, _, next) {\n        if (transition === _this2._currentTransition) {\n          transition.callHook(hook, null, next, {\n            expectBoolean: true\n          });\n        }\n      }, startTransition);\n    } else {\n      startTransition();\n    }\n\n    if (!this._rendered && this._startCb) {\n      this._startCb.call(null);\n    }\n\n    // HACK:\n    // set rendered to true after the transition start, so\n    // that components that are acitvated synchronously know\n    // whether it is the initial render.\n    this._rendered = true;\n  };\n\n  /**\n   * Set current to the new transition.\n   * This is called by the transition object when the\n   * validation of a route has succeeded.\n   *\n   * @param {Transition} transition\n   */\n\n  Router.prototype._onTransitionValidated = function _onTransitionValidated(transition) {\n    // set current route\n    var route = this._currentRoute = transition.to;\n    // update route context for all children\n    if (this.app.$route !== route) {\n      this.app.$route = route;\n      this._children.forEach(function (child) {\n        child.$route = route;\n      });\n    }\n    // call global after hook\n    if (this._afterEachHooks.length) {\n      this._afterEachHooks.forEach(function (hook) {\n        return hook.call(null, {\n          to: transition.to,\n          from: transition.from\n        });\n      });\n    }\n    this._currentTransition.done = true;\n  };\n\n  /**\n   * Handle stuff after the transition.\n   *\n   * @param {Route} route\n   * @param {Object} [state]\n   * @param {String} [anchor]\n   */\n\n  Router.prototype._postTransition = function _postTransition(route, state, anchor) {\n    // handle scroll positions\n    // saved scroll positions take priority\n    // then we check if the path has an anchor\n    var pos = state && state.pos;\n    if (pos && this._saveScrollPosition) {\n      Vue.nextTick(function () {\n        window.scrollTo(pos.x, pos.y);\n      });\n    } else if (anchor) {\n      Vue.nextTick(function () {\n        var el = document.getElementById(anchor.slice(1));\n        if (el) {\n          window.scrollTo(window.scrollX, el.offsetTop);\n        }\n      });\n    }\n  };\n\n  /**\n   * Normalize named route object / string paths into\n   * a string.\n   *\n   * @param {Object|String|Number} path\n   * @return {String}\n   */\n\n  Router.prototype._stringifyPath = function _stringifyPath(path) {\n    if (path && typeof path === 'object') {\n      if (path.name) {\n        var params = path.params || {};\n        if (path.query) {\n          params.queryParams = path.query;\n        }\n        return this._recognizer.generate(path.name, params);\n      } else if (path.path) {\n        var fullPath = path.path;\n        if (path.query) {\n          var query = this._recognizer.generateQueryString(path.query);\n          if (fullPath.indexOf('?') > -1) {\n            fullPath += '&' + query.slice(1);\n          } else {\n            fullPath += query;\n          }\n        }\n        return fullPath;\n      } else {\n        return '';\n      }\n    } else {\n      return path ? path + '' : '';\n    }\n  };\n\n  return Router;\n})();\n\nfunction guardComponent(path, handler) {\n  var comp = handler.component;\n  if (Vue.util.isPlainObject(comp)) {\n    comp = handler.component = Vue.extend(comp);\n  }\n  /* istanbul ignore if */\n  if (typeof comp !== 'function') {\n    handler.component = null;\n    warn('invalid component for route \"' + path + '\".');\n  }\n}\n\n/* Installation */\n\nRouter.installed = false;\n\n/**\n * Installation interface.\n * Install the necessary directives.\n */\n\nRouter.install = function (externalVue) {\n  /* istanbul ignore if */\n  if (Router.installed) {\n    warn('already installed.');\n    return;\n  }\n  Vue = externalVue;\n  applyOverride(Vue);\n  View(Vue);\n  Link(Vue);\n  exports$1.Vue = Vue;\n  Router.installed = true;\n};\n\n// auto install\n/* istanbul ignore if */\nif (typeof window !== 'undefined' && window.Vue) {\n  window.Vue.use(Router);\n}\n\nmodule.exports = Router;\n},{}],37:[function(require,module,exports){\nvar _ = require('../util')\nvar Watcher = require('../watcher')\nvar Path = require('../parsers/path')\nvar textParser = require('../parsers/text')\nvar dirParser = require('../parsers/directive')\nvar expParser = require('../parsers/expression')\nvar filterRE = /[^|]\\|[^|]/\n\n/**\n * Get the value from an expression on this vm.\n *\n * @param {String} exp\n * @param {Boolean} [asStatement]\n * @return {*}\n */\n\nexports.$get = function (exp, asStatement) {\n  var res = expParser.parse(exp)\n  if (res) {\n    if (asStatement && !expParser.isSimplePath(exp)) {\n      var self = this\n      return function statementHandler () {\n        res.get.call(self, self)\n      }\n    } else {\n      try {\n        return res.get.call(this, this)\n      } catch (e) {}\n    }\n  }\n}\n\n/**\n * Set the value from an expression on this vm.\n * The expression must be a valid left-hand\n * expression in an assignment.\n *\n * @param {String} exp\n * @param {*} val\n */\n\nexports.$set = function (exp, val) {\n  var res = expParser.parse(exp, true)\n  if (res && res.set) {\n    res.set.call(this, this, val)\n  }\n}\n\n/**\n * Delete a property on the VM\n *\n * @param {String} key\n */\n\nexports.$delete = function (key) {\n  _.delete(this._data, key)\n}\n\n/**\n * Watch an expression, trigger callback when its\n * value changes.\n *\n * @param {String|Function} expOrFn\n * @param {Function} cb\n * @param {Object} [options]\n *                 - {Boolean} deep\n *                 - {Boolean} immediate\n * @return {Function} - unwatchFn\n */\n\nexports.$watch = function (expOrFn, cb, options) {\n  var vm = this\n  var parsed\n  if (typeof expOrFn === 'string') {\n    parsed = dirParser.parse(expOrFn)\n    expOrFn = parsed.expression\n  }\n  var watcher = new Watcher(vm, expOrFn, cb, {\n    deep: options && options.deep,\n    filters: parsed && parsed.filters\n  })\n  if (options && options.immediate) {\n    cb.call(vm, watcher.value)\n  }\n  return function unwatchFn () {\n    watcher.teardown()\n  }\n}\n\n/**\n * Evaluate a text directive, including filters.\n *\n * @param {String} text\n * @param {Boolean} [asStatement]\n * @return {String}\n */\n\nexports.$eval = function (text, asStatement) {\n  // check for filters.\n  if (filterRE.test(text)) {\n    var dir = dirParser.parse(text)\n    // the filter regex check might give false positive\n    // for pipes inside strings, so it's possible that\n    // we don't get any filters here\n    var val = this.$get(dir.expression, asStatement)\n    return dir.filters\n      ? this._applyFilters(val, null, dir.filters)\n      : val\n  } else {\n    // no filter\n    return this.$get(text, asStatement)\n  }\n}\n\n/**\n * Interpolate a piece of template text.\n *\n * @param {String} text\n * @return {String}\n */\n\nexports.$interpolate = function (text) {\n  var tokens = textParser.parse(text)\n  var vm = this\n  if (tokens) {\n    if (tokens.length === 1) {\n      return vm.$eval(tokens[0].value) + ''\n    } else {\n      return tokens.map(function (token) {\n        return token.tag\n          ? vm.$eval(token.value)\n          : token.value\n      }).join('')\n    }\n  } else {\n    return text\n  }\n}\n\n/**\n * Log instance data as a plain JS object\n * so that it is easier to inspect in console.\n * This method assumes console is available.\n *\n * @param {String} [path]\n */\n\nexports.$log = function (path) {\n  var data = path\n    ? Path.get(this._data, path)\n    : this._data\n  if (data) {\n    data = clean(data)\n  }\n  // include computed fields\n  if (!path) {\n    for (var key in this.$options.computed) {\n      data[key] = clean(this[key])\n    }\n  }\n  console.log(data)\n}\n\n/**\n * \"clean\" a getter/setter converted object into a plain\n * object copy.\n *\n * @param {Object} - obj\n * @return {Object}\n */\n\nfunction clean (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\n},{\"../parsers/directive\":87,\"../parsers/expression\":88,\"../parsers/path\":89,\"../parsers/text\":91,\"../util\":99,\"../watcher\":103}],38:[function(require,module,exports){\nvar _ = require('../util')\nvar transition = require('../transition')\n\n/**\n * Convenience on-instance nextTick. The callback is\n * auto-bound to the instance, and this avoids component\n * modules having to rely on the global Vue.\n *\n * @param {Function} fn\n */\n\nexports.$nextTick = function (fn) {\n  _.nextTick(fn, this)\n}\n\n/**\n * Append instance to target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$appendTo = function (target, cb, withTransition) {\n  return insert(\n    this, target, cb, withTransition,\n    append, transition.append\n  )\n}\n\n/**\n * Prepend instance to target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$prependTo = function (target, cb, withTransition) {\n  target = query(target)\n  if (target.hasChildNodes()) {\n    this.$before(target.firstChild, cb, withTransition)\n  } else {\n    this.$appendTo(target, cb, withTransition)\n  }\n  return this\n}\n\n/**\n * Insert instance before target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$before = function (target, cb, withTransition) {\n  return insert(\n    this, target, cb, withTransition,\n    before, transition.before\n  )\n}\n\n/**\n * Insert instance after target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$after = function (target, cb, withTransition) {\n  target = query(target)\n  if (target.nextSibling) {\n    this.$before(target.nextSibling, cb, withTransition)\n  } else {\n    this.$appendTo(target.parentNode, cb, withTransition)\n  }\n  return this\n}\n\n/**\n * Remove instance from DOM\n *\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$remove = function (cb, withTransition) {\n  if (!this.$el.parentNode) {\n    return cb && cb()\n  }\n  var inDoc = this._isAttached && _.inDoc(this.$el)\n  // if we are not in document, no need to check\n  // for transitions\n  if (!inDoc) withTransition = false\n  var self = this\n  var realCb = function () {\n    if (inDoc) self._callHook('detached')\n    if (cb) cb()\n  }\n  if (this._isFragment) {\n    _.removeNodeRange(\n      this._fragmentStart,\n      this._fragmentEnd,\n      this, this._fragment, realCb\n    )\n  } else {\n    var op = withTransition === false\n      ? remove\n      : transition.remove\n    op(this.$el, this, realCb)\n  }\n  return this\n}\n\n/**\n * Shared DOM insertion function.\n *\n * @param {Vue} vm\n * @param {Element} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition]\n * @param {Function} op1 - op for non-transition insert\n * @param {Function} op2 - op for transition insert\n * @return vm\n */\n\nfunction insert (vm, target, cb, withTransition, op1, op2) {\n  target = query(target)\n  var targetIsDetached = !_.inDoc(target)\n  var op = withTransition === false || targetIsDetached\n      ? op1\n      : op2\n  var shouldCallHook =\n    !targetIsDetached &&\n    !vm._isAttached &&\n    !_.inDoc(vm.$el)\n  if (vm._isFragment) {\n    _.mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\n      op(node, target, vm)\n    })\n    cb && cb()\n  } else {\n    op(vm.$el, target, vm, cb)\n  }\n  if (shouldCallHook) {\n    vm._callHook('attached')\n  }\n  return vm\n}\n\n/**\n * Check for selectors\n *\n * @param {String|Element} el\n */\n\nfunction query (el) {\n  return typeof el === 'string'\n    ? document.querySelector(el)\n    : el\n}\n\n/**\n * Append operation that takes a callback.\n *\n * @param {Node} el\n * @param {Node} target\n * @param {Vue} vm - unused\n * @param {Function} [cb]\n */\n\nfunction append (el, target, vm, cb) {\n  target.appendChild(el)\n  if (cb) cb()\n}\n\n/**\n * InsertBefore operation that takes a callback.\n *\n * @param {Node} el\n * @param {Node} target\n * @param {Vue} vm - unused\n * @param {Function} [cb]\n */\n\nfunction before (el, target, vm, cb) {\n  _.before(el, target)\n  if (cb) cb()\n}\n\n/**\n * Remove operation that takes a callback.\n *\n * @param {Node} el\n * @param {Vue} vm - unused\n * @param {Function} [cb]\n */\n\nfunction remove (el, vm, cb) {\n  _.remove(el)\n  if (cb) cb()\n}\n\n},{\"../transition\":92,\"../util\":99}],39:[function(require,module,exports){\nvar _ = require('../util')\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n */\n\nexports.$on = function (event, fn) {\n  (this._events[event] || (this._events[event] = []))\n    .push(fn)\n  modifyListenerCount(this, event, 1)\n  return this\n}\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n */\n\nexports.$once = function (event, fn) {\n  var self = this\n  function on () {\n    self.$off(event, on)\n    fn.apply(this, arguments)\n  }\n  on.fn = fn\n  this.$on(event, on)\n  return this\n}\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n */\n\nexports.$off = function (event, fn) {\n  var cbs\n  // all\n  if (!arguments.length) {\n    if (this.$parent) {\n      for (event in this._events) {\n        cbs = this._events[event]\n        if (cbs) {\n          modifyListenerCount(this, event, -cbs.length)\n        }\n      }\n    }\n    this._events = {}\n    return this\n  }\n  // specific event\n  cbs = this._events[event]\n  if (!cbs) {\n    return this\n  }\n  if (arguments.length === 1) {\n    modifyListenerCount(this, event, -cbs.length)\n    this._events[event] = null\n    return this\n  }\n  // specific handler\n  var cb\n  var i = cbs.length\n  while (i--) {\n    cb = cbs[i]\n    if (cb === fn || cb.fn === fn) {\n      modifyListenerCount(this, event, -1)\n      cbs.splice(i, 1)\n      break\n    }\n  }\n  return this\n}\n\n/**\n * Trigger an event on self.\n *\n * @param {String} event\n */\n\nexports.$emit = function (event) {\n  var cbs = this._events[event]\n  this._shouldPropagate = !cbs\n  if (cbs) {\n    cbs = cbs.length > 1\n      ? _.toArray(cbs)\n      : cbs\n    var args = _.toArray(arguments, 1)\n    for (var i = 0, l = cbs.length; i < l; i++) {\n      var res = cbs[i].apply(this, args)\n      if (res === true) {\n        this._shouldPropagate = true\n      }\n    }\n  }\n  return this\n}\n\n/**\n * Recursively broadcast an event to all children instances.\n *\n * @param {String} event\n * @param {...*} additional arguments\n */\n\nexports.$broadcast = function (event) {\n  // if no child has registered for this event,\n  // then there's no need to broadcast.\n  if (!this._eventsCount[event]) return\n  var children = this.$children\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i]\n    child.$emit.apply(child, arguments)\n    if (child._shouldPropagate) {\n      child.$broadcast.apply(child, arguments)\n    }\n  }\n  return this\n}\n\n/**\n * Recursively propagate an event up the parent chain.\n *\n * @param {String} event\n * @param {...*} additional arguments\n */\n\nexports.$dispatch = function () {\n  this.$emit.apply(this, arguments)\n  var parent = this.$parent\n  while (parent) {\n    parent.$emit.apply(parent, arguments)\n    parent = parent._shouldPropagate\n      ? parent.$parent\n      : null\n  }\n  return this\n}\n\n/**\n * Modify the listener counts on all parents.\n * This bookkeeping allows $broadcast to return early when\n * no child has listened to a certain event.\n *\n * @param {Vue} vm\n * @param {String} event\n * @param {Number} count\n */\n\nvar hookRE = /^hook:/\nfunction modifyListenerCount (vm, event, count) {\n  var parent = vm.$parent\n  // hooks do not get broadcasted so no need\n  // to do bookkeeping for them\n  if (!parent || !count || hookRE.test(event)) return\n  while (parent) {\n    parent._eventsCount[event] =\n      (parent._eventsCount[event] || 0) + count\n    parent = parent.$parent\n  }\n}\n\n},{\"../util\":99}],40:[function(require,module,exports){\nvar _ = require('../util')\nvar config = require('../config')\n\n/**\n * Expose useful internals\n */\n\nexports.util = _\nexports.config = config\nexports.set = _.set\nexports.delete = _.delete\nexports.nextTick = _.nextTick\n\n/**\n * The following are exposed for advanced usage / plugins\n */\n\nexports.compiler = require('../compiler')\nexports.FragmentFactory = require('../fragment/factory')\nexports.internalDirectives = require('../directives/internal')\nexports.parsers = {\n  path: require('../parsers/path'),\n  text: require('../parsers/text'),\n  template: require('../parsers/template'),\n  directive: require('../parsers/directive'),\n  expression: require('../parsers/expression')\n}\n\n/**\n * Each instance constructor, including Vue, has a unique\n * cid. This enables us to create wrapped \"child\n * constructors\" for prototypal inheritance and cache them.\n */\n\nexports.cid = 0\nvar cid = 1\n\n/**\n * Class inheritance\n *\n * @param {Object} extendOptions\n */\n\nexports.extend = function (extendOptions) {\n  extendOptions = extendOptions || {}\n  var Super = this\n  var isFirstExtend = Super.cid === 0\n  if (isFirstExtend && extendOptions._Ctor) {\n    return extendOptions._Ctor\n  }\n  var name = extendOptions.name || Super.options.name\n  var Sub = createClass(name || 'VueComponent')\n  Sub.prototype = Object.create(Super.prototype)\n  Sub.prototype.constructor = Sub\n  Sub.cid = cid++\n  Sub.options = _.mergeOptions(\n    Super.options,\n    extendOptions\n  )\n  Sub['super'] = Super\n  // allow further extension\n  Sub.extend = Super.extend\n  // create asset registers, so extended classes\n  // can have their private assets too.\n  config._assetTypes.forEach(function (type) {\n    Sub[type] = Super[type]\n  })\n  // enable recursive self-lookup\n  if (name) {\n    Sub.options.components[name] = Sub\n  }\n  // cache constructor\n  if (isFirstExtend) {\n    extendOptions._Ctor = Sub\n  }\n  return Sub\n}\n\n/**\n * A function that returns a sub-class constructor with the\n * given name. This gives us much nicer output when\n * logging instances in the console.\n *\n * @param {String} name\n * @return {Function}\n */\n\nfunction createClass (name) {\n  return new Function(\n    'return function ' + _.classify(name) +\n    ' (options) { this._init(options) }'\n  )()\n}\n\n/**\n * Plugin system\n *\n * @param {Object} plugin\n */\n\nexports.use = function (plugin) {\n  /* istanbul ignore if */\n  if (plugin.installed) {\n    return\n  }\n  // additional parameters\n  var args = _.toArray(arguments, 1)\n  args.unshift(this)\n  if (typeof plugin.install === 'function') {\n    plugin.install.apply(plugin, args)\n  } else {\n    plugin.apply(null, args)\n  }\n  plugin.installed = true\n  return this\n}\n\n/**\n * Apply a global mixin by merging it into the default\n * options.\n */\n\nexports.mixin = function (mixin) {\n  var Vue = _.Vue\n  Vue.options = _.mergeOptions(Vue.options, mixin)\n}\n\n/**\n * Create asset registration methods with the following\n * signature:\n *\n * @param {String} id\n * @param {*} definition\n */\n\nconfig._assetTypes.forEach(function (type) {\n  exports[type] = function (id, definition) {\n    if (!definition) {\n      return this.options[type + 's'][id]\n    } else {\n      if (\n        type === 'component' &&\n        _.isPlainObject(definition)\n      ) {\n        definition.name = id\n        definition = _.Vue.extend(definition)\n      }\n      this.options[type + 's'][id] = definition\n      return definition\n    }\n  }\n})\n\n},{\"../compiler\":46,\"../config\":48,\"../directives/internal\":55,\"../fragment/factory\":77,\"../parsers/directive\":87,\"../parsers/expression\":88,\"../parsers/path\":89,\"../parsers/template\":90,\"../parsers/text\":91,\"../util\":99}],41:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar compiler = require('../compiler')\n\n/**\n * Set instance target element and kick off the compilation\n * process. The passed in `el` can be a selector string, an\n * existing Element, or a DocumentFragment (for block\n * instances).\n *\n * @param {Element|DocumentFragment|string} el\n * @public\n */\n\nexports.$mount = function (el) {\n  if (this._isCompiled) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      '$mount() should be called only once.'\n    )\n    return\n  }\n  el = _.query(el)\n  if (!el) {\n    el = document.createElement('div')\n  }\n  this._compile(el)\n  this._initDOMHooks()\n  if (_.inDoc(this.$el)) {\n    this._callHook('attached')\n    ready.call(this)\n  } else {\n    this.$once('hook:attached', ready)\n  }\n  return this\n}\n\n/**\n * Mark an instance as ready.\n */\n\nfunction ready () {\n  this._isAttached = true\n  this._isReady = true\n  this._callHook('ready')\n}\n\n/**\n * Teardown the instance, simply delegate to the internal\n * _destroy.\n */\n\nexports.$destroy = function (remove, deferCleanup) {\n  this._destroy(remove, deferCleanup)\n}\n\n/**\n * Partially compile a piece of DOM and return a\n * decompile function.\n *\n * @param {Element|DocumentFragment} el\n * @param {Vue} [host]\n * @return {Function}\n */\n\nexports.$compile = function (el, host, scope, frag) {\n  return compiler.compile(el, this.$options, true)(\n    this, el, host, scope, frag\n  )\n}\n\n}).call(this,require('_process'))\n\n},{\"../compiler\":46,\"../util\":99,\"_process\":1}],42:[function(require,module,exports){\n(function (process){\nvar _ = require('./util')\nvar config = require('./config')\n\n// we have two separate queues: one for directive updates\n// and one for user watcher registered via $watch().\n// we want to guarantee directive updates to be called\n// before user watchers so that when user watchers are\n// triggered, the DOM would have already been in updated\n// state.\nvar queue = []\nvar userQueue = []\nvar has = {}\nvar circular = {}\nvar waiting = false\nvar internalQueueDepleted = false\n\n/**\n * Reset the batcher's state.\n */\n\nfunction resetBatcherState () {\n  queue = []\n  userQueue = []\n  has = {}\n  circular = {}\n  waiting = internalQueueDepleted = false\n}\n\n/**\n * Flush both queues and run the watchers.\n */\n\nfunction flushBatcherQueue () {\n  runBatcherQueue(queue)\n  internalQueueDepleted = true\n  runBatcherQueue(userQueue)\n  // dev tool hook\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production') {\n    if (_.inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {\n      window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('flush')\n    }\n  }\n  resetBatcherState()\n}\n\n/**\n * Run the watchers in a single queue.\n *\n * @param {Array} queue\n */\n\nfunction runBatcherQueue (queue) {\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (var i = 0; i < queue.length; i++) {\n    var watcher = queue[i]\n    var id = watcher.id\n    has[id] = null\n    watcher.run()\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1\n      if (circular[id] > config._maxUpdateCount) {\n        queue.splice(has[id], 1)\n        _.warn(\n          'You may have an infinite update loop for watcher ' +\n          'with expression: ' + watcher.expression\n        )\n      }\n    }\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n *\n * @param {Watcher} watcher\n *   properties:\n *   - {Number} id\n *   - {Function} run\n */\n\nexports.push = function (watcher) {\n  var id = watcher.id\n  if (has[id] == null) {\n    // if an internal watcher is pushed, but the internal\n    // queue is already depleted, we run it immediately.\n    if (internalQueueDepleted && !watcher.user) {\n      watcher.run()\n      return\n    }\n    // push watcher into appropriate queue\n    var q = watcher.user ? userQueue : queue\n    has[id] = q.length\n    q.push(watcher)\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n      _.nextTick(flushBatcherQueue)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"./config\":48,\"./util\":99,\"_process\":1}],43:[function(require,module,exports){\n/**\n * A doubly linked list-based Least Recently Used (LRU)\n * cache. Will keep most recently used items while\n * discarding least recently used items when its limit is\n * reached. This is a bare-bone version of\n * Rasmus Andersson's js-lru:\n *\n *   https://github.com/rsms/js-lru\n *\n * @param {Number} limit\n * @constructor\n */\n\nfunction Cache (limit) {\n  this.size = 0\n  this.limit = limit\n  this.head = this.tail = undefined\n  this._keymap = Object.create(null)\n}\n\nvar p = Cache.prototype\n\n/**\n * Put <value> into the cache associated with <key>.\n * Returns the entry which was removed to make room for\n * the new entry. Otherwise undefined is returned.\n * (i.e. if there was enough room already).\n *\n * @param {String} key\n * @param {*} value\n * @return {Entry|undefined}\n */\n\np.put = function (key, value) {\n  var entry = {\n    key: key,\n    value: value\n  }\n  this._keymap[key] = entry\n  if (this.tail) {\n    this.tail.newer = entry\n    entry.older = this.tail\n  } else {\n    this.head = entry\n  }\n  this.tail = entry\n  if (this.size === this.limit) {\n    return this.shift()\n  } else {\n    this.size++\n  }\n}\n\n/**\n * Purge the least recently used (oldest) entry from the\n * cache. Returns the removed entry or undefined if the\n * cache was empty.\n */\n\np.shift = function () {\n  var entry = this.head\n  if (entry) {\n    this.head = this.head.newer\n    this.head.older = undefined\n    entry.newer = entry.older = undefined\n    this._keymap[entry.key] = undefined\n  }\n  return entry\n}\n\n/**\n * Get and register recent use of <key>. Returns the value\n * associated with <key> or undefined if not in cache.\n *\n * @param {String} key\n * @param {Boolean} returnEntry\n * @return {Entry|*}\n */\n\np.get = function (key, returnEntry) {\n  var entry = this._keymap[key]\n  if (entry === undefined) return\n  if (entry === this.tail) {\n    return returnEntry\n      ? entry\n      : entry.value\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry.newer) {\n    if (entry === this.head) {\n      this.head = entry.newer\n    }\n    entry.newer.older = entry.older // C <-- E.\n  }\n  if (entry.older) {\n    entry.older.newer = entry.newer // C. --> E\n  }\n  entry.newer = undefined // D --x\n  entry.older = this.tail // D. --> E\n  if (this.tail) {\n    this.tail.newer = entry // E. <-- D\n  }\n  this.tail = entry\n  return returnEntry\n    ? entry\n    : entry.value\n}\n\nmodule.exports = Cache\n\n},{}],44:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar dirParser = require('../parsers/directive')\nvar propDef = require('../directives/internal/prop')\nvar propBindingModes = require('../config')._propBindingModes\nvar empty = {}\n\n// regexes\nvar identRE = require('../parsers/path').identRE\nvar settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/\n\n/**\n * Compile props on a root element and return\n * a props link function.\n *\n * @param {Element|DocumentFragment} el\n * @param {Array} propOptions\n * @return {Function} propsLinkFn\n */\n\nmodule.exports = function compileProps (el, propOptions) {\n  var props = []\n  var names = Object.keys(propOptions)\n  var i = names.length\n  var options, name, attr, value, path, parsed, prop, isTitleBinding\n  while (i--) {\n    name = names[i]\n    options = propOptions[name] || empty\n\n    if (process.env.NODE_ENV !== 'production' && name === '$data') {\n      _.warn('Do not use $data as prop.')\n      continue\n    }\n\n    // props could contain dashes, which will be\n    // interpreted as minus calculations by the parser\n    // so we need to camelize the path here\n    path = _.camelize(name)\n    if (!identRE.test(path)) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Invalid prop key: \"' + name + '\". Prop keys ' +\n        'must be valid identifiers.'\n      )\n      continue\n    }\n\n    prop = {\n      name: name,\n      path: path,\n      options: options,\n      mode: propBindingModes.ONE_WAY\n    }\n\n    // IE title issues\n    isTitleBinding = false\n    if (name === 'title' && (el.getAttribute(':title') || el.getAttribute('v-bind:title'))) {\n      isTitleBinding = true\n    }\n\n    // first check literal version\n    attr = _.hyphenate(name)\n    value = prop.raw = _.attr(el, attr)\n    if (value === null || isTitleBinding) {\n      // then check dynamic version\n      if ((value = _.getBindAttr(el, attr)) === null) {\n        if ((value = _.getBindAttr(el, attr + '.sync')) !== null) {\n          prop.mode = propBindingModes.TWO_WAY\n        } else if ((value = _.getBindAttr(el, attr + '.once')) !== null) {\n          prop.mode = propBindingModes.ONE_TIME\n        }\n      }\n      prop.raw = value\n      if (value !== null) {\n        parsed = dirParser.parse(value)\n        value = parsed.expression\n        prop.filters = parsed.filters\n        // check binding type\n        if (_.isLiteral(value)) {\n          // for expressions containing literal numbers and\n          // booleans, there's no need to setup a prop binding,\n          // so we can optimize them as a one-time set.\n          prop.optimizedLiteral = true\n        } else {\n          prop.dynamic = true\n          // check non-settable path for two-way bindings\n          if (process.env.NODE_ENV !== 'production' &&\n              prop.mode === propBindingModes.TWO_WAY &&\n              !settablePathRE.test(value)) {\n            prop.mode = propBindingModes.ONE_WAY\n            _.warn(\n              'Cannot bind two-way prop with non-settable ' +\n              'parent path: ' + value\n            )\n          }\n        }\n        prop.parentPath = value\n\n        // warn required two-way\n        if (\n          process.env.NODE_ENV !== 'production' &&\n          options.twoWay &&\n          prop.mode !== propBindingModes.TWO_WAY\n        ) {\n          _.warn(\n            'Prop \"' + name + '\" expects a two-way binding type.'\n          )\n        }\n\n      } else if (options.required) {\n        // warn missing required\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'Missing required prop: ' + name\n        )\n      }\n    }\n\n    // push prop\n    props.push(prop)\n  }\n  return makePropsLinkFn(props)\n}\n\n/**\n * Build a function that applies props to a vm.\n *\n * @param {Array} props\n * @return {Function} propsLinkFn\n */\n\nfunction makePropsLinkFn (props) {\n  return function propsLinkFn (vm, scope) {\n    // store resolved props info\n    vm._props = {}\n    var i = props.length\n    var prop, path, options, value, raw\n    while (i--) {\n      prop = props[i]\n      raw = prop.raw\n      path = prop.path\n      options = prop.options\n      vm._props[path] = prop\n      if (raw === null) {\n        // initialize absent prop\n        _.initProp(vm, prop, getDefault(vm, options))\n      } else if (prop.dynamic) {\n        // dynamic prop\n        if (vm._context) {\n          if (prop.mode === propBindingModes.ONE_TIME) {\n            // one time binding\n            value = (scope || vm._context).$get(prop.parentPath)\n            _.initProp(vm, prop, value)\n          } else {\n            // dynamic binding\n            vm._bindDir({\n              name: 'prop',\n              def: propDef,\n              prop: prop\n            }, null, null, scope) // el, host, scope\n          }\n        } else {\n          process.env.NODE_ENV !== 'production' && _.warn(\n            'Cannot bind dynamic prop on a root instance' +\n            ' with no parent: ' + prop.name + '=\"' +\n            raw + '\"'\n          )\n        }\n      } else if (prop.optimizedLiteral) {\n        // optimized literal, cast it and just set once\n        raw = _.stripQuotes(raw)\n        value = _.toBoolean(_.toNumber(raw))\n        _.initProp(vm, prop, value)\n      } else {\n        // string literal, but we need to cater for\n        // Boolean props with no value\n        value = options.type === Boolean && raw === ''\n          ? true\n          : raw\n        _.initProp(vm, prop, value)\n      }\n    }\n  }\n}\n\n/**\n * Get the default value of a prop.\n *\n * @param {Vue} vm\n * @param {Object} options\n * @return {*}\n */\n\nfunction getDefault (vm, options) {\n  // no default, return undefined\n  if (!options.hasOwnProperty('default')) {\n    // absent boolean value defaults to false\n    return options.type === Boolean\n      ? false\n      : undefined\n  }\n  var def = options.default\n  // warn against non-factory defaults for Object & Array\n  if (_.isObject(def)) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Object/Array as default prop values will be shared ' +\n      'across multiple instances. Use a factory function ' +\n      'to return the default value instead.'\n    )\n  }\n  // call factory function for non-Function types\n  return typeof def === 'function' && options.type !== Function\n    ? def.call(vm)\n    : def\n}\n\n}).call(this,require('_process'))\n\n},{\"../config\":48,\"../directives/internal/prop\":56,\"../parsers/directive\":87,\"../parsers/path\":89,\"../util\":99,\"_process\":1}],45:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar publicDirectives = require('../directives/public')\nvar internalDirectives = require('../directives/internal')\nvar compileProps = require('./compile-props')\nvar textParser = require('../parsers/text')\nvar dirParser = require('../parsers/directive')\nvar templateParser = require('../parsers/template')\nvar resolveAsset = _.resolveAsset\n\n// special binding prefixes\nvar bindRE = /^v-bind:|^:/\nvar onRE = /^v-on:|^@/\nvar argRE = /:(.*)$/\nvar modifierRE = /\\.[^\\.]+/g\nvar transitionRE = /^(v-bind:|:)?transition$/\n\n// terminal directives\nvar terminalDirectives = [\n  'for',\n  'if'\n]\n\n// default directive priority\nvar DEFAULT_PRIORITY = 1000\n\n/**\n * Compile a template and return a reusable composite link\n * function, which recursively contains more link functions\n * inside. This top level compile function would normally\n * be called on instance root nodes, but can also be used\n * for partial compilation if the partial argument is true.\n *\n * The returned composite link function, when called, will\n * return an unlink function that tearsdown all directives\n * created during the linking phase.\n *\n * @param {Element|DocumentFragment} el\n * @param {Object} options\n * @param {Boolean} partial\n * @return {Function}\n */\n\nexports.compile = function (el, options, partial) {\n  // link function for the node itself.\n  var nodeLinkFn = partial || !options._asComponent\n    ? compileNode(el, options)\n    : null\n  // link function for the childNodes\n  var childLinkFn =\n    !(nodeLinkFn && nodeLinkFn.terminal) &&\n    el.tagName !== 'SCRIPT' &&\n    el.hasChildNodes()\n      ? compileNodeList(el.childNodes, options)\n      : null\n\n  /**\n   * A composite linker function to be called on a already\n   * compiled piece of DOM, which instantiates all directive\n   * instances.\n   *\n   * @param {Vue} vm\n   * @param {Element|DocumentFragment} el\n   * @param {Vue} [host] - host vm of transcluded content\n   * @param {Object} [scope] - v-for scope\n   * @param {Fragment} [frag] - link context fragment\n   * @return {Function|undefined}\n   */\n\n  return function compositeLinkFn (vm, el, host, scope, frag) {\n    // cache childNodes before linking parent, fix #657\n    var childNodes = _.toArray(el.childNodes)\n    // link\n    var dirs = linkAndCapture(function compositeLinkCapturer () {\n      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag)\n      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag)\n    }, vm)\n    return makeUnlinkFn(vm, dirs)\n  }\n}\n\n/**\n * Apply a linker to a vm/element pair and capture the\n * directives created during the process.\n *\n * @param {Function} linker\n * @param {Vue} vm\n */\n\nfunction linkAndCapture (linker, vm) {\n  var originalDirCount = vm._directives.length\n  linker()\n  var dirs = vm._directives.slice(originalDirCount)\n  dirs.sort(directiveComparator)\n  for (var i = 0, l = dirs.length; i < l; i++) {\n    dirs[i]._bind()\n  }\n  return dirs\n}\n\n/**\n * Directive priority sort comparator\n *\n * @param {Object} a\n * @param {Object} b\n */\n\nfunction directiveComparator (a, b) {\n  a = a.descriptor.def.priority || DEFAULT_PRIORITY\n  b = b.descriptor.def.priority || DEFAULT_PRIORITY\n  return a > b ? -1 : a === b ? 0 : 1\n}\n\n/**\n * Linker functions return an unlink function that\n * tearsdown all directives instances generated during\n * the process.\n *\n * We create unlink functions with only the necessary\n * information to avoid retaining additional closures.\n *\n * @param {Vue} vm\n * @param {Array} dirs\n * @param {Vue} [context]\n * @param {Array} [contextDirs]\n * @return {Function}\n */\n\nfunction makeUnlinkFn (vm, dirs, context, contextDirs) {\n  return function unlink (destroying) {\n    teardownDirs(vm, dirs, destroying)\n    if (context && contextDirs) {\n      teardownDirs(context, contextDirs)\n    }\n  }\n}\n\n/**\n * Teardown partial linked directives.\n *\n * @param {Vue} vm\n * @param {Array} dirs\n * @param {Boolean} destroying\n */\n\nfunction teardownDirs (vm, dirs, destroying) {\n  var i = dirs.length\n  while (i--) {\n    dirs[i]._teardown()\n    if (!destroying) {\n      vm._directives.$remove(dirs[i])\n    }\n  }\n}\n\n/**\n * Compile link props on an instance.\n *\n * @param {Vue} vm\n * @param {Element} el\n * @param {Object} props\n * @param {Object} [scope]\n * @return {Function}\n */\n\nexports.compileAndLinkProps = function (vm, el, props, scope) {\n  var propsLinkFn = compileProps(el, props)\n  var propDirs = linkAndCapture(function () {\n    propsLinkFn(vm, scope)\n  }, vm)\n  return makeUnlinkFn(vm, propDirs)\n}\n\n/**\n * Compile the root element of an instance.\n *\n * 1. attrs on context container (context scope)\n * 2. attrs on the component template root node, if\n *    replace:true (child scope)\n *\n * If this is a fragment instance, we only need to compile 1.\n *\n * @param {Vue} vm\n * @param {Element} el\n * @param {Object} options\n * @param {Object} contextOptions\n * @return {Function}\n */\n\nexports.compileRoot = function (el, options, contextOptions) {\n  var containerAttrs = options._containerAttrs\n  var replacerAttrs = options._replacerAttrs\n  var contextLinkFn, replacerLinkFn\n\n  // only need to compile other attributes for\n  // non-fragment instances\n  if (el.nodeType !== 11) {\n    // for components, container and replacer need to be\n    // compiled separately and linked in different scopes.\n    if (options._asComponent) {\n      // 2. container attributes\n      if (containerAttrs && contextOptions) {\n        contextLinkFn = compileDirectives(containerAttrs, contextOptions)\n      }\n      if (replacerAttrs) {\n        // 3. replacer attributes\n        replacerLinkFn = compileDirectives(replacerAttrs, options)\n      }\n    } else {\n      // non-component, just compile as a normal element.\n      replacerLinkFn = compileDirectives(el.attributes, options)\n    }\n  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {\n    // warn container directives for fragment instances\n    var names = containerAttrs.map(function (attr) {\n      return '\"' + attr.name + '\"'\n    }).join(', ')\n    var plural = containerAttrs.length > 1\n    _.warn(\n      'Attribute' + (plural ? 's ' : ' ') + names +\n      (plural ? ' are' : ' is') + ' ignored on component ' +\n      '<' + options.el.tagName.toLowerCase() + '> because ' +\n      'the component is a fragment instance: ' +\n      'http://vuejs.org/guide/components.html#Fragment_Instance'\n    )\n  }\n\n  return function rootLinkFn (vm, el, scope) {\n    // link context scope dirs\n    var context = vm._context\n    var contextDirs\n    if (context && contextLinkFn) {\n      contextDirs = linkAndCapture(function () {\n        contextLinkFn(context, el, null, scope)\n      }, context)\n    }\n\n    // link self\n    var selfDirs = linkAndCapture(function () {\n      if (replacerLinkFn) replacerLinkFn(vm, el)\n    }, vm)\n\n    // return the unlink function that tearsdown context\n    // container directives.\n    return makeUnlinkFn(vm, selfDirs, context, contextDirs)\n  }\n}\n\n/**\n * Compile a node and return a nodeLinkFn based on the\n * node type.\n *\n * @param {Node} node\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileNode (node, options) {\n  var type = node.nodeType\n  if (type === 1 && node.tagName !== 'SCRIPT') {\n    return compileElement(node, options)\n  } else if (type === 3 && node.data.trim()) {\n    return compileTextNode(node, options)\n  } else {\n    return null\n  }\n}\n\n/**\n * Compile an element and return a nodeLinkFn.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileElement (el, options) {\n  // preprocess textareas.\n  // textarea treats its text content as the initial value.\n  // just bind it as an attr directive for value.\n  if (el.tagName === 'TEXTAREA') {\n    var tokens = textParser.parse(el.value)\n    if (tokens) {\n      el.setAttribute(':value', textParser.tokensToExp(tokens))\n      el.value = ''\n    }\n  }\n  var linkFn\n  var hasAttrs = el.hasAttributes()\n  // check terminal directives (for & if)\n  if (hasAttrs) {\n    linkFn = checkTerminalDirectives(el, options)\n  }\n  // check element directives\n  if (!linkFn) {\n    linkFn = checkElementDirectives(el, options)\n  }\n  // check component\n  if (!linkFn) {\n    linkFn = checkComponent(el, options)\n  }\n  // normal directives\n  if (!linkFn && hasAttrs) {\n    linkFn = compileDirectives(el.attributes, options)\n  }\n  return linkFn\n}\n\n/**\n * Compile a textNode and return a nodeLinkFn.\n *\n * @param {TextNode} node\n * @param {Object} options\n * @return {Function|null} textNodeLinkFn\n */\n\nfunction compileTextNode (node, options) {\n  var tokens = textParser.parse(node.data)\n  if (!tokens) {\n    return null\n  }\n  var frag = document.createDocumentFragment()\n  var el, token\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i]\n    el = token.tag\n      ? processTextToken(token, options)\n      : document.createTextNode(token.value)\n    frag.appendChild(el)\n  }\n  return makeTextNodeLinkFn(tokens, frag, options)\n}\n\n/**\n * Process a single text token.\n *\n * @param {Object} token\n * @param {Object} options\n * @return {Node}\n */\n\nfunction processTextToken (token, options) {\n  var el\n  if (token.oneTime) {\n    el = document.createTextNode(token.value)\n  } else {\n    if (token.html) {\n      el = document.createComment('v-html')\n      setTokenType('html')\n    } else {\n      // IE will clean up empty textNodes during\n      // frag.cloneNode(true), so we have to give it\n      // something here...\n      el = document.createTextNode(' ')\n      setTokenType('text')\n    }\n  }\n  function setTokenType (type) {\n    if (token.descriptor) return\n    var parsed = dirParser.parse(token.value)\n    token.descriptor = {\n      name: type,\n      def: publicDirectives[type],\n      expression: parsed.expression,\n      filters: parsed.filters\n    }\n  }\n  return el\n}\n\n/**\n * Build a function that processes a textNode.\n *\n * @param {Array<Object>} tokens\n * @param {DocumentFragment} frag\n */\n\nfunction makeTextNodeLinkFn (tokens, frag) {\n  return function textNodeLinkFn (vm, el, host, scope) {\n    var fragClone = frag.cloneNode(true)\n    var childNodes = _.toArray(fragClone.childNodes)\n    var token, value, node\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      token = tokens[i]\n      value = token.value\n      if (token.tag) {\n        node = childNodes[i]\n        if (token.oneTime) {\n          value = (scope || vm).$eval(value)\n          if (token.html) {\n            _.replace(node, templateParser.parse(value, true))\n          } else {\n            node.data = value\n          }\n        } else {\n          vm._bindDir(token.descriptor, node, host, scope)\n        }\n      }\n    }\n    _.replace(el, fragClone)\n  }\n}\n\n/**\n * Compile a node list and return a childLinkFn.\n *\n * @param {NodeList} nodeList\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction compileNodeList (nodeList, options) {\n  var linkFns = []\n  var nodeLinkFn, childLinkFn, node\n  for (var i = 0, l = nodeList.length; i < l; i++) {\n    node = nodeList[i]\n    nodeLinkFn = compileNode(node, options)\n    childLinkFn =\n      !(nodeLinkFn && nodeLinkFn.terminal) &&\n      node.tagName !== 'SCRIPT' &&\n      node.hasChildNodes()\n        ? compileNodeList(node.childNodes, options)\n        : null\n    linkFns.push(nodeLinkFn, childLinkFn)\n  }\n  return linkFns.length\n    ? makeChildLinkFn(linkFns)\n    : null\n}\n\n/**\n * Make a child link function for a node's childNodes.\n *\n * @param {Array<Function>} linkFns\n * @return {Function} childLinkFn\n */\n\nfunction makeChildLinkFn (linkFns) {\n  return function childLinkFn (vm, nodes, host, scope, frag) {\n    var node, nodeLinkFn, childrenLinkFn\n    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n      node = nodes[n]\n      nodeLinkFn = linkFns[i++]\n      childrenLinkFn = linkFns[i++]\n      // cache childNodes before linking parent, fix #657\n      var childNodes = _.toArray(node.childNodes)\n      if (nodeLinkFn) {\n        nodeLinkFn(vm, node, host, scope, frag)\n      }\n      if (childrenLinkFn) {\n        childrenLinkFn(vm, childNodes, host, scope, frag)\n      }\n    }\n  }\n}\n\n/**\n * Check for element directives (custom elements that should\n * be resovled as terminal directives).\n *\n * @param {Element} el\n * @param {Object} options\n */\n\nfunction checkElementDirectives (el, options) {\n  var tag = el.tagName.toLowerCase()\n  if (_.commonTagRE.test(tag)) return\n  var def = resolveAsset(options, 'elementDirectives', tag)\n  if (def) {\n    return makeTerminalNodeLinkFn(el, tag, '', options, def)\n  }\n}\n\n/**\n * Check if an element is a component. If yes, return\n * a component link function.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction checkComponent (el, options) {\n  var component = _.checkComponent(el, options)\n  if (component) {\n    var descriptor = {\n      name: 'component',\n      expression: component.id,\n      def: internalDirectives.component,\n      modifiers: {\n        literal: !component.dynamic\n      }\n    }\n    var componentLinkFn = function (vm, el, host, scope, frag) {\n      vm._bindDir(descriptor, el, host, scope, frag)\n    }\n    componentLinkFn.terminal = true\n    return componentLinkFn\n  }\n}\n\n/**\n * Check an element for terminal directives in fixed order.\n * If it finds one, return a terminal link function.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function} terminalLinkFn\n */\n\nfunction checkTerminalDirectives (el, options) {\n  // skip v-pre\n  if (_.attr(el, 'v-pre') !== null) {\n    return skip\n  }\n  // skip v-else block, but only if following v-if\n  if (el.hasAttribute('v-else')) {\n    var prev = el.previousElementSibling\n    if (prev && prev.hasAttribute('v-if')) {\n      return skip\n    }\n  }\n  var value, dirName\n  for (var i = 0, l = terminalDirectives.length; i < l; i++) {\n    dirName = terminalDirectives[i]\n    /* eslint-disable no-cond-assign */\n    if (value = el.getAttribute('v-' + dirName)) {\n      return makeTerminalNodeLinkFn(el, dirName, value, options)\n    }\n    /* eslint-enable no-cond-assign */\n  }\n}\n\nfunction skip () {}\nskip.terminal = true\n\n/**\n * Build a node link function for a terminal directive.\n * A terminal link function terminates the current\n * compilation recursion and handles compilation of the\n * subtree in the directive.\n *\n * @param {Element} el\n * @param {String} dirName\n * @param {String} value\n * @param {Object} options\n * @param {Object} [def]\n * @return {Function} terminalLinkFn\n */\n\nfunction makeTerminalNodeLinkFn (el, dirName, value, options, def) {\n  var parsed = dirParser.parse(value)\n  var descriptor = {\n    name: dirName,\n    expression: parsed.expression,\n    filters: parsed.filters,\n    raw: value,\n    // either an element directive, or if/for\n    def: def || publicDirectives[dirName]\n  }\n  var fn = function terminalNodeLinkFn (vm, el, host, scope, frag) {\n    vm._bindDir(descriptor, el, host, scope, frag)\n  }\n  fn.terminal = true\n  return fn\n}\n\n/**\n * Compile the directives on an element and return a linker.\n *\n * @param {Array|NamedNodeMap} attrs\n * @param {Object} options\n * @return {Function}\n */\n\nfunction compileDirectives (attrs, options) {\n  var i = attrs.length\n  var dirs = []\n  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens\n  while (i--) {\n    attr = attrs[i]\n    name = rawName = attr.name\n    value = rawValue = attr.value\n    tokens = textParser.parse(value)\n    // reset arg\n    arg = null\n    // check modifiers\n    modifiers = parseModifiers(name)\n    name = name.replace(modifierRE, '')\n\n    // attribute interpolations\n    if (tokens) {\n      value = textParser.tokensToExp(tokens)\n      arg = name\n      pushDir('bind', publicDirectives.bind, true)\n    } else\n\n    // special attribute: transition\n    if (transitionRE.test(name)) {\n      modifiers.literal = !bindRE.test(name)\n      pushDir('transition', internalDirectives.transition)\n    } else\n\n    // event handlers\n    if (onRE.test(name)) {\n      arg = name.replace(onRE, '')\n      pushDir('on', publicDirectives.on)\n    } else\n\n    // attribute bindings\n    if (bindRE.test(name)) {\n      dirName = name.replace(bindRE, '')\n      if (dirName === 'style' || dirName === 'class') {\n        pushDir(dirName, internalDirectives[dirName])\n      } else {\n        arg = dirName\n        pushDir('bind', publicDirectives.bind)\n      }\n    } else\n\n    // normal directives\n    if (name.indexOf('v-') === 0) {\n      // check arg\n      arg = (arg = name.match(argRE)) && arg[1]\n      if (arg) {\n        name = name.replace(argRE, '')\n      }\n      // extract directive name\n      dirName = name.slice(2)\n\n      // skip v-else (when used with v-show)\n      if (dirName === 'else') {\n        continue\n      }\n\n      dirDef = resolveAsset(options, 'directives', dirName)\n\n      if (process.env.NODE_ENV !== 'production') {\n        _.assertAsset(dirDef, 'directive', dirName)\n      }\n\n      if (dirDef) {\n        if (_.isLiteral(value)) {\n          value = _.stripQuotes(value)\n          modifiers.literal = true\n        }\n        pushDir(dirName, dirDef)\n      }\n    }\n  }\n\n  /**\n   * Push a directive.\n   *\n   * @param {String} dirName\n   * @param {Object|Function} def\n   * @param {Boolean} [interp]\n   */\n\n  function pushDir (dirName, def, interp) {\n    var parsed = dirParser.parse(value)\n    dirs.push({\n      name: dirName,\n      attr: rawName,\n      raw: rawValue,\n      def: def,\n      arg: arg,\n      modifiers: modifiers,\n      expression: parsed.expression,\n      filters: parsed.filters,\n      interp: interp\n    })\n  }\n\n  if (dirs.length) {\n    return makeNodeLinkFn(dirs)\n  }\n}\n\n/**\n * Parse modifiers from directive attribute name.\n *\n * @param {String} name\n * @return {Object}\n */\n\nfunction parseModifiers (name) {\n  var res = Object.create(null)\n  var match = name.match(modifierRE)\n  if (match) {\n    var i = match.length\n    while (i--) {\n      res[match[i].slice(1)] = true\n    }\n  }\n  return res\n}\n\n/**\n * Build a link function for all directives on a single node.\n *\n * @param {Array} directives\n * @return {Function} directivesLinkFn\n */\n\nfunction makeNodeLinkFn (directives) {\n  return function nodeLinkFn (vm, el, host, scope, frag) {\n    // reverse apply because it's sorted low to high\n    var i = directives.length\n    while (i--) {\n      vm._bindDir(directives[i], el, host, scope, frag)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../directives/internal\":55,\"../directives/public\":65,\"../parsers/directive\":87,\"../parsers/template\":90,\"../parsers/text\":91,\"../util\":99,\"./compile-props\":44,\"_process\":1}],46:[function(require,module,exports){\nvar _ = require('../util')\n\n_.extend(exports, require('./compile'))\n_.extend(exports, require('./transclude'))\n\n},{\"../util\":99,\"./compile\":45,\"./transclude\":47}],47:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar templateParser = require('../parsers/template')\nvar specialCharRE = /[^\\w\\-:\\.]/\n\n/**\n * Process an element or a DocumentFragment based on a\n * instance option object. This allows us to transclude\n * a template node/fragment before the instance is created,\n * so the processed fragment can then be cloned and reused\n * in v-for.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nexports.transclude = function (el, options) {\n  // extract container attributes to pass them down\n  // to compiler, because they need to be compiled in\n  // parent scope. we are mutating the options object here\n  // assuming the same object will be used for compile\n  // right after this.\n  if (options) {\n    options._containerAttrs = extractAttrs(el)\n  }\n  // for template tags, what we want is its content as\n  // a documentFragment (for fragment instances)\n  if (_.isTemplate(el)) {\n    el = templateParser.parse(el)\n  }\n  if (options) {\n    if (options._asComponent && !options.template) {\n      options.template = '<slot></slot>'\n    }\n    if (options.template) {\n      options._content = _.extractContent(el)\n      el = transcludeTemplate(el, options)\n    }\n  }\n  if (el instanceof DocumentFragment) {\n    // anchors for fragment instance\n    // passing in `persist: true` to avoid them being\n    // discarded by IE during template cloning\n    _.prepend(_.createAnchor('v-start', true), el)\n    el.appendChild(_.createAnchor('v-end', true))\n  }\n  return el\n}\n\n/**\n * Process the template option.\n * If the replace option is true this will swap the $el.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nfunction transcludeTemplate (el, options) {\n  var template = options.template\n  var frag = templateParser.parse(template, true)\n  if (frag) {\n    var replacer = frag.firstChild\n    var tag = replacer.tagName && replacer.tagName.toLowerCase()\n    if (options.replace) {\n      /* istanbul ignore if */\n      if (el === document.body) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'You are mounting an instance with a template to ' +\n          '<body>. This will replace <body> entirely. You ' +\n          'should probably use `replace: false` here.'\n        )\n      }\n      // there are many cases where the instance must\n      // become a fragment instance: basically anything that\n      // can create more than 1 root nodes.\n      if (\n        // multi-children template\n        frag.childNodes.length > 1 ||\n        // non-element template\n        replacer.nodeType !== 1 ||\n        // single nested component\n        tag === 'component' ||\n        _.resolveAsset(options, 'components', tag) ||\n        replacer.hasAttribute('is') ||\n        replacer.hasAttribute(':is') ||\n        replacer.hasAttribute('v-bind:is') ||\n        // element directive\n        _.resolveAsset(options, 'elementDirectives', tag) ||\n        // for block\n        replacer.hasAttribute('v-for') ||\n        // if block\n        replacer.hasAttribute('v-if')\n      ) {\n        return frag\n      } else {\n        options._replacerAttrs = extractAttrs(replacer)\n        mergeAttrs(el, replacer)\n        return replacer\n      }\n    } else {\n      el.appendChild(frag)\n      return el\n    }\n  } else {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Invalid template option: ' + template\n    )\n  }\n}\n\n/**\n * Helper to extract a component container's attributes\n * into a plain object array.\n *\n * @param {Element} el\n * @return {Array}\n */\n\nfunction extractAttrs (el) {\n  if (el.nodeType === 1 && el.hasAttributes()) {\n    return _.toArray(el.attributes)\n  }\n}\n\n/**\n * Merge the attributes of two elements, and make sure\n * the class names are merged properly.\n *\n * @param {Element} from\n * @param {Element} to\n */\n\nfunction mergeAttrs (from, to) {\n  var attrs = from.attributes\n  var i = attrs.length\n  var name, value\n  while (i--) {\n    name = attrs[i].name\n    value = attrs[i].value\n    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\n      to.setAttribute(name, value)\n    } else if (name === 'class') {\n      value = to.getAttribute(name) + ' ' + value\n      to.setAttribute(name, value)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../parsers/template\":90,\"../util\":99,\"_process\":1}],48:[function(require,module,exports){\nmodule.exports = {\n\n  /**\n   * Whether to print debug messages.\n   * Also enables stack trace for warnings.\n   *\n   * @type {Boolean}\n   */\n\n  debug: false,\n\n  /**\n   * Whether to suppress warnings.\n   *\n   * @type {Boolean}\n   */\n\n  silent: false,\n\n  /**\n   * Whether to use async rendering.\n   */\n\n  async: true,\n\n  /**\n   * Whether to warn against errors caught when evaluating\n   * expressions.\n   */\n\n  warnExpressionErrors: true,\n\n  /**\n   * Internal flag to indicate the delimiters have been\n   * changed.\n   *\n   * @type {Boolean}\n   */\n\n  _delimitersChanged: true,\n\n  /**\n   * List of asset types that a component can own.\n   *\n   * @type {Array}\n   */\n\n  _assetTypes: [\n    'component',\n    'directive',\n    'elementDirective',\n    'filter',\n    'transition',\n    'partial'\n  ],\n\n  /**\n   * prop binding modes\n   */\n\n  _propBindingModes: {\n    ONE_WAY: 0,\n    TWO_WAY: 1,\n    ONE_TIME: 2\n  },\n\n  /**\n   * Max circular updates allowed in a batcher flush cycle.\n   */\n\n  _maxUpdateCount: 100\n\n}\n\n/**\n * Interpolation delimiters. Changing these would trigger\n * the text parser to re-compile the regular expressions.\n *\n * @type {Array<String>}\n */\n\nvar delimiters = ['{{', '}}']\nvar unsafeDelimiters = ['{{{', '}}}']\nvar textParser = require('./parsers/text')\n\nObject.defineProperty(module.exports, 'delimiters', {\n  get: function () {\n    return delimiters\n  },\n  set: function (val) {\n    delimiters = val\n    textParser.compileRegex()\n  }\n})\n\nObject.defineProperty(module.exports, 'unsafeDelimiters', {\n  get: function () {\n    return unsafeDelimiters\n  },\n  set: function (val) {\n    unsafeDelimiters = val\n    textParser.compileRegex()\n  }\n})\n\n},{\"./parsers/text\":91}],49:[function(require,module,exports){\n(function (process){\nvar _ = require('./util')\nvar Watcher = require('./watcher')\nvar expParser = require('./parsers/expression')\nfunction noop () {}\n\n/**\n * A directive links a DOM element with a piece of data,\n * which is the result of evaluating an expression.\n * It registers a watcher with the expression and calls\n * the DOM update function when a change is triggered.\n *\n * @param {String} name\n * @param {Node} el\n * @param {Vue} vm\n * @param {Object} descriptor\n *                 - {String} name\n *                 - {Object} def\n *                 - {String} expression\n *                 - {Array<Object>} [filters]\n *                 - {Boolean} literal\n *                 - {String} attr\n *                 - {String} raw\n * @param {Object} def - directive definition object\n * @param {Vue} [host] - transclusion host component\n * @param {Object} [scope] - v-for scope\n * @param {Fragment} [frag] - owner fragment\n * @constructor\n */\n\nfunction Directive (descriptor, vm, el, host, scope, frag) {\n  this.vm = vm\n  this.el = el\n  // copy descriptor properties\n  this.descriptor = descriptor\n  this.name = descriptor.name\n  this.expression = descriptor.expression\n  this.arg = descriptor.arg\n  this.modifiers = descriptor.modifiers\n  this.filters = descriptor.filters\n  this.literal = this.modifiers && this.modifiers.literal\n  // private\n  this._locked = false\n  this._bound = false\n  this._listeners = null\n  // link context\n  this._host = host\n  this._scope = scope\n  this._frag = frag\n  // store directives on node in dev mode\n  if (process.env.NODE_ENV !== 'production' && this.el) {\n    this.el._vue_directives = this.el._vue_directives || []\n    this.el._vue_directives.push(this)\n  }\n}\n\n/**\n * Initialize the directive, mixin definition properties,\n * setup the watcher, call definition bind() and update()\n * if present.\n *\n * @param {Object} def\n */\n\nDirective.prototype._bind = function () {\n  var name = this.name\n  var descriptor = this.descriptor\n\n  // remove attribute\n  if (\n    (name !== 'cloak' || this.vm._isCompiled) &&\n    this.el && this.el.removeAttribute\n  ) {\n    var attr = descriptor.attr || ('v-' + name)\n    this.el.removeAttribute(attr)\n  }\n\n  // copy def properties\n  var def = descriptor.def\n  if (typeof def === 'function') {\n    this.update = def\n  } else {\n    _.extend(this, def)\n  }\n\n  // setup directive params\n  this._setupParams()\n\n  // initial bind\n  if (this.bind) {\n    this.bind()\n  }\n\n  if (this.literal) {\n    this.update && this.update(descriptor.raw)\n  } else if (\n    (this.expression || this.modifiers) &&\n    (this.update || this.twoWay) &&\n    !this._checkStatement()\n  ) {\n    // wrapped updater for context\n    var dir = this\n    if (this.update) {\n      this._update = function (val, oldVal) {\n        if (!dir._locked) {\n          dir.update(val, oldVal)\n        }\n      }\n    } else {\n      this._update = noop\n    }\n    var preProcess = this._preProcess\n      ? _.bind(this._preProcess, this)\n      : null\n    var postProcess = this._postProcess\n      ? _.bind(this._postProcess, this)\n      : null\n    var watcher = this._watcher = new Watcher(\n      this.vm,\n      this.expression,\n      this._update, // callback\n      {\n        filters: this.filters,\n        twoWay: this.twoWay,\n        deep: this.deep,\n        preProcess: preProcess,\n        postProcess: postProcess,\n        scope: this._scope\n      }\n    )\n    // v-model with inital inline value need to sync back to\n    // model instead of update to DOM on init. They would\n    // set the afterBind hook to indicate that.\n    if (this.afterBind) {\n      this.afterBind()\n    } else if (this.update) {\n      this.update(watcher.value)\n    }\n  }\n  this._bound = true\n}\n\n/**\n * Setup all param attributes, e.g. track-by,\n * transition-mode, etc...\n */\n\nDirective.prototype._setupParams = function () {\n  if (!this.params) {\n    return\n  }\n  var params = this.params\n  // swap the params array with a fresh object.\n  this.params = Object.create(null)\n  var i = params.length\n  var key, val, mappedKey\n  while (i--) {\n    key = params[i]\n    mappedKey = _.camelize(key)\n    val = _.getBindAttr(this.el, key)\n    if (val != null) {\n      // dynamic\n      this._setupParamWatcher(mappedKey, val)\n    } else {\n      // static\n      val = _.attr(this.el, key)\n      if (val != null) {\n        this.params[mappedKey] = val === '' ? true : val\n      }\n    }\n  }\n}\n\n/**\n * Setup a watcher for a dynamic param.\n *\n * @param {String} key\n * @param {String} expression\n */\n\nDirective.prototype._setupParamWatcher = function (key, expression) {\n  var self = this\n  var called = false\n  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\n    self.params[key] = val\n    // since we are in immediate mode,\n    // only call the param change callbacks if this is not the first update.\n    if (called) {\n      var cb = self.paramWatchers && self.paramWatchers[key]\n      if (cb) {\n        cb.call(self, val, oldVal)\n      }\n    } else {\n      called = true\n    }\n  }, {\n    immediate: true\n  })\n  ;(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch)\n}\n\n/**\n * Check if the directive is a function caller\n * and if the expression is a callable one. If both true,\n * we wrap up the expression and use it as the event\n * handler.\n *\n * e.g. on-click=\"a++\"\n *\n * @return {Boolean}\n */\n\nDirective.prototype._checkStatement = function () {\n  var expression = this.expression\n  if (\n    expression && this.acceptStatement &&\n    !expParser.isSimplePath(expression)\n  ) {\n    var fn = expParser.parse(expression).get\n    var scope = this._scope || this.vm\n    var handler = function () {\n      fn.call(scope, scope)\n    }\n    if (this.filters) {\n      handler = scope._applyFilters(handler, null, this.filters)\n    }\n    this.update(handler)\n    return true\n  }\n}\n\n/**\n * Set the corresponding value with the setter.\n * This should only be used in two-way directives\n * e.g. v-model.\n *\n * @param {*} value\n * @public\n */\n\nDirective.prototype.set = function (value) {\n  /* istanbul ignore else */\n  if (this.twoWay) {\n    this._withLock(function () {\n      this._watcher.set(value)\n    })\n  } else if (process.env.NODE_ENV !== 'production') {\n    _.warn(\n      'Directive.set() can only be used inside twoWay' +\n      'directives.'\n    )\n  }\n}\n\n/**\n * Execute a function while preventing that function from\n * triggering updates on this directive instance.\n *\n * @param {Function} fn\n */\n\nDirective.prototype._withLock = function (fn) {\n  var self = this\n  self._locked = true\n  fn.call(self)\n  _.nextTick(function () {\n    self._locked = false\n  })\n}\n\n/**\n * Convenience method that attaches a DOM event listener\n * to the directive element and autometically tears it down\n * during unbind.\n *\n * @param {String} event\n * @param {Function} handler\n */\n\nDirective.prototype.on = function (event, handler) {\n  _.on(this.el, event, handler)\n  ;(this._listeners || (this._listeners = []))\n    .push([event, handler])\n}\n\n/**\n * Teardown the watcher and call unbind.\n */\n\nDirective.prototype._teardown = function () {\n  if (this._bound) {\n    this._bound = false\n    if (this.unbind) {\n      this.unbind()\n    }\n    if (this._watcher) {\n      this._watcher.teardown()\n    }\n    var listeners = this._listeners\n    var i\n    if (listeners) {\n      i = listeners.length\n      while (i--) {\n        _.off(this.el, listeners[i][0], listeners[i][1])\n      }\n    }\n    var unwatchFns = this._paramUnwatchFns\n    if (unwatchFns) {\n      i = unwatchFns.length\n      while (i--) {\n        unwatchFns[i]()\n      }\n    }\n    if (process.env.NODE_ENV !== 'production' && this.el) {\n      this.el._vue_directives.$remove(this)\n    }\n    this.vm = this.el = this._watcher = this._listeners = null\n  }\n}\n\nmodule.exports = Directive\n\n}).call(this,require('_process'))\n\n},{\"./parsers/expression\":88,\"./util\":99,\"./watcher\":103,\"_process\":1}],50:[function(require,module,exports){\nexports.slot = require('./slot')\nexports.partial = require('./partial')\n\n},{\"./partial\":51,\"./slot\":52}],51:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\nvar vIf = require('../public/if')\nvar FragmentFactory = require('../../fragment/factory')\n\nmodule.exports = {\n\n  priority: 1750,\n\n  params: ['name'],\n\n  // watch changes to name for dynamic partials\n  paramWatchers: {\n    name: function (value) {\n      vIf.remove.call(this)\n      if (value) {\n        this.insert(value)\n      }\n    }\n  },\n\n  bind: function () {\n    this.anchor = _.createAnchor('v-partial')\n    _.replace(this.el, this.anchor)\n    this.insert(this.params.name)\n  },\n\n  insert: function (id) {\n    var partial = _.resolveAsset(this.vm.$options, 'partials', id)\n    if (process.env.NODE_ENV !== 'production') {\n      _.assertAsset(partial, 'partial', id)\n    }\n    if (partial) {\n      this.factory = new FragmentFactory(this.vm, partial)\n      vIf.insert.call(this)\n    }\n  },\n\n  unbind: function () {\n    if (this.frag) {\n      this.frag.destroy()\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../fragment/factory\":77,\"../../util\":99,\"../public/if\":64,\"_process\":1}],52:[function(require,module,exports){\nvar _ = require('../../util')\nvar templateParser = require('../../parsers/template')\n\n// This is the elementDirective that handles <content>\n// transclusions. It relies on the raw content of an\n// instance being stored as `$options._content` during\n// the transclude phase.\n\nmodule.exports = {\n\n  priority: 1750,\n\n  params: ['name'],\n\n  bind: function () {\n    var host = this.vm\n    var raw = host.$options._content\n    var content\n    if (!raw) {\n      this.fallback()\n      return\n    }\n    var context = host._context\n    var slotName = this.params.name\n    if (!slotName) {\n      // Default content\n      var self = this\n      var compileDefaultContent = function () {\n        self.compile(\n          extractFragment(raw.childNodes, raw, true),\n          context,\n          host\n        )\n      }\n      if (!host._isCompiled) {\n        // defer until the end of instance compilation,\n        // because the default outlet must wait until all\n        // other possible outlets with selectors have picked\n        // out their contents.\n        host.$once('hook:compiled', compileDefaultContent)\n      } else {\n        compileDefaultContent()\n      }\n    } else {\n      var selector = '[slot=\"' + slotName + '\"]'\n      var nodes = raw.querySelectorAll(selector)\n      if (nodes.length) {\n        content = extractFragment(nodes, raw)\n        if (content.hasChildNodes()) {\n          this.compile(content, context, host)\n        } else {\n          this.fallback()\n        }\n      } else {\n        this.fallback()\n      }\n    }\n  },\n\n  fallback: function () {\n    this.compile(_.extractContent(this.el, true), this.vm)\n  },\n\n  compile: function (content, context, host) {\n    if (content && context) {\n      var scope = host\n        ? host._scope\n        : this._scope\n      this.unlink = context.$compile(\n        content, host, scope, this._frag\n      )\n    }\n    if (content) {\n      _.replace(this.el, content)\n    } else {\n      _.remove(this.el)\n    }\n  },\n\n  unbind: function () {\n    if (this.unlink) {\n      this.unlink()\n    }\n  }\n}\n\n/**\n * Extract qualified content nodes from a node list.\n *\n * @param {NodeList} nodes\n * @param {Element} parent\n * @param {Boolean} main\n * @return {DocumentFragment}\n */\n\nfunction extractFragment (nodes, parent, main) {\n  var frag = document.createDocumentFragment()\n  for (var i = 0, l = nodes.length; i < l; i++) {\n    var node = nodes[i]\n    // if this is the main outlet, we want to skip all\n    // previously selected nodes;\n    // otherwise, we want to mark the node as selected.\n    // clone the node so the original raw content remains\n    // intact. this ensures proper re-compilation in cases\n    // where the outlet is inside a conditional block\n    if (main && !node.__v_selected) {\n      append(node)\n    } else if (!main && node.parentNode === parent) {\n      node.__v_selected = true\n      append(node)\n    }\n  }\n  return frag\n\n  function append (node) {\n    if (_.isTemplate(node) &&\n        !node.hasAttribute('v-if') &&\n        !node.hasAttribute('v-for')) {\n      node = templateParser.parse(node)\n    }\n    node = templateParser.clone(node)\n    frag.appendChild(node)\n  }\n}\n\n},{\"../../parsers/template\":90,\"../../util\":99}],53:[function(require,module,exports){\nvar _ = require('../../util')\nvar addClass = _.addClass\nvar removeClass = _.removeClass\n\nmodule.exports = {\n\n  deep: true,\n\n  update: function (value) {\n    if (value && typeof value === 'string') {\n      this.handleObject(stringToObject(value))\n    } else if (_.isPlainObject(value)) {\n      this.handleObject(value)\n    } else if (_.isArray(value)) {\n      this.handleArray(value)\n    } else {\n      this.cleanup()\n    }\n  },\n\n  handleObject: function (value) {\n    this.cleanup(value)\n    var keys = this.prevKeys = Object.keys(value)\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i]\n      if (value[key]) {\n        addClass(this.el, key)\n      } else {\n        removeClass(this.el, key)\n      }\n    }\n  },\n\n  handleArray: function (value) {\n    this.cleanup(value)\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        addClass(this.el, value[i])\n      }\n    }\n    this.prevKeys = value.slice()\n  },\n\n  cleanup: function (value) {\n    if (this.prevKeys) {\n      var i = this.prevKeys.length\n      while (i--) {\n        var key = this.prevKeys[i]\n        if (key && (!value || !contains(value, key))) {\n          removeClass(this.el, key)\n        }\n      }\n    }\n  }\n}\n\nfunction stringToObject (value) {\n  var res = {}\n  var keys = value.trim().split(/\\s+/)\n  var i = keys.length\n  while (i--) {\n    res[keys[i]] = true\n  }\n  return res\n}\n\nfunction contains (value, key) {\n  return _.isArray(value)\n    ? value.indexOf(key) > -1\n    : value.hasOwnProperty(key)\n}\n\n},{\"../../util\":99}],54:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\nvar templateParser = require('../../parsers/template')\n\nmodule.exports = {\n\n  priority: 1500,\n\n  params: [\n    'keep-alive',\n    'transition-mode',\n    'inline-template'\n  ],\n\n  /**\n   * Setup. Two possible usages:\n   *\n   * - static:\n   *   <comp> or <div v-component=\"comp\">\n   *\n   * - dynamic:\n   *   <component :is=\"view\">\n   */\n\n  bind: function () {\n    if (!this.el.__vue__) {\n      // check ref\n      this.ref = _.findRef(this.el)\n      var refs = (this._scope || this.vm).$refs\n      if (this.ref && !refs.hasOwnProperty(this.ref)) {\n        _.defineReactive(refs, this.ref, null)\n      }\n      // keep-alive cache\n      this.keepAlive = this.params.keepAlive\n      if (this.keepAlive) {\n        this.cache = {}\n      }\n      // check inline-template\n      if (this.params.inlineTemplate) {\n        // extract inline template as a DocumentFragment\n        this.inlineTemplate = _.extractContent(this.el, true)\n      }\n      // component resolution related state\n      this.pendingComponentCb =\n      this.Component = null\n      // transition related state\n      this.pendingRemovals = 0\n      this.pendingRemovalCb = null\n      // check dynamic component params\n        // create a ref anchor\n      this.anchor = _.createAnchor('v-component')\n      _.replace(this.el, this.anchor)\n      // if static, build right now.\n      if (this.literal) {\n        this.setComponent(this.expression)\n      }\n    } else {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'cannot mount component \"' + this.expression + '\" ' +\n        'on already mounted element: ' + this.el\n      )\n    }\n  },\n\n  /**\n   * Public update, called by the watcher in the dynamic\n   * literal scenario, e.g. <component :is=\"view\">\n   */\n\n  update: function (value) {\n    if (!this.literal) {\n      this.setComponent(value)\n    }\n  },\n\n  /**\n   * Switch dynamic components. May resolve the component\n   * asynchronously, and perform transition based on\n   * specified transition mode. Accepts a few additional\n   * arguments specifically for vue-router.\n   *\n   * The callback is called when the full transition is\n   * finished.\n   *\n   * @param {String} value\n   * @param {Function} [cb]\n   */\n\n  setComponent: function (value, cb) {\n    this.invalidatePending()\n    if (!value) {\n      // just remove current\n      this.unbuild(true)\n      this.remove(this.childVM, cb)\n      this.childVM = null\n    } else {\n      var self = this\n      this.resolveComponent(value, function () {\n        self.mountComponent(cb)\n      })\n    }\n  },\n\n  /**\n   * Resolve the component constructor to use when creating\n   * the child vm.\n   */\n\n  resolveComponent: function (id, cb) {\n    var self = this\n    this.pendingComponentCb = _.cancellable(function (Component) {\n      self.ComponentName = Component.options.name || id\n      self.Component = Component\n      cb()\n    })\n    this.vm._resolveComponent(id, this.pendingComponentCb)\n  },\n\n  /**\n   * Create a new instance using the current constructor and\n   * replace the existing instance. This method doesn't care\n   * whether the new component and the old one are actually\n   * the same.\n   *\n   * @param {Function} [cb]\n   */\n\n  mountComponent: function (cb) {\n    // actual mount\n    this.unbuild(true)\n    var self = this\n    var activateHook = this.Component.options.activate\n    var cached = this.getCached()\n    var newComponent = this.build()\n    if (activateHook && !cached) {\n      this.waitingFor = newComponent\n      activateHook.call(newComponent, function () {\n        self.waitingFor = null\n        self.transition(newComponent, cb)\n      })\n    } else {\n      this.transition(newComponent, cb)\n    }\n  },\n\n  /**\n   * When the component changes or unbinds before an async\n   * constructor is resolved, we need to invalidate its\n   * pending callback.\n   */\n\n  invalidatePending: function () {\n    if (this.pendingComponentCb) {\n      this.pendingComponentCb.cancel()\n      this.pendingComponentCb = null\n    }\n  },\n\n  /**\n   * Instantiate/insert a new child vm.\n   * If keep alive and has cached instance, insert that\n   * instance; otherwise build a new one and cache it.\n   *\n   * @param {Object} [extraOptions]\n   * @return {Vue} - the created instance\n   */\n\n  build: function (extraOptions) {\n    var cached = this.getCached()\n    if (cached) {\n      return cached\n    }\n    if (this.Component) {\n      // default options\n      var options = {\n        name: this.ComponentName,\n        el: templateParser.clone(this.el),\n        template: this.inlineTemplate,\n        // make sure to add the child with correct parent\n        // if this is a transcluded component, its parent\n        // should be the transclusion host.\n        parent: this._host || this.vm,\n        // if no inline-template, then the compiled\n        // linker can be cached for better performance.\n        _linkerCachable: !this.inlineTemplate,\n        _ref: this.ref,\n        _asComponent: true,\n        _isRouterView: this._isRouterView,\n        // if this is a transcluded component, context\n        // will be the common parent vm of this instance\n        // and its host.\n        _context: this.vm,\n        // if this is inside an inline v-for, the scope\n        // will be the intermediate scope created for this\n        // repeat fragment. this is used for linking props\n        // and container directives.\n        _scope: this._scope,\n        // pass in the owner fragment of this component.\n        // this is necessary so that the fragment can keep\n        // track of its contained components in order to\n        // call attach/detach hooks for them.\n        _frag: this._frag\n      }\n      // extra options\n      // in 1.0.0 this is used by vue-router only\n      /* istanbul ignore if */\n      if (extraOptions) {\n        _.extend(options, extraOptions)\n      }\n      var child = new this.Component(options)\n      if (this.keepAlive) {\n        this.cache[this.Component.cid] = child\n      }\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' &&\n          this.el.hasAttribute('transition') &&\n          child._isFragment) {\n        _.warn(\n          'Transitions will not work on a fragment instance. ' +\n          'Template: ' + child.$options.template\n        )\n      }\n      return child\n    }\n  },\n\n  /**\n   * Try to get a cached instance of the current component.\n   *\n   * @return {Vue|undefined}\n   */\n\n  getCached: function () {\n    return this.keepAlive && this.cache[this.Component.cid]\n  },\n\n  /**\n   * Teardown the current child, but defers cleanup so\n   * that we can separate the destroy and removal steps.\n   *\n   * @param {Boolean} defer\n   */\n\n  unbuild: function (defer) {\n    if (this.waitingFor) {\n      this.waitingFor.$destroy()\n      this.waitingFor = null\n    }\n    var child = this.childVM\n    if (!child || this.keepAlive) {\n      return\n    }\n    // the sole purpose of `deferCleanup` is so that we can\n    // \"deactivate\" the vm right now and perform DOM removal\n    // later.\n    child.$destroy(false, defer)\n  },\n\n  /**\n   * Remove current destroyed child and manually do\n   * the cleanup after removal.\n   *\n   * @param {Function} cb\n   */\n\n  remove: function (child, cb) {\n    var keepAlive = this.keepAlive\n    if (child) {\n      // we may have a component switch when a previous\n      // component is still being transitioned out.\n      // we want to trigger only one lastest insertion cb\n      // when the existing transition finishes. (#1119)\n      this.pendingRemovals++\n      this.pendingRemovalCb = cb\n      var self = this\n      child.$remove(function () {\n        self.pendingRemovals--\n        if (!keepAlive) child._cleanup()\n        if (!self.pendingRemovals && self.pendingRemovalCb) {\n          self.pendingRemovalCb()\n          self.pendingRemovalCb = null\n        }\n      })\n    } else if (cb) {\n      cb()\n    }\n  },\n\n  /**\n   * Actually swap the components, depending on the\n   * transition mode. Defaults to simultaneous.\n   *\n   * @param {Vue} target\n   * @param {Function} [cb]\n   */\n\n  transition: function (target, cb) {\n    var self = this\n    var current = this.childVM\n    // for devtool inspection\n    if (process.env.NODE_ENV !== 'production') {\n      if (current) current._inactive = true\n      target._inactive = false\n    }\n    this.childVM = target\n    switch (self.params.transitionMode) {\n      case 'in-out':\n        target.$before(self.anchor, function () {\n          self.remove(current, cb)\n        })\n        break\n      case 'out-in':\n        self.remove(current, function () {\n          target.$before(self.anchor, cb)\n        })\n        break\n      default:\n        self.remove(current)\n        target.$before(self.anchor, cb)\n    }\n  },\n\n  /**\n   * Unbind.\n   */\n\n  unbind: function () {\n    this.invalidatePending()\n    // Do not defer cleanup when unbinding\n    this.unbuild()\n    // destroy all keep-alive cached instances\n    if (this.cache) {\n      for (var key in this.cache) {\n        this.cache[key].$destroy()\n      }\n      this.cache = null\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../parsers/template\":90,\"../../util\":99,\"_process\":1}],55:[function(require,module,exports){\nexports.style = require('./style')\nexports['class'] = require('./class')\nexports.component = require('./component')\nexports.prop = require('./prop')\nexports.transition = require('./transition')\n\n},{\"./class\":53,\"./component\":54,\"./prop\":56,\"./style\":57,\"./transition\":58}],56:[function(require,module,exports){\n// NOTE: the prop internal directive is compiled and linked\n// during _initScope(), before the created hook is called.\n// The purpose is to make the initial prop values available\n// inside `created` hooks and `data` functions.\n\nvar _ = require('../../util')\nvar Watcher = require('../../watcher')\nvar bindingModes = require('../../config')._propBindingModes\n\nmodule.exports = {\n\n  bind: function () {\n\n    var child = this.vm\n    var parent = child._context\n    // passed in from compiler directly\n    var prop = this.descriptor.prop\n    var childKey = prop.path\n    var parentKey = prop.parentPath\n    var twoWay = prop.mode === bindingModes.TWO_WAY\n\n    var parentWatcher = this.parentWatcher = new Watcher(\n      parent,\n      parentKey,\n      function (val) {\n        if (_.assertProp(prop, val)) {\n          child[childKey] = val\n        }\n      }, {\n        twoWay: twoWay,\n        filters: prop.filters,\n        // important: props need to be observed on the\n        // v-for scope if present\n        scope: this._scope\n      }\n    )\n\n    // set the child initial value.\n    _.initProp(child, prop, parentWatcher.value)\n\n    // setup two-way binding\n    if (twoWay) {\n      // important: defer the child watcher creation until\n      // the created hook (after data observation)\n      var self = this\n      child.$once('hook:created', function () {\n        self.childWatcher = new Watcher(\n          child,\n          childKey,\n          function (val) {\n            parentWatcher.set(val)\n          }\n        )\n      })\n    }\n  },\n\n  unbind: function () {\n    this.parentWatcher.teardown()\n    if (this.childWatcher) {\n      this.childWatcher.teardown()\n    }\n  }\n}\n\n},{\"../../config\":48,\"../../util\":99,\"../../watcher\":103}],57:[function(require,module,exports){\nvar _ = require('../../util')\nvar prefixes = ['-webkit-', '-moz-', '-ms-']\nvar camelPrefixes = ['Webkit', 'Moz', 'ms']\nvar importantRE = /!important;?$/\nvar testEl = null\nvar propCache = {}\n\nmodule.exports = {\n\n  deep: true,\n\n  update: function (value) {\n    if (typeof value === 'string') {\n      this.el.style.cssText = value\n    } else if (_.isArray(value)) {\n      this.handleObject(value.reduce(_.extend, {}))\n    } else {\n      this.handleObject(value || {})\n    }\n  },\n\n  handleObject: function (value) {\n    // cache object styles so that only changed props\n    // are actually updated.\n    var cache = this.cache || (this.cache = {})\n    var name, val\n    for (name in cache) {\n      if (!(name in value)) {\n        this.handleSingle(name, null)\n        delete cache[name]\n      }\n    }\n    for (name in value) {\n      val = value[name]\n      if (val !== cache[name]) {\n        cache[name] = val\n        this.handleSingle(name, val)\n      }\n    }\n  },\n\n  handleSingle: function (prop, value) {\n    prop = normalize(prop)\n    if (!prop) return // unsupported prop\n    // cast possible numbers/booleans into strings\n    if (value != null) value += ''\n    if (value) {\n      var isImportant = importantRE.test(value)\n        ? 'important'\n        : ''\n      if (isImportant) {\n        value = value.replace(importantRE, '').trim()\n      }\n      this.el.style.setProperty(prop, value, isImportant)\n    } else {\n      this.el.style.removeProperty(prop)\n    }\n  }\n\n}\n\n/**\n * Normalize a CSS property name.\n * - cache result\n * - auto prefix\n * - camelCase -> dash-case\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction normalize (prop) {\n  if (propCache[prop]) {\n    return propCache[prop]\n  }\n  var res = prefix(prop)\n  propCache[prop] = propCache[res] = res\n  return res\n}\n\n/**\n * Auto detect the appropriate prefix for a CSS property.\n * https://gist.github.com/paulirish/523692\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction prefix (prop) {\n  prop = _.hyphenate(prop)\n  var camel = _.camelize(prop)\n  var upper = camel.charAt(0).toUpperCase() + camel.slice(1)\n  if (!testEl) {\n    testEl = document.createElement('div')\n  }\n  if (camel in testEl.style) {\n    return prop\n  }\n  var i = prefixes.length\n  var prefixed\n  while (i--) {\n    prefixed = camelPrefixes[i] + upper\n    if (prefixed in testEl.style) {\n      return prefixes[i] + prop\n    }\n  }\n}\n\n},{\"../../util\":99}],58:[function(require,module,exports){\nvar _ = require('../../util')\nvar Transition = require('../../transition/transition')\n\nmodule.exports = {\n\n  priority: 1000,\n\n  update: function (id, oldId) {\n    var el = this.el\n    // resolve on owner vm\n    var hooks = _.resolveAsset(this.vm.$options, 'transitions', id)\n    id = id || 'v'\n    // apply on closest vm\n    el.__v_trans = new Transition(el, id, hooks, this.el.__vue__ || this.vm)\n    if (oldId) {\n      _.removeClass(el, oldId + '-transition')\n    }\n    _.addClass(el, id + '-transition')\n  }\n}\n\n},{\"../../transition/transition\":94,\"../../util\":99}],59:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\n\n// xlink\nvar xlinkNS = 'http://www.w3.org/1999/xlink'\nvar xlinkRE = /^xlink:/\n\n// these input element attributes should also set their\n// corresponding properties\nvar inputProps = {\n  value: 1,\n  checked: 1,\n  selected: 1\n}\n\n// these attributes should set a hidden property for\n// binding v-model to object values\nvar modelProps = {\n  value: '_value',\n  'true-value': '_trueValue',\n  'false-value': '_falseValue'\n}\n\n// check for attributes that prohibit interpolations\nvar disallowedInterpAttrRE = /^v-|^:|^@|^(is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/\n\nmodule.exports = {\n\n  priority: 850,\n\n  bind: function () {\n    var attr = this.arg\n    var tag = this.el.tagName\n    // should be deep watch on object mode\n    if (!attr) {\n      this.deep = true\n    }\n    // handle interpolation bindings\n    if (this.descriptor.interp) {\n      // only allow binding on native attributes\n      if (\n        disallowedInterpAttrRE.test(attr) ||\n        (attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT'))\n      ) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          attr + '=\"' + this.descriptor.raw + '\": ' +\n          'attribute interpolation is not allowed in Vue.js ' +\n          'directives and special attributes.'\n        )\n        this.el.removeAttribute(attr)\n        this.invalid = true\n      }\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production') {\n        var raw = attr + '=\"' + this.descriptor.raw + '\": '\n        // warn src\n        if (attr === 'src') {\n          _.warn(\n            raw + 'interpolation in \"src\" attribute will cause ' +\n            'a 404 request. Use v-bind:src instead.'\n          )\n        }\n\n        // warn style\n        if (attr === 'style') {\n          _.warn(\n            raw + 'interpolation in \"style\" attribute will cause ' +\n            'the attribute to be discarded in Internet Explorer. ' +\n            'Use v-bind:style instead.'\n          )\n        }\n      }\n    }\n  },\n\n  update: function (value) {\n    if (this.invalid) {\n      return\n    }\n    var attr = this.arg\n    if (this.arg) {\n      this.handleSingle(attr, value)\n    } else {\n      this.handleObject(value || {})\n    }\n  },\n\n  // share object handler with v-bind:class\n  handleObject: require('../internal/style').handleObject,\n\n  handleSingle: function (attr, value) {\n    if (inputProps[attr] && attr in this.el) {\n      this.el[attr] = attr === 'value'\n        ? (value || '') // IE9 will set input.value to \"null\" for null...\n        : value\n    }\n    // set model props\n    var modelProp = modelProps[attr]\n    if (modelProp) {\n      this.el[modelProp] = value\n      // update v-model if present\n      var model = this.el.__v_model\n      if (model) {\n        model.listener()\n      }\n    }\n    // do not set value attribute for textarea\n    if (attr === 'value' && this.el.tagName === 'TEXTAREA') {\n      this.el.removeAttribute(attr)\n      return\n    }\n    // update attribute\n    if (value != null && value !== false) {\n      if (xlinkRE.test(attr)) {\n        this.el.setAttributeNS(xlinkNS, attr, value)\n      } else {\n        this.el.setAttribute(attr, value)\n      }\n    } else {\n      this.el.removeAttribute(attr)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../util\":99,\"../internal/style\":57,\"_process\":1}],60:[function(require,module,exports){\nmodule.exports = {\n  bind: function () {\n    var el = this.el\n    this.vm.$once('hook:compiled', function () {\n      el.removeAttribute('v-cloak')\n    })\n  }\n}\n\n},{}],61:[function(require,module,exports){\nvar _ = require('../../util')\n\nmodule.exports = {\n\n  priority: 1500,\n\n  bind: function () {\n    /* istanbul ignore if */\n    if (!this.arg) {\n      return\n    }\n    var id = this.id = _.camelize(this.arg)\n    var refs = (this._scope || this.vm).$els\n    if (refs.hasOwnProperty(id)) {\n      refs[id] = this.el\n    } else {\n      _.defineReactive(refs, id, this.el)\n    }\n  },\n\n  unbind: function () {\n    var refs = (this._scope || this.vm).$els\n    if (refs[this.id] === this.el) {\n      refs[this.id] = null\n    }\n  }\n}\n\n},{\"../../util\":99}],62:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\nvar FragmentFactory = require('../../fragment/factory')\nvar isObject = _.isObject\nvar uid = 0\n\nmodule.exports = {\n\n  priority: 2000,\n\n  params: [\n    'track-by',\n    'stagger',\n    'enter-stagger',\n    'leave-stagger'\n  ],\n\n  bind: function () {\n    // support \"item in items\" syntax\n    var inMatch = this.expression.match(/(.*) in (.*)/)\n    if (inMatch) {\n      var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/)\n      if (itMatch) {\n        this.iterator = itMatch[1].trim()\n        this.alias = itMatch[2].trim()\n      } else {\n        this.alias = inMatch[1].trim()\n      }\n      this.expression = inMatch[2]\n    }\n\n    if (!this.alias) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Alias is required in v-for.'\n      )\n      return\n    }\n\n    // uid as a cache identifier\n    this.id = '__v-for__' + (++uid)\n\n    // check if this is an option list,\n    // so that we know if we need to update the <select>'s\n    // v-model when the option list has changed.\n    // because v-model has a lower priority than v-for,\n    // the v-model is not bound here yet, so we have to\n    // retrive it in the actual updateModel() function.\n    var tag = this.el.tagName\n    this.isOption =\n      (tag === 'OPTION' || tag === 'OPTGROUP') &&\n      this.el.parentNode.tagName === 'SELECT'\n\n    // setup anchor nodes\n    this.start = _.createAnchor('v-for-start')\n    this.end = _.createAnchor('v-for-end')\n    _.replace(this.el, this.end)\n    _.before(this.start, this.end)\n\n    // check ref\n    this.ref = _.findRef(this.el)\n\n    // cache\n    this.cache = Object.create(null)\n\n    // fragment factory\n    this.factory = new FragmentFactory(this.vm, this.el)\n  },\n\n  update: function (data) {\n    this.diff(data)\n    this.updateRef()\n    this.updateModel()\n  },\n\n  /**\n   * Diff, based on new data and old data, determine the\n   * minimum amount of DOM manipulations needed to make the\n   * DOM reflect the new data Array.\n   *\n   * The algorithm diffs the new data Array by storing a\n   * hidden reference to an owner vm instance on previously\n   * seen data. This allows us to achieve O(n) which is\n   * better than a levenshtein distance based algorithm,\n   * which is O(m * n).\n   *\n   * @param {Array} data\n   */\n\n  diff: function (data) {\n    // check if the Array was converted from an Object\n    var item = data[0]\n    var convertedFromObject = this.fromObject =\n      isObject(item) &&\n      item.hasOwnProperty('$key') &&\n      item.hasOwnProperty('$value')\n\n    var trackByKey = this.params.trackBy\n    var oldFrags = this.frags\n    var frags = this.frags = new Array(data.length)\n    var alias = this.alias\n    var iterator = this.iterator\n    var start = this.start\n    var end = this.end\n    var inDoc = _.inDoc(start)\n    var init = !oldFrags\n    var i, l, frag, key, value, primitive\n\n    // First pass, go through the new Array and fill up\n    // the new frags array. If a piece of data has a cached\n    // instance for it, we reuse it. Otherwise build a new\n    // instance.\n    for (i = 0, l = data.length; i < l; i++) {\n      item = data[i]\n      key = convertedFromObject ? item.$key : null\n      value = convertedFromObject ? item.$value : item\n      primitive = !isObject(value)\n      frag = !init && this.getCachedFrag(value, i, key)\n      if (frag) { // reusable fragment\n        frag.reused = true\n        // update $index\n        frag.scope.$index = i\n        // update $key\n        if (key) {\n          frag.scope.$key = key\n        }\n        // update iterator\n        if (iterator) {\n          frag.scope[iterator] = key !== null ? key : i\n        }\n        // update data for track-by, object repeat &\n        // primitive values.\n        if (trackByKey || convertedFromObject || primitive) {\n          frag.scope[alias] = value\n        }\n      } else { // new isntance\n        frag = this.create(value, alias, i, key)\n        frag.fresh = !init\n      }\n      frags[i] = frag\n      if (init) {\n        frag.before(end)\n      }\n    }\n\n    // we're done for the initial render.\n    if (init) {\n      return\n    }\n\n    // Second pass, go through the old fragments and\n    // destroy those who are not reused (and remove them\n    // from cache)\n    var removalIndex = 0\n    var totalRemoved = oldFrags.length - frags.length\n    for (i = 0, l = oldFrags.length; i < l; i++) {\n      frag = oldFrags[i]\n      if (!frag.reused) {\n        this.deleteCachedFrag(frag)\n        this.remove(frag, removalIndex++, totalRemoved, inDoc)\n      }\n    }\n\n    // Final pass, move/insert new fragments into the\n    // right place.\n    var targetPrev, prevEl, currentPrev\n    var insertionIndex = 0\n    for (i = 0, l = frags.length; i < l; i++) {\n      frag = frags[i]\n      // this is the frag that we should be after\n      targetPrev = frags[i - 1]\n      prevEl = targetPrev\n        ? targetPrev.staggerCb\n          ? targetPrev.staggerAnchor\n          : targetPrev.end || targetPrev.node\n        : start\n      if (frag.reused && !frag.staggerCb) {\n        currentPrev = findPrevFrag(frag, start, this.id)\n        if (currentPrev !== targetPrev) {\n          this.move(frag, prevEl)\n        }\n      } else {\n        // new instance, or still in stagger.\n        // insert with updated stagger index.\n        this.insert(frag, insertionIndex++, prevEl, inDoc)\n      }\n      frag.reused = frag.fresh = false\n    }\n  },\n\n  /**\n   * Create a new fragment instance.\n   *\n   * @param {*} value\n   * @param {String} alias\n   * @param {Number} index\n   * @param {String} [key]\n   * @return {Fragment}\n   */\n\n  create: function (value, alias, index, key) {\n    var host = this._host\n    // create iteration scope\n    var parentScope = this._scope || this.vm\n    var scope = Object.create(parentScope)\n    // ref holder for the scope\n    scope.$refs = Object.create(parentScope.$refs)\n    scope.$els = Object.create(parentScope.$els)\n    // make sure point $parent to parent scope\n    scope.$parent = parentScope\n    // for two-way binding on alias\n    scope.$forContext = this\n    // define scope properties\n    _.defineReactive(scope, alias, value)\n    _.defineReactive(scope, '$index', index)\n    if (key) {\n      _.defineReactive(scope, '$key', key)\n    } else if (scope.$key) {\n      // avoid accidental fallback\n      _.define(scope, '$key', null)\n    }\n    if (this.iterator) {\n      _.defineReactive(scope, this.iterator, key !== null ? key : index)\n    }\n    var frag = this.factory.create(host, scope, this._frag)\n    frag.forId = this.id\n    this.cacheFrag(value, frag, index, key)\n    return frag\n  },\n\n  /**\n   * Update the v-ref on owner vm.\n   */\n\n  updateRef: function () {\n    var ref = this.ref\n    if (!ref) return\n    var hash = (this._scope || this.vm).$refs\n    var refs\n    if (!this.fromObject) {\n      refs = this.frags.map(findVmFromFrag)\n    } else {\n      refs = {}\n      this.frags.forEach(function (frag) {\n        refs[frag.scope.$key] = findVmFromFrag(frag)\n      })\n    }\n    if (!hash.hasOwnProperty(ref)) {\n      _.defineReactive(hash, ref, refs)\n    } else {\n      hash[ref] = refs\n    }\n  },\n\n  /**\n   * For option lists, update the containing v-model on\n   * parent <select>.\n   */\n\n  updateModel: function () {\n    if (this.isOption) {\n      var parent = this.start.parentNode\n      var model = parent && parent.__v_model\n      if (model) {\n        model.forceUpdate()\n      }\n    }\n  },\n\n  /**\n   * Insert a fragment. Handles staggering.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Node} prevEl\n   * @param {Boolean} inDoc\n   */\n\n  insert: function (frag, index, prevEl, inDoc) {\n    if (frag.staggerCb) {\n      frag.staggerCb.cancel()\n      frag.staggerCb = null\n    }\n    var staggerAmount = this.getStagger(frag, index, null, 'enter')\n    if (inDoc && staggerAmount) {\n      // create an anchor and insert it synchronously,\n      // so that we can resolve the correct order without\n      // worrying about some elements not inserted yet\n      var anchor = frag.staggerAnchor\n      if (!anchor) {\n        anchor = frag.staggerAnchor = _.createAnchor('stagger-anchor')\n        anchor.__vfrag__ = frag\n      }\n      _.after(anchor, prevEl)\n      var op = frag.staggerCb = _.cancellable(function () {\n        frag.staggerCb = null\n        frag.before(anchor)\n        _.remove(anchor)\n      })\n      setTimeout(op, staggerAmount)\n    } else {\n      frag.before(prevEl.nextSibling)\n    }\n  },\n\n  /**\n   * Remove a fragment. Handles staggering.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Number} total\n   * @param {Boolean} inDoc\n   */\n\n  remove: function (frag, index, total, inDoc) {\n    if (frag.staggerCb) {\n      frag.staggerCb.cancel()\n      frag.staggerCb = null\n      // it's not possible for the same frag to be removed\n      // twice, so if we have a pending stagger callback,\n      // it means this frag is queued for enter but removed\n      // before its transition started. Since it is already\n      // destroyed, we can just leave it in detached state.\n      return\n    }\n    var staggerAmount = this.getStagger(frag, index, total, 'leave')\n    if (inDoc && staggerAmount) {\n      var op = frag.staggerCb = _.cancellable(function () {\n        frag.staggerCb = null\n        frag.remove(true)\n      })\n      setTimeout(op, staggerAmount)\n    } else {\n      frag.remove(true)\n    }\n  },\n\n  /**\n   * Move a fragment to a new position.\n   * Force no transition.\n   *\n   * @param {Fragment} frag\n   * @param {Node} prevEl\n   */\n\n  move: function (frag, prevEl) {\n    frag.before(prevEl.nextSibling, false)\n  },\n\n  /**\n   * Cache a fragment using track-by or the object key.\n   *\n   * @param {*} value\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {String} [key]\n   */\n\n  cacheFrag: function (value, frag, index, key) {\n    var trackByKey = this.params.trackBy\n    var cache = this.cache\n    var primitive = !isObject(value)\n    var id\n    if (key || trackByKey || primitive) {\n      id = trackByKey\n        ? trackByKey === '$index'\n          ? index\n          : value[trackByKey]\n        : (key || value)\n      if (!cache[id]) {\n        cache[id] = frag\n      } else if (trackByKey !== '$index') {\n        process.env.NODE_ENV !== 'production' &&\n        this.warnDuplicate(value)\n      }\n    } else {\n      id = this.id\n      if (value.hasOwnProperty(id)) {\n        if (value[id] === null) {\n          value[id] = frag\n        } else {\n          process.env.NODE_ENV !== 'production' &&\n          this.warnDuplicate(value)\n        }\n      } else {\n        _.define(value, id, frag)\n      }\n    }\n    frag.raw = value\n  },\n\n  /**\n   * Get a cached fragment from the value/index/key\n   *\n   * @param {*} value\n   * @param {Number} index\n   * @param {String} key\n   * @return {Fragment}\n   */\n\n  getCachedFrag: function (value, index, key) {\n    var trackByKey = this.params.trackBy\n    var primitive = !isObject(value)\n    var frag\n    if (key || trackByKey || primitive) {\n      var id = trackByKey\n        ? trackByKey === '$index'\n          ? index\n          : value[trackByKey]\n        : (key || value)\n      frag = this.cache[id]\n    } else {\n      frag = value[this.id]\n    }\n    if (frag && (frag.reused || frag.fresh)) {\n      process.env.NODE_ENV !== 'production' &&\n      this.warnDuplicate(value)\n    }\n    return frag\n  },\n\n  /**\n   * Delete a fragment from cache.\n   *\n   * @param {Fragment} frag\n   */\n\n  deleteCachedFrag: function (frag) {\n    var value = frag.raw\n    var trackByKey = this.params.trackBy\n    var scope = frag.scope\n    var index = scope.$index\n    // fix #948: avoid accidentally fall through to\n    // a parent repeater which happens to have $key.\n    var key = scope.hasOwnProperty('$key') && scope.$key\n    var primitive = !isObject(value)\n    if (trackByKey || key || primitive) {\n      var id = trackByKey\n        ? trackByKey === '$index'\n          ? index\n          : value[trackByKey]\n        : (key || value)\n      this.cache[id] = null\n    } else {\n      value[this.id] = null\n      frag.raw = null\n    }\n  },\n\n  /**\n   * Get the stagger amount for an insertion/removal.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Number} total\n   * @param {String} type\n   */\n\n  getStagger: function (frag, index, total, type) {\n    type = type + 'Stagger'\n    var trans = frag.node.__v_trans\n    var hooks = trans && trans.hooks\n    var hook = hooks && (hooks[type] || hooks.stagger)\n    return hook\n      ? hook.call(frag, index, total)\n      : index * parseInt(this.params[type] || this.params.stagger, 10)\n  },\n\n  /**\n   * Pre-process the value before piping it through the\n   * filters. This is passed to and called by the watcher.\n   */\n\n  _preProcess: function (value) {\n    // regardless of type, store the un-filtered raw value.\n    this.rawValue = value\n    return value\n  },\n\n  /**\n   * Post-process the value after it has been piped through\n   * the filters. This is passed to and called by the watcher.\n   *\n   * It is necessary for this to be called during the\n   * wathcer's dependency collection phase because we want\n   * the v-for to update when the source Object is mutated.\n   */\n\n  _postProcess: function (value) {\n    if (_.isArray(value)) {\n      return value\n    } else if (_.isPlainObject(value)) {\n      // convert plain object to array.\n      var keys = Object.keys(value)\n      var i = keys.length\n      var res = new Array(i)\n      var key\n      while (i--) {\n        key = keys[i]\n        res[i] = {\n          $key: key,\n          $value: value[key]\n        }\n      }\n      return res\n    } else {\n      var type = typeof value\n      if (type === 'number') {\n        value = range(value)\n      } else if (type === 'string') {\n        value = _.toArray(value)\n      }\n      return value || []\n    }\n  },\n\n  unbind: function () {\n    if (this.ref) {\n      (this._scope || this.vm).$refs[this.ref] = null\n    }\n    if (this.frags) {\n      var i = this.frags.length\n      var frag\n      while (i--) {\n        frag = this.frags[i]\n        this.deleteCachedFrag(frag)\n        frag.destroy()\n      }\n    }\n  }\n}\n\n/**\n * Helper to find the previous element that is a fragment\n * anchor. This is necessary because a destroyed frag's\n * element could still be lingering in the DOM before its\n * leaving transition finishes, but its inserted flag\n * should have been set to false so we can skip them.\n *\n * If this is a block repeat, we want to make sure we only\n * return frag that is bound to this v-for. (see #929)\n *\n * @param {Fragment} frag\n * @param {Comment|Text} anchor\n * @param {String} id\n * @return {Fragment}\n */\n\nfunction findPrevFrag (frag, anchor, id) {\n  var el = frag.node.previousSibling\n  /* istanbul ignore if */\n  if (!el) return\n  frag = el.__vfrag__\n  while (\n    (!frag || frag.forId !== id || !frag.inserted) &&\n    el !== anchor\n  ) {\n    el = el.previousSibling\n    /* istanbul ignore if */\n    if (!el) return\n    frag = el.__vfrag__\n  }\n  return frag\n}\n\n/**\n * Find a vm from a fragment.\n *\n * @param {Fragment} frag\n * @return {Vue|undefined}\n */\n\nfunction findVmFromFrag (frag) {\n  return frag.node.__vue__ || frag.node.nextSibling.__vue__\n}\n\n/**\n * Create a range array from given number.\n *\n * @param {Number} n\n * @return {Array}\n */\n\nfunction range (n) {\n  var i = -1\n  var ret = new Array(n)\n  while (++i < n) {\n    ret[i] = i\n  }\n  return ret\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  module.exports.warnDuplicate = function (value) {\n    _.warn(\n      'Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' +\n      JSON.stringify(value) + '. Use track-by=\"$index\" if ' +\n      'you are expecting duplicate values.'\n    )\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../fragment/factory\":77,\"../../util\":99,\"_process\":1}],63:[function(require,module,exports){\nvar _ = require('../../util')\nvar templateParser = require('../../parsers/template')\n\nmodule.exports = {\n\n  bind: function () {\n    // a comment node means this is a binding for\n    // {{{ inline unescaped html }}}\n    if (this.el.nodeType === 8) {\n      // hold nodes\n      this.nodes = []\n      // replace the placeholder with proper anchor\n      this.anchor = _.createAnchor('v-html')\n      _.replace(this.el, this.anchor)\n    }\n  },\n\n  update: function (value) {\n    value = _.toString(value)\n    if (this.nodes) {\n      this.swap(value)\n    } else {\n      this.el.innerHTML = value\n    }\n  },\n\n  swap: function (value) {\n    // remove old nodes\n    var i = this.nodes.length\n    while (i--) {\n      _.remove(this.nodes[i])\n    }\n    // convert new value to a fragment\n    // do not attempt to retrieve from id selector\n    var frag = templateParser.parse(value, true, true)\n    // save a reference to these nodes so we can remove later\n    this.nodes = _.toArray(frag.childNodes)\n    _.before(frag, this.anchor)\n  }\n}\n\n},{\"../../parsers/template\":90,\"../../util\":99}],64:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\nvar FragmentFactory = require('../../fragment/factory')\n\nmodule.exports = {\n\n  priority: 2000,\n\n  bind: function () {\n    var el = this.el\n    if (!el.__vue__) {\n      // check else block\n      var next = el.nextElementSibling\n      if (next && _.attr(next, 'v-else') !== null) {\n        _.remove(next)\n        this.elseFactory = new FragmentFactory(this.vm, next)\n      }\n      // check main block\n      this.anchor = _.createAnchor('v-if')\n      _.replace(el, this.anchor)\n      this.factory = new FragmentFactory(this.vm, el)\n    } else {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'v-if=\"' + this.expression + '\" cannot be ' +\n        'used on an instance root element.'\n      )\n      this.invalid = true\n    }\n  },\n\n  update: function (value) {\n    if (this.invalid) return\n    if (value) {\n      if (!this.frag) {\n        this.insert()\n      }\n    } else {\n      this.remove()\n    }\n  },\n\n  insert: function () {\n    if (this.elseFrag) {\n      this.elseFrag.remove(true)\n      this.elseFrag = null\n    }\n    this.frag = this.factory.create(this._host, this._scope, this._frag)\n    this.frag.before(this.anchor)\n  },\n\n  remove: function () {\n    if (this.frag) {\n      this.frag.remove(true)\n      this.frag = null\n    }\n    if (this.elseFactory) {\n      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag)\n      this.elseFrag.before(this.anchor)\n    }\n  },\n\n  unbind: function () {\n    if (this.frag) {\n      this.frag.destroy()\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../fragment/factory\":77,\"../../util\":99,\"_process\":1}],65:[function(require,module,exports){\n// text & html\nexports.text = require('./text')\nexports.html = require('./html')\n\n// logic control\nexports['for'] = require('./for')\nexports['if'] = require('./if')\nexports.show = require('./show')\n\n// two-way binding\nexports.model = require('./model')\n\n// event handling\nexports.on = require('./on')\n\n// attributes\nexports.bind = require('./bind')\n\n// ref & el\nexports.el = require('./el')\nexports.ref = require('./ref')\n\n// cloak\nexports.cloak = require('./cloak')\n\n},{\"./bind\":59,\"./cloak\":60,\"./el\":61,\"./for\":62,\"./html\":63,\"./if\":64,\"./model\":67,\"./on\":71,\"./ref\":72,\"./show\":73,\"./text\":74}],66:[function(require,module,exports){\nvar _ = require('../../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n\n    this.getValue = function () {\n      return el.hasOwnProperty('_value')\n        ? el._value\n        : self.params.number\n          ? _.toNumber(el.value)\n          : el.value\n    }\n\n    function getBooleanValue () {\n      var val = el.checked\n      if (val && el.hasOwnProperty('_trueValue')) {\n        return el._trueValue\n      }\n      if (!val && el.hasOwnProperty('_falseValue')) {\n        return el._falseValue\n      }\n      return val\n    }\n\n    this.listener = function () {\n      var model = self._watcher.value\n      if (_.isArray(model)) {\n        var val = self.getValue()\n        if (el.checked) {\n          if (_.indexOf(model, val) < 0) {\n            model.push(val)\n          }\n        } else {\n          model.$remove(val)\n        }\n      } else {\n        self.set(getBooleanValue())\n      }\n    }\n\n    this.on('change', this.listener)\n    if (el.checked) {\n      this.afterBind = this.listener\n    }\n  },\n\n  update: function (value) {\n    var el = this.el\n    if (_.isArray(value)) {\n      el.checked = _.indexOf(value, this.getValue()) > -1\n    } else {\n      if (el.hasOwnProperty('_trueValue')) {\n        el.checked = _.looseEqual(value, el._trueValue)\n      } else {\n        el.checked = !!value\n      }\n    }\n  }\n}\n\n},{\"../../../util\":99}],67:[function(require,module,exports){\n(function (process){\nvar _ = require('../../../util')\n\nvar handlers = {\n  text: require('./text'),\n  radio: require('./radio'),\n  select: require('./select'),\n  checkbox: require('./checkbox')\n}\n\nmodule.exports = {\n\n  priority: 800,\n  twoWay: true,\n  handlers: handlers,\n  params: ['lazy', 'number', 'debounce'],\n\n  /**\n   * Possible elements:\n   *   <select>\n   *   <textarea>\n   *   <input type=\"*\">\n   *     - text\n   *     - checkbox\n   *     - radio\n   *     - number\n   */\n\n  bind: function () {\n    // friendly warning...\n    this.checkFilters()\n    if (this.hasRead && !this.hasWrite) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'It seems you are using a read-only filter with ' +\n        'v-model. You might want to use a two-way filter ' +\n        'to ensure correct behavior.'\n      )\n    }\n    var el = this.el\n    var tag = el.tagName\n    var handler\n    if (tag === 'INPUT') {\n      handler = handlers[el.type] || handlers.text\n    } else if (tag === 'SELECT') {\n      handler = handlers.select\n    } else if (tag === 'TEXTAREA') {\n      handler = handlers.text\n    } else {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'v-model does not support element type: ' + tag\n      )\n      return\n    }\n    el.__v_model = this\n    handler.bind.call(this)\n    this.update = handler.update\n    this._unbind = handler.unbind\n  },\n\n  /**\n   * Check read/write filter stats.\n   */\n\n  checkFilters: function () {\n    var filters = this.filters\n    if (!filters) return\n    var i = filters.length\n    while (i--) {\n      var filter = _.resolveAsset(this.vm.$options, 'filters', filters[i].name)\n      if (typeof filter === 'function' || filter.read) {\n        this.hasRead = true\n      }\n      if (filter.write) {\n        this.hasWrite = true\n      }\n    }\n  },\n\n  unbind: function () {\n    this.el.__v_model = null\n    this._unbind && this._unbind()\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../../util\":99,\"./checkbox\":66,\"./radio\":68,\"./select\":69,\"./text\":70,\"_process\":1}],68:[function(require,module,exports){\nvar _ = require('../../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n\n    this.getValue = function () {\n      // value overwrite via v-bind:value\n      if (el.hasOwnProperty('_value')) {\n        return el._value\n      }\n      var val = el.value\n      if (self.params.number) {\n        val = _.toNumber(val)\n      }\n      return val\n    }\n\n    this.listener = function () {\n      self.set(self.getValue())\n    }\n    this.on('change', this.listener)\n\n    if (el.checked) {\n      this.afterBind = this.listener\n    }\n  },\n\n  update: function (value) {\n    this.el.checked = _.looseEqual(value, this.getValue())\n  }\n}\n\n},{\"../../../util\":99}],69:[function(require,module,exports){\nvar _ = require('../../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n\n    // method to force update DOM using latest value.\n    this.forceUpdate = function () {\n      if (self._watcher) {\n        self.update(self._watcher.get())\n      }\n    }\n\n    // check if this is a multiple select\n    var multiple = this.multiple = el.hasAttribute('multiple')\n\n    // attach listener\n    this.listener = function () {\n      var value = getValue(el, multiple)\n      value = self.params.number\n        ? _.isArray(value)\n          ? value.map(_.toNumber)\n          : _.toNumber(value)\n        : value\n      self.set(value)\n    }\n    this.on('change', this.listener)\n\n    // if has initial value, set afterBind\n    var initValue = getValue(el, multiple, true)\n    if ((multiple && initValue.length) ||\n        (!multiple && initValue !== null)) {\n      this.afterBind = this.listener\n    }\n\n    // All major browsers except Firefox resets\n    // selectedIndex with value -1 to 0 when the element\n    // is appended to a new parent, therefore we have to\n    // force a DOM update whenever that happens...\n    this.vm.$on('hook:attached', this.forceUpdate)\n  },\n\n  update: function (value) {\n    var el = this.el\n    el.selectedIndex = -1\n    var multi = this.multiple && _.isArray(value)\n    var options = el.options\n    var i = options.length\n    var op, val\n    while (i--) {\n      op = options[i]\n      val = op.hasOwnProperty('_value')\n        ? op._value\n        : op.value\n      /* eslint-disable eqeqeq */\n      op.selected = multi\n        ? indexOf(value, val) > -1\n        : _.looseEqual(value, val)\n      /* eslint-enable eqeqeq */\n    }\n  },\n\n  unbind: function () {\n    /* istanbul ignore next */\n    this.vm.$off('hook:attached', this.forceUpdate)\n  }\n}\n\n/**\n * Get select value\n *\n * @param {SelectElement} el\n * @param {Boolean} multi\n * @param {Boolean} init\n * @return {Array|*}\n */\n\nfunction getValue (el, multi, init) {\n  var res = multi ? [] : null\n  var op, val, selected\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    op = el.options[i]\n    selected = init\n      ? op.hasAttribute('selected')\n      : op.selected\n    if (selected) {\n      val = op.hasOwnProperty('_value')\n        ? op._value\n        : op.value\n      if (multi) {\n        res.push(val)\n      } else {\n        return val\n      }\n    }\n  }\n  return res\n}\n\n/**\n * Native Array.indexOf uses strict equal, but in this\n * case we need to match string/numbers with custom equal.\n *\n * @param {Array} arr\n * @param {*} val\n */\n\nfunction indexOf (arr, val) {\n  var i = arr.length\n  while (i--) {\n    if (_.looseEqual(arr[i], val)) {\n      return i\n    }\n  }\n  return -1\n}\n\n},{\"../../../util\":99}],70:[function(require,module,exports){\nvar _ = require('../../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n    var isRange = el.type === 'range'\n    var lazy = this.params.lazy\n    var number = this.params.number\n    var debounce = this.params.debounce\n\n    // handle composition events.\n    //   http://blog.evanyou.me/2014/01/03/composition-event/\n    // skip this for Android because it handles composition\n    // events quite differently. Android doesn't trigger\n    // composition events for language input methods e.g.\n    // Chinese, but instead triggers them for spelling\n    // suggestions... (see Discussion/#162)\n    var composing = false\n    if (!_.isAndroid && !isRange) {\n      this.on('compositionstart', function () {\n        composing = true\n      })\n      this.on('compositionend', function () {\n        composing = false\n        // in IE11 the \"compositionend\" event fires AFTER\n        // the \"input\" event, so the input handler is blocked\n        // at the end... have to call it here.\n        //\n        // #1327: in lazy mode this is unecessary.\n        if (!lazy) {\n          self.listener()\n        }\n      })\n    }\n\n    // prevent messing with the input when user is typing,\n    // and force update on blur.\n    this.focused = false\n    if (!isRange) {\n      this.on('focus', function () {\n        self.focused = true\n      })\n      this.on('blur', function () {\n        self.focused = false\n        self.listener()\n      })\n    }\n\n    // Now attach the main listener\n    this.listener = function () {\n      if (composing) return\n      var val = number || isRange\n        ? _.toNumber(el.value)\n        : el.value\n      self.set(val)\n      // force update on next tick to avoid lock & same value\n      // also only update when user is not typing\n      _.nextTick(function () {\n        if (self._bound && !self.focused) {\n          self.update(self._watcher.value)\n        }\n      })\n    }\n\n    // apply debounce\n    if (debounce) {\n      this.listener = _.debounce(this.listener, debounce)\n    }\n\n    // Support jQuery events, since jQuery.trigger() doesn't\n    // trigger native events in some cases and some plugins\n    // rely on $.trigger()\n    //\n    // We want to make sure if a listener is attached using\n    // jQuery, it is also removed with jQuery, that's why\n    // we do the check for each directive instance and\n    // store that check result on itself. This also allows\n    // easier test coverage control by unsetting the global\n    // jQuery variable in tests.\n    this.hasjQuery = typeof jQuery === 'function'\n    if (this.hasjQuery) {\n      jQuery(el).on('change', this.listener)\n      if (!lazy) {\n        jQuery(el).on('input', this.listener)\n      }\n    } else {\n      this.on('change', this.listener)\n      if (!lazy) {\n        this.on('input', this.listener)\n      }\n    }\n\n    // IE9 doesn't fire input event on backspace/del/cut\n    if (!lazy && _.isIE9) {\n      this.on('cut', function () {\n        _.nextTick(self.listener)\n      })\n      this.on('keyup', function (e) {\n        if (e.keyCode === 46 || e.keyCode === 8) {\n          self.listener()\n        }\n      })\n    }\n\n    // set initial value if present\n    if (\n      el.hasAttribute('value') ||\n      (el.tagName === 'TEXTAREA' && el.value.trim())\n    ) {\n      this.afterBind = this.listener\n    }\n  },\n\n  update: function (value) {\n    this.el.value = _.toString(value)\n  },\n\n  unbind: function () {\n    var el = this.el\n    if (this.hasjQuery) {\n      jQuery(el).off('change', this.listener)\n      jQuery(el).off('input', this.listener)\n    }\n  }\n}\n\n},{\"../../../util\":99}],71:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  'delete': 46,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40\n}\n\nfunction keyFilter (handler, keys) {\n  var codes = keys.map(function (key) {\n    var code = keyCodes[key]\n    if (!code) {\n      code = parseInt(key, 10)\n    }\n    return code\n  })\n  return function keyHandler (e) {\n    if (codes.indexOf(e.keyCode) > -1) {\n      return handler.call(this, e)\n    }\n  }\n}\n\nfunction stopFilter (handler) {\n  return function stopHandler (e) {\n    e.stopPropagation()\n    return handler.call(this, e)\n  }\n}\n\nfunction preventFilter (handler) {\n  return function preventHandler (e) {\n    e.preventDefault()\n    return handler.call(this, e)\n  }\n}\n\nmodule.exports = {\n\n  acceptStatement: true,\n  priority: 700,\n\n  bind: function () {\n    // deal with iframes\n    if (\n      this.el.tagName === 'IFRAME' &&\n      this.arg !== 'load'\n    ) {\n      var self = this\n      this.iframeBind = function () {\n        _.on(self.el.contentWindow, self.arg, self.handler)\n      }\n      this.on('load', this.iframeBind)\n    }\n  },\n\n  update: function (handler) {\n    // stub a noop for v-on with no value,\n    // e.g. @mousedown.prevent\n    if (!this.descriptor.raw) {\n      handler = function () {}\n    }\n\n    if (typeof handler !== 'function') {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'v-on:' + this.arg + '=\"' +\n        this.expression + '\" expects a function value, ' +\n        'got ' + handler\n      )\n      return\n    }\n\n    // apply modifiers\n    if (this.modifiers.stop) {\n      handler = stopFilter(handler)\n    }\n    if (this.modifiers.prevent) {\n      handler = preventFilter(handler)\n    }\n    // key filter\n    var keys = Object.keys(this.modifiers)\n      .filter(function (key) {\n        return key !== 'stop' && key !== 'prevent'\n      })\n    if (keys.length) {\n      handler = keyFilter(handler, keys)\n    }\n\n    this.reset()\n    var scope = this._scope || this.vm\n    this.handler = function (e) {\n      scope.$event = e\n      var res = handler(e)\n      scope.$event = null\n      return res\n    }\n    if (this.iframeBind) {\n      this.iframeBind()\n    } else {\n      _.on(this.el, this.arg, this.handler)\n    }\n  },\n\n  reset: function () {\n    var el = this.iframeBind\n      ? this.el.contentWindow\n      : this.el\n    if (this.handler) {\n      _.off(el, this.arg, this.handler)\n    }\n  },\n\n  unbind: function () {\n    this.reset()\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../util\":99,\"_process\":1}],72:[function(require,module,exports){\n(function (process){\nif (process.env.NODE_ENV !== 'production') {\n  module.exports = {\n    bind: function () {\n      require('../../util').warn(\n        'v-ref:' + this.arg + ' must be used on a child ' +\n        'component. Found on <' + this.el.tagName.toLowerCase() + '>.'\n      )\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../util\":99,\"_process\":1}],73:[function(require,module,exports){\nvar _ = require('../../util')\nvar transition = require('../../transition')\n\nmodule.exports = {\n\n  bind: function () {\n    // check else block\n    var next = this.el.nextElementSibling\n    if (next && _.attr(next, 'v-else') !== null) {\n      this.elseEl = next\n    }\n  },\n\n  update: function (value) {\n    var el = this.el\n    transition.apply(el, value ? 1 : -1, function () {\n      el.style.display = value ? '' : 'none'\n    }, this.vm)\n    var elseEl = this.elseEl\n    if (elseEl) {\n      transition.apply(elseEl, value ? -1 : 1, function () {\n        elseEl.style.display = value ? 'none' : ''\n      }, this.vm)\n    }\n  }\n}\n\n},{\"../../transition\":92,\"../../util\":99}],74:[function(require,module,exports){\nvar _ = require('../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    this.attr = this.el.nodeType === 3\n      ? 'data'\n      : 'textContent'\n  },\n\n  update: function (value) {\n    this.el[this.attr] = _.toString(value)\n  }\n}\n\n},{\"../../util\":99}],75:[function(require,module,exports){\nvar _ = require('../util')\nvar Path = require('../parsers/path')\nvar toArray = require('../directives/public/for')._postProcess\n\n/**\n * Limit filter for arrays\n *\n * @param {Number} n\n */\n\nexports.limitBy = function (arr, n) {\n  return typeof n === 'number'\n    ? arr.slice(0, n)\n    : arr\n}\n\n/**\n * Filter filter for arrays\n *\n * @param {String} searchKey\n * @param {String} [delimiter]\n * @param {String} dataKey\n */\n\nexports.filterBy = function (arr, search, delimiter /* ...dataKeys */) {\n  arr = toArray(arr)\n  if (search == null) {\n    return arr\n  }\n  if (typeof search === 'function') {\n    return arr.filter(search)\n  }\n  // cast to lowercase string\n  search = ('' + search).toLowerCase()\n  // allow optional `in` delimiter\n  // because why not\n  var n = delimiter === 'in' ? 3 : 2\n  // extract and flatten keys\n  var keys = _.toArray(arguments, n).reduce(function (prev, cur) {\n    return prev.concat(cur)\n  }, [])\n  var res = []\n  var item, key, val, j\n  for (var i = 0, l = arr.length; i < l; i++) {\n    item = arr[i]\n    val = (item && item.$value) || item\n    j = keys.length\n    if (j) {\n      while (j--) {\n        key = keys[j]\n        if ((key === '$key' && contains(item.$key, search)) ||\n            contains(Path.get(val, key), search)) {\n          res.push(item)\n          break\n        }\n      }\n    } else if (contains(item, search)) {\n      res.push(item)\n    }\n  }\n  return res\n}\n\n/**\n * Filter filter for arrays\n *\n * @param {String} sortKey\n * @param {String} reverse\n */\n\nexports.orderBy = function (arr, sortKey, reverse) {\n  arr = toArray(arr)\n  if (!sortKey) {\n    return arr\n  }\n  var order = (reverse && reverse < 0) ? -1 : 1\n  // sort on a copy to avoid mutating original array\n  return arr.slice().sort(function (a, b) {\n    if (sortKey !== '$key') {\n      if (_.isObject(a) && '$value' in a) a = a.$value\n      if (_.isObject(b) && '$value' in b) b = b.$value\n    }\n    a = _.isObject(a) ? Path.get(a, sortKey) : a\n    b = _.isObject(b) ? Path.get(b, sortKey) : b\n    return a === b ? 0 : a > b ? order : -order\n  })\n}\n\n/**\n * String contain helper\n *\n * @param {*} val\n * @param {String} search\n */\n\nfunction contains (val, search) {\n  var i\n  if (_.isPlainObject(val)) {\n    var keys = Object.keys(val)\n    i = keys.length\n    while (i--) {\n      if (contains(val[keys[i]], search)) {\n        return true\n      }\n    }\n  } else if (_.isArray(val)) {\n    i = val.length\n    while (i--) {\n      if (contains(val[i], search)) {\n        return true\n      }\n    }\n  } else if (val != null) {\n    return val.toString().toLowerCase().indexOf(search) > -1\n  }\n}\n\n},{\"../directives/public/for\":62,\"../parsers/path\":89,\"../util\":99}],76:[function(require,module,exports){\nvar _ = require('../util')\n\n/**\n * Stringify value.\n *\n * @param {Number} indent\n */\n\nexports.json = {\n  read: function (value, indent) {\n    return typeof value === 'string'\n      ? value\n      : JSON.stringify(value, null, Number(indent) || 2)\n  },\n  write: function (value) {\n    try {\n      return JSON.parse(value)\n    } catch (e) {\n      return value\n    }\n  }\n}\n\n/**\n * 'abc' => 'Abc'\n */\n\nexports.capitalize = function (value) {\n  if (!value && value !== 0) return ''\n  value = value.toString()\n  return value.charAt(0).toUpperCase() + value.slice(1)\n}\n\n/**\n * 'abc' => 'ABC'\n */\n\nexports.uppercase = function (value) {\n  return (value || value === 0)\n    ? value.toString().toUpperCase()\n    : ''\n}\n\n/**\n * 'AbC' => 'abc'\n */\n\nexports.lowercase = function (value) {\n  return (value || value === 0)\n    ? value.toString().toLowerCase()\n    : ''\n}\n\n/**\n * 12345 => $12,345.00\n *\n * @param {String} sign\n */\n\nvar digitsRE = /(\\d{3})(?=\\d)/g\nexports.currency = function (value, currency) {\n  value = parseFloat(value)\n  if (!isFinite(value) || (!value && value !== 0)) return ''\n  currency = currency != null ? currency : '$'\n  var stringified = Math.abs(value).toFixed(2)\n  var _int = stringified.slice(0, -3)\n  var i = _int.length % 3\n  var head = i > 0\n    ? (_int.slice(0, i) + (_int.length > 3 ? ',' : ''))\n    : ''\n  var _float = stringified.slice(-3)\n  var sign = value < 0 ? '-' : ''\n  return currency + sign + head +\n    _int.slice(i).replace(digitsRE, '$1,') +\n    _float\n}\n\n/**\n * 'item' => 'items'\n *\n * @params\n *  an array of strings corresponding to\n *  the single, double, triple ... forms of the word to\n *  be pluralized. When the number to be pluralized\n *  exceeds the length of the args, it will use the last\n *  entry in the array.\n *\n *  e.g. ['single', 'double', 'triple', 'multiple']\n */\n\nexports.pluralize = function (value) {\n  var args = _.toArray(arguments, 1)\n  return args.length > 1\n    ? (args[value % 10 - 1] || args[args.length - 1])\n    : (args[0] + (value === 1 ? '' : 's'))\n}\n\n/**\n * Debounce a handler function.\n *\n * @param {Function} handler\n * @param {Number} delay = 300\n * @return {Function}\n */\n\nexports.debounce = function (handler, delay) {\n  if (!handler) return\n  if (!delay) {\n    delay = 300\n  }\n  return _.debounce(handler, delay)\n}\n\n/**\n * Install special array filters\n */\n\n_.extend(exports, require('./array-filters'))\n\n},{\"../util\":99,\"./array-filters\":75}],77:[function(require,module,exports){\nvar _ = require('../util')\nvar compiler = require('../compiler')\nvar templateParser = require('../parsers/template')\nvar Fragment = require('./fragment')\nvar Cache = require('../cache')\nvar linkerCache = new Cache(5000)\n\n/**\n * A factory that can be used to create instances of a\n * fragment. Caches the compiled linker if possible.\n *\n * @param {Vue} vm\n * @param {Element|String} el\n */\n\nfunction FragmentFactory (vm, el) {\n  this.vm = vm\n  var template\n  var isString = typeof el === 'string'\n  if (isString || _.isTemplate(el)) {\n    template = templateParser.parse(el, true)\n  } else {\n    template = document.createDocumentFragment()\n    template.appendChild(el)\n  }\n  this.template = template\n  // linker can be cached, but only for components\n  var linker\n  var cid = vm.constructor.cid\n  if (cid > 0) {\n    var cacheId = cid + (isString ? el : el.outerHTML)\n    linker = linkerCache.get(cacheId)\n    if (!linker) {\n      linker = compiler.compile(template, vm.$options, true)\n      linkerCache.put(cacheId, linker)\n    }\n  } else {\n    linker = compiler.compile(template, vm.$options, true)\n  }\n  this.linker = linker\n}\n\n/**\n * Create a fragment instance with given host and scope.\n *\n * @param {Vue} host\n * @param {Object} scope\n * @param {Fragment} parentFrag\n */\n\nFragmentFactory.prototype.create = function (host, scope, parentFrag) {\n  var frag = templateParser.clone(this.template)\n  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag)\n}\n\nmodule.exports = FragmentFactory\n\n},{\"../cache\":43,\"../compiler\":46,\"../parsers/template\":90,\"../util\":99,\"./fragment\":78}],78:[function(require,module,exports){\nvar _ = require('../util')\nvar transition = require('../transition')\n\n/**\n * Abstraction for a partially-compiled fragment.\n * Can optionally compile content with a child scope.\n *\n * @param {Function} linker\n * @param {Vue} vm\n * @param {DocumentFragment} frag\n * @param {Vue} [host]\n * @param {Object} [scope]\n */\n\nfunction Fragment (linker, vm, frag, host, scope, parentFrag) {\n  this.children = []\n  this.childFrags = []\n  this.vm = vm\n  this.scope = scope\n  this.inserted = false\n  this.parentFrag = parentFrag\n  if (parentFrag) {\n    parentFrag.childFrags.push(this)\n  }\n  this.unlink = linker(vm, frag, host, scope, this)\n  var single = this.single = frag.childNodes.length === 1\n  if (single) {\n    this.node = frag.childNodes[0]\n    this.before = singleBefore\n    this.remove = singleRemove\n  } else {\n    this.node = _.createAnchor('fragment-start')\n    this.end = _.createAnchor('fragment-end')\n    this.frag = frag\n    _.prepend(this.node, frag)\n    frag.appendChild(this.end)\n    this.before = multiBefore\n    this.remove = multiRemove\n  }\n  this.node.__vfrag__ = this\n}\n\n/**\n * Call attach/detach for all components contained within\n * this fragment. Also do so recursively for all child\n * fragments.\n *\n * @param {Function} hook\n */\n\nFragment.prototype.callHook = function (hook) {\n  var i, l\n  for (i = 0, l = this.children.length; i < l; i++) {\n    hook(this.children[i])\n  }\n  for (i = 0, l = this.childFrags.length; i < l; i++) {\n    this.childFrags[i].callHook(hook)\n  }\n}\n\n/**\n * Destroy the fragment.\n */\n\nFragment.prototype.destroy = function () {\n  if (this.parentFrag) {\n    this.parentFrag.childFrags.$remove(this)\n  }\n  this.unlink()\n}\n\n/**\n * Insert fragment before target, single node version\n *\n * @param {Node} target\n * @param {Boolean} withTransition\n */\n\nfunction singleBefore (target, withTransition) {\n  this.inserted = true\n  var method = withTransition !== false\n    ? transition.before\n    : _.before\n  method(this.node, target, this.vm)\n  if (_.inDoc(this.node)) {\n    this.callHook(attach)\n  }\n}\n\n/**\n * Remove fragment, single node version\n *\n * @param {Boolean} [destroy]\n */\n\nfunction singleRemove (destroy) {\n  this.inserted = false\n  var shouldCallRemove = _.inDoc(this.node)\n  var self = this\n  transition.remove(this.node, this.vm, function () {\n    if (shouldCallRemove) {\n      self.callHook(detach)\n    }\n    if (destroy) {\n      self.destroy()\n    }\n  })\n}\n\n/**\n * Insert fragment before target, multi-nodes version\n *\n * @param {Node} target\n * @param {Boolean} withTransition\n */\n\nfunction multiBefore (target, withTransition) {\n  this.inserted = true\n  var vm = this.vm\n  var method = withTransition !== false\n    ? transition.before\n    : _.before\n  _.mapNodeRange(this.node, this.end, function (node) {\n    method(node, target, vm)\n  })\n  if (_.inDoc(this.node)) {\n    this.callHook(attach)\n  }\n}\n\n/**\n * Remove fragment, multi-nodes version\n *\n * @param {Boolean} [destroy]\n */\n\nfunction multiRemove (destroy) {\n  this.inserted = false\n  var self = this\n  var shouldCallRemove = _.inDoc(this.node)\n  _.removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\n    if (shouldCallRemove) {\n      self.callHook(detach)\n    }\n    if (destroy) {\n      self.destroy()\n    }\n  })\n}\n\n/**\n * Call attach hook for a Vue instance.\n *\n * @param {Vue} child\n */\n\nfunction attach (child) {\n  if (!child._isAttached) {\n    child._callHook('attached')\n  }\n}\n\n/**\n * Call detach hook for a Vue instance.\n *\n * @param {Vue} child\n */\n\nfunction detach (child) {\n  if (child._isAttached) {\n    child._callHook('detached')\n  }\n}\n\nmodule.exports = Fragment\n\n},{\"../transition\":92,\"../util\":99}],79:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar inDoc = _.inDoc\nvar eventRE = /^v-on:|^@/\n\n/**\n * Setup the instance's option events & watchers.\n * If the value is a string, we pull it from the\n * instance's methods by name.\n */\n\nexports._initEvents = function () {\n  var options = this.$options\n  if (options._asComponent) {\n    registerComponentEvents(this, options.el)\n  }\n  registerCallbacks(this, '$on', options.events)\n  registerCallbacks(this, '$watch', options.watch)\n}\n\n/**\n * Register v-on events on a child component\n *\n * @param {Vue} vm\n * @param {Element} el\n */\n\nfunction registerComponentEvents (vm, el) {\n  var attrs = el.attributes\n  var name, handler\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    name = attrs[i].name\n    if (eventRE.test(name)) {\n      name = name.replace(eventRE, '')\n      handler = (vm._scope || vm._context).$eval(attrs[i].value, true)\n      vm.$on(name.replace(eventRE), handler)\n    }\n  }\n}\n\n/**\n * Register callbacks for option events and watchers.\n *\n * @param {Vue} vm\n * @param {String} action\n * @param {Object} hash\n */\n\nfunction registerCallbacks (vm, action, hash) {\n  if (!hash) return\n  var handlers, key, i, j\n  for (key in hash) {\n    handlers = hash[key]\n    if (_.isArray(handlers)) {\n      for (i = 0, j = handlers.length; i < j; i++) {\n        register(vm, action, key, handlers[i])\n      }\n    } else {\n      register(vm, action, key, handlers)\n    }\n  }\n}\n\n/**\n * Helper to register an event/watch callback.\n *\n * @param {Vue} vm\n * @param {String} action\n * @param {String} key\n * @param {Function|String|Object} handler\n * @param {Object} [options]\n */\n\nfunction register (vm, action, key, handler, options) {\n  var type = typeof handler\n  if (type === 'function') {\n    vm[action](key, handler, options)\n  } else if (type === 'string') {\n    var methods = vm.$options.methods\n    var method = methods && methods[handler]\n    if (method) {\n      vm[action](key, method, options)\n    } else {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Unknown method: \"' + handler + '\" when ' +\n        'registering callback for ' + action +\n        ': \"' + key + '\".'\n      )\n    }\n  } else if (handler && type === 'object') {\n    register(vm, action, key, handler.handler, handler)\n  }\n}\n\n/**\n * Setup recursive attached/detached calls\n */\n\nexports._initDOMHooks = function () {\n  this.$on('hook:attached', onAttached)\n  this.$on('hook:detached', onDetached)\n}\n\n/**\n * Callback to recursively call attached hook on children\n */\n\nfunction onAttached () {\n  if (!this._isAttached) {\n    this._isAttached = true\n    this.$children.forEach(callAttach)\n  }\n}\n\n/**\n * Iterator to call attached hook\n *\n * @param {Vue} child\n */\n\nfunction callAttach (child) {\n  if (!child._isAttached && inDoc(child.$el)) {\n    child._callHook('attached')\n  }\n}\n\n/**\n * Callback to recursively call detached hook on children\n */\n\nfunction onDetached () {\n  if (this._isAttached) {\n    this._isAttached = false\n    this.$children.forEach(callDetach)\n  }\n}\n\n/**\n * Iterator to call detached hook\n *\n * @param {Vue} child\n */\n\nfunction callDetach (child) {\n  if (child._isAttached && !inDoc(child.$el)) {\n    child._callHook('detached')\n  }\n}\n\n/**\n * Trigger all handlers for a hook\n *\n * @param {String} hook\n */\n\nexports._callHook = function (hook) {\n  var handlers = this.$options[hook]\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      handlers[i].call(this)\n    }\n  }\n  this.$emit('hook:' + hook)\n}\n\n}).call(this,require('_process'))\n\n},{\"../util\":99,\"_process\":1}],80:[function(require,module,exports){\nvar mergeOptions = require('../util').mergeOptions\nvar uid = 0\n\n/**\n * The main init sequence. This is called for every\n * instance, including ones that are created from extended\n * constructors.\n *\n * @param {Object} options - this options object should be\n *                           the result of merging class\n *                           options and the options passed\n *                           in to the constructor.\n */\n\nexports._init = function (options) {\n\n  options = options || {}\n\n  this.$el = null\n  this.$parent = options.parent\n  this.$root = this.$parent\n    ? this.$parent.$root\n    : this\n  this.$children = []\n  this.$refs = {}       // child vm references\n  this.$els = {}        // element references\n  this._watchers = []   // all watchers as an array\n  this._directives = [] // all directives\n\n  // a uid\n  this._uid = uid++\n\n  // a flag to avoid this being observed\n  this._isVue = true\n\n  // events bookkeeping\n  this._events = {}            // registered callbacks\n  this._eventsCount = {}       // for $broadcast optimization\n  this._shouldPropagate = false // for event propagation\n\n  // fragment instance properties\n  this._isFragment = false\n  this._fragment =         // @type {DocumentFragment}\n  this._fragmentStart =    // @type {Text|Comment}\n  this._fragmentEnd = null // @type {Text|Comment}\n\n  // lifecycle state\n  this._isCompiled =\n  this._isDestroyed =\n  this._isReady =\n  this._isAttached =\n  this._isBeingDestroyed = false\n  this._unlinkFn = null\n\n  // context:\n  // if this is a transcluded component, context\n  // will be the common parent vm of this instance\n  // and its host.\n  this._context = options._context || this.$parent\n\n  // scope:\n  // if this is inside an inline v-for, the scope\n  // will be the intermediate scope created for this\n  // repeat fragment. this is used for linking props\n  // and container directives.\n  this._scope = options._scope\n\n  // fragment:\n  // if this instance is compiled inside a Fragment, it\n  // needs to reigster itself as a child of that fragment\n  // for attach/detach to work properly.\n  this._frag = options._frag\n  if (this._frag) {\n    this._frag.children.push(this)\n  }\n\n  // push self into parent / transclusion host\n  if (this.$parent) {\n    this.$parent.$children.push(this)\n  }\n\n  // set ref\n  if (options._ref) {\n    (this._scope || this._context).$refs[options._ref] = this\n  }\n\n  // merge options.\n  options = this.$options = mergeOptions(\n    this.constructor.options,\n    options,\n    this\n  )\n\n  // initialize data as empty object.\n  // it will be filled up in _initScope().\n  this._data = {}\n\n  // call init hook\n  this._callHook('init')\n\n  // initialize data observation and scope inheritance.\n  this._initState()\n\n  // setup event system and option events.\n  this._initEvents()\n\n  // call created hook\n  this._callHook('created')\n\n  // if `el` option is passed, start compilation.\n  if (options.el) {\n    this.$mount(options.el)\n  }\n}\n\n},{\"../util\":99}],81:[function(require,module,exports){\nvar _ = require('../util')\nvar Directive = require('../directive')\nvar compiler = require('../compiler')\n\n/**\n * Transclude, compile and link element.\n *\n * If a pre-compiled linker is available, that means the\n * passed in element will be pre-transcluded and compiled\n * as well - all we need to do is to call the linker.\n *\n * Otherwise we need to call transclude/compile/link here.\n *\n * @param {Element} el\n * @return {Element}\n */\n\nexports._compile = function (el) {\n  var options = this.$options\n\n  // transclude and init element\n  // transclude can potentially replace original\n  // so we need to keep reference; this step also injects\n  // the template and caches the original attributes\n  // on the container node and replacer node.\n  var original = el\n  el = compiler.transclude(el, options)\n  this._initElement(el)\n\n  // root is always compiled per-instance, because\n  // container attrs and props can be different every time.\n  var contextOptions = this._context && this._context.$options\n  var rootLinker = compiler.compileRoot(el, options, contextOptions)\n\n  // compile and link the rest\n  var contentLinkFn\n  var ctor = this.constructor\n  // component compilation can be cached\n  // as long as it's not using inline-template\n  if (options._linkerCachable) {\n    contentLinkFn = ctor.linker\n    if (!contentLinkFn) {\n      contentLinkFn = ctor.linker = compiler.compile(el, options)\n    }\n  }\n\n  // link phase\n  // make sure to link root with prop scope!\n  var rootUnlinkFn = rootLinker(this, el, this._scope)\n  var contentUnlinkFn = contentLinkFn\n    ? contentLinkFn(this, el)\n    : compiler.compile(el, options)(this, el)\n\n  // register composite unlink function\n  // to be called during instance destruction\n  this._unlinkFn = function () {\n    rootUnlinkFn()\n    // passing destroying: true to avoid searching and\n    // splicing the directives\n    contentUnlinkFn(true)\n  }\n\n  // finally replace original\n  if (options.replace) {\n    _.replace(original, el)\n  }\n\n  this._isCompiled = true\n  this._callHook('compiled')\n  return el\n}\n\n/**\n * Initialize instance element. Called in the public\n * $mount() method.\n *\n * @param {Element} el\n */\n\nexports._initElement = function (el) {\n  if (el instanceof DocumentFragment) {\n    this._isFragment = true\n    this.$el = this._fragmentStart = el.firstChild\n    this._fragmentEnd = el.lastChild\n    // set persisted text anchors to empty\n    if (this._fragmentStart.nodeType === 3) {\n      this._fragmentStart.data = this._fragmentEnd.data = ''\n    }\n    this._fragment = el\n  } else {\n    this.$el = el\n  }\n  this.$el.__vue__ = this\n  this._callHook('beforeCompile')\n}\n\n/**\n * Create and bind a directive to an element.\n *\n * @param {String} name - directive name\n * @param {Node} node   - target node\n * @param {Object} desc - parsed directive descriptor\n * @param {Object} def  - directive definition object\n * @param {Vue} [host] - transclusion host component\n * @param {Object} [scope] - v-for scope\n * @param {Fragment} [frag] - owner fragment\n */\n\nexports._bindDir = function (descriptor, node, host, scope, frag) {\n  this._directives.push(\n    new Directive(descriptor, this, node, host, scope, frag)\n  )\n}\n\n/**\n * Teardown an instance, unobserves the data, unbind all the\n * directives, turn off all the event listeners, etc.\n *\n * @param {Boolean} remove - whether to remove the DOM node.\n * @param {Boolean} deferCleanup - if true, defer cleanup to\n *                                 be called later\n */\n\nexports._destroy = function (remove, deferCleanup) {\n  if (this._isBeingDestroyed) {\n    return\n  }\n  this._callHook('beforeDestroy')\n  this._isBeingDestroyed = true\n  var i\n  // remove self from parent. only necessary\n  // if parent is not being destroyed as well.\n  var parent = this.$parent\n  if (parent && !parent._isBeingDestroyed) {\n    parent.$children.$remove(this)\n    // unregister ref\n    var ref = this.$options._ref\n    if (ref) {\n      var scope = this._scope || this._context\n      if (scope.$refs[ref] === this) {\n        scope.$refs[ref] = null\n      }\n    }\n  }\n  // remove self from owner fragment\n  if (this._frag) {\n    this._frag.children.$remove(this)\n  }\n  // destroy all children.\n  i = this.$children.length\n  while (i--) {\n    this.$children[i].$destroy()\n  }\n  // teardown props\n  if (this._propsUnlinkFn) {\n    this._propsUnlinkFn()\n  }\n  // teardown all directives. this also tearsdown all\n  // directive-owned watchers.\n  if (this._unlinkFn) {\n    this._unlinkFn()\n  }\n  i = this._watchers.length\n  while (i--) {\n    this._watchers[i].teardown()\n  }\n  // remove reference to self on $el\n  if (this.$el) {\n    this.$el.__vue__ = null\n  }\n  // remove DOM element\n  var self = this\n  if (remove && this.$el) {\n    this.$remove(function () {\n      self._cleanup()\n    })\n  } else if (!deferCleanup) {\n    this._cleanup()\n  }\n}\n\n/**\n * Clean up to ensure garbage collection.\n * This is called after the leave transition if there\n * is any.\n */\n\nexports._cleanup = function () {\n  // remove reference from data ob\n  // frozen object may not have observer.\n  if (this._data.__ob__) {\n    this._data.__ob__.removeVm(this)\n  }\n  // Clean up references to private properties and other\n  // instances. preserve reference to _data so that proxy\n  // accessors still work. The only potential side effect\n  // here is that mutating the instance after it's destroyed\n  // may affect the state of other components that are still\n  // observing the same object, but that seems to be a\n  // reasonable responsibility for the user rather than\n  // always throwing an error on them.\n  this.$el =\n  this.$parent =\n  this.$root =\n  this.$children =\n  this._watchers =\n  this._context =\n  this._scope =\n  this._directives = null\n  // call the last hook...\n  this._isDestroyed = true\n  this._callHook('destroyed')\n  // turn off all instance listeners.\n  this.$off()\n}\n\n},{\"../compiler\":46,\"../directive\":49,\"../util\":99}],82:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\n\n/**\n * Apply a list of filter (descriptors) to a value.\n * Using plain for loops here because this will be called in\n * the getter of any watcher with filters so it is very\n * performance sensitive.\n *\n * @param {*} value\n * @param {*} [oldValue]\n * @param {Array} filters\n * @param {Boolean} write\n * @return {*}\n */\n\nexports._applyFilters = function (value, oldValue, filters, write) {\n  var filter, fn, args, arg, offset, i, l, j, k\n  for (i = 0, l = filters.length; i < l; i++) {\n    filter = filters[i]\n    fn = _.resolveAsset(this.$options, 'filters', filter.name)\n    if (process.env.NODE_ENV !== 'production') {\n      _.assertAsset(fn, 'filter', filter.name)\n    }\n    if (!fn) continue\n    fn = write ? fn.write : (fn.read || fn)\n    if (typeof fn !== 'function') continue\n    args = write ? [value, oldValue] : [value]\n    offset = write ? 2 : 1\n    if (filter.args) {\n      for (j = 0, k = filter.args.length; j < k; j++) {\n        arg = filter.args[j]\n        args[j + offset] = arg.dynamic\n          ? this.$get(arg.value)\n          : arg.value\n      }\n    }\n    value = fn.apply(this, args)\n  }\n  return value\n}\n\n/**\n * Resolve a component, depending on whether the component\n * is defined normally or using an async factory function.\n * Resolves synchronously if already resolved, otherwise\n * resolves asynchronously and caches the resolved\n * constructor on the factory.\n *\n * @param {String} id\n * @param {Function} cb\n */\n\nexports._resolveComponent = function (id, cb) {\n  var factory = _.resolveAsset(this.$options, 'components', id)\n  if (process.env.NODE_ENV !== 'production') {\n    _.assertAsset(factory, 'component', id)\n  }\n  if (!factory) {\n    return\n  }\n  // async component factory\n  if (!factory.options) {\n    if (factory.resolved) {\n      // cached\n      cb(factory.resolved)\n    } else if (factory.requested) {\n      // pool callbacks\n      factory.pendingCallbacks.push(cb)\n    } else {\n      factory.requested = true\n      var cbs = factory.pendingCallbacks = [cb]\n      factory(function resolve (res) {\n        if (_.isPlainObject(res)) {\n          res = _.Vue.extend(res)\n        }\n        // cache resolved\n        factory.resolved = res\n        // invoke callbacks\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res)\n        }\n      }, function reject (reason) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'Failed to resolve async component: ' + id + '. ' +\n          (reason ? '\\nReason: ' + reason : '')\n        )\n      })\n    }\n  } else {\n    // normal component\n    cb(factory)\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../util\":99,\"_process\":1}],83:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar compiler = require('../compiler')\nvar Observer = require('../observer')\nvar Dep = require('../observer/dep')\nvar Watcher = require('../watcher')\n\n/**\n * Setup the scope of an instance, which contains:\n * - observed data\n * - computed properties\n * - user methods\n * - meta properties\n */\n\nexports._initState = function () {\n  this._initProps()\n  this._initMeta()\n  this._initMethods()\n  this._initData()\n  this._initComputed()\n}\n\n/**\n * Initialize props.\n */\n\nexports._initProps = function () {\n  var options = this.$options\n  var el = options.el\n  var props = options.props\n  if (props && !el) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Props will not be compiled if no `el` option is ' +\n      'provided at instantiation.'\n    )\n  }\n  // make sure to convert string selectors into element now\n  el = options.el = _.query(el)\n  this._propsUnlinkFn = el && el.nodeType === 1 && props\n    // props must be linked in proper scope if inside v-for\n    ? compiler.compileAndLinkProps(this, el, props, this._scope)\n    : null\n}\n\n/**\n * Initialize the data.\n */\n\nexports._initData = function () {\n  var propsData = this._data\n  var optionsDataFn = this.$options.data\n  var optionsData = optionsDataFn && optionsDataFn()\n  if (optionsData) {\n    this._data = optionsData\n    for (var prop in propsData) {\n      if (process.env.NODE_ENV !== 'production' &&\n          optionsData.hasOwnProperty(prop)) {\n        _.warn(\n          'Data field \"' + prop + '\" is already defined ' +\n          'as a prop. Use prop default value instead.'\n        )\n      }\n      if (this._props[prop].raw !== null ||\n          !optionsData.hasOwnProperty(prop)) {\n        _.set(optionsData, prop, propsData[prop])\n      }\n    }\n  }\n  var data = this._data\n  // proxy data on instance\n  var keys = Object.keys(data)\n  var i, key\n  i = keys.length\n  while (i--) {\n    key = keys[i]\n    this._proxy(key)\n  }\n  // observe data\n  Observer.create(data, this)\n}\n\n/**\n * Swap the isntance's $data. Called in $data's setter.\n *\n * @param {Object} newData\n */\n\nexports._setData = function (newData) {\n  newData = newData || {}\n  var oldData = this._data\n  this._data = newData\n  var keys, key, i\n  // unproxy keys not present in new data\n  keys = Object.keys(oldData)\n  i = keys.length\n  while (i--) {\n    key = keys[i]\n    if (!(key in newData)) {\n      this._unproxy(key)\n    }\n  }\n  // proxy keys not already proxied,\n  // and trigger change for changed values\n  keys = Object.keys(newData)\n  i = keys.length\n  while (i--) {\n    key = keys[i]\n    if (!this.hasOwnProperty(key)) {\n      // new property\n      this._proxy(key)\n    }\n  }\n  oldData.__ob__.removeVm(this)\n  Observer.create(newData, this)\n  this._digest()\n}\n\n/**\n * Proxy a property, so that\n * vm.prop === vm._data.prop\n *\n * @param {String} key\n */\n\nexports._proxy = function (key) {\n  if (!_.isReserved(key)) {\n    // need to store ref to self here\n    // because these getter/setters might\n    // be called by child scopes via\n    // prototype inheritance.\n    var self = this\n    Object.defineProperty(self, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return self._data[key]\n      },\n      set: function proxySetter (val) {\n        self._data[key] = val\n      }\n    })\n  }\n}\n\n/**\n * Unproxy a property.\n *\n * @param {String} key\n */\n\nexports._unproxy = function (key) {\n  if (!_.isReserved(key)) {\n    delete this[key]\n  }\n}\n\n/**\n * Force update on every watcher in scope.\n */\n\nexports._digest = function () {\n  for (var i = 0, l = this._watchers.length; i < l; i++) {\n    this._watchers[i].update(true) // shallow updates\n  }\n}\n\n/**\n * Setup computed properties. They are essentially\n * special getter/setters\n */\n\nfunction noop () {}\nexports._initComputed = function () {\n  var computed = this.$options.computed\n  if (computed) {\n    for (var key in computed) {\n      var userDef = computed[key]\n      var def = {\n        enumerable: true,\n        configurable: true\n      }\n      if (typeof userDef === 'function') {\n        def.get = makeComputedGetter(userDef, this)\n        def.set = noop\n      } else {\n        def.get = userDef.get\n          ? userDef.cache !== false\n            ? makeComputedGetter(userDef.get, this)\n            : _.bind(userDef.get, this)\n          : noop\n        def.set = userDef.set\n          ? _.bind(userDef.set, this)\n          : noop\n      }\n      Object.defineProperty(this, key, def)\n    }\n  }\n}\n\nfunction makeComputedGetter (getter, owner) {\n  var watcher = new Watcher(owner, getter, null, {\n    lazy: true\n  })\n  return function computedGetter () {\n    if (watcher.dirty) {\n      watcher.evaluate()\n    }\n    if (Dep.target) {\n      watcher.depend()\n    }\n    return watcher.value\n  }\n}\n\n/**\n * Setup instance methods. Methods must be bound to the\n * instance since they might be passed down as a prop to\n * child components.\n */\n\nexports._initMethods = function () {\n  var methods = this.$options.methods\n  if (methods) {\n    for (var key in methods) {\n      this[key] = _.bind(methods[key], this)\n    }\n  }\n}\n\n/**\n * Initialize meta information like $index, $key & $value.\n */\n\nexports._initMeta = function () {\n  var metas = this.$options._meta\n  if (metas) {\n    for (var key in metas) {\n      _.defineReactive(this, key, metas[key])\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../compiler\":46,\"../observer\":86,\"../observer/dep\":85,\"../util\":99,\"../watcher\":103,\"_process\":1}],84:[function(require,module,exports){\nvar _ = require('../util')\nvar arrayProto = Array.prototype\nvar arrayMethods = Object.create(arrayProto)\n\n/**\n * Intercept mutating methods and emit events\n */\n\n;[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method]\n  _.define(arrayMethods, method, function mutator () {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length\n    var args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i]\n    }\n    var result = original.apply(this, args)\n    var ob = this.__ob__\n    var inserted\n    switch (method) {\n      case 'push':\n        inserted = args\n        break\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n\n/**\n * Swap the element at the given index with a new value\n * and emits corresponding event.\n *\n * @param {Number} index\n * @param {*} val\n * @return {*} - replaced element\n */\n\n_.define(\n  arrayProto,\n  '$set',\n  function $set (index, val) {\n    if (index >= this.length) {\n      this.length = index + 1\n    }\n    return this.splice(index, 1, val)[0]\n  }\n)\n\n/**\n * Convenience method to remove the element at given index.\n *\n * @param {Number} index\n * @param {*} val\n */\n\n_.define(\n  arrayProto,\n  '$remove',\n  function $remove (item) {\n    /* istanbul ignore if */\n    if (!this.length) return\n    var index = _.indexOf(this, item)\n    if (index > -1) {\n      return this.splice(index, 1)\n    }\n  }\n)\n\nmodule.exports = arrayMethods\n\n},{\"../util\":99}],85:[function(require,module,exports){\nvar _ = require('../util')\nvar uid = 0\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\n * @constructor\n */\n\nfunction Dep () {\n  this.id = uid++\n  this.subs = []\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\n\n/**\n * Add a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.addSub = function (sub) {\n  this.subs.push(sub)\n}\n\n/**\n * Remove a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.removeSub = function (sub) {\n  this.subs.$remove(sub)\n}\n\n/**\n * Add self as a dependency to the target watcher.\n */\n\nDep.prototype.depend = function () {\n  Dep.target.addDep(this)\n}\n\n/**\n * Notify all subscribers of a new value.\n */\n\nDep.prototype.notify = function () {\n  // stablize the subscriber list first\n  var subs = _.toArray(this.subs)\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update()\n  }\n}\n\nmodule.exports = Dep\n\n},{\"../util\":99}],86:[function(require,module,exports){\nvar _ = require('../util')\nvar Dep = require('./dep')\nvar arrayMethods = require('./array')\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods)\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @param {Array|Object} value\n * @constructor\n */\n\nfunction Observer (value) {\n  this.value = value\n  this.dep = new Dep()\n  _.define(value, '__ob__', this)\n  if (_.isArray(value)) {\n    var augment = _.hasProto\n      ? protoAugment\n      : copyAugment\n    augment(value, arrayMethods, arrayKeys)\n    this.observeArray(value)\n  } else {\n    this.walk(value)\n  }\n}\n\n// Static methods\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @param {Vue} [vm]\n * @return {Observer|undefined}\n * @static\n */\n\nObserver.create = function (value, vm) {\n  if (!value || typeof value !== 'object') {\n    return\n  }\n  var ob\n  if (\n    value.hasOwnProperty('__ob__') &&\n    value.__ob__ instanceof Observer\n  ) {\n    ob = value.__ob__\n  } else if (\n    (_.isArray(value) || _.isPlainObject(value)) &&\n    !Object.isFrozen(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (ob && vm) {\n    ob.addVm(vm)\n  }\n  return ob\n}\n\n// Instance methods\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n *\n * @param {Object} obj\n */\n\nObserver.prototype.walk = function (obj) {\n  var keys = Object.keys(obj)\n  var i = keys.length\n  while (i--) {\n    this.convert(keys[i], obj[keys[i]])\n  }\n}\n\n/**\n * Observe a list of Array items.\n *\n * @param {Array} items\n */\n\nObserver.prototype.observeArray = function (items) {\n  var i = items.length\n  while (i--) {\n    Observer.create(items[i])\n  }\n}\n\n/**\n * Convert a property into getter/setter so we can emit\n * the events when the property is accessed/changed.\n *\n * @param {String} key\n * @param {*} val\n */\n\nObserver.prototype.convert = function (key, val) {\n  defineReactive(this.value, key, val)\n}\n\n/**\n * Add an owner vm, so that when $set/$delete mutations\n * happen we can notify owner vms to proxy the keys and\n * digest the watchers. This is only called when the object\n * is observed as an instance's root $data.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.addVm = function (vm) {\n  (this.vms || (this.vms = [])).push(vm)\n}\n\n/**\n * Remove an owner vm. This is called when the object is\n * swapped out as an instance's $data object.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.removeVm = function (vm) {\n  this.vms.$remove(vm)\n}\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n *\n * @param {Object|Array} target\n * @param {Object} proto\n */\n\nfunction protoAugment (target, src) {\n  target.__proto__ = src\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n *\n * @param {Object|Array} target\n * @param {Object} proto\n */\n\nfunction copyAugment (target, src, keys) {\n  var i = keys.length\n  var key\n  while (i--) {\n    key = keys[i]\n    _.define(target, key, src[key])\n  }\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n */\n\nfunction defineReactive (obj, key, val) {\n  var dep = new Dep()\n  var childOb = Observer.create(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function metaGetter () {\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n        }\n        if (_.isArray(val)) {\n          for (var e, i = 0, l = val.length; i < l; i++) {\n            e = val[i]\n            e && e.__ob__ && e.__ob__.dep.depend()\n          }\n        }\n      }\n      return val\n    },\n    set: function metaSetter (newVal) {\n      if (newVal === val) return\n      val = newVal\n      childOb = Observer.create(newVal)\n      dep.notify()\n    }\n  })\n}\n\n// Attach to the util object so it can be used elsewhere.\n_.defineReactive = defineReactive\n\nmodule.exports = Observer\n\n},{\"../util\":99,\"./array\":84,\"./dep\":85}],87:[function(require,module,exports){\nvar _ = require('../util')\nvar Cache = require('../cache')\nvar cache = new Cache(1000)\nvar filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g\nvar reservedArgRE = /^in$|^-?\\d+/\n\n/**\n * Parser state\n */\n\nvar str, dir\nvar c, i, l, lastFilterIndex\nvar inSingle, inDouble, curly, square, paren\n\n/**\n * Push a filter to the current directive object\n */\n\nfunction pushFilter () {\n  var exp = str.slice(lastFilterIndex, i).trim()\n  var filter\n  if (exp) {\n    filter = {}\n    var tokens = exp.match(filterTokenRE)\n    filter.name = tokens[0]\n    if (tokens.length > 1) {\n      filter.args = tokens.slice(1).map(processFilterArg)\n    }\n  }\n  if (filter) {\n    (dir.filters = dir.filters || []).push(filter)\n  }\n  lastFilterIndex = i + 1\n}\n\n/**\n * Check if an argument is dynamic and strip quotes.\n *\n * @param {String} arg\n * @return {Object}\n */\n\nfunction processFilterArg (arg) {\n  if (reservedArgRE.test(arg)) {\n    return {\n      value: _.toNumber(arg),\n      dynamic: false\n    }\n  } else {\n    var stripped = _.stripQuotes(arg)\n    var dynamic = stripped === arg\n    return {\n      value: dynamic ? arg : stripped,\n      dynamic: dynamic\n    }\n  }\n}\n\n/**\n * Parse a directive value and extract the expression\n * and its filters into a descriptor.\n *\n * Example:\n *\n * \"a + 1 | uppercase\" will yield:\n * {\n *   expression: 'a + 1',\n *   filters: [\n *     { name: 'uppercase', args: null }\n *   ]\n * }\n *\n * @param {String} str\n * @return {Object}\n */\n\nexports.parse = function (s) {\n\n  var hit = cache.get(s)\n  if (hit) {\n    return hit\n  }\n\n  // reset parser state\n  str = s\n  inSingle = inDouble = false\n  curly = square = paren = 0\n  lastFilterIndex = 0\n  dir = {}\n\n  for (i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i)\n    if (inSingle) {\n      // check single quote\n      if (c === 0x27) inSingle = !inSingle\n    } else if (inDouble) {\n      // check double quote\n      if (c === 0x22) inDouble = !inDouble\n    } else if (\n      c === 0x7C && // pipe\n      str.charCodeAt(i + 1) !== 0x7C &&\n      str.charCodeAt(i - 1) !== 0x7C\n    ) {\n      if (dir.expression == null) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1\n        dir.expression = str.slice(0, i).trim()\n      } else {\n        // already has filter\n        pushFilter()\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break // \"\n        case 0x27: inSingle = true; break // '\n        case 0x28: paren++; break         // (\n        case 0x29: paren--; break         // )\n        case 0x5B: square++; break        // [\n        case 0x5D: square--; break        // ]\n        case 0x7B: curly++; break         // {\n        case 0x7D: curly--; break         // }\n      }\n    }\n  }\n\n  if (dir.expression == null) {\n    dir.expression = str.slice(0, i).trim()\n  } else if (lastFilterIndex !== 0) {\n    pushFilter()\n  }\n\n  cache.put(s, dir)\n  return dir\n}\n\n},{\"../cache\":43,\"../util\":99}],88:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar Path = require('./path')\nvar Cache = require('../cache')\nvar expressionCache = new Cache(1000)\n\nvar allowedKeywords =\n  'Math,Date,this,true,false,null,undefined,Infinity,NaN,' +\n  'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' +\n  'encodeURIComponent,parseInt,parseFloat'\nvar allowedKeywordsRE =\n  new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)')\n\n// keywords that don't make sense inside expressions\nvar improperKeywords =\n  'break,case,class,catch,const,continue,debugger,default,' +\n  'delete,do,else,export,extends,finally,for,function,if,' +\n  'import,in,instanceof,let,return,super,switch,throw,try,' +\n  'var,while,with,yield,enum,await,implements,package,' +\n  'proctected,static,interface,private,public'\nvar improperKeywordsRE =\n  new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)')\n\nvar wsRE = /\\s/g\nvar newlineRE = /\\n/g\nvar saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('[^']*'|\"[^\"]*\")|new |typeof |void /g\nvar restoreRE = /\"(\\d+)\"/g\nvar pathTestRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/\nvar pathReplaceRE = /[^\\w$\\.]([A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\])*)/g\nvar booleanLiteralRE = /^(true|false)$/\n\n/**\n * Save / Rewrite / Restore\n *\n * When rewriting paths found in an expression, it is\n * possible for the same letter sequences to be found in\n * strings and Object literal property keys. Therefore we\n * remove and store these parts in a temporary array, and\n * restore them after the path rewrite.\n */\n\nvar saved = []\n\n/**\n * Save replacer\n *\n * The save regex can match two possible cases:\n * 1. An opening object literal\n * 2. A string\n * If matched as a plain string, we need to escape its\n * newlines, since the string needs to be preserved when\n * generating the function body.\n *\n * @param {String} str\n * @param {String} isString - str if matched as a string\n * @return {String} - placeholder with index\n */\n\nfunction save (str, isString) {\n  var i = saved.length\n  saved[i] = isString\n    ? str.replace(newlineRE, '\\\\n')\n    : str\n  return '\"' + i + '\"'\n}\n\n/**\n * Path rewrite replacer\n *\n * @param {String} raw\n * @return {String}\n */\n\nfunction rewrite (raw) {\n  var c = raw.charAt(0)\n  var path = raw.slice(1)\n  if (allowedKeywordsRE.test(path)) {\n    return raw\n  } else {\n    path = path.indexOf('\"') > -1\n      ? path.replace(restoreRE, restore)\n      : path\n    return c + 'scope.' + path\n  }\n}\n\n/**\n * Restore replacer\n *\n * @param {String} str\n * @param {String} i - matched save index\n * @return {String}\n */\n\nfunction restore (str, i) {\n  return saved[i]\n}\n\n/**\n * Rewrite an expression, prefixing all path accessors with\n * `scope.` and generate getter/setter functions.\n *\n * @param {String} exp\n * @param {Boolean} needSet\n * @return {Function}\n */\n\nfunction compileExpFns (exp, needSet) {\n  if (improperKeywordsRE.test(exp)) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Avoid using reserved keywords in expression: ' + exp\n    )\n  }\n  // reset state\n  saved.length = 0\n  // save strings and object literal keys\n  var body = exp\n    .replace(saveRE, save)\n    .replace(wsRE, '')\n  // rewrite all paths\n  // pad 1 space here becaue the regex matches 1 extra char\n  body = (' ' + body)\n    .replace(pathReplaceRE, rewrite)\n    .replace(restoreRE, restore)\n  var getter = makeGetter(body)\n  if (getter) {\n    return {\n      get: getter,\n      body: body,\n      set: needSet\n        ? makeSetter(body)\n        : null\n    }\n  }\n}\n\n/**\n * Compile getter setters for a simple path.\n *\n * @param {String} exp\n * @return {Function}\n */\n\nfunction compilePathFns (exp) {\n  var getter, path\n  if (exp.indexOf('[') < 0) {\n    // really simple path\n    path = exp.split('.')\n    path.raw = exp\n    getter = Path.compileGetter(path)\n  } else {\n    // do the real parsing\n    path = Path.parse(exp)\n    getter = path.get\n  }\n  return {\n    get: getter,\n    // always generate setter for simple paths\n    set: function (obj, val) {\n      Path.set(obj, path, val)\n    }\n  }\n}\n\n/**\n * Build a getter function. Requires eval.\n *\n * We isolate the try/catch so it doesn't affect the\n * optimization of the parse function when it is not called.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeGetter (body) {\n  try {\n    return new Function('scope', 'return ' + body + ';')\n  } catch (e) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Invalid expression. ' +\n      'Generated function body: ' + body\n    )\n  }\n}\n\n/**\n * Build a setter function.\n *\n * This is only needed in rare situations like \"a[b]\" where\n * a settable path requires dynamic evaluation.\n *\n * This setter function may throw error when called if the\n * expression body is not a valid left-hand expression in\n * assignment.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeSetter (body) {\n  try {\n    return new Function('scope', 'value', body + '=value;')\n  } catch (e) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Invalid setter function body: ' + body\n    )\n  }\n}\n\n/**\n * Check for setter existence on a cache hit.\n *\n * @param {Function} hit\n */\n\nfunction checkSetter (hit) {\n  if (!hit.set) {\n    hit.set = makeSetter(hit.body)\n  }\n}\n\n/**\n * Parse an expression into re-written getter/setters.\n *\n * @param {String} exp\n * @param {Boolean} needSet\n * @return {Function}\n */\n\nexports.parse = function (exp, needSet) {\n  exp = exp.trim()\n  // try cache\n  var hit = expressionCache.get(exp)\n  if (hit) {\n    if (needSet) {\n      checkSetter(hit)\n    }\n    return hit\n  }\n  // we do a simple path check to optimize for them.\n  // the check fails valid paths with unusal whitespaces,\n  // but that's too rare and we don't care.\n  // also skip boolean literals and paths that start with\n  // global \"Math\"\n  var res = exports.isSimplePath(exp)\n    ? compilePathFns(exp)\n    : compileExpFns(exp, needSet)\n  expressionCache.put(exp, res)\n  return res\n}\n\n/**\n * Check if an expression is a simple path.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nexports.isSimplePath = function (exp) {\n  return pathTestRE.test(exp) &&\n    // don't treat true/false as paths\n    !booleanLiteralRE.test(exp) &&\n    // Math constants e.g. Math.PI, Math.E etc.\n    exp.slice(0, 5) !== 'Math.'\n}\n\n}).call(this,require('_process'))\n\n},{\"../cache\":43,\"../util\":99,\"./path\":89,\"_process\":1}],89:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar Cache = require('../cache')\nvar pathCache = new Cache(1000)\nvar identRE = exports.identRE = /^[$_a-zA-Z]+[\\w$]*$/\n\n// actions\nvar APPEND = 0\nvar PUSH = 1\n\n// states\nvar BEFORE_PATH = 0\nvar IN_PATH = 1\nvar BEFORE_IDENT = 2\nvar IN_IDENT = 3\nvar BEFORE_ELEMENT = 4\nvar AFTER_ZERO = 5\nvar IN_INDEX = 6\nvar IN_SINGLE_QUOTE = 7\nvar IN_DOUBLE_QUOTE = 8\nvar IN_SUB_PATH = 9\nvar AFTER_ELEMENT = 10\nvar AFTER_PATH = 11\nvar ERROR = 12\n\nvar pathStateMachine = []\n\npathStateMachine[BEFORE_PATH] = {\n  'ws': [BEFORE_PATH],\n  'ident': [IN_IDENT, APPEND],\n  '[': [BEFORE_ELEMENT],\n  'eof': [AFTER_PATH]\n}\n\npathStateMachine[IN_PATH] = {\n  'ws': [IN_PATH],\n  '.': [BEFORE_IDENT],\n  '[': [BEFORE_ELEMENT],\n  'eof': [AFTER_PATH]\n}\n\npathStateMachine[BEFORE_IDENT] = {\n  'ws': [BEFORE_IDENT],\n  'ident': [IN_IDENT, APPEND]\n}\n\npathStateMachine[IN_IDENT] = {\n  'ident': [IN_IDENT, APPEND],\n  '0': [IN_IDENT, APPEND],\n  'number': [IN_IDENT, APPEND],\n  'ws': [IN_PATH, PUSH],\n  '.': [BEFORE_IDENT, PUSH],\n  '[': [BEFORE_ELEMENT, PUSH],\n  'eof': [AFTER_PATH, PUSH]\n}\n\npathStateMachine[BEFORE_ELEMENT] = {\n  'ws': [BEFORE_ELEMENT],\n  '0': [AFTER_ZERO, APPEND],\n  'number': [IN_INDEX, APPEND],\n  \"'\": [IN_SINGLE_QUOTE, APPEND, ''],\n  '\"': [IN_DOUBLE_QUOTE, APPEND, ''],\n  'ident': [IN_SUB_PATH, APPEND, '*']\n}\n\npathStateMachine[AFTER_ZERO] = {\n  'ws': [AFTER_ELEMENT, PUSH],\n  ']': [IN_PATH, PUSH]\n}\n\npathStateMachine[IN_INDEX] = {\n  '0': [IN_INDEX, APPEND],\n  'number': [IN_INDEX, APPEND],\n  'ws': [AFTER_ELEMENT],\n  ']': [IN_PATH, PUSH]\n}\n\npathStateMachine[IN_SINGLE_QUOTE] = {\n  \"'\": [AFTER_ELEMENT],\n  'eof': ERROR,\n  'else': [IN_SINGLE_QUOTE, APPEND]\n}\n\npathStateMachine[IN_DOUBLE_QUOTE] = {\n  '\"': [AFTER_ELEMENT],\n  'eof': ERROR,\n  'else': [IN_DOUBLE_QUOTE, APPEND]\n}\n\npathStateMachine[IN_SUB_PATH] = {\n  'ident': [IN_SUB_PATH, APPEND],\n  '0': [IN_SUB_PATH, APPEND],\n  'number': [IN_SUB_PATH, APPEND],\n  'ws': [AFTER_ELEMENT],\n  ']': [IN_PATH, PUSH]\n}\n\npathStateMachine[AFTER_ELEMENT] = {\n  'ws': [AFTER_ELEMENT],\n  ']': [IN_PATH, PUSH]\n}\n\n/**\n * Determine the type of a character in a keypath.\n *\n * @param {Char} ch\n * @return {String} type\n */\n\nfunction getPathCharType (ch) {\n  if (ch === undefined) {\n    return 'eof'\n  }\n\n  var code = ch.charCodeAt(0)\n\n  switch (code) {\n    case 0x5B: // [\n    case 0x5D: // ]\n    case 0x2E: // .\n    case 0x22: // \"\n    case 0x27: // '\n    case 0x30: // 0\n      return ch\n\n    case 0x5F: // _\n    case 0x24: // $\n      return 'ident'\n\n    case 0x20: // Space\n    case 0x09: // Tab\n    case 0x0A: // Newline\n    case 0x0D: // Return\n    case 0xA0:  // No-break space\n    case 0xFEFF:  // Byte Order Mark\n    case 0x2028:  // Line Separator\n    case 0x2029:  // Paragraph Separator\n      return 'ws'\n  }\n\n  // a-z, A-Z\n  if (\n    (code >= 0x61 && code <= 0x7A) ||\n    (code >= 0x41 && code <= 0x5A)\n  ) {\n    return 'ident'\n  }\n\n  // 1-9\n  if (code >= 0x31 && code <= 0x39) {\n    return 'number'\n  }\n\n  return 'else'\n}\n\n/**\n * Parse a string path into an array of segments\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nfunction parsePath (path) {\n  var keys = []\n  var index = -1\n  var mode = BEFORE_PATH\n  var c, newChar, key, type, transition, action, typeMap\n\n  var actions = []\n  actions[PUSH] = function () {\n    if (key === undefined) {\n      return\n    }\n    keys.push(key)\n    key = undefined\n  }\n  actions[APPEND] = function () {\n    if (key === undefined) {\n      key = newChar\n    } else {\n      key += newChar\n    }\n  }\n\n  function maybeUnescapeQuote () {\n    var nextChar = path[index + 1]\n    if ((mode === IN_SINGLE_QUOTE && nextChar === \"'\") ||\n        (mode === IN_DOUBLE_QUOTE && nextChar === '\"')) {\n      index++\n      newChar = nextChar\n      actions[APPEND]()\n      return true\n    }\n  }\n\n  while (mode != null) {\n    index++\n    c = path[index]\n\n    if (c === '\\\\' && maybeUnescapeQuote()) {\n      continue\n    }\n\n    type = getPathCharType(c)\n    typeMap = pathStateMachine[mode]\n    transition = typeMap[type] || typeMap['else'] || ERROR\n\n    if (transition === ERROR) {\n      return // parse error\n    }\n\n    mode = transition[0]\n    action = actions[transition[1]]\n    if (action) {\n      newChar = transition[2]\n      newChar = newChar === undefined\n        ? c\n        : newChar === '*'\n          ? newChar + c\n          : newChar\n      action()\n    }\n\n    if (mode === AFTER_PATH) {\n      keys.raw = path\n      return keys\n    }\n  }\n}\n\n/**\n * Format a accessor segment based on its type.\n *\n * @param {String} key\n * @return {Boolean}\n */\n\nfunction formatAccessor (key) {\n  if (identRE.test(key)) { // identifier\n    return '.' + key\n  } else if (+key === key >>> 0) { // bracket index\n    return '[' + key + ']'\n  } else if (key.charAt(0) === '*') {\n    return '[o' + formatAccessor(key.slice(1)) + ']'\n  } else { // bracket string\n    return '[\"' + key.replace(/\"/g, '\\\\\"') + '\"]'\n  }\n}\n\n/**\n * Compiles a getter function with a fixed path.\n * The fixed path getter supresses errors.\n *\n * @param {Array} path\n * @return {Function}\n */\n\nexports.compileGetter = function (path) {\n  var body = 'return o' + path.map(formatAccessor).join('')\n  return new Function('o', body)\n}\n\n/**\n * External parse that check for a cache hit first\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nexports.parse = function (path) {\n  var hit = pathCache.get(path)\n  if (!hit) {\n    hit = parsePath(path)\n    if (hit) {\n      hit.get = exports.compileGetter(hit)\n      pathCache.put(path, hit)\n    }\n  }\n  return hit\n}\n\n/**\n * Get from an object from a path string\n *\n * @param {Object} obj\n * @param {String} path\n */\n\nexports.get = function (obj, path) {\n  path = exports.parse(path)\n  if (path) {\n    return path.get(obj)\n  }\n}\n\n/**\n * Warn against setting non-existent root path on a vm.\n */\n\nvar warnNonExistent\nif (process.env.NODE_ENV !== 'production') {\n  warnNonExistent = function (path) {\n    _.warn(\n      'You are setting a non-existent path \"' + path.raw + '\" ' +\n      'on a vm instance. Consider pre-initializing the property ' +\n      'with the \"data\" option for more reliable reactivity ' +\n      'and better performance.'\n    )\n  }\n}\n\n/**\n * Set on an object from a path\n *\n * @param {Object} obj\n * @param {String | Array} path\n * @param {*} val\n */\n\nexports.set = function (obj, path, val) {\n  var original = obj\n  if (typeof path === 'string') {\n    path = exports.parse(path)\n  }\n  if (!path || !_.isObject(obj)) {\n    return false\n  }\n  var last, key\n  for (var i = 0, l = path.length; i < l; i++) {\n    last = obj\n    key = path[i]\n    if (key.charAt(0) === '*') {\n      key = original[key.slice(1)]\n    }\n    if (i < l - 1) {\n      obj = obj[key]\n      if (!_.isObject(obj)) {\n        obj = {}\n        if (process.env.NODE_ENV !== 'production' && last._isVue) {\n          warnNonExistent(path)\n        }\n        _.set(last, key, obj)\n      }\n    } else {\n      if (_.isArray(obj)) {\n        obj.$set(key, val)\n      } else if (key in obj) {\n        obj[key] = val\n      } else {\n        if (process.env.NODE_ENV !== 'production' && obj._isVue) {\n          warnNonExistent(path)\n        }\n        _.set(obj, key, val)\n      }\n    }\n  }\n  return true\n}\n\n}).call(this,require('_process'))\n\n},{\"../cache\":43,\"../util\":99,\"_process\":1}],90:[function(require,module,exports){\nvar _ = require('../util')\nvar Cache = require('../cache')\nvar templateCache = new Cache(1000)\nvar idSelectorCache = new Cache(1000)\n\nvar map = {\n  _default: [0, '', ''],\n  legend: [1, '<fieldset>', '</fieldset>'],\n  tr: [2, '<table><tbody>', '</tbody></table>'],\n  col: [\n    2,\n    '<table><tbody></tbody><colgroup>',\n    '</colgroup></table>'\n  ]\n}\n\nmap.td =\nmap.th = [\n  3,\n  '<table><tbody><tr>',\n  '</tr></tbody></table>'\n]\n\nmap.option =\nmap.optgroup = [\n  1,\n  '<select multiple=\"multiple\">',\n  '</select>'\n]\n\nmap.thead =\nmap.tbody =\nmap.colgroup =\nmap.caption =\nmap.tfoot = [1, '<table>', '</table>']\n\nmap.g =\nmap.defs =\nmap.symbol =\nmap.use =\nmap.image =\nmap.text =\nmap.circle =\nmap.ellipse =\nmap.line =\nmap.path =\nmap.polygon =\nmap.polyline =\nmap.rect = [\n  1,\n  '<svg ' +\n    'xmlns=\"http://www.w3.org/2000/svg\" ' +\n    'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' +\n    'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' +\n    'version=\"1.1\">',\n  '</svg>'\n]\n\n/**\n * Check if a node is a supported template node with a\n * DocumentFragment content.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction isRealTemplate (node) {\n  return _.isTemplate(node) &&\n    node.content instanceof DocumentFragment\n}\n\nvar tagRE = /<([\\w:]+)/\nvar entityRE = /&\\w+;|&#\\d+;|&#x[\\dA-F]+;/\n\n/**\n * Convert a string template to a DocumentFragment.\n * Determines correct wrapping by tag types. Wrapping\n * strategy found in jQuery & component/domify.\n *\n * @param {String} templateString\n * @return {DocumentFragment}\n */\n\nfunction stringToFragment (templateString) {\n  // try a cache hit first\n  var hit = templateCache.get(templateString)\n  if (hit) {\n    return hit\n  }\n\n  var frag = document.createDocumentFragment()\n  var tagMatch = templateString.match(tagRE)\n  var entityMatch = entityRE.test(templateString)\n\n  if (!tagMatch && !entityMatch) {\n    // text only, return a single text node.\n    frag.appendChild(\n      document.createTextNode(templateString)\n    )\n  } else {\n\n    var tag = tagMatch && tagMatch[1]\n    var wrap = map[tag] || map._default\n    var depth = wrap[0]\n    var prefix = wrap[1]\n    var suffix = wrap[2]\n    var node = document.createElement('div')\n\n    node.innerHTML = prefix + templateString.trim() + suffix\n    while (depth--) {\n      node = node.lastChild\n    }\n\n    var child\n    /* eslint-disable no-cond-assign */\n    while (child = node.firstChild) {\n    /* eslint-enable no-cond-assign */\n      frag.appendChild(child)\n    }\n  }\n\n  templateCache.put(templateString, frag)\n  return frag\n}\n\n/**\n * Convert a template node to a DocumentFragment.\n *\n * @param {Node} node\n * @return {DocumentFragment}\n */\n\nfunction nodeToFragment (node) {\n  // if its a template tag and the browser supports it,\n  // its content is already a document fragment.\n  if (isRealTemplate(node)) {\n    _.trimNode(node.content)\n    return node.content\n  }\n  // script template\n  if (node.tagName === 'SCRIPT') {\n    return stringToFragment(node.textContent)\n  }\n  // normal node, clone it to avoid mutating the original\n  var clone = exports.clone(node)\n  var frag = document.createDocumentFragment()\n  var child\n  /* eslint-disable no-cond-assign */\n  while (child = clone.firstChild) {\n  /* eslint-enable no-cond-assign */\n    frag.appendChild(child)\n  }\n  _.trimNode(frag)\n  return frag\n}\n\n// Test for the presence of the Safari template cloning bug\n// https://bugs.webkit.org/show_bug.cgi?id=137755\nvar hasBrokenTemplate = (function () {\n  /* istanbul ignore else */\n  if (_.inBrowser) {\n    var a = document.createElement('div')\n    a.innerHTML = '<template>1</template>'\n    return !a.cloneNode(true).firstChild.innerHTML\n  } else {\n    return false\n  }\n})()\n\n// Test for IE10/11 textarea placeholder clone bug\nvar hasTextareaCloneBug = (function () {\n  /* istanbul ignore else */\n  if (_.inBrowser) {\n    var t = document.createElement('textarea')\n    t.placeholder = 't'\n    return t.cloneNode(true).value === 't'\n  } else {\n    return false\n  }\n})()\n\n/**\n * 1. Deal with Safari cloning nested <template> bug by\n *    manually cloning all template instances.\n * 2. Deal with IE10/11 textarea placeholder bug by setting\n *    the correct value after cloning.\n *\n * @param {Element|DocumentFragment} node\n * @return {Element|DocumentFragment}\n */\n\nexports.clone = function (node) {\n  if (!node.querySelectorAll) {\n    return node.cloneNode()\n  }\n  var res = node.cloneNode(true)\n  var i, original, cloned\n  /* istanbul ignore if */\n  if (hasBrokenTemplate) {\n    var clone = res\n    if (isRealTemplate(node)) {\n      node = node.content\n      clone = res.content\n    }\n    original = node.querySelectorAll('template')\n    if (original.length) {\n      cloned = clone.querySelectorAll('template')\n      i = cloned.length\n      while (i--) {\n        cloned[i].parentNode.replaceChild(\n          exports.clone(original[i]),\n          cloned[i]\n        )\n      }\n    }\n  }\n  /* istanbul ignore if */\n  if (hasTextareaCloneBug) {\n    if (node.tagName === 'TEXTAREA') {\n      res.value = node.value\n    } else {\n      original = node.querySelectorAll('textarea')\n      if (original.length) {\n        cloned = res.querySelectorAll('textarea')\n        i = cloned.length\n        while (i--) {\n          cloned[i].value = original[i].value\n        }\n      }\n    }\n  }\n  return res\n}\n\n/**\n * Process the template option and normalizes it into a\n * a DocumentFragment that can be used as a partial or a\n * instance template.\n *\n * @param {*} template\n *    Possible values include:\n *    - DocumentFragment object\n *    - Node object of type Template\n *    - id selector: '#some-template-id'\n *    - template string: '<div><span>{{msg}}</span></div>'\n * @param {Boolean} clone\n * @param {Boolean} noSelector\n * @return {DocumentFragment|undefined}\n */\n\nexports.parse = function (template, clone, noSelector) {\n  var node, frag\n\n  // if the template is already a document fragment,\n  // do nothing\n  if (template instanceof DocumentFragment) {\n    _.trimNode(template)\n    return clone\n      ? exports.clone(template)\n      : template\n  }\n\n  if (typeof template === 'string') {\n    // id selector\n    if (!noSelector && template.charAt(0) === '#') {\n      // id selector can be cached too\n      frag = idSelectorCache.get(template)\n      if (!frag) {\n        node = document.getElementById(template.slice(1))\n        if (node) {\n          frag = nodeToFragment(node)\n          // save selector to cache\n          idSelectorCache.put(template, frag)\n        }\n      }\n    } else {\n      // normal string template\n      frag = stringToFragment(template)\n    }\n  } else if (template.nodeType) {\n    // a direct node\n    frag = nodeToFragment(template)\n  }\n\n  return frag && clone\n    ? exports.clone(frag)\n    : frag\n}\n\n},{\"../cache\":43,\"../util\":99}],91:[function(require,module,exports){\nvar Cache = require('../cache')\nvar config = require('../config')\nvar dirParser = require('./directive')\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g\nvar cache, tagRE, htmlRE\n\n/**\n * Escape a string so it can be used in a RegExp\n * constructor.\n *\n * @param {String} str\n */\n\nfunction escapeRegex (str) {\n  return str.replace(regexEscapeRE, '\\\\$&')\n}\n\nexports.compileRegex = function () {\n  var open = escapeRegex(config.delimiters[0])\n  var close = escapeRegex(config.delimiters[1])\n  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0])\n  var unsafeClose = escapeRegex(config.unsafeDelimiters[1])\n  tagRE = new RegExp(\n    unsafeOpen + '(.+?)' + unsafeClose + '|' +\n    open + '(.+?)' + close,\n    'g'\n  )\n  htmlRE = new RegExp(\n    '^' + unsafeOpen + '.*' + unsafeClose + '$'\n  )\n  // reset cache\n  cache = new Cache(1000)\n}\n\n/**\n * Parse a template text string into an array of tokens.\n *\n * @param {String} text\n * @return {Array<Object> | null}\n *               - {String} type\n *               - {String} value\n *               - {Boolean} [html]\n *               - {Boolean} [oneTime]\n */\n\nexports.parse = function (text) {\n  if (!cache) {\n    exports.compileRegex()\n  }\n  var hit = cache.get(text)\n  if (hit) {\n    return hit\n  }\n  text = text.replace(/\\n/g, '')\n  if (!tagRE.test(text)) {\n    return null\n  }\n  var tokens = []\n  var lastIndex = tagRE.lastIndex = 0\n  var match, index, html, value, first, oneTime\n  /* eslint-disable no-cond-assign */\n  while (match = tagRE.exec(text)) {\n  /* eslint-enable no-cond-assign */\n    index = match.index\n    // push text token\n    if (index > lastIndex) {\n      tokens.push({\n        value: text.slice(lastIndex, index)\n      })\n    }\n    // tag token\n    html = htmlRE.test(match[0])\n    value = html ? match[1] : match[2]\n    first = value.charCodeAt(0)\n    oneTime = first === 42 // *\n    value = oneTime\n      ? value.slice(1)\n      : value\n    tokens.push({\n      tag: true,\n      value: value.trim(),\n      html: html,\n      oneTime: oneTime\n    })\n    lastIndex = index + match[0].length\n  }\n  if (lastIndex < text.length) {\n    tokens.push({\n      value: text.slice(lastIndex)\n    })\n  }\n  cache.put(text, tokens)\n  return tokens\n}\n\n/**\n * Format a list of tokens into an expression.\n * e.g. tokens parsed from 'a {{b}} c' can be serialized\n * into one single expression as '\"a \" + b + \" c\"'.\n *\n * @param {Array} tokens\n * @return {String}\n */\n\nexports.tokensToExp = function (tokens) {\n  if (tokens.length > 1) {\n    return tokens.map(function (token) {\n      return formatToken(token)\n    }).join('+')\n  } else {\n    return formatToken(tokens[0], true)\n  }\n}\n\n/**\n * Format a single token.\n *\n * @param {Object} token\n * @param {Boolean} single\n * @return {String}\n */\n\nfunction formatToken (token, single) {\n  return token.tag\n    ? inlineFilters(token.value, single)\n    : '\"' + token.value + '\"'\n}\n\n/**\n * For an attribute with multiple interpolation tags,\n * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n * the whole thing into a single watchable expression, we\n * have to inline those filters. This function does exactly\n * that. This is a bit hacky but it avoids heavy changes\n * to directive parser and watcher mechanism.\n *\n * @param {String} exp\n * @param {Boolean} single\n * @return {String}\n */\n\nvar filterRE = /[^|]\\|[^|]/\nfunction inlineFilters (exp, single) {\n  if (!filterRE.test(exp)) {\n    return single\n      ? exp\n      : '(' + exp + ')'\n  } else {\n    var dir = dirParser.parse(exp)\n    if (!dir.filters) {\n      return '(' + exp + ')'\n    } else {\n      return 'this._applyFilters(' +\n        dir.expression + // value\n        ',null,' +       // oldValue (null for read)\n        JSON.stringify(dir.filters) + // filter descriptors\n        ',false)'        // write?\n    }\n  }\n}\n\n},{\"../cache\":43,\"../config\":48,\"./directive\":87}],92:[function(require,module,exports){\nvar _ = require('../util')\n\n/**\n * Append with transition.\n *\n * @param {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nexports.append = function (el, target, vm, cb) {\n  apply(el, 1, function () {\n    target.appendChild(el)\n  }, vm, cb)\n}\n\n/**\n * InsertBefore with transition.\n *\n * @param {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nexports.before = function (el, target, vm, cb) {\n  apply(el, 1, function () {\n    _.before(el, target)\n  }, vm, cb)\n}\n\n/**\n * Remove with transition.\n *\n * @param {Element} el\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nexports.remove = function (el, vm, cb) {\n  apply(el, -1, function () {\n    _.remove(el)\n  }, vm, cb)\n}\n\n/**\n * Apply transitions with an operation callback.\n *\n * @param {Element} el\n * @param {Number} direction\n *                  1: enter\n *                 -1: leave\n * @param {Function} op - the actual DOM operation\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nvar apply = exports.apply = function (el, direction, op, vm, cb) {\n  var transition = el.__v_trans\n  if (\n    !transition ||\n    // skip if there are no js hooks and CSS transition is\n    // not supported\n    (!transition.hooks && !_.transitionEndEvent) ||\n    // skip transitions for initial compile\n    !vm._isCompiled ||\n    // if the vm is being manipulated by a parent directive\n    // during the parent's compilation phase, skip the\n    // animation.\n    (vm.$parent && !vm.$parent._isCompiled)\n  ) {\n    op()\n    if (cb) cb()\n    return\n  }\n  var action = direction > 0 ? 'enter' : 'leave'\n  transition[action](op, cb)\n}\n\n},{\"../util\":99}],93:[function(require,module,exports){\nvar _ = require('../util')\nvar queue = []\nvar queued = false\n\n/**\n * Push a job into the queue.\n *\n * @param {Function} job\n */\n\nexports.push = function (job) {\n  queue.push(job)\n  if (!queued) {\n    queued = true\n    _.nextTick(flush)\n  }\n}\n\n/**\n * Flush the queue, and do one forced reflow before\n * triggering transitions.\n */\n\nfunction flush () {\n  // Force layout\n  var f = document.documentElement.offsetHeight\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n  queue = []\n  queued = false\n  // dummy return, so js linters don't complain about\n  // unused variable f\n  return f\n}\n\n},{\"../util\":99}],94:[function(require,module,exports){\nvar _ = require('../util')\nvar queue = require('./queue')\nvar addClass = _.addClass\nvar removeClass = _.removeClass\nvar transitionEndEvent = _.transitionEndEvent\nvar animationEndEvent = _.animationEndEvent\nvar transDurationProp = _.transitionProp + 'Duration'\nvar animDurationProp = _.animationProp + 'Duration'\n\nvar TYPE_TRANSITION = 1\nvar TYPE_ANIMATION = 2\n\n/**\n * A Transition object that encapsulates the state and logic\n * of the transition.\n *\n * @param {Element} el\n * @param {String} id\n * @param {Object} hooks\n * @param {Vue} vm\n */\n\nfunction Transition (el, id, hooks, vm) {\n  this.id = id\n  this.el = el\n  this.enterClass = id + '-enter'\n  this.leaveClass = id + '-leave'\n  this.hooks = hooks\n  this.vm = vm\n  // async state\n  this.pendingCssEvent =\n  this.pendingCssCb =\n  this.cancel =\n  this.pendingJsCb =\n  this.op =\n  this.cb = null\n  this.justEntered = false\n  this.entered = this.left = false\n  this.typeCache = {}\n  // bind\n  var self = this\n  ;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone']\n    .forEach(function (m) {\n      self[m] = _.bind(self[m], self)\n    })\n}\n\nvar p = Transition.prototype\n\n/**\n * Start an entering transition.\n *\n * 1. enter transition triggered\n * 2. call beforeEnter hook\n * 3. add enter class\n * 4. insert/show element\n * 5. call enter hook (with possible explicit js callback)\n * 6. reflow\n * 7. based on transition type:\n *    - transition:\n *        remove class now, wait for transitionend,\n *        then done if there's no explicit js callback.\n *    - animation:\n *        wait for animationend, remove class,\n *        then done if there's no explicit js callback.\n *    - no css transition:\n *        done now if there's no explicit js callback.\n * 8. wait for either done or js callback, then call\n *    afterEnter hook.\n *\n * @param {Function} op - insert/show the element\n * @param {Function} [cb]\n */\n\np.enter = function (op, cb) {\n  this.cancelPending()\n  this.callHook('beforeEnter')\n  this.cb = cb\n  addClass(this.el, this.enterClass)\n  op()\n  this.entered = false\n  this.callHookWithCb('enter')\n  if (this.entered) {\n    return // user called done synchronously.\n  }\n  this.cancel = this.hooks && this.hooks.enterCancelled\n  queue.push(this.enterNextTick)\n}\n\n/**\n * The \"nextTick\" phase of an entering transition, which is\n * to be pushed into a queue and executed after a reflow so\n * that removing the class can trigger a CSS transition.\n */\n\np.enterNextTick = function () {\n\n  // Important hack:\n  // in Chrome, if a just-entered element is applied the\n  // leave class while its interpolated property still has\n  // a very small value (within one frame), Chrome will\n  // skip the leave transition entirely and not firing the\n  // transtionend event. Therefore we need to protected\n  // against such cases using a one-frame timeout.\n  this.justEntered = true\n  var self = this\n  setTimeout(function () {\n    self.justEntered = false\n  }, 17)\n\n  var enterDone = this.enterDone\n  var type = this.getCssTransitionType(this.enterClass)\n  if (!this.pendingJsCb) {\n    if (type === TYPE_TRANSITION) {\n      // trigger transition by removing enter class now\n      removeClass(this.el, this.enterClass)\n      this.setupCssCb(transitionEndEvent, enterDone)\n    } else if (type === TYPE_ANIMATION) {\n      this.setupCssCb(animationEndEvent, enterDone)\n    } else {\n      enterDone()\n    }\n  } else if (type === TYPE_TRANSITION) {\n    removeClass(this.el, this.enterClass)\n  }\n}\n\n/**\n * The \"cleanup\" phase of an entering transition.\n */\n\np.enterDone = function () {\n  this.entered = true\n  this.cancel = this.pendingJsCb = null\n  removeClass(this.el, this.enterClass)\n  this.callHook('afterEnter')\n  if (this.cb) this.cb()\n}\n\n/**\n * Start a leaving transition.\n *\n * 1. leave transition triggered.\n * 2. call beforeLeave hook\n * 3. add leave class (trigger css transition)\n * 4. call leave hook (with possible explicit js callback)\n * 5. reflow if no explicit js callback is provided\n * 6. based on transition type:\n *    - transition or animation:\n *        wait for end event, remove class, then done if\n *        there's no explicit js callback.\n *    - no css transition:\n *        done if there's no explicit js callback.\n * 7. wait for either done or js callback, then call\n *    afterLeave hook.\n *\n * @param {Function} op - remove/hide the element\n * @param {Function} [cb]\n */\n\np.leave = function (op, cb) {\n  this.cancelPending()\n  this.callHook('beforeLeave')\n  this.op = op\n  this.cb = cb\n  addClass(this.el, this.leaveClass)\n  this.left = false\n  this.callHookWithCb('leave')\n  if (this.left) {\n    return // user called done synchronously.\n  }\n  this.cancel = this.hooks && this.hooks.leaveCancelled\n  // only need to handle leaveDone if\n  // 1. the transition is already done (synchronously called\n  //    by the user, which causes this.op set to null)\n  // 2. there's no explicit js callback\n  if (this.op && !this.pendingJsCb) {\n    // if a CSS transition leaves immediately after enter,\n    // the transitionend event never fires. therefore we\n    // detect such cases and end the leave immediately.\n    if (this.justEntered) {\n      this.leaveDone()\n    } else {\n      queue.push(this.leaveNextTick)\n    }\n  }\n}\n\n/**\n * The \"nextTick\" phase of a leaving transition.\n */\n\np.leaveNextTick = function () {\n  var type = this.getCssTransitionType(this.leaveClass)\n  if (type) {\n    var event = type === TYPE_TRANSITION\n      ? transitionEndEvent\n      : animationEndEvent\n    this.setupCssCb(event, this.leaveDone)\n  } else {\n    this.leaveDone()\n  }\n}\n\n/**\n * The \"cleanup\" phase of a leaving transition.\n */\n\np.leaveDone = function () {\n  this.left = true\n  this.cancel = this.pendingJsCb = null\n  this.op()\n  removeClass(this.el, this.leaveClass)\n  this.callHook('afterLeave')\n  if (this.cb) this.cb()\n  this.op = null\n}\n\n/**\n * Cancel any pending callbacks from a previously running\n * but not finished transition.\n */\n\np.cancelPending = function () {\n  this.op = this.cb = null\n  var hasPending = false\n  if (this.pendingCssCb) {\n    hasPending = true\n    _.off(this.el, this.pendingCssEvent, this.pendingCssCb)\n    this.pendingCssEvent = this.pendingCssCb = null\n  }\n  if (this.pendingJsCb) {\n    hasPending = true\n    this.pendingJsCb.cancel()\n    this.pendingJsCb = null\n  }\n  if (hasPending) {\n    removeClass(this.el, this.enterClass)\n    removeClass(this.el, this.leaveClass)\n  }\n  if (this.cancel) {\n    this.cancel.call(this.vm, this.el)\n    this.cancel = null\n  }\n}\n\n/**\n * Call a user-provided synchronous hook function.\n *\n * @param {String} type\n */\n\np.callHook = function (type) {\n  if (this.hooks && this.hooks[type]) {\n    this.hooks[type].call(this.vm, this.el)\n  }\n}\n\n/**\n * Call a user-provided, potentially-async hook function.\n * We check for the length of arguments to see if the hook\n * expects a `done` callback. If true, the transition's end\n * will be determined by when the user calls that callback;\n * otherwise, the end is determined by the CSS transition or\n * animation.\n *\n * @param {String} type\n */\n\np.callHookWithCb = function (type) {\n  var hook = this.hooks && this.hooks[type]\n  if (hook) {\n    if (hook.length > 1) {\n      this.pendingJsCb = _.cancellable(this[type + 'Done'])\n    }\n    hook.call(this.vm, this.el, this.pendingJsCb)\n  }\n}\n\n/**\n * Get an element's transition type based on the\n * calculated styles.\n *\n * @param {String} className\n * @return {Number}\n */\n\np.getCssTransitionType = function (className) {\n  /* istanbul ignore if */\n  if (\n    !transitionEndEvent ||\n    // skip CSS transitions if page is not visible -\n    // this solves the issue of transitionend events not\n    // firing until the page is visible again.\n    // pageVisibility API is supported in IE10+, same as\n    // CSS transitions.\n    document.hidden ||\n    // explicit js-only transition\n    (this.hooks && this.hooks.css === false) ||\n    // element is hidden\n    isHidden(this.el)\n  ) {\n    return\n  }\n  var type = this.typeCache[className]\n  if (type) return type\n  var inlineStyles = this.el.style\n  var computedStyles = window.getComputedStyle(this.el)\n  var transDuration =\n    inlineStyles[transDurationProp] ||\n    computedStyles[transDurationProp]\n  if (transDuration && transDuration !== '0s') {\n    type = TYPE_TRANSITION\n  } else {\n    var animDuration =\n      inlineStyles[animDurationProp] ||\n      computedStyles[animDurationProp]\n    if (animDuration && animDuration !== '0s') {\n      type = TYPE_ANIMATION\n    }\n  }\n  if (type) {\n    this.typeCache[className] = type\n  }\n  return type\n}\n\n/**\n * Setup a CSS transitionend/animationend callback.\n *\n * @param {String} event\n * @param {Function} cb\n */\n\np.setupCssCb = function (event, cb) {\n  this.pendingCssEvent = event\n  var self = this\n  var el = this.el\n  var onEnd = this.pendingCssCb = function (e) {\n    if (e.target === el) {\n      _.off(el, event, onEnd)\n      self.pendingCssEvent = self.pendingCssCb = null\n      if (!self.pendingJsCb && cb) {\n        cb()\n      }\n    }\n  }\n  _.on(el, event, onEnd)\n}\n\n/**\n * Check if an element is hidden - in that case we can just\n * skip the transition alltogether.\n *\n * @param {Element} el\n * @return {Boolean}\n */\n\nfunction isHidden (el) {\n  return !(\n    el.offsetWidth &&\n    el.offsetHeight &&\n    el.getClientRects().length\n  )\n}\n\nmodule.exports = Transition\n\n},{\"../util\":99,\"./queue\":93}],95:[function(require,module,exports){\n(function (process){\nvar _ = require('./index')\n\n/**\n * Check if an element is a component, if yes return its\n * component id.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Object|undefined}\n */\n\nexports.commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/\nexports.checkComponent = function (el, options) {\n  var tag = el.tagName.toLowerCase()\n  var hasAttrs = el.hasAttributes()\n  if (!exports.commonTagRE.test(tag) && tag !== 'component') {\n    if (_.resolveAsset(options, 'components', tag)) {\n      return { id: tag }\n    } else {\n      var is = hasAttrs && getIsBinding(el)\n      if (is) {\n        return is\n      } else if (process.env.NODE_ENV !== 'production') {\n        if (\n          tag.indexOf('-') > -1 ||\n          (\n            /HTMLUnknownElement/.test(el.toString()) &&\n            // Chrome returns unknown for several HTML5 elements.\n            // https://code.google.com/p/chromium/issues/detail?id=540526\n            !/^(data|time|rtc|rb)$/.test(tag)\n          )\n        ) {\n          _.warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly?'\n          )\n        }\n      }\n    }\n  } else if (hasAttrs) {\n    return getIsBinding(el)\n  }\n}\n\n/**\n * Get \"is\" binding from an element.\n *\n * @param {Element} el\n * @return {Object|undefined}\n */\n\nfunction getIsBinding (el) {\n  // dynamic syntax\n  var exp = _.attr(el, 'is')\n  if (exp != null) {\n    return { id: exp }\n  } else {\n    exp = _.getBindAttr(el, 'is')\n    if (exp != null) {\n      return { id: exp, dynamic: true }\n    }\n  }\n}\n\n/**\n * Set a prop's initial value on a vm and its data object.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} value\n */\n\nexports.initProp = function (vm, prop, value) {\n  if (exports.assertProp(prop, value)) {\n    var key = prop.path\n    vm[key] = vm._data[key] = value\n  }\n}\n\n/**\n * Assert whether a prop is valid.\n *\n * @param {Object} prop\n * @param {*} value\n */\n\nexports.assertProp = function (prop, value) {\n  // if a prop is not provided and is not required,\n  // skip the check.\n  if (prop.raw === null && !prop.required) {\n    return true\n  }\n  var options = prop.options\n  var type = options.type\n  var valid = true\n  var expectedType\n  if (type) {\n    if (type === String) {\n      expectedType = 'string'\n      valid = typeof value === expectedType\n    } else if (type === Number) {\n      expectedType = 'number'\n      valid = typeof value === 'number'\n    } else if (type === Boolean) {\n      expectedType = 'boolean'\n      valid = typeof value === 'boolean'\n    } else if (type === Function) {\n      expectedType = 'function'\n      valid = typeof value === 'function'\n    } else if (type === Object) {\n      expectedType = 'object'\n      valid = _.isPlainObject(value)\n    } else if (type === Array) {\n      expectedType = 'array'\n      valid = _.isArray(value)\n    } else {\n      valid = value instanceof type\n    }\n  }\n  if (!valid) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Invalid prop: type check failed for ' +\n      prop.path + '=\"' + prop.raw + '\".' +\n      ' Expected ' + formatType(expectedType) +\n      ', got ' + formatValue(value) + '.'\n    )\n    return false\n  }\n  var validator = options.validator\n  if (validator) {\n    if (!validator.call(null, value)) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Invalid prop: custom validator check failed for ' +\n        prop.path + '=\"' + prop.raw + '\"'\n      )\n      return false\n    }\n  }\n  return true\n}\n\nfunction formatType (val) {\n  return val\n    ? val.charAt(0).toUpperCase() + val.slice(1)\n    : 'custom type'\n}\n\nfunction formatValue (val) {\n  return Object.prototype.toString.call(val).slice(8, -1)\n}\n\n}).call(this,require('_process'))\n\n},{\"./index\":99,\"_process\":1}],96:[function(require,module,exports){\n(function (process){\n/**\n * Enable debug utilities.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n\n  var config = require('../config')\n  var hasConsole = typeof console !== 'undefined'\n\n  /**\n   * Log a message.\n   *\n   * @param {String} msg\n   */\n\n  exports.log = function (msg) {\n    if (hasConsole && config.debug) {\n      console.log('[Vue info]: ' + msg)\n    }\n  }\n\n  /**\n   * We've got a problem here.\n   *\n   * @param {String} msg\n   */\n\n  exports.warn = function (msg, e) {\n    if (hasConsole && (!config.silent || config.debug)) {\n      console.warn('[Vue warn]: ' + msg)\n      /* istanbul ignore if */\n      if (config.debug) {\n        console.warn((e || new Error('Warning Stack Trace')).stack)\n      }\n    }\n  }\n\n  /**\n   * Assert asset exists\n   */\n\n  exports.assertAsset = function (val, type, id) {\n    if (!val) {\n      exports.warn('Failed to resolve ' + type + ': ' + id)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../config\":48,\"_process\":1}],97:[function(require,module,exports){\n(function (process){\nvar _ = require('./index')\nvar config = require('../config')\nvar transition = require('../transition')\n\n/**\n * Query an element selector if it's not an element already.\n *\n * @param {String|Element} el\n * @return {Element}\n */\n\nexports.query = function (el) {\n  if (typeof el === 'string') {\n    var selector = el\n    el = document.querySelector(el)\n    if (!el) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Cannot find element: ' + selector\n      )\n    }\n  }\n  return el\n}\n\n/**\n * Check if a node is in the document.\n * Note: document.documentElement.contains should work here\n * but always returns false for comment nodes in phantomjs,\n * making unit tests difficult. This is fixed by doing the\n * contains() check on the node's parentNode instead of\n * the node itself.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nexports.inDoc = function (node) {\n  var doc = document.documentElement\n  var parent = node && node.parentNode\n  return doc === node ||\n    doc === parent ||\n    !!(parent && parent.nodeType === 1 && (doc.contains(parent)))\n}\n\n/**\n * Get and remove an attribute from a node.\n *\n * @param {Node} node\n * @param {String} attr\n */\n\nexports.attr = function (node, attr) {\n  var val = node.getAttribute(attr)\n  if (val !== null) {\n    node.removeAttribute(attr)\n  }\n  return val\n}\n\n/**\n * Get an attribute with colon or v-bind: prefix.\n *\n * @param {Node} node\n * @param {String} name\n * @return {String|null}\n */\n\nexports.getBindAttr = function (node, name) {\n  var val = exports.attr(node, ':' + name)\n  if (val === null) {\n    val = exports.attr(node, 'v-bind:' + name)\n  }\n  return val\n}\n\n/**\n * Insert el before target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nexports.before = function (el, target) {\n  target.parentNode.insertBefore(el, target)\n}\n\n/**\n * Insert el after target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nexports.after = function (el, target) {\n  if (target.nextSibling) {\n    exports.before(el, target.nextSibling)\n  } else {\n    target.parentNode.appendChild(el)\n  }\n}\n\n/**\n * Remove el from DOM\n *\n * @param {Element} el\n */\n\nexports.remove = function (el) {\n  el.parentNode.removeChild(el)\n}\n\n/**\n * Prepend el to target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nexports.prepend = function (el, target) {\n  if (target.firstChild) {\n    exports.before(el, target.firstChild)\n  } else {\n    target.appendChild(el)\n  }\n}\n\n/**\n * Replace target with el\n *\n * @param {Element} target\n * @param {Element} el\n */\n\nexports.replace = function (target, el) {\n  var parent = target.parentNode\n  if (parent) {\n    parent.replaceChild(el, target)\n  }\n}\n\n/**\n * Add event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n */\n\nexports.on = function (el, event, cb) {\n  el.addEventListener(event, cb)\n}\n\n/**\n * Remove event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n */\n\nexports.off = function (el, event, cb) {\n  el.removeEventListener(event, cb)\n}\n\n/**\n * Add class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {Strong} cls\n */\n\nexports.addClass = function (el, cls) {\n  if (el.classList) {\n    el.classList.add(cls)\n  } else {\n    var cur = ' ' + (el.getAttribute('class') || '') + ' '\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim())\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {Strong} cls\n */\n\nexports.removeClass = function (el, cls) {\n  if (el.classList) {\n    el.classList.remove(cls)\n  } else {\n    var cur = ' ' + (el.getAttribute('class') || '') + ' '\n    var tar = ' ' + cls + ' '\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ')\n    }\n    el.setAttribute('class', cur.trim())\n  }\n  if (!el.className) {\n    el.removeAttribute('class')\n  }\n}\n\n/**\n * Extract raw content inside an element into a temporary\n * container div\n *\n * @param {Element} el\n * @param {Boolean} asFragment\n * @return {Element}\n */\n\nexports.extractContent = function (el, asFragment) {\n  var child\n  var rawContent\n  /* istanbul ignore if */\n  if (\n    exports.isTemplate(el) &&\n    el.content instanceof DocumentFragment\n  ) {\n    el = el.content\n  }\n  if (el.hasChildNodes()) {\n    exports.trimNode(el)\n    rawContent = asFragment\n      ? document.createDocumentFragment()\n      : document.createElement('div')\n    /* eslint-disable no-cond-assign */\n    while (child = el.firstChild) {\n    /* eslint-enable no-cond-assign */\n      rawContent.appendChild(child)\n    }\n  }\n  return rawContent\n}\n\n/**\n * Trim possible empty head/tail textNodes inside a parent.\n *\n * @param {Node} node\n */\n\nexports.trimNode = function (node) {\n  trim(node, node.firstChild)\n  trim(node, node.lastChild)\n}\n\nfunction trim (parent, node) {\n  if (node && node.nodeType === 3 && !node.data.trim()) {\n    parent.removeChild(node)\n  }\n}\n\n/**\n * Check if an element is a template tag.\n * Note if the template appears inside an SVG its tagName\n * will be in lowercase.\n *\n * @param {Element} el\n */\n\nexports.isTemplate = function (el) {\n  return el.tagName &&\n    el.tagName.toLowerCase() === 'template'\n}\n\n/**\n * Create an \"anchor\" for performing dom insertion/removals.\n * This is used in a number of scenarios:\n * - fragment instance\n * - v-html\n * - v-if\n * - v-for\n * - component\n *\n * @param {String} content\n * @param {Boolean} persist - IE trashes empty textNodes on\n *                            cloneNode(true), so in certain\n *                            cases the anchor needs to be\n *                            non-empty to be persisted in\n *                            templates.\n * @return {Comment|Text}\n */\n\nexports.createAnchor = function (content, persist) {\n  return config.debug\n    ? document.createComment(content)\n    : document.createTextNode(persist ? ' ' : '')\n}\n\n/**\n * Find a component ref attribute that starts with $.\n *\n * @param {Element} node\n * @return {String|undefined}\n */\n\nvar refRE = /^v-ref:/\nexports.findRef = function (node) {\n  if (node.hasAttributes()) {\n    var attrs = node.attributes\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      var name = attrs[i].name\n      if (refRE.test(name)) {\n        node.removeAttribute(name)\n        return _.camelize(name.replace(refRE, ''))\n      }\n    }\n  }\n}\n\n/**\n * Map a function to a range of nodes .\n *\n * @param {Node} node\n * @param {Node} end\n * @param {Function} op\n */\n\nexports.mapNodeRange = function (node, end, op) {\n  var next\n  while (node !== end) {\n    next = node.nextSibling\n    op(node)\n    node = next\n  }\n  op(end)\n}\n\n/**\n * Remove a range of nodes with transition, store\n * the nodes in a fragment with correct ordering,\n * and call callback when done.\n *\n * @param {Node} start\n * @param {Node} end\n * @param {Vue} vm\n * @param {DocumentFragment} frag\n * @param {Function} cb\n */\n\nexports.removeNodeRange = function (start, end, vm, frag, cb) {\n  var done = false\n  var removed = 0\n  var nodes = []\n  exports.mapNodeRange(start, end, function (node) {\n    if (node === end) done = true\n    nodes.push(node)\n    transition.remove(node, vm, onRemoved)\n  })\n  function onRemoved () {\n    removed++\n    if (done && removed >= nodes.length) {\n      for (var i = 0; i < nodes.length; i++) {\n        frag.appendChild(nodes[i])\n      }\n      cb && cb()\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../config\":48,\"../transition\":92,\"./index\":99,\"_process\":1}],98:[function(require,module,exports){\n// can we use __proto__?\nexports.hasProto = '__proto__' in {}\n\n// Browser environment sniffing\nvar inBrowser = exports.inBrowser =\n  typeof window !== 'undefined' &&\n  Object.prototype.toString.call(window) !== '[object Object]'\n\nexports.isIE9 =\n  inBrowser &&\n  navigator.userAgent.toLowerCase().indexOf('msie 9.0') > 0\n\nexports.isAndroid =\n  inBrowser &&\n  navigator.userAgent.toLowerCase().indexOf('android') > 0\n\n// Transition property/event sniffing\nif (inBrowser && !exports.isIE9) {\n  var isWebkitTrans =\n    window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  var isWebkitAnim =\n    window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  exports.transitionProp = isWebkitTrans\n    ? 'WebkitTransition'\n    : 'transition'\n  exports.transitionEndEvent = isWebkitTrans\n    ? 'webkitTransitionEnd'\n    : 'transitionend'\n  exports.animationProp = isWebkitAnim\n    ? 'WebkitAnimation'\n    : 'animation'\n  exports.animationEndEvent = isWebkitAnim\n    ? 'webkitAnimationEnd'\n    : 'animationend'\n}\n\n/**\n * Defer a task to execute it asynchronously. Ideally this\n * should be executed as a microtask, so we leverage\n * MutationObserver if it's available, and fallback to\n * setTimeout(0).\n *\n * @param {Function} cb\n * @param {Object} ctx\n */\n\nexports.nextTick = (function () {\n  var callbacks = []\n  var pending = false\n  var timerFunc\n  function nextTickHandler () {\n    pending = false\n    var copies = callbacks.slice(0)\n    callbacks = []\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]()\n    }\n  }\n  /* istanbul ignore if */\n  if (typeof MutationObserver !== 'undefined') {\n    var counter = 1\n    var observer = new MutationObserver(nextTickHandler)\n    var textNode = document.createTextNode(counter)\n    observer.observe(textNode, {\n      characterData: true\n    })\n    timerFunc = function () {\n      counter = (counter + 1) % 2\n      textNode.data = counter\n    }\n  } else {\n    timerFunc = setTimeout\n  }\n  return function (cb, ctx) {\n    var func = ctx\n      ? function () { cb.call(ctx) }\n      : cb\n    callbacks.push(func)\n    if (pending) return\n    pending = true\n    timerFunc(nextTickHandler, 0)\n  }\n})()\n\n},{}],99:[function(require,module,exports){\nvar lang = require('./lang')\nvar extend = lang.extend\n\nextend(exports, lang)\nextend(exports, require('./env'))\nextend(exports, require('./dom'))\nextend(exports, require('./options'))\nextend(exports, require('./component'))\nextend(exports, require('./debug'))\n\n},{\"./component\":95,\"./debug\":96,\"./dom\":97,\"./env\":98,\"./lang\":100,\"./options\":101}],100:[function(require,module,exports){\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n * @public\n */\n\nexports.set = function set (obj, key, val) {\n  if (obj.hasOwnProperty(key)) {\n    obj[key] = val\n    return\n  }\n  if (obj._isVue) {\n    set(obj._data, key, val)\n    return\n  }\n  var ob = obj.__ob__\n  if (!ob) {\n    obj[key] = val\n    return\n  }\n  ob.convert(key, val)\n  ob.dep.notify()\n  if (ob.vms) {\n    var i = ob.vms.length\n    while (i--) {\n      var vm = ob.vms[i]\n      vm._proxy(key)\n      vm._digest()\n    }\n  }\n}\n\n/**\n * Delete a property and trigger change if necessary.\n *\n * @param {Object} obj\n * @param {String} key\n */\n\nexports.delete = function (obj, key) {\n  if (!obj.hasOwnProperty(key)) {\n    return\n  }\n  delete obj[key]\n  var ob = obj.__ob__\n  if (!ob) {\n    return\n  }\n  ob.dep.notify()\n  if (ob.vms) {\n    var i = ob.vms.length\n    while (i--) {\n      var vm = ob.vms[i]\n      vm._unproxy(key)\n      vm._digest()\n    }\n  }\n}\n\n/**\n * Check if an expression is a literal value.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nvar literalValueRE = /^\\s?(true|false|[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/\nexports.isLiteral = function (exp) {\n  return literalValueRE.test(exp)\n}\n\n/**\n * Check if a string starts with $ or _\n *\n * @param {String} str\n * @return {Boolean}\n */\n\nexports.isReserved = function (str) {\n  var c = (str + '').charCodeAt(0)\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Guard text output, make sure undefined outputs\n * empty string\n *\n * @param {*} value\n * @return {String}\n */\n\nexports.toString = function (value) {\n  return value == null\n    ? ''\n    : value.toString()\n}\n\n/**\n * Check and convert possible numeric strings to numbers\n * before setting back to data\n *\n * @param {*} value\n * @return {*|Number}\n */\n\nexports.toNumber = function (value) {\n  if (typeof value !== 'string') {\n    return value\n  } else {\n    var parsed = Number(value)\n    return isNaN(parsed)\n      ? value\n      : parsed\n  }\n}\n\n/**\n * Convert string boolean literals into real booleans.\n *\n * @param {*} value\n * @return {*|Boolean}\n */\n\nexports.toBoolean = function (value) {\n  return value === 'true'\n    ? true\n    : value === 'false'\n      ? false\n      : value\n}\n\n/**\n * Strip quotes from a string\n *\n * @param {String} str\n * @return {String | false}\n */\n\nexports.stripQuotes = function (str) {\n  var a = str.charCodeAt(0)\n  var b = str.charCodeAt(str.length - 1)\n  return a === b && (a === 0x22 || a === 0x27)\n    ? str.slice(1, -1)\n    : str\n}\n\n/**\n * Camelize a hyphen-delmited string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar camelizeRE = /-(\\w)/g\nexports.camelize = function (str) {\n  return str.replace(camelizeRE, toUpper)\n}\n\nfunction toUpper (_, c) {\n  return c ? c.toUpperCase() : ''\n}\n\n/**\n * Hyphenate a camelCase string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar hyphenateRE = /([a-z\\d])([A-Z])/g\nexports.hyphenate = function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n}\n\n/**\n * Converts hyphen/underscore/slash delimitered names into\n * camelized classNames.\n *\n * e.g. my-component => MyComponent\n *      some_else    => SomeElse\n *      some/comp    => SomeComp\n *\n * @param {String} str\n * @return {String}\n */\n\nvar classifyRE = /(?:^|[-_\\/])(\\w)/g\nexports.classify = function (str) {\n  return str.replace(classifyRE, toUpper)\n}\n\n/**\n * Simple bind, faster than native\n *\n * @param {Function} fn\n * @param {Object} ctx\n * @return {Function}\n */\n\nexports.bind = function (fn, ctx) {\n  return function (a) {\n    var l = arguments.length\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n}\n\n/**\n * Convert an Array-like object to a real Array.\n *\n * @param {Array-like} list\n * @param {Number} [start] - start index\n * @return {Array}\n */\n\nexports.toArray = function (list, start) {\n  start = start || 0\n  var i = list.length - start\n  var ret = new Array(i)\n  while (i--) {\n    ret[i] = list[i + start]\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n *\n * @param {Object} to\n * @param {Object} from\n */\n\nexports.extend = function (to, from) {\n  var keys = Object.keys(from)\n  var i = keys.length\n  while (i--) {\n    to[keys[i]] = from[keys[i]]\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nexports.isObject = function (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar toString = Object.prototype.toString\nvar OBJECT_STRING = '[object Object]'\nexports.isPlainObject = function (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Array type check.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nexports.isArray = Array.isArray\n\n/**\n * Define a non-enumerable property\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n * @param {Boolean} [enumerable]\n */\n\nexports.define = function (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  })\n}\n\n/**\n * Debounce a function so it only gets called after the\n * input stops arriving after the given wait period.\n *\n * @param {Function} func\n * @param {Number} wait\n * @return {Function} - the debounced function\n */\n\nexports.debounce = function (func, wait) {\n  var timeout, args, context, timestamp, result\n  var later = function () {\n    var last = Date.now() - timestamp\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last)\n    } else {\n      timeout = null\n      result = func.apply(context, args)\n      if (!timeout) context = args = null\n    }\n  }\n  return function () {\n    context = this\n    args = arguments\n    timestamp = Date.now()\n    if (!timeout) {\n      timeout = setTimeout(later, wait)\n    }\n    return result\n  }\n}\n\n/**\n * Manual indexOf because it's slightly faster than\n * native.\n *\n * @param {Array} arr\n * @param {*} obj\n */\n\nexports.indexOf = function (arr, obj) {\n  var i = arr.length\n  while (i--) {\n    if (arr[i] === obj) return i\n  }\n  return -1\n}\n\n/**\n * Make a cancellable version of an async callback.\n *\n * @param {Function} fn\n * @return {Function}\n */\n\nexports.cancellable = function (fn) {\n  var cb = function () {\n    if (!cb.cancelled) {\n      return fn.apply(this, arguments)\n    }\n  }\n  cb.cancel = function () {\n    cb.cancelled = true\n  }\n  return cb\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n *\n * @param {*} a\n * @param {*} b\n * @return {Boolean}\n */\n\nexports.looseEqual = function (a, b) {\n  /* eslint-disable eqeqeq */\n  return a == b || (\n    exports.isObject(a) && exports.isObject(b)\n      ? JSON.stringify(a) === JSON.stringify(b)\n      : false\n  )\n  /* eslint-enable eqeqeq */\n}\n\n},{}],101:[function(require,module,exports){\n(function (process){\nvar _ = require('./index')\nvar config = require('../config')\nvar extend = _.extend\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n *\n * All strategy functions follow the same signature:\n *\n * @param {*} parentVal\n * @param {*} childVal\n * @param {Vue} [vm]\n */\n\nvar strats = config.optionMergeStrategies = Object.create(null)\n\n/**\n * Helper that recursively merges two data objects together.\n */\n\nfunction mergeData (to, from) {\n  var key, toVal, fromVal\n  for (key in from) {\n    toVal = to[key]\n    fromVal = from[key]\n    if (!to.hasOwnProperty(key)) {\n      _.set(to, key, fromVal)\n    } else if (_.isObject(toVal) && _.isObject(fromVal)) {\n      mergeData(toVal, fromVal)\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.'\n      )\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\n/**\n * El\n */\n\nstrats.el = function (parentVal, childVal, vm) {\n  if (!vm && childVal && typeof childVal !== 'function') {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'The \"el\" option should be a function ' +\n      'that returns a per-instance value in component ' +\n      'definitions.'\n    )\n    return\n  }\n  var ret = childVal || parentVal\n  // invoke the element factory if this is instance merge\n  return vm && typeof ret === 'function'\n    ? ret.call(vm)\n    : ret\n}\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\n\nstrats.init =\nstrats.created =\nstrats.ready =\nstrats.attached =\nstrats.detached =\nstrats.beforeCompile =\nstrats.compiled =\nstrats.beforeDestroy =\nstrats.destroyed = function (parentVal, childVal) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : _.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\n/**\n * 0.11 deprecation warning\n */\n\nstrats.paramAttributes = function () {\n  /* istanbul ignore next */\n  process.env.NODE_ENV !== 'production' && _.warn(\n    '\"paramAttributes\" option has been deprecated in 0.12. ' +\n    'Use \"props\" instead.'\n  )\n}\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\n\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal)\n  return childVal\n    ? extend(res, guardArrayAssets(childVal))\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets\n})\n\n/**\n * Events & Watchers.\n *\n * Events & watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\n\nstrats.watch =\nstrats.events = function (parentVal, childVal) {\n  if (!childVal) return parentVal\n  if (!parentVal) return childVal\n  var ret = {}\n  extend(ret, parentVal)\n  for (var key in childVal) {\n    var parent = ret[key]\n    var child = childVal[key]\n    if (parent && !_.isArray(parent)) {\n      parent = [parent]\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child]\n  }\n  return ret\n}\n\n/**\n * Other object hashes.\n */\n\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) return parentVal\n  if (!parentVal) return childVal\n  var ret = Object.create(null)\n  extend(ret, parentVal)\n  extend(ret, childVal)\n  return ret\n}\n\n/**\n * Default strategy.\n */\n\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n}\n\n/**\n * Make sure component options get converted to actual\n * constructors.\n *\n * @param {Object} options\n */\n\nfunction guardComponents (options) {\n  if (options.components) {\n    var components = options.components =\n      guardArrayAssets(options.components)\n    var def\n    var ids = Object.keys(components)\n    for (var i = 0, l = ids.length; i < l; i++) {\n      var key = ids[i]\n      if (_.commonTagRE.test(key)) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'Do not use built-in HTML elements as component ' +\n          'id: ' + key\n        )\n        continue\n      }\n      def = components[key]\n      if (_.isPlainObject(def)) {\n        components[key] = _.Vue.extend(def)\n      }\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n *\n * @param {Object} options\n */\n\nfunction guardProps (options) {\n  var props = options.props\n  var i\n  if (_.isArray(props)) {\n    options.props = {}\n    i = props.length\n    while (i--) {\n      options.props[props[i]] = null\n    }\n  } else if (_.isPlainObject(props)) {\n    var keys = Object.keys(props)\n    i = keys.length\n    while (i--) {\n      var val = props[keys[i]]\n      if (typeof val === 'function') {\n        props[keys[i]] = { type: val }\n      }\n    }\n  }\n}\n\n/**\n * Guard an Array-format assets option and converted it\n * into the key-value Object format.\n *\n * @param {Object|Array} assets\n * @return {Object}\n */\n\nfunction guardArrayAssets (assets) {\n  if (_.isArray(assets)) {\n    var res = {}\n    var i = assets.length\n    var asset\n    while (i--) {\n      asset = assets[i]\n      var id = typeof asset === 'function'\n        ? ((asset.options && asset.options.name) || asset.id)\n        : (asset.name || asset.id)\n      if (!id) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'Array-syntax assets must provide a \"name\" or \"id\" field.'\n        )\n      } else {\n        res[id] = asset\n      }\n    }\n    return res\n  }\n  return assets\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n *\n * @param {Object} parent\n * @param {Object} child\n * @param {Vue} [vm] - if vm is present, indicates this is\n *                     an instantiation merge.\n */\n\nexports.mergeOptions = function merge (parent, child, vm) {\n  guardComponents(child)\n  guardProps(child)\n  var options = {}\n  var key\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = merge(parent, child.mixins[i], vm)\n    }\n  }\n  for (key in parent) {\n    mergeField(key)\n  }\n  for (key in child) {\n    if (!(parent.hasOwnProperty(key))) {\n      mergeField(key)\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key)\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n *\n * @param {Object} options\n * @param {String} type\n * @param {String} id\n * @return {Object|Function}\n */\n\nexports.resolveAsset = function resolve (options, type, id) {\n  var assets = options[type]\n  var camelizedId\n  return assets[id] ||\n    // camelCase ID\n    assets[camelizedId = _.camelize(id)] ||\n    // Pascal Case ID\n    assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)]\n}\n\n}).call(this,require('_process'))\n\n},{\"../config\":48,\"./index\":99,\"_process\":1}],102:[function(require,module,exports){\n(function (process){\nvar _ = require('./util')\nvar extend = _.extend\n\n/**\n * The exposed Vue constructor.\n *\n * API conventions:\n * - public API methods/properties are prefiexed with `$`\n * - internal methods/properties are prefixed with `_`\n * - non-prefixed properties are assumed to be proxied user\n *   data.\n *\n * @constructor\n * @param {Object} [options]\n * @public\n */\n\nfunction Vue (options) {\n  this._init(options)\n}\n\n/**\n * Mixin global API\n */\n\nextend(Vue, require('./api/global'))\n\n/**\n * Vue and every constructor that extends Vue has an\n * associated options object, which can be accessed during\n * compilation steps as `this.constructor.options`.\n *\n * These can be seen as the default options of every\n * Vue instance.\n */\n\nVue.options = {\n  replace: true,\n  directives: require('./directives/public'),\n  elementDirectives: require('./directives/element'),\n  filters: require('./filters'),\n  transitions: {},\n  components: {},\n  partials: {}\n}\n\n/**\n * Build up the prototype\n */\n\nvar p = Vue.prototype\n\n/**\n * $data has a setter which does a bunch of\n * teardown/setup work\n */\n\nObject.defineProperty(p, '$data', {\n  get: function () {\n    return this._data\n  },\n  set: function (newData) {\n    if (newData !== this._data) {\n      this._setData(newData)\n    }\n  }\n})\n\n/**\n * Mixin internal instance methods\n */\n\nextend(p, require('./instance/init'))\nextend(p, require('./instance/events'))\nextend(p, require('./instance/state'))\nextend(p, require('./instance/lifecycle'))\nextend(p, require('./instance/misc'))\n\n/**\n * Mixin public API methods\n */\n\nextend(p, require('./api/data'))\nextend(p, require('./api/dom'))\nextend(p, require('./api/events'))\nextend(p, require('./api/lifecycle'))\n\nVue.version = '1.0.4'\nmodule.exports = _.Vue = Vue\n\n/* istanbul ignore if */\nif (process.env.NODE_ENV !== 'production') {\n  if (_.inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {\n    window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('init', Vue)\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"./api/data\":37,\"./api/dom\":38,\"./api/events\":39,\"./api/global\":40,\"./api/lifecycle\":41,\"./directives/element\":50,\"./directives/public\":65,\"./filters\":76,\"./instance/events\":79,\"./instance/init\":80,\"./instance/lifecycle\":81,\"./instance/misc\":82,\"./instance/state\":83,\"./util\":99,\"_process\":1}],103:[function(require,module,exports){\n(function (process){\nvar _ = require('./util')\nvar config = require('./config')\nvar Dep = require('./observer/dep')\nvar expParser = require('./parsers/expression')\nvar batcher = require('./batcher')\nvar uid = 0\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n *\n * @param {Vue} vm\n * @param {String} expression\n * @param {Function} cb\n * @param {Object} options\n *                 - {Array} filters\n *                 - {Boolean} twoWay\n *                 - {Boolean} deep\n *                 - {Boolean} user\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n *                 - {Function} [preProcess]\n *                 - {Function} [postProcess]\n * @constructor\n */\n\nfunction Watcher (vm, expOrFn, cb, options) {\n  // mix in options\n  if (options) {\n    _.extend(this, options)\n  }\n  var isFn = typeof expOrFn === 'function'\n  this.vm = vm\n  vm._watchers.push(this)\n  this.expression = isFn ? expOrFn.toString() : expOrFn\n  this.cb = cb\n  this.id = ++uid // uid for batching\n  this.active = true\n  this.dirty = this.lazy // for lazy watchers\n  this.deps = Object.create(null)\n  this.newDeps = null\n  this.prevError = null // for async error stacks\n  // parse expression for getter/setter\n  if (isFn) {\n    this.getter = expOrFn\n    this.setter = undefined\n  } else {\n    var res = expParser.parse(expOrFn, this.twoWay)\n    this.getter = res.get\n    this.setter = res.set\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get()\n  // state for avoiding false triggers for deep and Array\n  // watchers during vm._digest()\n  this.queued = this.shallow = false\n}\n\n/**\n * Add a dependency to this directive.\n *\n * @param {Dep} dep\n */\n\nWatcher.prototype.addDep = function (dep) {\n  var id = dep.id\n  if (!this.newDeps[id]) {\n    this.newDeps[id] = dep\n    if (!this.deps[id]) {\n      this.deps[id] = dep\n      dep.addSub(this)\n    }\n  }\n}\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\nWatcher.prototype.get = function () {\n  this.beforeGet()\n  var scope = this.scope || this.vm\n  var value\n  try {\n    value = this.getter.call(scope, scope)\n  } catch (e) {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      config.warnExpressionErrors\n    ) {\n      _.warn(\n        'Error when evaluating expression \"' +\n        this.expression + '\". ' +\n        (config.debug\n          ? ''\n          : 'Turn on debug mode to see stack trace.'\n        ), e\n      )\n    }\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value)\n  }\n  if (this.preProcess) {\n    value = this.preProcess(value)\n  }\n  if (this.filters) {\n    value = scope._applyFilters(value, null, this.filters, false)\n  }\n  if (this.postProcess) {\n    value = this.postProcess(value)\n  }\n  this.afterGet()\n  return value\n}\n\n/**\n * Set the corresponding value with the setter.\n *\n * @param {*} value\n */\n\nWatcher.prototype.set = function (value) {\n  var scope = this.scope || this.vm\n  if (this.filters) {\n    value = scope._applyFilters(\n      value, this.value, this.filters, true)\n  }\n  try {\n    this.setter.call(scope, scope, value)\n  } catch (e) {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      config.warnExpressionErrors\n    ) {\n      _.warn(\n        'Error when evaluating setter \"' +\n        this.expression + '\"', e\n      )\n    }\n  }\n  // two-way sync for v-for alias\n  var forContext = scope.$forContext\n  if (process.env.NODE_ENV !== 'production') {\n    if (\n      forContext &&\n      forContext.filters &&\n      (new RegExp(forContext.alias + '\\\\b')).test(this.expression)\n    ) {\n      _.warn(\n        'It seems you are using two-way binding on ' +\n        'a v-for alias (' + this.expression + '), and the ' +\n        'v-for has filters. This will not work properly. ' +\n        'Either remove the filters or use an array of ' +\n        'objects and bind to object properties instead.'\n      )\n    }\n  }\n  if (\n    forContext &&\n    forContext.alias === this.expression &&\n    !forContext.filters\n  ) {\n    if (scope.$key) { // original is an object\n      forContext.rawValue[scope.$key] = value\n    } else {\n      forContext.rawValue.$set(scope.$index, value)\n    }\n  }\n}\n\n/**\n * Prepare for dependency collection.\n */\n\nWatcher.prototype.beforeGet = function () {\n  Dep.target = this\n  this.newDeps = Object.create(null)\n}\n\n/**\n * Clean up for dependency collection.\n */\n\nWatcher.prototype.afterGet = function () {\n  Dep.target = null\n  var ids = Object.keys(this.deps)\n  var i = ids.length\n  while (i--) {\n    var id = ids[i]\n    if (!this.newDeps[id]) {\n      this.deps[id].removeSub(this)\n    }\n  }\n  this.deps = this.newDeps\n}\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n *\n * @param {Boolean} shallow\n */\n\nWatcher.prototype.update = function (shallow) {\n  if (this.lazy) {\n    this.dirty = true\n  } else if (this.sync || !config.async) {\n    this.run()\n  } else {\n    // if queued, only overwrite shallow with non-shallow,\n    // but not the other way around.\n    this.shallow = this.queued\n      ? shallow\n        ? this.shallow\n        : false\n      : !!shallow\n    this.queued = true\n    // record before-push error stack in debug mode\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.debug) {\n      this.prevError = new Error('[vue] async stack trace')\n    }\n    batcher.push(this)\n  }\n}\n\n/**\n * Batcher job interface.\n * Will be called by the batcher.\n */\n\nWatcher.prototype.run = function () {\n  if (this.active) {\n    var value = this.get()\n    if (\n      value !== this.value ||\n      // Deep watchers and Array watchers should fire even\n      // when the value is the same, because the value may\n      // have mutated; but only do so if this is a\n      // non-shallow update (caused by a vm digest).\n      ((_.isArray(value) || this.deep) && !this.shallow)\n    ) {\n      // set new value\n      var oldValue = this.value\n      this.value = value\n      // in debug + async mode, when a watcher callbacks\n      // throws, we also throw the saved before-push error\n      // so the full cross-tick stack trace is available.\n      var prevError = this.prevError\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' &&\n          config.debug && prevError) {\n        this.prevError = null\n        try {\n          this.cb.call(this.vm, value, oldValue)\n        } catch (e) {\n          _.nextTick(function () {\n            throw prevError\n          }, 0)\n          throw e\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue)\n      }\n    }\n    this.queued = this.shallow = false\n  }\n}\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\n\nWatcher.prototype.evaluate = function () {\n  // avoid overwriting another watcher that is being\n  // collected.\n  var current = Dep.target\n  this.value = this.get()\n  this.dirty = false\n  Dep.target = current\n}\n\n/**\n * Depend on all deps collected by this watcher.\n */\n\nWatcher.prototype.depend = function () {\n  var depIds = Object.keys(this.deps)\n  var i = depIds.length\n  while (i--) {\n    this.deps[depIds[i]].depend()\n  }\n}\n\n/**\n * Remove self from all dependencies' subcriber list.\n */\n\nWatcher.prototype.teardown = function () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // we can skip this if the vm if being destroyed\n    // which can improve teardown performance.\n    if (!this.vm._isBeingDestroyed) {\n      this.vm._watchers.$remove(this)\n    }\n    var depIds = Object.keys(this.deps)\n    var i = depIds.length\n    while (i--) {\n      this.deps[depIds[i]].removeSub(this)\n    }\n    this.active = false\n    this.vm = this.cb = this.value = null\n  }\n}\n\n/**\n * Recrusively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n *\n * @param {*} val\n */\n\nfunction traverse (val) {\n  var i, keys\n  if (_.isArray(val)) {\n    i = val.length\n    while (i--) traverse(val[i])\n  } else if (_.isObject(val)) {\n    keys = Object.keys(val)\n    i = keys.length\n    while (i--) traverse(val[keys[i]])\n  }\n}\n\nmodule.exports = Watcher\n\n}).call(this,require('_process'))\n\n},{\"./batcher\":42,\"./config\":48,\"./observer/dep\":85,\"./parsers/expression\":88,\"./util\":99,\"_process\":1}],104:[function(require,module,exports){\nvar inserted = exports.cache = {}\n\nexports.insert = function (css) {\n  if (inserted[css]) return\n  inserted[css] = true\n\n  var elem = document.createElement('style')\n  elem.setAttribute('type', 'text/css')\n\n  if ('textContent' in elem) {\n    elem.textContent = css\n  } else {\n    elem.styleSheet.cssText = css\n  }\n\n  document.getElementsByTagName('head')[0].appendChild(elem)\n  return elem\n}\n\n},{}],105:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar makePromise = require('./makePromise');\n\tvar Scheduler = require('./Scheduler');\n\tvar async = require('./env').asap;\n\n\treturn makePromise({\n\t\tscheduler: new Scheduler(async)\n\t});\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n},{\"./Scheduler\":106,\"./env\":118,\"./makePromise\":120}],106:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for next-tick conflation.\n\n\t/**\n\t * Async task scheduler\n\t * @param {function} async function to schedule a single async function\n\t * @constructor\n\t */\n\tfunction Scheduler(async) {\n\t\tthis._async = async;\n\t\tthis._running = false;\n\n\t\tthis._queue = this;\n\t\tthis._queueLen = 0;\n\t\tthis._afterQueue = {};\n\t\tthis._afterQueueLen = 0;\n\n\t\tvar self = this;\n\t\tthis.drain = function() {\n\t\t\tself._drain();\n\t\t};\n\t}\n\n\t/**\n\t * Enqueue a task\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.enqueue = function(task) {\n\t\tthis._queue[this._queueLen++] = task;\n\t\tthis.run();\n\t};\n\n\t/**\n\t * Enqueue a task to run after the main task queue\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.afterQueue = function(task) {\n\t\tthis._afterQueue[this._afterQueueLen++] = task;\n\t\tthis.run();\n\t};\n\n\tScheduler.prototype.run = function() {\n\t\tif (!this._running) {\n\t\t\tthis._running = true;\n\t\t\tthis._async(this.drain);\n\t\t}\n\t};\n\n\t/**\n\t * Drain the handler queue entirely, and then the after queue\n\t */\n\tScheduler.prototype._drain = function() {\n\t\tvar i = 0;\n\t\tfor (; i < this._queueLen; ++i) {\n\t\t\tthis._queue[i].run();\n\t\t\tthis._queue[i] = void 0;\n\t\t}\n\n\t\tthis._queueLen = 0;\n\t\tthis._running = false;\n\n\t\tfor (i = 0; i < this._afterQueueLen; ++i) {\n\t\t\tthis._afterQueue[i].run();\n\t\t\tthis._afterQueue[i] = void 0;\n\t\t}\n\n\t\tthis._afterQueueLen = 0;\n\t};\n\n\treturn Scheduler;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],107:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\t/**\n\t * Custom error type for promises rejected by promise.timeout\n\t * @param {string} message\n\t * @constructor\n\t */\n\tfunction TimeoutError (message) {\n\t\tError.call(this);\n\t\tthis.message = message;\n\t\tthis.name = TimeoutError.name;\n\t\tif (typeof Error.captureStackTrace === 'function') {\n\t\t\tError.captureStackTrace(this, TimeoutError);\n\t\t}\n\t}\n\n\tTimeoutError.prototype = Object.create(Error.prototype);\n\tTimeoutError.prototype.constructor = TimeoutError;\n\n\treturn TimeoutError;\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n},{}],108:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\tmakeApply.tryCatchResolve = tryCatchResolve;\n\n\treturn makeApply;\n\n\tfunction makeApply(Promise, call) {\n\t\tif(arguments.length < 2) {\n\t\t\tcall = tryCatchResolve;\n\t\t}\n\n\t\treturn apply;\n\n\t\tfunction apply(f, thisArg, args) {\n\t\t\tvar p = Promise._defer();\n\t\t\tvar l = args.length;\n\t\t\tvar params = new Array(l);\n\t\t\tcallAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);\n\n\t\t\treturn p;\n\t\t}\n\n\t\tfunction callAndResolve(c, h) {\n\t\t\tif(c.i < 0) {\n\t\t\t\treturn call(c.f, c.thisArg, c.params, h);\n\t\t\t}\n\n\t\t\tvar handler = Promise._handler(c.args[c.i]);\n\t\t\thandler.fold(callAndResolveNext, c, void 0, h);\n\t\t}\n\n\t\tfunction callAndResolveNext(c, x, h) {\n\t\t\tc.params[c.i] = x;\n\t\t\tc.i -= 1;\n\t\t\tcallAndResolve(c, h);\n\t\t}\n\t}\n\n\tfunction tryCatchResolve(f, thisArg, args, resolver) {\n\t\ttry {\n\t\t\tresolver.resolve(f.apply(thisArg, args));\n\t\t} catch(e) {\n\t\t\tresolver.reject(e);\n\t\t}\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n},{}],109:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar state = require('../state');\n\tvar applier = require('../apply');\n\n\treturn function array(Promise) {\n\n\t\tvar applyFold = applier(Promise);\n\t\tvar toPromise = Promise.resolve;\n\t\tvar all = Promise.all;\n\n\t\tvar ar = Array.prototype.reduce;\n\t\tvar arr = Array.prototype.reduceRight;\n\t\tvar slice = Array.prototype.slice;\n\n\t\t// Additional array combinators\n\n\t\tPromise.any = any;\n\t\tPromise.some = some;\n\t\tPromise.settle = settle;\n\n\t\tPromise.map = map;\n\t\tPromise.filter = filter;\n\t\tPromise.reduce = reduce;\n\t\tPromise.reduceRight = reduceRight;\n\n\t\t/**\n\t\t * When this promise fulfills with an array, do\n\t\t * onFulfilled.apply(void 0, array)\n\t\t * @param {function} onFulfilled function to apply\n\t\t * @returns {Promise} promise for the result of applying onFulfilled\n\t\t */\n\t\tPromise.prototype.spread = function(onFulfilled) {\n\t\t\treturn this.then(all).then(function(array) {\n\t\t\t\treturn onFulfilled.apply(this, array);\n\t\t\t});\n\t\t};\n\n\t\treturn Promise;\n\n\t\t/**\n\t\t * One-winner competitive race.\n\t\t * Return a promise that will fulfill when one of the promises\n\t\t * in the input array fulfills, or will reject when all promises\n\t\t * have rejected.\n\t\t * @param {array} promises\n\t\t * @returns {Promise} promise for the first fulfilled value\n\t\t */\n\t\tfunction any(promises) {\n\t\t\tvar p = Promise._defer();\n\t\t\tvar resolver = p._handler;\n\t\t\tvar l = promises.length>>>0;\n\n\t\t\tvar pending = l;\n\t\t\tvar errors = [];\n\n\t\t\tfor (var h, x, i = 0; i < l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = Promise._handler(x);\n\t\t\t\tif(h.state() > 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tPromise._visitRemaining(promises, i, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, handleFulfill, handleReject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.reject(new RangeError('any(): array must not be empty'));\n\t\t\t}\n\n\t\t\treturn p;\n\n\t\t\tfunction handleFulfill(x) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\terrors = null;\n\t\t\t\tthis.resolve(x); // this === resolver\n\t\t\t}\n\n\t\t\tfunction handleReject(e) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terrors.push(e);\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tthis.reject(errors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * N-winner competitive race\n\t\t * Return a promise that will fulfill when n input promises have\n\t\t * fulfilled, or will reject when it becomes impossible for n\n\t\t * input promises to fulfill (ie when promises.length - n + 1\n\t\t * have rejected)\n\t\t * @param {array} promises\n\t\t * @param {number} n\n\t\t * @returns {Promise} promise for the earliest n fulfillment values\n\t\t *\n\t\t * @deprecated\n\t\t */\n\t\tfunction some(promises, n) {\n\t\t\t/*jshint maxcomplexity:7*/\n\t\t\tvar p = Promise._defer();\n\t\t\tvar resolver = p._handler;\n\n\t\t\tvar results = [];\n\t\t\tvar errors = [];\n\n\t\t\tvar l = promises.length>>>0;\n\t\t\tvar nFulfill = 0;\n\t\t\tvar nReject;\n\t\t\tvar x, i; // reused in both for() loops\n\n\t\t\t// First pass: count actual array items\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t++nFulfill;\n\t\t\t}\n\n\t\t\t// Compute actual goals\n\t\t\tn = Math.max(n, 0);\n\t\t\tnReject = (nFulfill - n + 1);\n\t\t\tnFulfill = Math.min(n, nFulfill);\n\n\t\t\tif(n > nFulfill) {\n\t\t\t\tresolver.reject(new RangeError('some(): array must contain at least '\n\t\t\t\t+ n + ' item(s), but had ' + nFulfill));\n\t\t\t} else if(nFulfill === 0) {\n\t\t\t\tresolver.resolve(results);\n\t\t\t}\n\n\t\t\t// Second pass: observe each array item, make progress toward goals\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPromise._handler(x).visit(resolver, fulfill, reject, resolver.notify);\n\t\t\t}\n\n\t\t\treturn p;\n\n\t\t\tfunction fulfill(x) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresults.push(x);\n\t\t\t\tif(--nFulfill === 0) {\n\t\t\t\t\terrors = null;\n\t\t\t\t\tthis.resolve(results);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction reject(e) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terrors.push(e);\n\t\t\t\tif(--nReject === 0) {\n\t\t\t\t\tresults = null;\n\t\t\t\t\tthis.reject(errors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Apply f to the value of each promise in a list of promises\n\t\t * and return a new list containing the results.\n\t\t * @param {array} promises\n\t\t * @param {function(x:*, index:Number):*} f mapping function\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction map(promises, f) {\n\t\t\treturn Promise._traverse(f, promises);\n\t\t}\n\n\t\t/**\n\t\t * Filter the provided array of promises using the provided predicate.  Input may\n\t\t * contain promises and values\n\t\t * @param {Array} promises array of promises and values\n\t\t * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n\t\t *  Must return truthy (or promise for truthy) for items to retain.\n\t\t * @returns {Promise} promise that will fulfill with an array containing all items\n\t\t *  for which predicate returned truthy.\n\t\t */\n\t\tfunction filter(promises, predicate) {\n\t\t\tvar a = slice.call(promises);\n\t\t\treturn Promise._traverse(predicate, a).then(function(keep) {\n\t\t\t\treturn filterSync(a, keep);\n\t\t\t});\n\t\t}\n\n\t\tfunction filterSync(promises, keep) {\n\t\t\t// Safe because we know all promises have fulfilled if we've made it this far\n\t\t\tvar l = keep.length;\n\t\t\tvar filtered = new Array(l);\n\t\t\tfor(var i=0, j=0; i<l; ++i) {\n\t\t\t\tif(keep[i]) {\n\t\t\t\t\tfiltered[j++] = Promise._handler(promises[i]).value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiltered.length = j;\n\t\t\treturn filtered;\n\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that will always fulfill with an array containing\n\t\t * the outcome states of all input promises.  The returned promise\n\t\t * will never reject.\n\t\t * @param {Array} promises\n\t\t * @returns {Promise} promise for array of settled state descriptors\n\t\t */\n\t\tfunction settle(promises) {\n\t\t\treturn all(promises.map(settleOne));\n\t\t}\n\n\t\tfunction settleOne(p) {\n\t\t\tvar h = Promise._handler(p);\n\t\t\tif(h.state() === 0) {\n\t\t\t\treturn toPromise(p).then(state.fulfilled, state.rejected);\n\t\t\t}\n\n\t\t\th._unreport();\n\t\t\treturn state.inspect(h);\n\t\t}\n\n\t\t/**\n\t\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t\t * input may contain promises and/or values, and reduceFunc\n\t\t * may return either a value or a promise, *and* initialValue may\n\t\t * be a promise for the starting value.\n\t\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t\t *      may contain a mix of promises and values.\n\t\t * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n\t\t * @returns {Promise} that will resolve to the final reduced value\n\t\t */\n\t\tfunction reduce(promises, f /*, initialValue */) {\n\t\t\treturn arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])\n\t\t\t\t\t: ar.call(promises, liftCombine(f));\n\t\t}\n\n\t\t/**\n\t\t * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but\n\t\t * input may contain promises and/or values, and reduceFunc\n\t\t * may return either a value or a promise, *and* initialValue may\n\t\t * be a promise for the starting value.\n\t\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t\t *      may contain a mix of promises and values.\n\t\t * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n\t\t * @returns {Promise} that will resolve to the final reduced value\n\t\t */\n\t\tfunction reduceRight(promises, f /*, initialValue */) {\n\t\t\treturn arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])\n\t\t\t\t\t: arr.call(promises, liftCombine(f));\n\t\t}\n\n\t\tfunction liftCombine(f) {\n\t\t\treturn function(z, x, i) {\n\t\t\t\treturn applyFold(f, void 0, [z,x,i]);\n\t\t\t};\n\t\t}\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n},{\"../apply\":108,\"../state\":121}],110:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function flow(Promise) {\n\n\t\tvar resolve = Promise.resolve;\n\t\tvar reject = Promise.reject;\n\t\tvar origCatch = Promise.prototype['catch'];\n\n\t\t/**\n\t\t * Handle the ultimate fulfillment value or rejection reason, and assume\n\t\t * responsibility for all errors.  If an error propagates out of result\n\t\t * or handleFatalError, it will be rethrown to the host, resulting in a\n\t\t * loud stack track on most platforms and a crash on some.\n\t\t * @param {function?} onResult\n\t\t * @param {function?} onError\n\t\t * @returns {undefined}\n\t\t */\n\t\tPromise.prototype.done = function(onResult, onError) {\n\t\t\tthis._handler.visit(this._handler.receiver, onResult, onError);\n\t\t};\n\n\t\t/**\n\t\t * Add Error-type and predicate matching to catch.  Examples:\n\t\t * promise.catch(TypeError, handleTypeError)\n\t\t *   .catch(predicate, handleMatchedErrors)\n\t\t *   .catch(handleRemainingErrors)\n\t\t * @param onRejected\n\t\t * @returns {*}\n\t\t */\n\t\tPromise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {\n\t\t\tif (arguments.length < 2) {\n\t\t\t\treturn origCatch.call(this, onRejected);\n\t\t\t}\n\n\t\t\tif(typeof onRejected !== 'function') {\n\t\t\t\treturn this.ensure(rejectInvalidPredicate);\n\t\t\t}\n\n\t\t\treturn origCatch.call(this, createCatchFilter(arguments[1], onRejected));\n\t\t};\n\n\t\t/**\n\t\t * Wraps the provided catch handler, so that it will only be called\n\t\t * if the predicate evaluates truthy\n\t\t * @param {?function} handler\n\t\t * @param {function} predicate\n\t\t * @returns {function} conditional catch handler\n\t\t */\n\t\tfunction createCatchFilter(handler, predicate) {\n\t\t\treturn function(e) {\n\t\t\t\treturn evaluatePredicate(e, predicate)\n\t\t\t\t\t? handler.call(this, e)\n\t\t\t\t\t: reject(e);\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} handler handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype['finally'] = Promise.prototype.ensure = function(handler) {\n\t\t\tif(typeof handler !== 'function') {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\treturn this.then(function(x) {\n\t\t\t\treturn runSideEffect(handler, this, identity, x);\n\t\t\t}, function(e) {\n\t\t\t\treturn runSideEffect(handler, this, reject, e);\n\t\t\t});\n\t\t};\n\n\t\tfunction runSideEffect (handler, thisArg, propagate, value) {\n\t\t\tvar result = handler.call(thisArg);\n\t\t\treturn maybeThenable(result)\n\t\t\t\t? propagateValue(result, propagate, value)\n\t\t\t\t: propagate(value);\n\t\t}\n\n\t\tfunction propagateValue (result, propagate, x) {\n\t\t\treturn resolve(result).then(function () {\n\t\t\t\treturn propagate(x);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Recover from a failure by returning a defaultValue.  If defaultValue\n\t\t * is a promise, it's fulfillment value will be used.  If defaultValue is\n\t\t * a promise that rejects, the returned promise will reject with the\n\t\t * same reason.\n\t\t * @param {*} defaultValue\n\t\t * @returns {Promise} new promise\n\t\t */\n\t\tPromise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {\n\t\t\treturn this.then(void 0, function() {\n\t\t\t\treturn defaultValue;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\tPromise.prototype['yield'] = function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Runs a side effect when this promise fulfills, without changing the\n\t\t * fulfillment value.\n\t\t * @param {function} onFulfilledSideEffect\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.tap = function(onFulfilledSideEffect) {\n\t\t\treturn this.then(onFulfilledSideEffect)['yield'](this);\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n\tfunction rejectInvalidPredicate() {\n\t\tthrow new TypeError('catch predicate must be a function');\n\t}\n\n\tfunction evaluatePredicate(e, predicate) {\n\t\treturn isError(predicate) ? e instanceof predicate : predicate(e);\n\t}\n\n\tfunction isError(predicate) {\n\t\treturn predicate === Error\n\t\t\t|| (predicate != null && predicate.prototype instanceof Error);\n\t}\n\n\tfunction maybeThenable(x) {\n\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t}\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],111:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n/** @author Jeff Escalante */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function fold(Promise) {\n\n\t\tPromise.prototype.fold = function(f, z) {\n\t\t\tvar promise = this._beget();\n\n\t\t\tthis._handler.fold(function(z, x, to) {\n\t\t\t\tPromise._handler(z).fold(function(x, z, to) {\n\t\t\t\t\tto.resolve(f.call(this, z, x));\n\t\t\t\t}, x, this, to);\n\t\t\t}, z, promise._handler.receiver, promise._handler);\n\n\t\t\treturn promise;\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],112:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar inspect = require('../state').inspect;\n\n\treturn function inspection(Promise) {\n\n\t\tPromise.prototype.inspect = function() {\n\t\t\treturn inspect(Promise._handler(this));\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n},{\"../state\":121}],113:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function generate(Promise) {\n\n\t\tvar resolve = Promise.resolve;\n\n\t\tPromise.iterate = iterate;\n\t\tPromise.unfold = unfold;\n\n\t\treturn Promise;\n\n\t\t/**\n\t\t * @deprecated Use github.com/cujojs/most streams and most.iterate\n\t\t * Generate a (potentially infinite) stream of promised values:\n\t\t * x, f(x), f(f(x)), etc. until condition(x) returns true\n\t\t * @param {function} f function to generate a new x from the previous x\n\t\t * @param {function} condition function that, given the current x, returns\n\t\t *  truthy when the iterate should stop\n\t\t * @param {function} handler function to handle the value produced by f\n\t\t * @param {*|Promise} x starting value, may be a promise\n\t\t * @return {Promise} the result of the last call to f before\n\t\t *  condition returns true\n\t\t */\n\t\tfunction iterate(f, condition, handler, x) {\n\t\t\treturn unfold(function(x) {\n\t\t\t\treturn [x, f(x)];\n\t\t\t}, condition, handler, x);\n\t\t}\n\n\t\t/**\n\t\t * @deprecated Use github.com/cujojs/most streams and most.unfold\n\t\t * Generate a (potentially infinite) stream of promised values\n\t\t * by applying handler(generator(seed)) iteratively until\n\t\t * condition(seed) returns true.\n\t\t * @param {function} unspool function that generates a [value, newSeed]\n\t\t *  given a seed.\n\t\t * @param {function} condition function that, given the current seed, returns\n\t\t *  truthy when the unfold should stop\n\t\t * @param {function} handler function to handle the value produced by unspool\n\t\t * @param x {*|Promise} starting value, may be a promise\n\t\t * @return {Promise} the result of the last value produced by unspool before\n\t\t *  condition returns true\n\t\t */\n\t\tfunction unfold(unspool, condition, handler, x) {\n\t\t\treturn resolve(x).then(function(seed) {\n\t\t\t\treturn resolve(condition(seed)).then(function(done) {\n\t\t\t\t\treturn done ? seed : resolve(unspool(seed)).spread(next);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tfunction next(item, newSeed) {\n\t\t\t\treturn resolve(handler(item)).then(function() {\n\t\t\t\t\treturn unfold(unspool, condition, handler, newSeed);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],114:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function progress(Promise) {\n\n\t\t/**\n\t\t * @deprecated\n\t\t * Register a progress handler for this promise\n\t\t * @param {function} onProgress\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.progress = function(onProgress) {\n\t\t\treturn this.then(void 0, void 0, onProgress);\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],115:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar env = require('../env');\n\tvar TimeoutError = require('../TimeoutError');\n\n\tfunction setTimeout(f, ms, x, y) {\n\t\treturn env.setTimer(function() {\n\t\t\tf(x, y, ms);\n\t\t}, ms);\n\t}\n\n\treturn function timed(Promise) {\n\t\t/**\n\t\t * Return a new promise whose fulfillment value is revealed only\n\t\t * after ms milliseconds\n\t\t * @param {number} ms milliseconds\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.delay = function(ms) {\n\t\t\tvar p = this._beget();\n\t\t\tthis._handler.fold(handleDelay, ms, void 0, p._handler);\n\t\t\treturn p;\n\t\t};\n\n\t\tfunction handleDelay(ms, x, h) {\n\t\t\tsetTimeout(resolveDelay, ms, x, h);\n\t\t}\n\n\t\tfunction resolveDelay(x, h) {\n\t\t\th.resolve(x);\n\t\t}\n\n\t\t/**\n\t\t * Return a new promise that rejects after ms milliseconds unless\n\t\t * this promise fulfills earlier, in which case the returned promise\n\t\t * fulfills with the same value.\n\t\t * @param {number} ms milliseconds\n\t\t * @param {Error|*=} reason optional rejection reason to use, defaults\n\t\t *   to a TimeoutError if not provided\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.timeout = function(ms, reason) {\n\t\t\tvar p = this._beget();\n\t\t\tvar h = p._handler;\n\n\t\t\tvar t = setTimeout(onTimeout, ms, reason, p._handler);\n\n\t\t\tthis._handler.visit(h,\n\t\t\t\tfunction onFulfill(x) {\n\t\t\t\t\tenv.clearTimer(t);\n\t\t\t\t\tthis.resolve(x); // this = h\n\t\t\t\t},\n\t\t\t\tfunction onReject(x) {\n\t\t\t\t\tenv.clearTimer(t);\n\t\t\t\t\tthis.reject(x); // this = h\n\t\t\t\t},\n\t\t\t\th.notify);\n\n\t\t\treturn p;\n\t\t};\n\n\t\tfunction onTimeout(reason, h, ms) {\n\t\t\tvar e = typeof reason === 'undefined'\n\t\t\t\t? new TimeoutError('timed out after ' + ms + 'ms')\n\t\t\t\t: reason;\n\t\t\th.reject(e);\n\t\t}\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n},{\"../TimeoutError\":107,\"../env\":118}],116:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar setTimer = require('../env').setTimer;\n\tvar format = require('../format');\n\n\treturn function unhandledRejection(Promise) {\n\n\t\tvar logError = noop;\n\t\tvar logInfo = noop;\n\t\tvar localConsole;\n\n\t\tif(typeof console !== 'undefined') {\n\t\t\t// Alias console to prevent things like uglify's drop_console option from\n\t\t\t// removing console.log/error. Unhandled rejections fall into the same\n\t\t\t// category as uncaught exceptions, and build tools shouldn't silence them.\n\t\t\tlocalConsole = console;\n\t\t\tlogError = typeof localConsole.error !== 'undefined'\n\t\t\t\t? function (e) { localConsole.error(e); }\n\t\t\t\t: function (e) { localConsole.log(e); };\n\n\t\t\tlogInfo = typeof localConsole.info !== 'undefined'\n\t\t\t\t? function (e) { localConsole.info(e); }\n\t\t\t\t: function (e) { localConsole.log(e); };\n\t\t}\n\n\t\tPromise.onPotentiallyUnhandledRejection = function(rejection) {\n\t\t\tenqueue(report, rejection);\n\t\t};\n\n\t\tPromise.onPotentiallyUnhandledRejectionHandled = function(rejection) {\n\t\t\tenqueue(unreport, rejection);\n\t\t};\n\n\t\tPromise.onFatalRejection = function(rejection) {\n\t\t\tenqueue(throwit, rejection.value);\n\t\t};\n\n\t\tvar tasks = [];\n\t\tvar reported = [];\n\t\tvar running = null;\n\n\t\tfunction report(r) {\n\t\t\tif(!r.handled) {\n\t\t\t\treported.push(r);\n\t\t\t\tlogError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));\n\t\t\t}\n\t\t}\n\n\t\tfunction unreport(r) {\n\t\t\tvar i = reported.indexOf(r);\n\t\t\tif(i >= 0) {\n\t\t\t\treported.splice(i, 1);\n\t\t\t\tlogInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));\n\t\t\t}\n\t\t}\n\n\t\tfunction enqueue(f, x) {\n\t\t\ttasks.push(f, x);\n\t\t\tif(running === null) {\n\t\t\t\trunning = setTimer(flush, 0);\n\t\t\t}\n\t\t}\n\n\t\tfunction flush() {\n\t\t\trunning = null;\n\t\t\twhile(tasks.length > 0) {\n\t\t\t\ttasks.shift()(tasks.shift());\n\t\t\t}\n\t\t}\n\n\t\treturn Promise;\n\t};\n\n\tfunction throwit(e) {\n\t\tthrow e;\n\t}\n\n\tfunction noop() {}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n},{\"../env\":118,\"../format\":119}],117:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function addWith(Promise) {\n\t\t/**\n\t\t * Returns a promise whose handlers will be called with `this` set to\n\t\t * the supplied receiver.  Subsequent promises derived from the\n\t\t * returned promise will also have their handlers called with receiver\n\t\t * as `this`. Calling `with` with undefined or no arguments will return\n\t\t * a promise whose handlers will again be called in the usual Promises/A+\n\t\t * way (no `this`) thus safely undoing any previous `with` in the\n\t\t * promise chain.\n\t\t *\n\t\t * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+\n\t\t * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)\n\t\t *\n\t\t * @param {object} receiver `this` value for all handlers attached to\n\t\t *  the returned promise.\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype['with'] = Promise.prototype.withThis = function(receiver) {\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\t\t\tchild.receiver = receiver;\n\t\t\tthis._handler.chain(child, receiver);\n\t\t\treturn p;\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n},{}],118:[function(require,module,exports){\n(function (process){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/\n(function(define) { 'use strict';\ndefine(function(require) {\n\t/*jshint maxcomplexity:6*/\n\n\t// Sniff \"best\" async scheduling option\n\t// Prefer process.nextTick or MutationObserver, then check for\n\t// setTimeout, and finally vertx, since its the only env that doesn't\n\t// have setTimeout\n\n\tvar MutationObs;\n\tvar capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;\n\n\t// Default env\n\tvar setTimer = function(f, ms) { return setTimeout(f, ms); };\n\tvar clearTimer = function(t) { return clearTimeout(t); };\n\tvar asap = function (f) { return capturedSetTimeout(f, 0); };\n\n\t// Detect specific env\n\tif (isNode()) { // Node\n\t\tasap = function (f) { return process.nextTick(f); };\n\n\t} else if (MutationObs = hasMutationObserver()) { // Modern browser\n\t\tasap = initMutationObserver(MutationObs);\n\n\t} else if (!capturedSetTimeout) { // vert.x\n\t\tvar vertxRequire = require;\n\t\tvar vertx = vertxRequire('vertx');\n\t\tsetTimer = function (f, ms) { return vertx.setTimer(ms, f); };\n\t\tclearTimer = vertx.cancelTimer;\n\t\tasap = vertx.runOnLoop || vertx.runOnContext;\n\t}\n\n\treturn {\n\t\tsetTimer: setTimer,\n\t\tclearTimer: clearTimer,\n\t\tasap: asap\n\t};\n\n\tfunction isNode () {\n\t\treturn typeof process !== 'undefined' &&\n\t\t\tObject.prototype.toString.call(process) === '[object process]';\n\t}\n\n\tfunction hasMutationObserver () {\n\t\treturn (typeof MutationObserver === 'function' && MutationObserver) ||\n\t\t\t(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver);\n\t}\n\n\tfunction initMutationObserver(MutationObserver) {\n\t\tvar scheduled;\n\t\tvar node = document.createTextNode('');\n\t\tvar o = new MutationObserver(run);\n\t\to.observe(node, { characterData: true });\n\n\t\tfunction run() {\n\t\t\tvar f = scheduled;\n\t\t\tscheduled = void 0;\n\t\t\tf();\n\t\t}\n\n\t\tvar i = 0;\n\t\treturn function (f) {\n\t\t\tscheduled = f;\n\t\t\tnode.data = (i ^= 1);\n\t\t};\n\t}\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n}).call(this,require('_process'))\n\n},{\"_process\":1}],119:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn {\n\t\tformatError: formatError,\n\t\tformatObject: formatObject,\n\t\ttryStringify: tryStringify\n\t};\n\n\t/**\n\t * Format an error into a string.  If e is an Error and has a stack property,\n\t * it's returned.  Otherwise, e is formatted using formatObject, with a\n\t * warning added about e not being a proper Error.\n\t * @param {*} e\n\t * @returns {String} formatted string, suitable for output to developers\n\t */\n\tfunction formatError(e) {\n\t\tvar s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);\n\t\treturn e instanceof Error ? s : s + ' (WARNING: non-Error used)';\n\t}\n\n\t/**\n\t * Format an object, detecting \"plain\" objects and running them through\n\t * JSON.stringify if possible.\n\t * @param {Object} o\n\t * @returns {string}\n\t */\n\tfunction formatObject(o) {\n\t\tvar s = String(o);\n\t\tif(s === '[object Object]' && typeof JSON !== 'undefined') {\n\t\t\ts = tryStringify(o, s);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t * Try to return the result of JSON.stringify(x).  If that fails, return\n\t * defaultValue\n\t * @param {*} x\n\t * @param {*} defaultValue\n\t * @returns {String|*} JSON.stringify(x) or defaultValue\n\t */\n\tfunction tryStringify(x, defaultValue) {\n\t\ttry {\n\t\t\treturn JSON.stringify(x);\n\t\t} catch(e) {\n\t\t\treturn defaultValue;\n\t\t}\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],120:[function(require,module,exports){\n(function (process){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function makePromise(environment) {\n\n\t\tvar tasks = environment.scheduler;\n\t\tvar emitRejection = initEmitRejection();\n\n\t\tvar objectCreate = Object.create ||\n\t\t\tfunction(proto) {\n\t\t\t\tfunction Child() {}\n\t\t\t\tChild.prototype = proto;\n\t\t\t\treturn new Child();\n\t\t\t};\n\n\t\t/**\n\t\t * Create a promise whose fate is determined by resolver\n\t\t * @constructor\n\t\t * @returns {Promise} promise\n\t\t * @name Promise\n\t\t */\n\t\tfunction Promise(resolver, handler) {\n\t\t\tthis._handler = resolver === Handler ? handler : init(resolver);\n\t\t}\n\n\t\t/**\n\t\t * Run the supplied resolver\n\t\t * @param resolver\n\t\t * @returns {Pending}\n\t\t */\n\t\tfunction init(resolver) {\n\t\t\tvar handler = new Pending();\n\n\t\t\ttry {\n\t\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t\t} catch (e) {\n\t\t\t\tpromiseReject(e);\n\t\t\t}\n\n\t\t\treturn handler;\n\n\t\t\t/**\n\t\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t\t * @param {*} x resolution value\n\t\t\t */\n\t\t\tfunction promiseResolve (x) {\n\t\t\t\thandler.resolve(x);\n\t\t\t}\n\t\t\t/**\n\t\t\t * Reject this promise with reason, which will be used verbatim\n\t\t\t * @param {Error|*} reason rejection reason, strongly suggested\n\t\t\t *   to be an Error type\n\t\t\t */\n\t\t\tfunction promiseReject (reason) {\n\t\t\t\thandler.reject(reason);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @deprecated\n\t\t\t * Issue a progress event, notifying all progress listeners\n\t\t\t * @param {*} x progress event payload to pass to all listeners\n\t\t\t */\n\t\t\tfunction promiseNotify (x) {\n\t\t\t\thandler.notify(x);\n\t\t\t}\n\t\t}\n\n\t\t// Creation\n\n\t\tPromise.resolve = resolve;\n\t\tPromise.reject = reject;\n\t\tPromise.never = never;\n\n\t\tPromise._defer = defer;\n\t\tPromise._handler = getHandler;\n\n\t\t/**\n\t\t * Returns a trusted promise. If x is already a trusted promise, it is\n\t\t * returned, otherwise returns a new trusted Promise which follows x.\n\t\t * @param  {*} x\n\t\t * @return {Promise} promise\n\t\t */\n\t\tfunction resolve(x) {\n\t\t\treturn isPromise(x) ? x\n\t\t\t\t: new Promise(Handler, new Async(getHandler(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a reject promise with x as its reason (x is used verbatim)\n\t\t * @param {*} x\n\t\t * @returns {Promise} rejected promise\n\t\t */\n\t\tfunction reject(x) {\n\t\t\treturn new Promise(Handler, new Async(new Rejected(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that remains pending forever\n\t\t * @returns {Promise} forever-pending promise.\n\t\t */\n\t\tfunction never() {\n\t\t\treturn foreverPendingPromise; // Should be frozen\n\t\t}\n\n\t\t/**\n\t\t * Creates an internal {promise, resolver} pair\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction defer() {\n\t\t\treturn new Promise(Handler, new Pending());\n\t\t}\n\n\t\t// Transformation and flow control\n\n\t\t/**\n\t\t * Transform this promise's fulfillment value, returning a new Promise\n\t\t * for the transformed result.  If the promise cannot be fulfilled, onRejected\n\t\t * is called with the reason.  onProgress *may* be called with updates toward\n\t\t * this promise's fulfillment.\n\t\t * @param {function=} onFulfilled fulfillment handler\n\t\t * @param {function=} onRejected rejection handler\n\t\t * @param {function=} onProgress @deprecated progress handler\n\t\t * @return {Promise} new promise\n\t\t */\n\t\tPromise.prototype.then = function(onFulfilled, onRejected, onProgress) {\n\t\t\tvar parent = this._handler;\n\t\t\tvar state = parent.join().state();\n\n\t\t\tif ((typeof onFulfilled !== 'function' && state > 0) ||\n\t\t\t\t(typeof onRejected !== 'function' && state < 0)) {\n\t\t\t\t// Short circuit: value will not change, simply share handler\n\t\t\t\treturn new this.constructor(Handler, parent);\n\t\t\t}\n\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\n\t\t\tparent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);\n\n\t\t\treturn p;\n\t\t};\n\n\t\t/**\n\t\t * If this promise cannot be fulfilled due to an error, call onRejected to\n\t\t * handle the error. Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\tPromise.prototype['catch'] = function(onRejected) {\n\t\t\treturn this.then(void 0, onRejected);\n\t\t};\n\n\t\t/**\n\t\t * Creates a new, pending promise of the same type as this promise\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype._beget = function() {\n\t\t\treturn begetFrom(this._handler, this.constructor);\n\t\t};\n\n\t\tfunction begetFrom(parent, Promise) {\n\t\t\tvar child = new Pending(parent.receiver, parent.join().context);\n\t\t\treturn new Promise(Handler, child);\n\t\t}\n\n\t\t// Array combinators\n\n\t\tPromise.all = all;\n\t\tPromise.race = race;\n\t\tPromise._traverse = traverse;\n\n\t\t/**\n\t\t * Return a promise that will fulfill when all promises in the\n\t\t * input array have fulfilled, or will reject when one of the\n\t\t * promises rejects.\n\t\t * @param {array} promises array of promises\n\t\t * @returns {Promise} promise for array of fulfillment values\n\t\t */\n\t\tfunction all(promises) {\n\t\t\treturn traverseWith(snd, null, promises);\n\t\t}\n\n\t\t/**\n\t\t * Array<Promise<X>> -> Promise<Array<f(X)>>\n\t\t * @private\n\t\t * @param {function} f function to apply to each promise's value\n\t\t * @param {Array} promises array of promises\n\t\t * @returns {Promise} promise for transformed values\n\t\t */\n\t\tfunction traverse(f, promises) {\n\t\t\treturn traverseWith(tryCatch2, f, promises);\n\t\t}\n\n\t\tfunction traverseWith(tryMap, f, promises) {\n\t\t\tvar handler = typeof f === 'function' ? mapAt : settleAt;\n\n\t\t\tvar resolver = new Pending();\n\t\t\tvar pending = promises.length >>> 0;\n\t\t\tvar results = new Array(pending);\n\n\t\t\tfor (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {\n\t\t\t\tx = promises[i];\n\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttraverseAt(promises, handler, i, x, resolver);\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t}\n\n\t\t\treturn new Promise(Handler, resolver);\n\n\t\t\tfunction mapAt(i, x, resolver) {\n\t\t\t\tif(!resolver.resolved) {\n\t\t\t\t\ttraverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction settleAt(i, x, resolver) {\n\t\t\t\tresults[i] = x;\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction traverseAt(promises, handler, i, x, resolver) {\n\t\t\tif (maybeThenable(x)) {\n\t\t\t\tvar h = getHandlerMaybeThenable(x);\n\t\t\t\tvar s = h.state();\n\n\t\t\t\tif (s === 0) {\n\t\t\t\t\th.fold(handler, i, void 0, resolver);\n\t\t\t\t} else if (s > 0) {\n\t\t\t\t\thandler(i, h.value, resolver);\n\t\t\t\t} else {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thandler(i, x, resolver);\n\t\t\t}\n\t\t}\n\n\t\tPromise._visitRemaining = visitRemaining;\n\t\tfunction visitRemaining(promises, start, handler) {\n\t\t\tfor(var i=start; i<promises.length; ++i) {\n\t\t\t\tmarkAsHandled(getHandler(promises[i]), handler);\n\t\t\t}\n\t\t}\n\n\t\tfunction markAsHandled(h, handler) {\n\t\t\tif(h === handler) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar s = h.state();\n\t\t\tif(s === 0) {\n\t\t\t\th.visit(h, void 0, h._unreport);\n\t\t\t} else if(s < 0) {\n\t\t\t\th._unreport();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fulfill-reject competitive race. Return a promise that will settle\n\t\t * to the same state as the earliest input promise to settle.\n\t\t *\n\t\t * WARNING: The ES6 Promise spec requires that race()ing an empty array\n\t\t * must return a promise that is pending forever.  This implementation\n\t\t * returns a singleton forever-pending promise, the same singleton that is\n\t\t * returned by Promise.never(), thus can be checked with ===\n\t\t *\n\t\t * @param {array} promises array of promises to race\n\t\t * @returns {Promise} if input is non-empty, a promise that will settle\n\t\t * to the same outcome as the earliest input promise to settle. if empty\n\t\t * is empty, returns a promise that will never settle.\n\t\t */\n\t\tfunction race(promises) {\n\t\t\tif(typeof promises !== 'object' || promises === null) {\n\t\t\t\treturn reject(new TypeError('non-iterable passed to race()'));\n\t\t\t}\n\n\t\t\t// Sigh, race([]) is untestable unless we return *something*\n\t\t\t// that is recognizable without calling .then() on it.\n\t\t\treturn promises.length === 0 ? never()\n\t\t\t\t : promises.length === 1 ? resolve(promises[0])\n\t\t\t\t : runRace(promises);\n\t\t}\n\n\t\tfunction runRace(promises) {\n\t\t\tvar resolver = new Pending();\n\t\t\tvar i, x, h;\n\t\t\tfor(i=0; i<promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = getHandler(x);\n\t\t\t\tif(h.state() !== 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, resolver.resolve, resolver.reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Promise(Handler, resolver);\n\t\t}\n\n\t\t// Promise internals\n\t\t// Below this, everything is @private\n\n\t\t/**\n\t\t * Get an appropriate handler for x, without checking for cycles\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandler(x) {\n\t\t\tif(isPromise(x)) {\n\t\t\t\treturn x._handler.join();\n\t\t\t}\n\t\t\treturn maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for thenable x.\n\t\t * NOTE: You must only call this if maybeThenable(x) == true\n\t\t * @param {object|function|Promise} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerMaybeThenable(x) {\n\t\t\treturn isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for potentially untrusted thenable x\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerUntrusted(x) {\n\t\t\ttry {\n\t\t\t\tvar untrustedThen = x.then;\n\t\t\t\treturn typeof untrustedThen === 'function'\n\t\t\t\t\t? new Thenable(untrustedThen, x)\n\t\t\t\t\t: new Fulfilled(x);\n\t\t\t} catch(e) {\n\t\t\t\treturn new Rejected(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handler for a promise that is pending forever\n\t\t * @constructor\n\t\t */\n\t\tfunction Handler() {}\n\n\t\tHandler.prototype.when\n\t\t\t= Handler.prototype.become\n\t\t\t= Handler.prototype.notify // deprecated\n\t\t\t= Handler.prototype.fail\n\t\t\t= Handler.prototype._unreport\n\t\t\t= Handler.prototype._report\n\t\t\t= noop;\n\n\t\tHandler.prototype._state = 0;\n\n\t\tHandler.prototype.state = function() {\n\t\t\treturn this._state;\n\t\t};\n\n\t\t/**\n\t\t * Recursively collapse handler chain to find the handler\n\t\t * nearest to the fully resolved value.\n\t\t * @returns {object} handler nearest the fully resolved value\n\t\t */\n\t\tHandler.prototype.join = function() {\n\t\t\tvar h = this;\n\t\t\twhile(h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t}\n\t\t\treturn h;\n\t\t};\n\n\t\tHandler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {\n\t\t\tthis.when({\n\t\t\t\tresolver: to,\n\t\t\t\treceiver: receiver,\n\t\t\t\tfulfilled: fulfilled,\n\t\t\t\trejected: rejected,\n\t\t\t\tprogress: progress\n\t\t\t});\n\t\t};\n\n\t\tHandler.prototype.visit = function(receiver, fulfilled, rejected, progress) {\n\t\t\tthis.chain(failIfRejected, receiver, fulfilled, rejected, progress);\n\t\t};\n\n\t\tHandler.prototype.fold = function(f, z, c, to) {\n\t\t\tthis.when(new Fold(f, z, c, to));\n\t\t};\n\n\t\t/**\n\t\t * Handler that invokes fail() on any handler it becomes\n\t\t * @constructor\n\t\t */\n\t\tfunction FailIfRejected() {}\n\n\t\tinherit(Handler, FailIfRejected);\n\n\t\tFailIfRejected.prototype.become = function(h) {\n\t\t\th.fail();\n\t\t};\n\n\t\tvar failIfRejected = new FailIfRejected();\n\n\t\t/**\n\t\t * Handler that manages a queue of consumers waiting on a pending promise\n\t\t * @constructor\n\t\t */\n\t\tfunction Pending(receiver, inheritedContext) {\n\t\t\tPromise.createContext(this, inheritedContext);\n\n\t\t\tthis.consumers = void 0;\n\t\t\tthis.receiver = receiver;\n\t\t\tthis.handler = void 0;\n\t\t\tthis.resolved = false;\n\t\t}\n\n\t\tinherit(Handler, Pending);\n\n\t\tPending.prototype._state = 0;\n\n\t\tPending.prototype.resolve = function(x) {\n\t\t\tthis.become(getHandler(x));\n\t\t};\n\n\t\tPending.prototype.reject = function(x) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.become(new Rejected(x));\n\t\t};\n\n\t\tPending.prototype.join = function() {\n\t\t\tif (!this.resolved) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar h = this;\n\n\t\t\twhile (h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t\tif (h === this) {\n\t\t\t\t\treturn this.handler = cycle();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn h;\n\t\t};\n\n\t\tPending.prototype.run = function() {\n\t\t\tvar q = this.consumers;\n\t\t\tvar handler = this.handler;\n\t\t\tthis.handler = this.handler.join();\n\t\t\tthis.consumers = void 0;\n\n\t\t\tfor (var i = 0; i < q.length; ++i) {\n\t\t\t\thandler.when(q[i]);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.become = function(handler) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.resolved = true;\n\t\t\tthis.handler = handler;\n\t\t\tif(this.consumers !== void 0) {\n\t\t\t\ttasks.enqueue(this);\n\t\t\t}\n\n\t\t\tif(this.context !== void 0) {\n\t\t\t\thandler._report(this.context);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.when = function(continuation) {\n\t\t\tif(this.resolved) {\n\t\t\t\ttasks.enqueue(new ContinuationTask(continuation, this.handler));\n\t\t\t} else {\n\t\t\t\tif(this.consumers === void 0) {\n\t\t\t\t\tthis.consumers = [continuation];\n\t\t\t\t} else {\n\t\t\t\t\tthis.consumers.push(continuation);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tPending.prototype.notify = function(x) {\n\t\t\tif(!this.resolved) {\n\t\t\t\ttasks.enqueue(new ProgressTask(x, this));\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.fail = function(context) {\n\t\t\tvar c = typeof context === 'undefined' ? this.context : context;\n\t\t\tthis.resolved && this.handler.join().fail(c);\n\t\t};\n\n\t\tPending.prototype._report = function(context) {\n\t\t\tthis.resolved && this.handler.join()._report(context);\n\t\t};\n\n\t\tPending.prototype._unreport = function() {\n\t\t\tthis.resolved && this.handler.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Wrap another handler and force it into a future stack\n\t\t * @param {object} handler\n\t\t * @constructor\n\t\t */\n\t\tfunction Async(handler) {\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tinherit(Handler, Async);\n\n\t\tAsync.prototype.when = function(continuation) {\n\t\t\ttasks.enqueue(new ContinuationTask(continuation, this));\n\t\t};\n\n\t\tAsync.prototype._report = function(context) {\n\t\t\tthis.join()._report(context);\n\t\t};\n\n\t\tAsync.prototype._unreport = function() {\n\t\t\tthis.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Handler that wraps an untrusted thenable and assimilates it in a future stack\n\t\t * @param {function} then\n\t\t * @param {{then: function}} thenable\n\t\t * @constructor\n\t\t */\n\t\tfunction Thenable(then, thenable) {\n\t\t\tPending.call(this);\n\t\t\ttasks.enqueue(new AssimilateTask(then, thenable, this));\n\t\t}\n\n\t\tinherit(Pending, Thenable);\n\n\t\t/**\n\t\t * Handler for a fulfilled promise\n\t\t * @param {*} x fulfillment value\n\t\t * @constructor\n\t\t */\n\t\tfunction Fulfilled(x) {\n\t\t\tPromise.createContext(this);\n\t\t\tthis.value = x;\n\t\t}\n\n\t\tinherit(Handler, Fulfilled);\n\n\t\tFulfilled.prototype._state = 1;\n\n\t\tFulfilled.prototype.fold = function(f, z, c, to) {\n\t\t\trunContinuation3(f, z, this, c, to);\n\t\t};\n\n\t\tFulfilled.prototype.when = function(cont) {\n\t\t\trunContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tvar errorId = 0;\n\n\t\t/**\n\t\t * Handler for a rejected promise\n\t\t * @param {*} x rejection reason\n\t\t * @constructor\n\t\t */\n\t\tfunction Rejected(x) {\n\t\t\tPromise.createContext(this);\n\n\t\t\tthis.id = ++errorId;\n\t\t\tthis.value = x;\n\t\t\tthis.handled = false;\n\t\t\tthis.reported = false;\n\n\t\t\tthis._report();\n\t\t}\n\n\t\tinherit(Handler, Rejected);\n\n\t\tRejected.prototype._state = -1;\n\n\t\tRejected.prototype.fold = function(f, z, c, to) {\n\t\t\tto.become(this);\n\t\t};\n\n\t\tRejected.prototype.when = function(cont) {\n\t\t\tif(typeof cont.rejected === 'function') {\n\t\t\t\tthis._unreport();\n\t\t\t}\n\t\t\trunContinuation1(cont.rejected, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tRejected.prototype._report = function(context) {\n\t\t\ttasks.afterQueue(new ReportTask(this, context));\n\t\t};\n\n\t\tRejected.prototype._unreport = function() {\n\t\t\tif(this.handled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handled = true;\n\t\t\ttasks.afterQueue(new UnreportTask(this));\n\t\t};\n\n\t\tRejected.prototype.fail = function(context) {\n\t\t\tthis.reported = true;\n\t\t\temitRejection('unhandledRejection', this);\n\t\t\tPromise.onFatalRejection(this, context === void 0 ? this.context : context);\n\t\t};\n\n\t\tfunction ReportTask(rejection, context) {\n\t\t\tthis.rejection = rejection;\n\t\t\tthis.context = context;\n\t\t}\n\n\t\tReportTask.prototype.run = function() {\n\t\t\tif(!this.rejection.handled && !this.rejection.reported) {\n\t\t\t\tthis.rejection.reported = true;\n\t\t\t\temitRejection('unhandledRejection', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejection(this.rejection, this.context);\n\t\t\t}\n\t\t};\n\n\t\tfunction UnreportTask(rejection) {\n\t\t\tthis.rejection = rejection;\n\t\t}\n\n\t\tUnreportTask.prototype.run = function() {\n\t\t\tif(this.rejection.reported) {\n\t\t\t\temitRejection('rejectionHandled', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejectionHandled(this.rejection);\n\t\t\t}\n\t\t};\n\n\t\t// Unhandled rejection hooks\n\t\t// By default, everything is a noop\n\n\t\tPromise.createContext\n\t\t\t= Promise.enterContext\n\t\t\t= Promise.exitContext\n\t\t\t= Promise.onPotentiallyUnhandledRejection\n\t\t\t= Promise.onPotentiallyUnhandledRejectionHandled\n\t\t\t= Promise.onFatalRejection\n\t\t\t= noop;\n\n\t\t// Errors and singletons\n\n\t\tvar foreverPendingHandler = new Handler();\n\t\tvar foreverPendingPromise = new Promise(Handler, foreverPendingHandler);\n\n\t\tfunction cycle() {\n\t\t\treturn new Rejected(new TypeError('Promise cycle'));\n\t\t}\n\n\t\t// Task runners\n\n\t\t/**\n\t\t * Run a single consumer\n\t\t * @constructor\n\t\t */\n\t\tfunction ContinuationTask(continuation, handler) {\n\t\t\tthis.continuation = continuation;\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tContinuationTask.prototype.run = function() {\n\t\t\tthis.handler.join().when(this.continuation);\n\t\t};\n\n\t\t/**\n\t\t * Run a queue of progress handlers\n\t\t * @constructor\n\t\t */\n\t\tfunction ProgressTask(value, handler) {\n\t\t\tthis.handler = handler;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tProgressTask.prototype.run = function() {\n\t\t\tvar q = this.handler.consumers;\n\t\t\tif(q === void 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var c, i = 0; i < q.length; ++i) {\n\t\t\t\tc = q[i];\n\t\t\t\trunNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Assimilate a thenable, sending it's value to resolver\n\t\t * @param {function} then\n\t\t * @param {object|function} thenable\n\t\t * @param {object} resolver\n\t\t * @constructor\n\t\t */\n\t\tfunction AssimilateTask(then, thenable, resolver) {\n\t\t\tthis._then = then;\n\t\t\tthis.thenable = thenable;\n\t\t\tthis.resolver = resolver;\n\t\t}\n\n\t\tAssimilateTask.prototype.run = function() {\n\t\t\tvar h = this.resolver;\n\t\t\ttryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);\n\n\t\t\tfunction _resolve(x) { h.resolve(x); }\n\t\t\tfunction _reject(x)  { h.reject(x); }\n\t\t\tfunction _notify(x)  { h.notify(x); }\n\t\t};\n\n\t\tfunction tryAssimilate(then, thenable, resolve, reject, notify) {\n\t\t\ttry {\n\t\t\t\tthen.call(thenable, resolve, reject, notify);\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fold a handler value with z\n\t\t * @constructor\n\t\t */\n\t\tfunction Fold(f, z, c, to) {\n\t\t\tthis.f = f; this.z = z; this.c = c; this.to = to;\n\t\t\tthis.resolver = failIfRejected;\n\t\t\tthis.receiver = this;\n\t\t}\n\n\t\tFold.prototype.fulfilled = function(x) {\n\t\t\tthis.f.call(this.c, this.z, x, this.to);\n\t\t};\n\n\t\tFold.prototype.rejected = function(x) {\n\t\t\tthis.to.reject(x);\n\t\t};\n\n\t\tFold.prototype.progress = function(x) {\n\t\t\tthis.to.notify(x);\n\t\t};\n\n\t\t// Other helpers\n\n\t\t/**\n\t\t * @param {*} x\n\t\t * @returns {boolean} true iff x is a trusted Promise\n\t\t */\n\t\tfunction isPromise(x) {\n\t\t\treturn x instanceof Promise;\n\t\t}\n\n\t\t/**\n\t\t * Test just enough to rule out primitives, in order to take faster\n\t\t * paths in some code\n\t\t * @param {*} x\n\t\t * @returns {boolean} false iff x is guaranteed *not* to be a thenable\n\t\t */\n\t\tfunction maybeThenable(x) {\n\t\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t\t}\n\n\t\tfunction runContinuation1(f, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject(f, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction runContinuation3(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject3(f, x, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tfunction runNotify(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.notify(x);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReturn(f, x, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction tryCatch2(f, a, b) {\n\t\t\ttry {\n\t\t\t\treturn f(a, b);\n\t\t\t} catch(e) {\n\t\t\t\treturn reject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws return a rejected promise for\n\t\t * the thrown exception\n\t\t */\n\t\tfunction tryCatchReject(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.become(getHandler(f.call(thisArg, x)));\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Same as above, but includes the extra argument parameter.\n\t\t */\n\t\tfunction tryCatchReject3(f, x, y, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tf.call(thisArg, x, y, next);\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t * Return f.call(thisArg, x), or if it throws, *return* the exception\n\t\t */\n\t\tfunction tryCatchReturn(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.notify(f.call(thisArg, x));\n\t\t\t} catch(e) {\n\t\t\t\tnext.notify(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction inherit(Parent, Child) {\n\t\t\tChild.prototype = objectCreate(Parent.prototype);\n\t\t\tChild.prototype.constructor = Child;\n\t\t}\n\n\t\tfunction snd(x, y) {\n\t\t\treturn y;\n\t\t}\n\n\t\tfunction noop() {}\n\n\t\tfunction initEmitRejection() {\n\t\t\t/*global process, self, CustomEvent*/\n\t\t\tif(typeof process !== 'undefined' && process !== null\n\t\t\t\t&& typeof process.emit === 'function') {\n\t\t\t\t// Returning falsy here means to call the default\n\t\t\t\t// onPotentiallyUnhandledRejection API.  This is safe even in\n\t\t\t\t// browserify since process.emit always returns falsy in browserify:\n\t\t\t\t// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46\n\t\t\t\treturn function(type, rejection) {\n\t\t\t\t\treturn type === 'unhandledRejection'\n\t\t\t\t\t\t? process.emit(type, rejection.value, rejection)\n\t\t\t\t\t\t: process.emit(type, rejection);\n\t\t\t\t};\n\t\t\t} else if(typeof self !== 'undefined' && typeof CustomEvent === 'function') {\n\t\t\t\treturn (function(noop, self, CustomEvent) {\n\t\t\t\t\tvar hasCustomEvent = false;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar ev = new CustomEvent('unhandledRejection');\n\t\t\t\t\t\thasCustomEvent = ev instanceof CustomEvent;\n\t\t\t\t\t} catch (e) {}\n\n\t\t\t\t\treturn !hasCustomEvent ? noop : function(type, rejection) {\n\t\t\t\t\t\tvar ev = new CustomEvent(type, {\n\t\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\t\treason: rejection.value,\n\t\t\t\t\t\t\t\tkey: rejection\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbubbles: false,\n\t\t\t\t\t\t\tcancelable: true\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !self.dispatchEvent(ev);\n\t\t\t\t\t};\n\t\t\t\t}(noop, self, CustomEvent));\n\t\t\t}\n\n\t\t\treturn noop;\n\t\t}\n\n\t\treturn Promise;\n\t};\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n}).call(this,require('_process'))\n\n},{\"_process\":1}],121:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn {\n\t\tpending: toPendingState,\n\t\tfulfilled: toFulfilledState,\n\t\trejected: toRejectedState,\n\t\tinspect: inspect\n\t};\n\n\tfunction toPendingState() {\n\t\treturn { state: 'pending' };\n\t}\n\n\tfunction toRejectedState(e) {\n\t\treturn { state: 'rejected', reason: e };\n\t}\n\n\tfunction toFulfilledState(x) {\n\t\treturn { state: 'fulfilled', value: x };\n\t}\n\n\tfunction inspect(handler) {\n\t\tvar state = handler.state();\n\t\treturn state === 0 ? toPendingState()\n\t\t\t : state > 0   ? toFulfilledState(handler.value)\n\t\t\t               : toRejectedState(handler.value);\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],122:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/**\n * Promises/A+ and when() implementation\n * when is part of the cujoJS family of libraries (http://cujojs.com/)\n * @author Brian Cavalier\n * @author John Hann\n */\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar timed = require('./lib/decorators/timed');\n\tvar array = require('./lib/decorators/array');\n\tvar flow = require('./lib/decorators/flow');\n\tvar fold = require('./lib/decorators/fold');\n\tvar inspect = require('./lib/decorators/inspect');\n\tvar generate = require('./lib/decorators/iterate');\n\tvar progress = require('./lib/decorators/progress');\n\tvar withThis = require('./lib/decorators/with');\n\tvar unhandledRejection = require('./lib/decorators/unhandledRejection');\n\tvar TimeoutError = require('./lib/TimeoutError');\n\n\tvar Promise = [array, flow, fold, generate, progress,\n\t\tinspect, withThis, timed, unhandledRejection]\n\t\t.reduce(function(Promise, feature) {\n\t\t\treturn feature(Promise);\n\t\t}, require('./lib/Promise'));\n\n\tvar apply = require('./lib/apply')(Promise);\n\n\t// Public API\n\n\twhen.promise     = promise;              // Create a pending promise\n\twhen.resolve     = Promise.resolve;      // Create a resolved promise\n\twhen.reject      = Promise.reject;       // Create a rejected promise\n\n\twhen.lift        = lift;                 // lift a function to return promises\n\twhen['try']      = attempt;              // call a function and return a promise\n\twhen.attempt     = attempt;              // alias for when.try\n\n\twhen.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\twhen.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\n\twhen.join        = join;                 // Join 2 or more promises\n\n\twhen.all         = all;                  // Resolve a list of promises\n\twhen.settle      = settle;               // Settle a list of promises\n\n\twhen.any         = lift(Promise.any);    // One-winner race\n\twhen.some        = lift(Promise.some);   // Multi-winner race\n\twhen.race        = lift(Promise.race);   // First-to-settle race\n\n\twhen.map         = map;                  // Array.map() for promises\n\twhen.filter      = filter;               // Array.filter() for promises\n\twhen.reduce      = lift(Promise.reduce);       // Array.reduce() for promises\n\twhen.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises\n\n\twhen.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable\n\n\twhen.Promise     = Promise;              // Promise constructor\n\twhen.defer       = defer;                // Create a {promise, resolve, reject} tuple\n\n\t// Error types\n\n\twhen.TimeoutError = TimeoutError;\n\n\t/**\n\t * Get a trusted promise for x, or by transforming x with onFulfilled\n\t *\n\t * @param {*} x\n\t * @param {function?} onFulfilled callback to be called when x is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} onRejected callback to be called when x is\n\t *   rejected.\n\t * @param {function?} onProgress callback to be called when progress updates\n\t *   are issued for x. @deprecated\n\t * @returns {Promise} a new promise that will fulfill with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(x, onFulfilled, onRejected, onProgress) {\n\t\tvar p = Promise.resolve(x);\n\t\tif (arguments.length < 2) {\n\t\t\treturn p;\n\t\t}\n\n\t\treturn p.then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn new Promise(resolver);\n\t}\n\n\t/**\n\t * Lift the supplied function, creating a version of f that returns\n\t * promises, and accepts promises as arguments.\n\t * @param {function} f\n\t * @returns {Function} version of f that returns promises\n\t */\n\tfunction lift(f) {\n\t\treturn function() {\n\t\t\tfor(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {\n\t\t\t\ta[i] = arguments[i];\n\t\t\t}\n\t\t\treturn apply(f, this, a);\n\t\t};\n\t}\n\n\t/**\n\t * Call f in a future turn, with the supplied args, and return a promise\n\t * for the result.\n\t * @param {function} f\n\t * @returns {Promise}\n\t */\n\tfunction attempt(f /*, args... */) {\n\t\t/*jshint validthis:true */\n\t\tfor(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {\n\t\t\ta[i] = arguments[i+1];\n\t\t}\n\t\treturn apply(f, this, a);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * @return {{promise: Promise, resolve: function, reject: function, notify: function}}\n\t */\n\tfunction defer() {\n\t\treturn new Deferred();\n\t}\n\n\tfunction Deferred() {\n\t\tvar p = Promise._defer();\n\n\t\tfunction resolve(x) { p._handler.resolve(x); }\n\t\tfunction reject(x) { p._handler.reject(x); }\n\t\tfunction notify(x) { p._handler.notify(x); }\n\n\t\tthis.promise = p;\n\t\tthis.resolve = resolve;\n\t\tthis.reject = reject;\n\t\tthis.notify = notify;\n\t\tthis.resolver = { resolve: resolve, reject: reject, notify: notify };\n\t}\n\n\t/**\n\t * Determines if x is promise-like, i.e. a thenable object\n\t * NOTE: Will return true for *any thenable object*, and isn't truly\n\t * safe, since it may attempt to access the `then` property of x (i.e.\n\t *  clever/malicious getters may do weird things)\n\t * @param {*} x anything\n\t * @returns {boolean} true if x is promise-like\n\t */\n\tfunction isPromiseLike(x) {\n\t\treturn x && typeof x.then === 'function';\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied arguments\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the arguments.\n\t * @param {...*} arguments may be a mix of promises and values\n\t * @returns {Promise}\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn Promise.all(arguments);\n\t}\n\n\t/**\n\t * Return a promise that will fulfill once all input promises have\n\t * fulfilled, or reject when any one input promise rejects.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise}\n\t */\n\tfunction all(promises) {\n\t\treturn when(promises, Promise.all);\n\t}\n\n\t/**\n\t * Return a promise that will always fulfill with an array containing\n\t * the outcome states of all input promises.  The returned promise\n\t * will only reject if `promises` itself is a rejected promise.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise} promise for array of settled state descriptors\n\t */\n\tfunction settle(promises) {\n\t\treturn when(promises, Promise.settle);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} promises array of anything, may contain promises and values\n\t * @param {function(x:*, index:Number):*} mapFunc map function which may\n\t *  return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(promises, mapFunc) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.map(promises, mapFunc);\n\t\t});\n\t}\n\n\t/**\n\t * Filter the provided array of promises using the provided predicate.  Input may\n\t * contain promises and values\n\t * @param {Array|Promise} promises array of promises and values\n\t * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n\t *  Must return truthy (or promise for truthy) for items to retain.\n\t * @returns {Promise} promise that will fulfill with an array containing all items\n\t *  for which predicate returned truthy.\n\t */\n\tfunction filter(promises, predicate) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.filter(promises, predicate);\n\t\t});\n\t}\n\n\treturn when;\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n},{\"./lib/Promise\":105,\"./lib/TimeoutError\":107,\"./lib/apply\":108,\"./lib/decorators/array\":109,\"./lib/decorators/flow\":110,\"./lib/decorators/fold\":111,\"./lib/decorators/inspect\":112,\"./lib/decorators/iterate\":113,\"./lib/decorators/progress\":114,\"./lib/decorators/timed\":115,\"./lib/decorators/unhandledRejection\":116,\"./lib/decorators/with\":117}],123:[function(require,module,exports){\n// Import requirements using browserify\n'use strict';\n\n// Insert vue-router and vue-resource into Vue\n\n// Import the actual routes, aliases, ...\n\nvar _routes = require('./routes');\n\n// Create our router object and set options on it\nwindow.Vue = require('vue');\nwindow.VueRouter = require('vue-router');\n\nVue.use(require('vue-resource'));var router = new VueRouter({});\n\n// Inject the routes into the VueRouter object\n(0, _routes.configRouter)(router);\n\n// Configure the application\nwindow.config = require('./config');\nVue.config.debug = true;\n\n// Configure our HTTP client\nvar rest = require('rest');\nvar pathPrefix = require('rest/interceptor/pathPrefix');\nvar mime = require('rest/interceptor/mime');\nvar defaultRequest = require('rest/interceptor/defaultRequest');\nvar errorCode = require('rest/interceptor/errorCode');\nvar interceptor = require('rest/interceptor');\nvar jwtAuth = require('./interceptors/jwtAuth');\n\nwindow.client = rest.wrap(pathPrefix, { prefix: config.api.base_url }).wrap(mime).wrap(defaultRequest, config.api.defaultRequest).wrap(errorCode, { code: 400 });\n//.wrap(jwtAuth);\n\n// Bootstrap the app\n// HRis Components\nVue.component('copyleft', require('./compiled/partials/copyleft.vue'));\nVue.component('action-area', require('./compiled/partials/action-area.vue'));\nVue.component('navbar-static-side', require('./compiled/partials/navbar-static-side.vue'));\nVue.component('navbar-static-profile-top', require('./compiled/partials/navbar-static-profile-top.vue'));\nVue.component('navbar-static-top', require('./compiled/partials/navbar-static-top.vue'));\nVue.component('static-footer', require('./compiled/partials/static-footer.vue'));\nVue.component('chosen', require('./compiled/partials/chosen.vue'));\n\nVue.directive('trans', {\n    update: function update(value) {\n        value = translate(value);\n        var arg = this.arg;\n        switch (arg) {\n            case 'placeholder':\n                this.el.placeholder = value;\n                break;\n            case 'value':\n                this.el.value = value;\n                break;\n            case 'html':\n                this.el.innerHTML = value;\n                break;\n            default:\n                this.el.innerHTML = value;\n        }\n    }\n});\n\nvar App = Vue.extend(require('./compiled/app.vue'));\nrouter.start(App, 'body');\nwindow.router = router;\n\n},{\"./compiled/app.vue\":124,\"./compiled/partials/action-area.vue\":134,\"./compiled/partials/chosen.vue\":135,\"./compiled/partials/copyleft.vue\":136,\"./compiled/partials/navbar-static-profile-top.vue\":137,\"./compiled/partials/navbar-static-side.vue\":138,\"./compiled/partials/navbar-static-top.vue\":139,\"./compiled/partials/static-footer.vue\":140,\"./config\":142,\"./interceptors/jwtAuth\":145,\"./routes\":146,\"rest\":3,\"rest/interceptor\":7,\"rest/interceptor/defaultRequest\":8,\"rest/interceptor/errorCode\":9,\"rest/interceptor/mime\":10,\"rest/interceptor/pathPrefix\":11,\"vue\":102,\"vue-resource\":29,\"vue-router\":36}],124:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    props: ['employee', 'page_title', 'job_titles', 'employment_statuses', 'routes', 'has_access', 'permission'],\n    replace: false,\n    data: function data() {\n        return {\n            employee: {\n                user: {\n                    data: {}\n                },\n                id: '',\n                first_name: '',\n                middle_name: '',\n                last_name: '',\n                employee_id: '',\n                face_id: '',\n                gender: '',\n                nationality_id: '',\n                marital_status_id: '',\n                job_history: [],\n                emergency_contacts: {\n                    data: []\n                }\n            },\n            has_access: ''\n        };\n    },\n    ready: function ready() {\n\n        this.t = 1;\n\n        var that = this;\n\n        this.$on('userHasLoggedOut', function () {\n            this.destroyLogin();\n        });\n\n        this.$on('userHasLoggedIn', function (user) {\n            that.setLogin(user);\n            localStorage.setItem('logged', btoa(JSON.stringify(user)));\n            localStorage.setItem('employee_id', user.employee.data.employee_id);\n            localStorage.setItem('avatar', user.employee.data.avatar);\n            localStorage.setItem('permissions', btoa(JSON.stringify(user.role.data[0].permissions)));\n        });\n\n        this.$on('update-page-title', function (page_title) {\n            that.page_title = page_title;\n            var route = [];\n            var route_path = this.$route.path.substr(1);\n            var route_segments = route_path.split('/');\n\n            var route_name = route_segments[0];\n            for (var i = 0; i < route_segments.length; i++) {\n\n                if (i && route_segments[i].indexOf('HRis') != 0) {\n                    // TODO: get employee_id_prefix from config\n                    route_name += '-' + route_segments[i];\n                }\n\n                if (route_segments[i] == 'pim') {\n                    route_segments[i] = 'PIM';\n                    continue;\n                } else if (route_segments[i].indexOf('HRis') != 0) {\n                    // TODO: get employee_id_prefix from config\n                    route_segments[i] = route_segments[i].replace('-', ' ');\n                    route_segments[i] = this.toTitleCase(route_segments[i]);\n                }\n\n                if (route_segments[i].indexOf('HRis') == 0) {\n                    // TODO: get employee_id_prefix from config\n                    route.push({\n                        'segment': route_segments[i],\n                        'name': route_name + '-personal-details',\n                        'params': { 'employee_id': route_segments[i] }\n                    });\n                } else {\n                    route.push({\n                        'segment': route_segments[i],\n                        'name': route_name,\n                        'params': { 'employee_id': route_segments[i - 1] }\n                    });\n                }\n            }\n\n            this.routes = route;\n            this.preparePermission();\n\n            document.title = 'HRis | ' + page_title;\n        });\n\n        this.$on('update-employee', function (employee) {\n\n            var self = this;\n\n            this.employee = employee;\n            this.employee.birth_date = this.employee.birth_date ? this.employee.birth_date.date.substring(0, 10) : null;\n\n            client({\n                path: '/job-titles?table_view=true',\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            }).then(function (response) {\n                self.job_titles = response.entity;\n                that.$broadcast('set-job-titles-default');\n                that.$broadcast('set-job-titles-action-area');\n            }, function (response) {\n                console.log(response);\n            });\n\n            client({\n                path: '/employment-statuses?table_view=true',\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            }).then(function (response) {\n                self.employment_statuses = response.entity;\n            }, function (response) {\n                console.log(response);\n            });\n\n            this.$broadcast('employee-loaded');\n        });\n\n        // The app has just been initialized, check if we can get the user data with an already existing token\n        var token = localStorage.getItem('jwt-token');\n        if (token !== null && token !== 'undefined') {\n            var that = this;\n\n            client({\n                path: '/users/me?include=employee,role',\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            }).then(function (response) {\n                // User has successfully logged in using the token from storage\n                that.setLogin(response);\n                // broadcast an event telling our children that the data is ready and views can be rendered\n                that.$broadcast('data-loaded');\n            }, function (response) {\n                // Login with our token failed, do some cleanup and redirect if we're on an authenticated route\n                that.destroyLogin();\n            });\n        }\n    },\n\n    data: function data() {\n        return {\n            user: null,\n            token: null,\n            authenticated: false\n        };\n    },\n\n    methods: {\n\n        setLogin: function setLogin(user) {\n\n            var that = this;\n\n            // Save login info in our data and set header in case it's not set already\n            this.user = user;\n            this.authenticated = true;\n            client({\n                method: 'POST',\n                path: '/sidebar',\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            }).then(function (response) {\n                localStorage.setItem('sidebar', btoa(response.entity.sidebar));\n                that.$broadcast('set-sidebar');\n            });\n        },\n\n        destroyLogin: function destroyLogin(user) {\n            // Cleanup when token was invalid our user has logged out\n            this.user = null;\n            this.token = null;\n            this.authenticated = false;\n            localStorage.removeItem('avatar');\n            localStorage.removeItem('employee_id');\n            localStorage.removeItem('jwt-token');\n            localStorage.removeItem('logged');\n            localStorage.removeItem('permissions');\n            localStorage.removeItem('sidebar');\n            if (this.$route.auth) this.$route.router.go('/login');\n        },\n\n        toTitleCase: function toTitleCase(str) {\n            return str.replace(/\\w\\S*/g, function (txt) {\n                return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n            });\n        },\n\n        preparePermission: function preparePermission() {\n            var route_path = this.$route.path.substr(1); // removes the first character ('/') in the path\n            var route_dotted = route_path.replace(/\\//g, '.');\n            var route_segment = route_path.split('/');\n            var route_is_pim = route_segment[0] == 'pim';\n\n            this.permission = route_dotted;\n            if (route_is_pim) {\n                route_segment = route_segment[route_segment.length - 1];\n                this.permission = 'pim.' + route_segment;\n            }\n\n            this.route = { 'path': route_path, 'dotted': route_dotted, 'segment': route_segment, 'pim': route_is_pim };\n\n            this.has_access = JSON.parse(atob(localStorage.getItem('permissions')));\n        }\n    }\n\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<router-view :employee=\\\"employee\\\" :page_title=\\\"page_title\\\" :job_titles=\\\"job_titles\\\" :employment_statuses=\\\"employment_statuses\\\" :routes=\\\"routes\\\" :has_access=\\\"has_access\\\" :permission=\\\"permission\\\"></router-view>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/app.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],125:[function(require,module,exports){\nvar __vueify_style__ = require(\"vueify-insert-css\").insert(\"\\n.title {\\n    color: #999;\\n    font-weight: 100;\\n    font-family: 'Lato', Helvetica, sans-serif;\\n    font-size: 60px;\\n    margin-bottom: 40px;\\n    text-align: center;\\n    margin-top: 20%;\\n}\\n.title a {\\n    display: block;\\n    margin-top: 20px;\\n}\\n.title a:hover {\\n    text-decoration: none;\\n}\")\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"container-fluid\\\">\\n\\t<div class=\\\"row\\\">\\n\\t\\t<div class=\\\"col-md-3\\\"></div>\\n\\t\\t<div class=\\\"col-md-6 title\\\">\\n\\t\\t\\tSorry, we couldn't find what you were looking for :-(<br>\\n\\t\\t\\t<a href=\\\"/\\\">Go back to the homepage</a>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"col-md-3\\\"></div>\\n\\t</div>\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/pages/404.vue\"\n  module.hot.dispose(function () {\n    require(\"vueify-insert-css\").cache[\"\\n.title {\\n    color: #999;\\n    font-weight: 100;\\n    font-family: 'Lato', Helvetica, sans-serif;\\n    font-size: 60px;\\n    margin-bottom: 40px;\\n    text-align: center;\\n    margin-top: 20%;\\n}\\n.title a {\\n    display: block;\\n    margin-top: 20px;\\n}\\n.title a:hover {\\n    text-decoration: none;\\n}\"] = false\n    document.head.removeChild(__vueify_style__)\n  })\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27,\"vueify-insert-css\":104}],126:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n    ready: function ready() {\n        this.$dispatch('updatePageTitle', 'Login');\n    },\n\n    data: function data() {\n        return {\n            user: {\n                email: null,\n                password: null\n            },\n            messages: []\n        };\n    },\n\n    methods: {\n        attempt: function attempt(e) {\n            e.preventDefault();\n            var that = this;\n\n            var params = {\n                path: '/login',\n                entity: { 'email': this.user.email, 'password': this.user.password }\n            };\n\n            client(params).then(function (response) {\n                localStorage.setItem('jwt-token', 'Bearer ' + response.entity.token);\n                that.getUserData();\n            }, function (response) {\n                that.messages = [];\n                if (response.entity.error) {\n                    that.messages.push({ type: 'danger', message: 'Sorry, you provided invalid credentials' });\n                }\n            });\n        },\n\n        getUserData: function getUserData() {\n            var that = this;\n\n            client({\n                path: '/users/me?include=employee,role',\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            }).then(function (response) {\n\n                that.$dispatch('userHasLoggedIn', response.entity.data);\n                that.$route.router.go('/dashboard');\n            }, function (response) {\n                console.log(response);\n            });\n        }\n    },\n\n    route: {\n        activate: function activate(transition) {\n            this.$dispatch('userHasLoggedOut');\n            transition.next();\n        }\n    }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"middle-box text-center loginscreen animated fadeInDown\\\">\\n    <div>\\n        <div>\\n\\n            <div class=\\\"logo-wrapper\\\">\\n                <img src=\\\"/images/hris-logo.png\\\">\\n            </div>\\n\\n        </div>\\n        <h3>Welcome to HRis</h3>\\n\\n        <div id=\\\"alerts\\\" v-if=\\\"messages.length > 0\\\">\\n            <div v-for=\\\"message in messages\\\" class=\\\"alert alert-{{ message.type }} alert-dismissible\\\" role=\\\"alert\\\">\\n                {{ message.message }}\\n            </div>\\n        </div>\\n\\n        <form class=\\\"m-t\\\" role=\\\"form\\\" action=\\\"/login\\\" method=\\\"post\\\">\\n            <div class=\\\"form-group form-group-default\\\">\\n                <input type=\\\"email\\\" class=\\\"form-control\\\" placeholder=\\\"Email\\\" name=\\\"email\\\" required=\\\"\\\" v-model=\\\"user.email\\\" aria-required=\\\"true\\\">\\n            </div>\\n            <div class=\\\"form-group form-group-default\\\">\\n                <input type=\\\"password\\\" class=\\\"form-control\\\" placeholder=\\\"Password\\\" name=\\\"password\\\" required=\\\"\\\" v-model=\\\"user.password\\\" aria-required=\\\"true\\\">\\n            </div>\\n            <button class=\\\"btn btn-primary block full-width m-b\\\" @click=\\\"attempt\\\">Login</button>\\n\\n            <a href=\\\"#\\\">\\n                <small>Forgot password?</small>\\n            </a>\\n            <p class=\\\"text-muted text-center\\\">\\n                <small>Do not have an account?</small>\\n            </p>\\n            <a class=\\\"btn btn-sm btn-white btn-block\\\" href=\\\"/auth/register\\\">Create an account</a>\\n        </form>\\n        <p class=\\\"m-t\\\">\\n            <small>b3 Studios © 2014</small>\\n        </p>\\n    </div>\\n</div>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/pages/auth/login.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],127:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    props: ['employee', 'page_title', 'job_titles', 'employment_statuses', 'routes', 'has_access', 'permission'],\n    route: {\n        canReuse: false\n    },\n    compiled: function compiled() {\n        this.$dispatch('update-page-title', 'Dashboard');\n    },\n    ready: function ready() {\n        var that = this;\n\n        if (this.$route.path.indexOf('/pim') > -1) {\n            this.employee_id = this.$route.params.employee_id;\n        } else {\n            this.employee_id = localStorage.getItem('employee_id');\n        }\n\n        var params = {\n            path: '/employee/get-by-employee-id?include=user',\n            entity: { 'employee_id': this.employee_id },\n            headers: { 'Authorization': localStorage.getItem('jwt-token') }\n        };\n\n        client(params).then(function (response) {\n\n            that.$dispatch('update-employee', response.entity.data);\n        });\n    }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"row wrapper border-bottom page-heading\\\" :class=\\\"{ 'grad-red': ($route.path.indexOf('/pim') == 0 || $route.path.indexOf('/admin') == 0), 'greenpro-bg': ($route.path.indexOf('/pim') == -1 &amp;&amp; $route.path.indexOf('/admin') == -1) }\\\">\\n    <div class=\\\"col-sm-6\\\">\\n        <h2>{{page_title}}</h2>\\n        <!-- Breadcrumbs -->\\n        <ol class=\\\"breadcrumb\\\">\\n            <li>\\n                <a v-link=\\\"{name: 'dashboard'}\\\">Home</a>\\n            </li>\\n            <li v-for=\\\"route in routes\\\">\\n                <a v-link=\\\"{name: route.name, params: {employee_id: route.params.employee_id} }\\\">{{route.segment}}</a>\\n            </li>\\n        </ol>\\n    </div>\\n</div>\\n<div class=\\\"row\\\">\\n    <div class=\\\"col-lg-12\\\">\\n        <div class=\\\"wrapper wrapper-content\\\">\\n            <router-view :employee=\\\"employee\\\" :page_title=\\\"page_title\\\" :job_titles=\\\"job_titles\\\" :employment_statuses=\\\"employment_statuses\\\" :routes=\\\"routes\\\" :has_access=\\\"has_access\\\" :permission=\\\"permission\\\"></router-view>\\n        </div>\\n    </div>\\n</div>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/pages/dashboard.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],128:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    props: ['employee', 'page_title', 'job_titles', 'employment_statuses', 'routes', 'has_access', 'permission'],\n    data: function data() {\n        return {\n            logged: {\n                avatar: '',\n                id: null,\n                employee: {\n                    data: {\n                        first_name: '',\n                        last_name: '',\n                        job_history: {\n                            data: {\n                                job_title_id: ''\n                            }\n                        }\n                    }\n                }\n            }\n        };\n    },\n\n    compiled: function compiled() {\n        this.logged = JSON.parse(atob(localStorage.getItem('logged')));\n        this.logged.employee_id = localStorage.getItem('employee_id');\n        this.logged.avatar = localStorage.getItem('avatar');\n        this.logged.has_access = JSON.parse(atob(localStorage.getItem('permissions')));\n    }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div id=\\\"wrapper\\\">\\n    <nav class=\\\"navbar-default navbar-static-side\\\" role=\\\"navigation\\\">\\n        <div class=\\\"sidebar-collapse\\\">\\n            <ul class=\\\"nav metismenu\\\" id=\\\"side-menu\\\">\\n                <li class=\\\"nav-header\\\">\\n                    <div class=\\\"dropdown profile-element\\\">\\n                        <span>\\n                            <img alt=\\\"image\\\" id=\\\"profile-image-nav\\\" class=\\\"img-circle\\\" src=\\\"/images/profile/default/0.png\\\">\\n                        </span>\\n                        <a data-toggle=\\\"dropdown\\\" class=\\\"dropdown-toggle\\\" href=\\\"#\\\">\\n                            <span class=\\\"clear\\\"> <span class=\\\"block m-t-xs\\\"> <strong class=\\\"font-bold\\\">{{\\n                                logged.employee.data.first_name }} {{ logged.employee.data.last_name }}</strong>\\n                                </span> <span class=\\\"text-muted text-xs block\\\" v-if=\\\"job_titles\\\">\\n                                    {{job_titles[logged.employee.data.job_history.data.job_title_id]}}\\n                                <b class=\\\"caret\\\"></b></span> </span> </a>\\n                        <ul class=\\\"dropdown-menu animated fadeInRight m-t-xs\\\">\\n                            <li><a href=\\\"/profile\\\">Profile</a></li>\\n                            <li><a href=\\\"contacts.html\\\">Contacts</a></li>\\n                            <li><a href=\\\"mailbox.html\\\">Mailbox</a></li>\\n                            <li class=\\\"divider\\\"></li>\\n                            <li><a href=\\\"#0\\\">Logout</a></li>\\n                        </ul>\\n                    </div>\\n                    <div class=\\\"logo-element\\\">\\n                        HRis\\n                    </div>\\n\\n                </li>\\n                <navbar-static-side></navbar-static-side>\\n            </ul>\\n        </div>\\n    </nav>\\n    <div id=\\\"page-wrapper\\\" class=\\\"gray-bg\\\">\\n        <div class=\\\"row border-bottom\\\">\\n            <navbar-static-top></navbar-static-top>\\n        </div>\\n        <router-view :employee=\\\"employee\\\" :page_title=\\\"page_title\\\" :job_titles=\\\"job_titles\\\" :employment_statuses=\\\"employment_statuses\\\" :routes=\\\"routes\\\" :has_access=\\\"has_access\\\" :permission=\\\"permission\\\"></router-view>\\n        <static-footer></static-footer>\\n    </div>\\n</div>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/pages/default-page.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],129:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    props: ['employee', 'page_title', 'job_titles', 'employment_statuses', 'routes', 'has_access', 'permission'],\n    route: {\n        canReuse: false\n    }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"row wrapper border-bottom page-heading\\\" :class=\\\"{ 'grad-red': ($route.path.indexOf('/pim') == 0 || $route.path.indexOf('/admin') == 0), 'greenpro-bg': ($route.path.indexOf('/pim') == -1 &amp;&amp; $route.path.indexOf('/admin') == -1) }\\\">\\n    <div class=\\\"col-sm-6\\\">\\n        <h2>{{page_title}}</h2>\\n        <!-- Breadcrumbs -->\\n        <ol class=\\\"breadcrumb\\\">\\n            <li>\\n                <a v-link=\\\"{name: 'dashboard'}\\\">Home</a>\\n            </li>\\n            <li v-for=\\\"route in routes\\\">\\n                <a v-link=\\\"{name: route.name, params: {employee_id: route.params.employee_id} }\\\">{{route.segment}}</a>\\n            </li>\\n        </ol>\\n    </div>\\n    <action-area :employee=\\\"employee\\\" :job_titles=\\\"job_titles\\\" :employment_statuses=\\\"employment_statuses\\\" v-if=\\\"$route.path.indexOf('employee-list/') > -1 || $route.path.indexOf('profile/') > -1\\\"></action-area>\\n</div>\\n<div class=\\\"row\\\">\\n    <div class=\\\"col-lg-12\\\">\\n        <div class=\\\"wrapper wrapper-content\\\">\\n            <router-view :employee=\\\"employee\\\" :page_title=\\\"page_title\\\" :job_titles=\\\"job_titles\\\" :employment_statuses=\\\"employment_statuses\\\" :routes=\\\"routes\\\" :has_access=\\\"has_access\\\" :permission=\\\"permission\\\"></router-view>\\n        </div>\\n    </div>\\n</div>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/pages/page.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],130:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    props: ['employee', 'page_title', 'job_titles', 'employment_statuses', 'routes', 'has_access', 'permission'],\n    compiled: function compiled() {\n        this.$dispatch('update-page-title', (this.$route.path.indexOf('pim') > -1 ? 'Employee\\'s ' : 'My ') + 'Contact Details');\n    },\n    data: function data() {\n        return {\n            id: '',\n            address_city_obj: {},\n            address_province_obj: {},\n            address_country_obj: {},\n            city: '',\n            cities_chosen: [{}],\n            province: '',\n            provinces_chosen: [{}],\n            country: '',\n            countries_chosen: [{}]\n        };\n    },\n\n    watch: {\n        'address_province_obj': function address_province_obj() {\n            // retrieve cities\n            if (this.address_province_obj) {\n                this.chosenCities(this.address_province_obj.id, false); // call twice since there's a bug in chosen.js vue directive.\n                this.chosenCities(this.address_province_obj.id, true);\n            }\n        },\n        'cities_chosen': function cities_chosen() {\n            for (var i = 0; i < this.cities_chosen.length; i++) {\n                if (this.employee.address_city_id == this.cities_chosen[i].id) {\n                    this.address_city_obj = this.cities_chosen[i];\n                    break;\n                }\n            }\n        }\n    },\n\n    ready: function ready() {\n        this.queryDatabase();\n    },\n    methods: {\n        queryDatabase: function queryDatabase() {\n            var that = this;\n\n            if (this.$route.path.indexOf('/pim') > -1) {\n                this.employee_id = this.$route.params.employee_id;\n            } else {\n                this.employee_id = localStorage.getItem('employee_id');\n            }\n\n            var params = {\n                path: '/employee/get-by-employee-id?include=user',\n                entity: { 'employee_id': this.employee_id },\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            };\n\n            client(params).then(function (response) {\n\n                that.$dispatch('update-employee', response.entity.data);\n\n                that.chosenProvinces();\n                that.chosenCountries();\n            }, function (response) {\n                console.log(response);\n            });\n        },\n\n        submitForm: function submitForm() {\n            var that = this;\n\n            // jasny bug work around\n            $('#address_1').focus();\n\n            // Set values\n            this.employee.address_city_id = this.address_city_obj.id;\n            this.employee.address_province_id = this.address_province_obj.id;\n            this.employee.address_country_id = this.address_country_obj.id;\n\n            var params = {\n                path: '/profile/contact-details',\n                method: 'PATCH',\n                entity: { 'employee': this.employee },\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            };\n\n            client(params).then(function (response) {\n                switch (response.status.code) {\n                    case 200:\n\n                        if (that.$route.path.indexOf('/pim') > -1) {\n                            that.$route.router.go({\n                                name: 'pim-employee-list-contact-details',\n                                params: { employee_id: response.entity.employee.employee_id }\n                            });\n                        }\n\n                        swal({ title: response.entity.status, type: 'success', timer: 2000 });\n                        that.cancelForm();\n                        break;\n                    case 405:\n                        swal({ title: response.entity.status, type: 'warning', timer: 2000 });\n                        break;\n                    case 500:\n                        $('#first_name').focus();\n                        swal({ title: response.entity.status, type: 'error', timer: 2000 });\n                        break;\n                }\n            });\n        },\n\n        modifyForm: function modifyForm() {\n\n            $('.save-form').css('display', '');\n            $('.modify-form').css('display', 'none');\n            $('.vue-chosen').prop('disabled', false).trigger(\"chosen:updated\");\n            $('.form-control').prop('disabled', false);\n\n            $('#address_1').focus();\n        },\n\n        cancelForm: function cancelForm() {\n            // retrieve original data since cancel button was pressed.\n            this.queryDatabase();\n\n            $('.save-form').css('display', 'none');\n            $('.modify-form').css('display', '');\n            $('.vue-chosen').prop('disabled', true).trigger(\"chosen:updated\");\n            $('.form-control').prop('disabled', true);\n        },\n\n        chosenProvinces: function chosenProvinces() {\n            var that = this;\n\n            // retrieve provinces\n            client({\n                path: '/provinces',\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            }).then(function (response) {\n                if (response) {\n                    that.provinces_chosen = response.entity;\n                }\n\n                that.address_province_obj = that.provinces_chosen[that.employee.address_province_id - 1];\n            });\n        },\n\n        chosenCountries: function chosenCountries() {\n            var that = this;\n\n            // retrieve countries\n            client({\n                path: '/countries',\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            }).then(function (response) {\n                if (response) {\n                    that.countries_chosen = response.entity;\n                }\n\n                that.address_country_obj = that.countries_chosen[that.employee.address_country_id - 1];\n            });\n        },\n\n        chosenCities: function chosenCities(value, open) {\n            var that = this;\n\n            // retrieve cities\n            client({\n                path: '/cities?province_id=' + value,\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            }).then(function (response) {\n                if (response) {\n                    that.cities_chosen = response.entity;\n                }\n                $('.vue-chosen').trigger(\"chosen:updated\");\n\n                if (open) {\n                    $('#address_city_id').trigger(\"chosen:open\");\n                }\n            });\n        }\n    }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"row\\\" v-if=\\\"employee\\\">\\n    <navbar-static-profile-top></navbar-static-profile-top>\\n    <div class=\\\"col-lg-12\\\">\\n        <div class=\\\"ibox float-e-margins\\\">\\n            <div class=\\\"ibox-title\\\">\\n                <h5>Contact Details</h5>\\n                <div class=\\\"ibox-tools\\\">\\n                    <a class=\\\"collapse-link\\\">\\n                        <i class=\\\"fa fa-chevron-up\\\"></i>\\n                    </a>\\n                </div>\\n            </div>\\n            <div class=\\\"ibox-content\\\">\\n                <form method=\\\"POST\\\" onsubmit=\\\"return false;\\\" accept-charset=\\\"UTF-8\\\" class=\\\"form-horizontal\\\" id=\\\"personalDetailsForm\\\">\\n                    <input name=\\\"user[id]\\\" type=\\\"hidden\\\" v-model=\\\"employee.user.id\\\">\\n                    <input name=\\\"id\\\" type=\\\"hidden\\\" v-model=\\\"employee.id\\\">\\n                    <!-- Start - Address Street -->\\n                    <div class=\\\"form-group\\\">\\n                        <label for=\\\"address_1\\\" class=\\\"col-md-2 control-label\\\">Address Street 1</label>\\n                        <div class=\\\"col-md-4\\\">\\n                            <input class=\\\"form-control\\\" disabled=\\\"disabled\\\" type=\\\"text\\\" v-model=\\\"employee.address_1\\\" id=\\\"address_1\\\">\\n                        </div>\\n\\n                        <label for=\\\"address_2\\\" class=\\\"col-md-2 control-label\\\">Address Street 2</label>\\n                        <div class=\\\"col-md-4\\\">\\n                            <input class=\\\"form-control\\\" disabled=\\\"disabled\\\" name=\\\"address_2\\\" type=\\\"text\\\" v-model=\\\"employee.address_2\\\" id=\\\"address_2\\\">\\n                        </div>\\n                    </div>\\n                    <!-- End - Address Street -->\\n\\n                    <!-- Start - City & Province -->\\n                    <div class=\\\"form-group\\\">\\n                        <label for=\\\"address_city_id\\\" class=\\\"col-md-2 control-label\\\">City</label>\\n                        <div class=\\\"col-md-4\\\">\\n                            <chosen id=\\\"address_city_id\\\" disabled=\\\"disabled\\\" class=\\\"vue-chosen\\\" :options=\\\"cities_chosen\\\" :v-model.sync=\\\"address_city_obj\\\" :chosen=\\\"{ width:'100%' }\\\" placeholder=\\\"--- Select ---\\\" text-key=\\\"name\\\"></chosen>\\n\\n                        </div>\\n\\n                        <label for=\\\"address_province_id\\\" class=\\\"col-md-2 control-label\\\">Province</label>\\n                        <div class=\\\"col-md-4\\\">\\n                            <chosen id=\\\"address_province_id\\\" disabled=\\\"disabled\\\" class=\\\"vue-chosen\\\" :options=\\\"provinces_chosen\\\" :v-model.sync=\\\"address_province_obj\\\" :chosen=\\\"{ width:'100%' }\\\" placeholder=\\\"--- Select ---\\\" text-key=\\\"name\\\"></chosen>\\n                        </div>\\n                    </div>\\n                    <!-- End - City & Province -->\\n\\n                    <!-- Start - Zip/Postal Code & Country -->\\n                    <div class=\\\"form-group\\\">\\n                        <label for=\\\"address_postal_code\\\" class=\\\"col-md-2 control-label\\\" data-mask=\\\"9999\\\">Zip/Postal\\n                            Code</label>\\n                        <div class=\\\"col-md-4\\\">\\n                            <input class=\\\"form-control\\\" disabled=\\\"disabled\\\" name=\\\"address_postal_code\\\" type=\\\"text\\\" v-model=\\\"employee.address_postal_code\\\" id=\\\"address_postal_code\\\">\\n                        </div>\\n                        <label for=\\\"address_country_id\\\" class=\\\"col-md-2 control-label\\\">Country</label>\\n                        <div class=\\\"col-md-4\\\">\\n                            <chosen id=\\\"address_country_id\\\" disabled=\\\"disabled\\\" class=\\\"vue-chosen\\\" :options=\\\"countries_chosen\\\" :v-model.sync=\\\"address_country_obj\\\" :chosen=\\\"{ width:'100%' }\\\" placeholder=\\\"--- Select ---\\\" text-key=\\\"name\\\"></chosen>\\n                        </div>\\n                    </div>\\n                    <!-- End - Zip/Postal Code & Country -->\\n\\n                    <div class=\\\"hr-line-dashed\\\"></div>\\n\\n                    <!-- Start - Home & Mobile -->\\n                    <div class=\\\"form-group\\\">\\n                        <label for=\\\"home_phone\\\" class=\\\"col-md-2 control-label\\\">Home Telephone</label>\\n                        <div class=\\\"col-md-4\\\">\\n                            <input class=\\\"form-control\\\" data-mask=\\\"099 999 9999\\\" disabled=\\\"disabled\\\" name=\\\"home_phone\\\" type=\\\"text\\\" v-model=\\\"employee.home_phone\\\" id=\\\"home_phone\\\">\\n                        </div>\\n\\n                        <label for=\\\"mobile_phone\\\" class=\\\"col-md-2 control-label\\\">Mobile</label>\\n                        <div class=\\\"col-md-4\\\">\\n                            <input class=\\\"form-control\\\" data-mask=\\\"0999 999 9999\\\" disabled=\\\"disabled\\\" name=\\\"mobile_phone\\\" type=\\\"text\\\" v-model=\\\"employee.mobile_phone\\\" id=\\\"mobile_phone\\\">\\n                        </div>\\n                    </div>\\n                    <!-- End - Home & Mobile -->\\n\\n                    <div class=\\\"hr-line-dashed\\\"></div>\\n\\n                    <!-- Start - Email -->\\n                    <div class=\\\"form-group\\\">\\n                        <label for=\\\"work_email\\\" class=\\\"col-md-2 control-label\\\">Work Email</label>\\n                        <div class=\\\"col-md-4\\\">\\n                            <input class=\\\"form-control\\\" disabled=\\\"disabled\\\" name=\\\"work_email\\\" type=\\\"email\\\" v-model=\\\"employee.work_email\\\" id=\\\"work_email\\\">\\n                        </div>\\n\\n                        <label for=\\\"other_email\\\" class=\\\"col-md-2 control-label\\\">Other Email</label>\\n                        <div class=\\\"col-md-4\\\">\\n                            <input class=\\\"form-control\\\" disabled=\\\"disabled\\\" name=\\\"other_email\\\" type=\\\"email\\\" v-model=\\\"employee.other_email\\\" id=\\\"other_email\\\">\\n                        </div>\\n                    </div>\\n\\n                    <div class=\\\"hr-line-dashed\\\"></div>\\n                    <!-- End - Email -->\\n\\n                    <!-- Start - Control Buttons -->\\n                    <div class=\\\"form-group save-form\\\" style=\\\"display:none;\\\">\\n                        <div class=\\\"col-sm-4 col-sm-offset-2\\\">\\n                            <a class=\\\"btn btn-white btn-xs cancel-form\\\" @click=\\\"cancelForm\\\">Cancel</a>\\n                            <input class=\\\"btn btn-primary btn-xs\\\" type=\\\"submit\\\" @click=\\\"submitForm\\\" value=\\\"Save changes\\\">\\n                        </div>\\n                    </div>\\n                    <div class=\\\"form-group\\\" v-if=\\\"has_access &amp;&amp; has_access[permission + '.update']\\\">\\n                        <div class=\\\"col-sm-4 col-sm-offset-2\\\">\\n                            <a class=\\\"btn btn-primary btn-xs modify-form\\\" @click=\\\"modifyForm\\\">Modify</a>\\n                        </div>\\n                    </div>\\n                    <!-- End - Control Buttons -->\\n                </form>\\n            </div>\\n        </div>\\n    </div>\\n</div>\\n\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/pages/profile/contact-details.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],131:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    props: ['employee', 'page_title', 'job_titles', 'employment_statuses', 'routes', 'has_access', 'permission'],\n    compiled: function compiled() {\n        this.$dispatch('update-page-title', (this.$route.path.indexOf('pim') > -1 ? 'Employee\\'s ' : 'My ') + 'Dependents');\n    },\n    data: function data() {\n        return {\n            editMode: false,\n            employee_id: '',\n            dependents: [],\n            relationships: [],\n            relationships_chosen: [{}],\n            relationship_obj: {},\n            modal: {\n                first_name: '',\n                middle_name: '',\n                last_name: '',\n                relationship_id: '',\n                birth_date: '',\n                dependent_id: 0\n            }\n        };\n    },\n    ready: function ready() {\n        var that = this;\n        this.queryDatabase();\n        this.chosenRelationships();\n\n        $(\"#dependentsForm\").submit(function (e) {\n            return false;\n        });\n    },\n    methods: {\n        queryDatabase: function queryDatabase() {\n\n            var that = this;\n\n            if (this.$route.path.indexOf('/pim') > -1) {\n                this.employee_id = this.$route.params.employee_id;\n            } else {\n                this.employee_id = localStorage.getItem('employee_id');\n            }\n\n            var params = {\n                path: '/employee/get-by-employee-id?include=user,dependents',\n                entity: { 'employee_id': this.employee_id },\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            };\n\n            client(params).then(function (response) {\n\n                that.$dispatch('update-employee', response.entity.data);\n\n                client({\n                    path: '/relationships?table_view=true',\n                    headers: { 'Authorization': localStorage.getItem('jwt-token') }\n                }).then(function (response) {\n                    that.relationships = response.entity;\n                });\n            }, function (response) {\n                if (response.status.code == 422) {\n                    that.$route.router.go({\n                        name: 'error-404'\n                    });\n                    console.log(response.entity);\n                }\n            });\n        },\n        toggleModal: function toggleModal() {\n\n            this.editMode = false;\n\n            this.modal.first_name = '';\n            this.modal.middle_name = '';\n            this.modal.last_name = '';\n            this.modal.relationship_id = '';\n            this.relationship_obj = '';\n            this.modal.birth_date = '';\n\n            // datepicker for birth_date\n            $('.input-group.date').datepicker({\n                format: 'yyyy-mm-dd',\n                keyboardNavigation: false,\n                forceParse: true,\n                calendarWeeks: true,\n                autoclose: true,\n                clearBtn: true\n            });\n\n            $('#dependent_modal').modal('toggle');\n            $('#dependent_modal').on('shown.bs.modal', function () {\n                $('.vue-chosen', this).trigger('chosen:updated');\n                $('#first_name').focus();\n            });\n        },\n        submitForm: function submitForm() {\n\n            var that = this;\n\n            // jasny bug work around\n            $('#first_name').focus();\n\n            that.modal.employee_id = that.employee.id;\n            that.modal.relationship_id = that.relationship_obj.id;\n\n            if (that.modal.relationship_id && that.modal.first_name && that.modal.last_name) {\n\n                client({\n                    path: '/profile/dependents',\n                    method: that.editMode ? 'PATCH' : 'POST',\n                    entity: that.modal,\n                    headers: { 'Authorization': localStorage.getItem('jwt-token') }\n                }).then(function (response) {\n                    switch (response.status.code) {\n                        case 200:\n                            $('#dependent_modal').modal('toggle');\n                            if (that.editMode) {\n                                that.updateRowInTable();\n                                swal({ title: response.entity.status, type: 'success', timer: 2000 });\n                            } else {\n                                that.employee.dependents.data.push(response.entity.dependent);\n                                swal({ title: response.entity.status, type: 'success', timer: 2000 });\n                            }\n                            break;\n                        case 500:\n                            swal({ title: response.entity.status, type: 'error', timer: 2000 });\n                            break;\n                    }\n                    $('.vue-chosen').trigger('chosen:updated');\n                });\n            } else {\n                $('#dependent_modal').on('shown.bs.modal', function () {\n                    $('.vue-chosen', this).trigger('chosen:open');\n                });\n            }\n        },\n        updateRowInTable: function updateRowInTable() {\n            this.employee.dependents.data[this.editIndex].first_name = this.modal.first_name;\n            this.employee.dependents.data[this.editIndex].middle_name = this.modal.middle_name;\n            this.employee.dependents.data[this.editIndex].last_name = this.modal.last_name;\n            this.employee.dependents.data[this.editIndex].relationship_id = this.modal.relationship_id;\n            this.employee.dependents.data[this.editIndex].birth_date = this.modal.birth_date;\n        },\n        editRecord: function editRecord(dependent, index) {\n            var that = this;\n\n            this.editMode = true;\n            this.editIndex = index;\n\n            that.assignValuesToModal(dependent);\n\n            // datepicker for birth_date\n            $('.input-group.date').datepicker({\n                format: 'yyyy-mm-dd',\n                keyboardNavigation: false,\n                forceParse: true,\n                calendarWeeks: true,\n                autoclose: true,\n                clearBtn: true\n            });\n\n            $('#dependent_modal').modal('toggle');\n            $('#dependent_modal').on('shown.bs.modal', function () {\n                $('.vue-chosen', this).trigger('chosen:updated');\n            });\n\n            $('#first_name').focus();\n        },\n        deleteRecord: function deleteRecord(dependent, index) {\n            var that = this;\n\n            var previousWindowKeyDown = window.onkeydown; // https://github.com/t4t5/sweetalert/issues/127\n            swal({\n                title: 'Are you sure?',\n                text: 'You will not be able to recover this record!',\n                showCancelButton: true,\n                cancelButtonColor: '#d33',\n                type: 'warning',\n                confirmButtonClass: 'confirm-class',\n                cancelButtonClass: 'cancel-class',\n                confirmButtonText: 'Yes, delete it!',\n                closeOnConfirm: false,\n                closeOnCancel: false\n            }, function (isConfirm) {\n                swal.disableButtons();\n                window.onkeydown = previousWindowKeyDown; // https://github.com/t4t5/sweetalert/issues/127\n                if (isConfirm) {\n                    client({\n                        path: '/profile/dependents',\n                        method: 'DELETE',\n                        entity: { id: dependent.id },\n                        headers: { 'Authorization': localStorage.getItem('jwt-token') }\n                    }).then(function (response) {\n                        switch (response.status.code) {\n                            case 200:\n                                swal({ title: response.entity.status, type: 'success', timer: 2000 });\n                                that.employee.dependents.data.splice(index, 1);\n                                break;\n                            case 500:\n                                swal({ title: response.entity.status, type: 'error', timer: 2000 });\n                                break;\n                        }\n                    });\n                } else {\n                    swal('Cancelled', 'No record has been deleted', 'error');\n                }\n            });\n        },\n        assignValuesToModal: function assignValuesToModal(dependent) {\n            this.modal.dependent_id = dependent.id;\n            this.modal.first_name = dependent.first_name;\n            this.modal.middle_name = dependent.middle_name;\n            this.modal.last_name = dependent.last_name;\n            this.modal.relationship_id = dependent.relationship_id;\n            this.relationship_obj = this.relationships_chosen[dependent.relationship_id - 1];\n            this.modal.birth_date = dependent.birth_date.substring(0, 10);\n        },\n        chosenRelationships: function chosenRelationships() {\n\n            var that = this;\n\n            // retrieve relationshops\n            client({\n                path: '/relationships',\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            }).then(function (response) {\n                if (response) {\n                    that.relationships_chosen = response.entity;\n                }\n                $('.vue-chosen').trigger('chosen:updated');\n            });\n        }\n    }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"row\\\" v-if=\\\"employee\\\">\\n    <navbar-static-profile-top></navbar-static-profile-top>\\n    <div class=\\\"col-lg-12\\\">\\n        <div class=\\\"ibox float-e-margins\\\">\\n            <div class=\\\"ibox-title\\\">\\n                <h5>Assigned Dependents</h5>\\n                <div class=\\\"ibox-tools\\\">\\n                    <a class=\\\"collapse-link\\\">\\n                        <i class=\\\"fa fa-chevron-up\\\"></i>\\n                    </a>\\n                </div>\\n            </div>\\n            <div class=\\\"ibox-content\\\">\\n\\n                <div class=\\\"\\\">\\n                    <a id=\\\"add_dependent\\\" v-if=\\\"has_access &amp;&amp; has_access[permission + '.create']\\\" @click=\\\"toggleModal\\\" href=\\\"javascript:void(0);\\\" class=\\\"btn btn-primary btn-xs\\\">Add a new row</a>\\n                </div>\\n                <div class=\\\"table-responsive\\\" v-if=\\\"employee.dependents\\\">\\n                    <table class=\\\"table table-striped\\\">\\n                        <thead>\\n                        <tr>\\n                            <th>Full Name</th>\\n                            <th>Relationship</th>\\n                            <th>Birth Date</th>\\n                            <th class=\\\"fix-width\\\">Action</th>\\n                        </tr>\\n                        </thead>\\n\\n                        <tbody id=\\\"dependents_body\\\">\\n\\n                        <tr v-for=\\\"dependent in employee.dependents.data\\\" class=\\\"item-{{$index}}\\\">\\n                            <td>{{dependent.first_name + ' ' + dependent.last_name}}</td>\\n                            <td>{{relationships[dependent.relationship_id]}}</td>\\n                            <td>{{dependent.birth_date}}</td>\\n                            <td>\\n                                <button rel=\\\"edit\\\" id=\\\"edit_{{dependent.id}}\\\" v-if=\\\"has_access[permission + '.update']\\\" class=\\\"btn btn-primary btn-xs btn-warning\\\" data-toggle=\\\"tooltip\\\" data-placement=\\\"bottom\\\" title=\\\"\\\" type=\\\"button\\\" @click=\\\"editRecord(dependent, $index)\\\" data-original-title=\\\"Edit\\\">\\n                                    <i class=\\\"fa fa-edit\\\"></i></button>\\n                                <button rel=\\\"delete\\\" id=\\\"delete_{{dependent.id}}\\\" v-if=\\\"has_access[permission + '.delete']\\\" class=\\\"btn btn-primary btn-xs btn-danger\\\" data-toggle=\\\"tooltip\\\" data-placement=\\\"bottom\\\" title=\\\"\\\" type=\\\"button\\\" @click=\\\"deleteRecord(dependent, $index)\\\" data-original-title=\\\"Delete\\\"><i class=\\\"fa fa-times\\\"></i></button>\\n                            </td>\\n                        </tr>\\n                        <tr v-if=\\\"employee.dependents &amp;&amp; employee.dependents.data.length == 0\\\">\\n                            <td colspan=\\\"4\\\">No dependents listed</td>\\n                        </tr>\\n                        </tbody>\\n                    </table>\\n                </div>\\n            </div>\\n        </div>\\n    </div>\\n    <!-- Modal -->\\n    <div class=\\\"modal fade\\\" id=\\\"dependent_modal\\\">\\n        <div class=\\\"modal-dialog\\\">\\n            <div class=\\\"modal-content\\\">\\n                <div class=\\\"modal-header\\\">\\n                    <button class=\\\"close\\\" data-dismiss=\\\"modal\\\" type=\\\"button\\\">×</button>\\n\\n                    <h4 class=\\\"modal-title\\\" id=\\\"my_modal_label\\\">Dependent Details</h4>\\n                </div>\\n\\n                <div class=\\\"modal-body\\\">\\n                    <!--Add form-->\\n                    <form method=\\\"POST\\\" onsubmit=\\\"return false;\\\" accept-charset=\\\"UTF-8\\\" class=\\\"form-horizontal\\\" id=\\\"dependentsForm\\\">\\n                        <input type=\\\"hidden\\\" v-model.sync=\\\"modal.dependent_id\\\">\\n                        <div class=\\\"form-group\\\">\\n                            <label for=\\\"first_name\\\" class=\\\"col-md-3 control-label\\\">First Name</label>\\n                            <div class=\\\"col-md-9\\\">\\n                                <input class=\\\"form-control\\\" required=\\\"required\\\" v-model.sync=\\\"modal.first_name\\\" type=\\\"text\\\" id=\\\"first_name\\\">\\n                            </div>\\n                        </div>\\n\\n                        <div class=\\\"form-group\\\">\\n                            <label for=\\\"middle_name\\\" class=\\\"col-md-3 control-label\\\">Middle Name</label>\\n                            <div class=\\\"col-md-9\\\">\\n                                <input class=\\\"form-control\\\" v-model.sync=\\\"modal.middle_name\\\" type=\\\"text\\\" id=\\\"middle_name\\\">\\n                            </div>\\n                        </div>\\n\\n                        <div class=\\\"form-group\\\">\\n                            <label for=\\\"last_name\\\" class=\\\"col-md-3 control-label\\\">Last Name</label>\\n                            <div class=\\\"col-md-9\\\">\\n                                <input class=\\\"form-control\\\" required=\\\"required\\\" v-model.sync=\\\"modal.last_name\\\" type=\\\"text\\\" id=\\\"last_name\\\">\\n                            </div>\\n                        </div>\\n\\n                        <div class=\\\"form-group\\\">\\n                            <label for=\\\"relationship_id\\\" class=\\\"col-md-3 control-label\\\">Relationship</label>\\n                            <div class=\\\"col-md-9\\\">\\n                                <chosen id=\\\"relationship_id\\\" class=\\\"vue-chosen\\\" :options=\\\"relationships_chosen\\\" :v-model.sync=\\\"relationship_obj\\\" :chosen=\\\"{ width:'100%' }\\\" placeholder=\\\"--- Select ---\\\" text-key=\\\"name\\\"></chosen>\\n                            </div>\\n                        </div>\\n\\n                        <div class=\\\"form-group\\\">\\n                            <label for=\\\"birth_date\\\" class=\\\"col-md-3 control-label\\\">Birth Date</label>\\n                            <div class=\\\"col-md-9\\\" id=\\\"datepicker\\\">\\n                                <div class=\\\"input-group date\\\">\\n                                    <span class=\\\"input-group-addon\\\"><i class=\\\"fa fa-calendar\\\"></i></span>\\n                                    <input class=\\\"form-control\\\" data-mask=\\\"9999-99-99\\\" v-model.sync=\\\"modal.birth_date\\\" type=\\\"text\\\" id=\\\"birth_date\\\">\\n                                </div>\\n                            </div>\\n                        </div>\\n\\n                        <div class=\\\"modal-footer\\\">\\n                            <button class=\\\"btn btn-white btn-xs\\\" data-dismiss=\\\"modal\\\" type=\\\"button\\\">Close</button>\\n                            <input class=\\\"btn btn-primary btn-xs\\\" type=\\\"submit\\\" @click=\\\"submitForm\\\" value=\\\"Save changes\\\">\\n                        </div>\\n\\n                    </form><!--// form-->\\n                </div>\\n            </div><!-- /.modal-content -->\\n        </div><!-- /.modal-dialog -->\\n    </div><!-- /.modal -->\\n</div>\\n\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/pages/profile/dependents.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],132:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    props: ['employee', 'page_title', 'job_titles', 'employment_statuses', 'routes', 'has_access', 'permission'],\n    compiled: function compiled() {\n        this.$dispatch('update-page-title', (this.$route.path.indexOf('pim') > -1 ? 'Employee\\'s ' : 'My ') + 'Emergency Contacts');\n    },\n    data: function data() {\n        return {\n            editMode: false,\n            employee_id: '',\n            emergency_contacts: [],\n            relationships: [],\n            relationships_chosen: [{}],\n            relationship_obj: {},\n            modal: {\n                first_name: '',\n                middle_name: '',\n                last_name: '',\n                relationship_id: '',\n                home_phone: '',\n                mobile_phone: '',\n                emergency_contact_id: 0\n            }\n        };\n    },\n    ready: function ready() {\n        var that = this;\n        this.queryDatabase();\n        this.chosenRelationships();\n\n        $(\"#emergencyContactsForm\").submit(function (e) {\n            return false;\n        });\n    },\n    methods: {\n        queryDatabase: function queryDatabase() {\n\n            var that = this;\n\n            if (this.$route.path.indexOf('/pim') > -1) {\n                this.employee_id = this.$route.params.employee_id;\n            } else {\n                this.employee_id = localStorage.getItem('employee_id');\n            }\n\n            var params = {\n                path: '/employee/get-by-employee-id?include=user,emergency_contacts',\n                entity: { 'employee_id': this.employee_id },\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            };\n\n            client(params).then(function (response) {\n\n                that.$dispatch('update-employee', response.entity.data);\n\n                client({\n                    path: '/relationships?table_view=true',\n                    headers: { 'Authorization': localStorage.getItem('jwt-token') }\n                }).then(function (response) {\n                    that.relationships = response.entity;\n                });\n            }, function (response) {\n                if (response.status.code == 422) {\n                    that.$route.router.go({\n                        name: 'error-404'\n                    });\n                    console.log(response.entity);\n                }\n            });\n        },\n        toggleModal: function toggleModal() {\n\n            this.editMode = false;\n\n            this.modal.first_name = '';\n            this.modal.middle_name = '';\n            this.modal.last_name = '';\n            this.modal.relationship_id = '';\n            this.relationship_obj = '';\n            this.modal.home_phone = '';\n            this.modal.mobile_phone = '';\n\n            $('#emergency_contact_modal').modal('toggle');\n            $('#emergency_contact_modal').on('shown.bs.modal', function () {\n                $('.vue-chosen', this).trigger('chosen:updated');\n                $('#first_name').focus();\n            });\n        },\n        submitForm: function submitForm() {\n\n            var that = this;\n\n            // jasny bug work around\n            $('#first_name').focus();\n\n            that.modal.employee_id = that.employee.id;\n            that.modal.relationship_id = that.relationship_obj.id;\n\n            if (that.modal.relationship_id && that.modal.first_name && that.modal.last_name) {\n\n                client({\n                    path: '/profile/emergency-contacts',\n                    method: that.editMode ? 'PATCH' : 'POST',\n                    entity: that.modal,\n                    headers: { 'Authorization': localStorage.getItem('jwt-token') }\n                }).then(function (response) {\n                    switch (response.status.code) {\n                        case 200:\n                            $('#emergency_contact_modal').modal('toggle');\n                            if (that.editMode) {\n                                that.updateRowInTable();\n                                swal({ title: response.entity.status, type: 'success', timer: 2000 });\n                            } else {\n                                that.employee.emergency_contacts.data.push(response.entity.emergency_contact);\n                                swal({ title: response.entity.status, type: 'success', timer: 2000 });\n                            }\n                            break;\n                        case 500:\n                            swal({ title: response.entity.status, type: 'error', timer: 2000 });\n                            break;\n                    }\n                    $('.vue-chosen').trigger('chosen:updated');\n                });\n            } else {\n                $('#emergency_contact_modal').on('shown.bs.modal', function () {\n                    $('.vue-chosen', this).trigger('chosen:open');\n                });\n            }\n        },\n        updateRowInTable: function updateRowInTable() {\n            this.employee.emergency_contacts.data[this.editIndex].first_name = this.modal.first_name;\n            this.employee.emergency_contacts.data[this.editIndex].middle_name = this.modal.middle_name;\n            this.employee.emergency_contacts.data[this.editIndex].last_name = this.modal.last_name;\n            this.employee.emergency_contacts.data[this.editIndex].relationship_id = this.modal.relationship_id;\n            this.employee.emergency_contacts.data[this.editIndex].home_phone = this.modal.home_phone;\n            this.employee.emergency_contacts.data[this.editIndex].mobile_phone = this.modal.mobile_phone;\n        },\n        editRecord: function editRecord(emergency_contact, index) {\n            var that = this;\n\n            this.editMode = true;\n            this.editIndex = index;\n\n            that.assignValuesToModal(emergency_contact);\n\n            $('#emergency_contact_modal').modal('toggle');\n\n            $('#emergency_contact_modal').on('shown.bs.modal', function () {\n                $('.vue-chosen', this).trigger('chosen:updated');\n            });\n\n            $('#first_name').focus();\n        },\n        deleteRecord: function deleteRecord(emergency_contact, index) {\n            var that = this;\n\n            var previousWindowKeyDown = window.onkeydown; // https://github.com/t4t5/sweetalert/issues/127\n            swal({\n                title: 'Are you sure?',\n                text: 'You will not be able to recover this record!',\n                showCancelButton: true,\n                cancelButtonColor: '#d33',\n                type: 'warning',\n                confirmButtonClass: 'confirm-class',\n                cancelButtonClass: 'cancel-class',\n                confirmButtonText: 'Yes, delete it!',\n                closeOnConfirm: false,\n                closeOnCancel: false\n            }, function (isConfirm) {\n                swal.disableButtons();\n                window.onkeydown = previousWindowKeyDown; // https://github.com/t4t5/sweetalert/issues/127\n                if (isConfirm) {\n                    client({\n                        path: '/profile/emergency-contacts',\n                        method: 'DELETE',\n                        entity: { id: emergency_contact.id },\n                        headers: { 'Authorization': localStorage.getItem('jwt-token') }\n                    }).then(function (response) {\n                        switch (response.status.code) {\n                            case 200:\n                                swal({ title: response.entity.status, type: 'success', timer: 2000 });\n                                that.employee.emergency_contacts.data.splice(index, 1);\n                                break;\n                            case 500:\n                                swal({ title: response.entity.status, type: 'error', timer: 2000 });\n                                break;\n                        }\n                    });\n                } else {\n                    swal('Cancelled', 'No record has been deleted', 'error');\n                }\n            });\n        },\n        assignValuesToModal: function assignValuesToModal(emergency_contact) {\n            this.modal.emergency_contact_id = emergency_contact.id;\n            this.modal.first_name = emergency_contact.first_name;\n            this.modal.middle_name = emergency_contact.middle_name;\n            this.modal.last_name = emergency_contact.last_name;\n            this.modal.relationship_id = emergency_contact.relationship_id;\n            this.relationship_obj = this.relationships_chosen[emergency_contact.relationship_id - 1];\n            this.modal.home_phone = emergency_contact.home_phone;\n            this.modal.mobile_phone = emergency_contact.mobile_phone;\n        },\n        chosenRelationships: function chosenRelationships() {\n\n            var that = this;\n\n            // retrieve relationshops\n            client({\n                path: '/relationships',\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            }).then(function (response) {\n                if (response) {\n                    that.relationships_chosen = response.entity;\n                }\n                $('.vue-chosen').trigger('chosen:updated');\n            });\n        }\n    }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"row\\\" v-if=\\\"employee\\\">\\n    <navbar-static-profile-top></navbar-static-profile-top>\\n    <div class=\\\"col-lg-12\\\">\\n        <div class=\\\"ibox float-e-margins\\\">\\n            <div class=\\\"ibox-title\\\">\\n                <h5>In case of Emergency</h5>\\n                <div class=\\\"ibox-tools\\\">\\n                    <a class=\\\"collapse-link\\\">\\n                        <i class=\\\"fa fa-chevron-up\\\"></i>\\n                    </a>\\n                </div>\\n            </div>\\n            <div class=\\\"ibox-content\\\">\\n\\n                <div class=\\\"\\\">\\n                    <a id=\\\"add_emergency_contact\\\" v-if=\\\"has_access &amp;&amp; has_access[permission + '.create']\\\" @click=\\\"toggleModal\\\" href=\\\"javascript:void(0);\\\" class=\\\"btn btn-primary btn-xs\\\">Add a new row</a>\\n                </div>\\n                <div class=\\\"table-responsive\\\" v-if=\\\"employee.emergency_contacts\\\">\\n                    <table class=\\\"table table-striped\\\">\\n                        <thead>\\n                        <tr>\\n                            <th>Full Name</th>\\n                            <th>Relationship</th>\\n                            <th>Home Telephone</th>\\n                            <th>Mobile</th>\\n                            <th class=\\\"fix-width\\\">Action</th>\\n                        </tr>\\n                        </thead>\\n\\n                        <tbody id=\\\"emergency_contacts_body\\\">\\n\\n                        <tr v-for=\\\"emergency_contact in employee.emergency_contacts.data\\\" class=\\\"item-{{$index}}\\\">\\n                            <td>{{emergency_contact.first_name + ' ' + emergency_contact.last_name}}</td>\\n                            <td>{{relationships[emergency_contact.relationship_id]}}</td>\\n                            <td>{{emergency_contact.home_phone}}</td>\\n                            <td>{{emergency_contact.mobile_phone}}</td>\\n                            <td>\\n                                <button rel=\\\"edit\\\" id=\\\"edit_{{emergency_contact.id}}\\\" v-if=\\\"has_access[permission + '.update']\\\" class=\\\"btn btn-primary btn-xs btn-warning\\\" data-toggle=\\\"tooltip\\\" data-placement=\\\"bottom\\\" title=\\\"\\\" type=\\\"button\\\" @click=\\\"editRecord(emergency_contact, $index)\\\" data-original-title=\\\"Edit\\\">\\n                                    <i class=\\\"fa fa-edit\\\"></i></button>\\n                                <button rel=\\\"delete\\\" id=\\\"delete_{{emergency_contact.id}}\\\" v-if=\\\"has_access[permission + '.delete']\\\" class=\\\"btn btn-primary btn-xs btn-danger\\\" data-toggle=\\\"tooltip\\\" data-placement=\\\"bottom\\\" title=\\\"\\\" type=\\\"button\\\" @click=\\\"deleteRecord(emergency_contact, $index)\\\" data-original-title=\\\"Delete\\\"><i class=\\\"fa fa-times\\\"></i></button>\\n                            </td>\\n                        </tr>\\n                        <tr v-if=\\\"employee.emergency_contacts &amp;&amp; employee.emergency_contacts.data.length == 0\\\">\\n                            <td colspan=\\\"5\\\">No emergency contacts listed</td>\\n                        </tr>\\n                        </tbody>\\n                    </table>\\n                </div>\\n            </div>\\n        </div>\\n    </div>\\n    <!-- Modal -->\\n    <div class=\\\"modal fade\\\" id=\\\"emergency_contact_modal\\\">\\n        <div class=\\\"modal-dialog\\\">\\n            <div class=\\\"modal-content\\\">\\n                <div class=\\\"modal-header\\\">\\n                    <button class=\\\"close\\\" data-dismiss=\\\"modal\\\" type=\\\"button\\\">×</button>\\n\\n                    <h4 class=\\\"modal-title\\\" id=\\\"my_modal_label\\\">Emergency Contact Details</h4>\\n                </div>\\n\\n                <div class=\\\"modal-body\\\">\\n                    <!--Add form-->\\n                    <form method=\\\"POST\\\" onsubmit=\\\"return false;\\\" accept-charset=\\\"UTF-8\\\" class=\\\"form-horizontal\\\" id=\\\"emergencyContactsForm\\\">\\n                        <input type=\\\"hidden\\\" v-model.sync=\\\"modal.emergency_contact_id\\\">\\n                        <div class=\\\"form-group\\\">\\n                            <label for=\\\"first_name\\\" class=\\\"col-md-3 control-label\\\">First Name</label>\\n                            <div class=\\\"col-md-9\\\">\\n                                <input class=\\\"form-control\\\" required=\\\"required\\\" v-model.sync=\\\"modal.first_name\\\" type=\\\"text\\\" id=\\\"first_name\\\">\\n                            </div>\\n                        </div>\\n\\n                        <div class=\\\"form-group\\\">\\n                            <label for=\\\"middle_name\\\" class=\\\"col-md-3 control-label\\\">Middle Name</label>\\n                            <div class=\\\"col-md-9\\\">\\n                                <input class=\\\"form-control\\\" v-model.sync=\\\"modal.middle_name\\\" type=\\\"text\\\" id=\\\"middle_name\\\">\\n                            </div>\\n                        </div>\\n\\n                        <div class=\\\"form-group\\\">\\n                            <label for=\\\"last_name\\\" class=\\\"col-md-3 control-label\\\">Last Name</label>\\n                            <div class=\\\"col-md-9\\\">\\n                                <input class=\\\"form-control\\\" required=\\\"required\\\" v-model.sync=\\\"modal.last_name\\\" type=\\\"text\\\" id=\\\"last_name\\\">\\n                            </div>\\n                        </div>\\n\\n                        <div class=\\\"form-group\\\">\\n                            <label for=\\\"relationship_id\\\" class=\\\"col-md-3 control-label\\\">Relationship</label>\\n                            <div class=\\\"col-md-9\\\">\\n                                <chosen id=\\\"relationship_id\\\" class=\\\"vue-chosen\\\" :options=\\\"relationships_chosen\\\" :v-model.sync=\\\"relationship_obj\\\" :chosen=\\\"{ width:'100%' }\\\" placeholder=\\\"--- Select ---\\\" text-key=\\\"name\\\"></chosen>\\n                            </div>\\n                        </div>\\n\\n                        <div class=\\\"form-group\\\">\\n                            <label for=\\\"mobile_phone\\\" class=\\\"col-md-3 control-label\\\">Mobile</label>\\n                            <div class=\\\"col-md-9\\\">\\n                                <input class=\\\"form-control\\\" data-mask=\\\"0999 999 9999\\\" v-model.sync=\\\"modal.mobile_phone\\\" type=\\\"text\\\" id=\\\"mobile_phone\\\">\\n                            </div>\\n                        </div>\\n\\n                        <div class=\\\"form-group\\\">\\n                            <label for=\\\"home_phone\\\" class=\\\"col-md-3 control-label\\\">Home Telephone</label>\\n                            <div class=\\\"col-md-9\\\">\\n                                <input class=\\\"form-control\\\" data-mask=\\\"099 999 9999\\\" v-model.sync=\\\"modal.home_phone\\\" type=\\\"text\\\" id=\\\"home_phone\\\">\\n                            </div>\\n                        </div>\\n\\n                        <div class=\\\"modal-footer\\\">\\n                            <button class=\\\"btn btn-white btn-xs\\\" data-dismiss=\\\"modal\\\" type=\\\"button\\\">Close</button>\\n                            <input class=\\\"btn btn-primary btn-xs\\\" type=\\\"submit\\\" @click=\\\"submitForm\\\" value=\\\"Save changes\\\">\\n                        </div>\\n\\n                    </form><!--// form-->\\n                </div>\\n            </div><!-- /.modal-content -->\\n        </div><!-- /.modal-dialog -->\\n    </div><!-- /.modal -->\\n</div>\\n\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/pages/profile/emergency-contacts.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],133:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    props: ['employee', 'page_title', 'job_titles', 'employment_statuses', 'routes', 'has_access', 'permission'],\n    compiled: function compiled() {\n        this.$dispatch('update-page-title', (this.$route.path.indexOf('pim') > -1 ? 'Employee\\'s ' : 'My ') + 'Personal Details');\n    },\n\n    route: {\n        canReuse: false\n    },\n\n    data: function data() {\n        return {\n            id: '',\n            nationality: '',\n            nationality_obj: {},\n            marital_status_obj: {},\n            nationalities_chosen: [{}],\n            marital_status: '',\n            marital_statuses_chosen: [{}],\n            original_employee_id: ''\n        };\n    },\n    ready: function ready() {\n        this.queryDatabase();\n    },\n    methods: {\n\n        queryDatabase: function queryDatabase() {\n            var that = this;\n\n            if (this.$route.path.indexOf('/pim') > -1) {\n                this.employee_id = this.$route.params.employee_id;\n            } else {\n                this.employee_id = localStorage.getItem('employee_id');\n            }\n\n            var params = {\n                path: '/employee/get-by-employee-id?include=user',\n                entity: { 'employee_id': this.employee_id },\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            };\n\n            client(params).then(function (response) {\n\n                that.$dispatch('update-employee', response.entity.data);\n\n                that.original_employee_id = response.entity.data.employee_id;\n\n                that.chosenNationalities();\n                that.chosenMaritalStatuses();\n\n                var maritalStatusChosenWatcher = setInterval(function () {\n                    if (that.employee != null) {\n                        // iCheck\n                        $('.i-checks').iCheck({\n                            checkboxClass: 'icheckbox_square-green',\n                            radioClass: 'iradio_square-green'\n                        });\n                        clearInterval(maritalStatusChosenWatcher);\n                    }\n                }, 1);\n\n                if (that.employee) {\n                    $('input[name=\"gender\"]').on('ifChecked', function (event) {\n                        that.employee.gender = this.value;\n                    });\n\n                    that.switchGender(that.employee.gender);\n                }\n            }, function (response) {\n                if (response.status.code == 422) {\n                    that.$route.router.go({\n                        name: 'error-404'\n                    });\n                    console.log(response.entity);\n                }\n            });\n        },\n        submitForm: function submitForm() {\n            var self = this;\n\n            // jasny bug work around\n            $('#first_name').focus();\n\n            this.employee.marital_status_id = this.marital_status_obj.id;\n            this.employee.nationality_id = this.nationality_obj.id;\n\n            var params = {\n                path: '/profile/personal-details',\n                method: 'PATCH',\n                entity: { 'employee': this.employee },\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            };\n\n            client(params).then(function (response) {\n                switch (response.status.code) {\n                    case 200:\n\n                        self.updateLocalStorage(response.entity.employee.employee_id);\n\n                        if (self.$route.path.indexOf('/pim') > -1) {\n                            self.$route.router.go({\n                                name: 'pim-employee-list-personal-details',\n                                params: { employee_id: response.entity.employee.employee_id }\n                            });\n                        }\n\n                        self.$route.params.employee_id = response.entity.employee.employee_id;\n                        swal({ title: response.entity.status, type: 'success', timer: 2000 });\n                        self.cancelForm();\n                        break;\n                    case 405:\n                        swal({ title: response.entity.status, type: 'warning', timer: 2000 });\n                        break;\n                    case 500:\n                        $('#first_name').focus();\n                        swal({ title: response.entity.status, type: 'error', timer: 2000 });\n                        break;\n                }\n            });\n        },\n        modifyForm: function modifyForm() {\n\n            $('.avatar').css('display', '');\n            $('.job-title').css('display', 'none');\n\n            $('.save-form').css('display', '');\n            $('.modify-form').css('display', 'none');\n            $('.vue-chosen').prop('disabled', false).trigger(\"chosen:updated\");\n            $('.form-control').prop('disabled', false);\n            $('.i-checks').iCheck('enable');\n\n            // datepicker for birth_date\n            $('.input-group.date').datepicker({\n                format: 'yyyy-mm-dd',\n                keyboardNavigation: false,\n                forceParse: true,\n                calendarWeeks: true,\n                autoclose: true,\n                clearBtn: true\n            }).datepicker('update', this.employee.birth_date);\n\n            $('#first_name').focus();\n        },\n        cancelForm: function cancelForm() {\n            // retrieve original data since cancel button was pressed.\n            this.queryDatabase();\n\n            $('.avatar').css('display', 'none');\n            $('.job-title').css('display', '');\n\n            $('.save-form').css('display', 'none');\n            $('.modify-form').css('display', '');\n            $('.vue-chosen').prop('disabled', true).trigger(\"chosen:updated\");\n            ;\n            $('.form-control').prop('disabled', true);\n            $('.i-checks').iCheck('disable');\n\n            // datepicker for birth_date\n            $('#datepicker_birth_date .input-group.date').datepicker('remove');\n        },\n        switchGender: function switchGender(gender) {\n            switch (gender) {\n                case 'M':\n                    $('input[id=\"gender[1]\"]').iCheck('check');\n                    break;\n                case 'F':\n                    $('input[id=\"gender[2]\"]').iCheck('check');\n                    break;\n            }\n        },\n        updateLocalStorage: function updateLocalStorage(new_employee_id) {\n            var self = this;\n\n            if (self.original_employee_id == localStorage.getItem('employee_id')) {\n                localStorage.setItem('employee_id', new_employee_id);\n            }\n        },\n        chosenNationalities: function chosenNationalities() {\n            var self = this;\n\n            // retrieve nationalities\n            client({\n                path: '/nationalities',\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            }).then(function (response) {\n                if (response) {\n                    self.nationalities_chosen = response.entity;\n                }\n\n                self.nationality_obj = self.nationalities_chosen[self.employee.nationality_id - 1];\n                $('.vue-chosen').trigger(\"chosen:updated\");\n            });\n        },\n        chosenMaritalStatuses: function chosenMaritalStatuses() {\n            var self = this;\n\n            // retrieve marital status\n            client({\n                path: '/marital-statuses',\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            }).then(function (response) {\n                if (response) {\n                    self.marital_statuses_chosen = response.entity;\n                }\n\n                self.marital_status_obj = self.marital_statuses_chosen[self.employee.marital_status_id - 1];\n                $('.vue-chosen').trigger(\"chosen:updated\");\n            });\n        }\n    }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"row\\\" v-if=\\\"employee\\\">\\n    <navbar-static-profile-top></navbar-static-profile-top>\\n    <div class=\\\"col-lg-12\\\">\\n        <div class=\\\"ibox float-e-margins\\\">\\n            <div class=\\\"ibox-title\\\">\\n                <h5>Personal Details</h5>\\n                <div class=\\\"ibox-tools\\\">\\n                    <a class=\\\"collapse-link\\\">\\n                        <i class=\\\"fa fa-chevron-up\\\"></i>\\n                    </a>\\n                </div>\\n            </div>\\n            <div class=\\\"ibox-content\\\">\\n                <form onsubmit=\\\"return false;\\\" accept-charset=\\\"UTF-8\\\" class=\\\"form-horizontal\\\" id=\\\"personalDetailsForm\\\">\\n                    <input name=\\\"user[id]\\\" type=\\\"hidden\\\" v-model=\\\"employee.user.data.id\\\">\\n                    <input name=\\\"id\\\" type=\\\"hidden\\\" v-model=\\\"employee.id\\\">\\n                    <!-- Start - Full Name -->\\n                    <div class=\\\"form-group\\\">\\n                        <label for=\\\"first_name\\\" class=\\\"col-md-2 control-label\\\">Full Name</label>\\n                        <div class=\\\"col-md-4\\\">\\n                            <input class=\\\"form-control\\\" disabled=\\\"disabled\\\" type=\\\"text\\\" v-model=\\\"employee.first_name\\\" id=\\\"first_name\\\" required=\\\"required\\\">\\n                            <span class=\\\"help-block m-b-none\\\">First Name</span>\\n                        </div>\\n                        <div class=\\\"col-md-2\\\">\\n                            <input class=\\\"form-control\\\" disabled=\\\"disabled\\\" type=\\\"text\\\" v-model=\\\"employee.middle_name\\\" id=\\\"middle_name\\\">\\n                            <span class=\\\"help-block m-b-none\\\">Middle Name</span>\\n                        </div>\\n                        <div class=\\\"col-md-4\\\">\\n                            <input class=\\\"form-control\\\" disabled=\\\"disabled\\\" type=\\\"text\\\" v-model=\\\"employee.last_name\\\" id=\\\"last_name\\\" required=\\\"required\\\">\\n                            <span class=\\\"help-block m-b-none\\\">Last Name</span>\\n                        </div>\\n                    </div>\\n                    <!-- End - Full Name -->\\n\\n                    <div class=\\\"hr-line-dashed\\\"></div>\\n\\n                    <!-- Start - Employee Id & Face Id -->\\n                    <div class=\\\"form-group\\\">\\n                        <label for=\\\"employee_id\\\" class=\\\"col-md-2 control-label\\\">Employee Id</label>\\n                        <div class=\\\"col-sm-4\\\">\\n                            <input class=\\\"form-control\\\" data-mask=\\\"HRis-9999\\\" disabled=\\\"disabled\\\" type=\\\"text\\\" v-model=\\\"employee.employee_id\\\" id=\\\"employee_id\\\" required=\\\"required\\\">\\n                        </div>\\n                        <label for=\\\"face_id\\\" class=\\\"col-md-2 control-label\\\">Face Id</label>\\n                        <div class=\\\"col-sm-4\\\">\\n                            <input class=\\\"form-control\\\" data-mask=\\\"999\\\" disabled=\\\"disabled\\\" type=\\\"text\\\" v-model=\\\"employee.face_id\\\" id=\\\"face_id\\\">\\n                        </div>\\n                    </div>\\n                    <!-- End - Employee Id & Face Id -->\\n\\n                    <div class=\\\"hr-line-dashed\\\"></div>\\n\\n                    <!-- Start - Gender & Marital Status -->\\n                    <div class=\\\"form-group\\\">\\n                        <label for=\\\"gender[1]\\\" class=\\\"col-md-2 control-label\\\">Gender</label>\\n                        <div class=\\\"col-sm-4\\\">\\n                            <label class=\\\"radio-inline i-checks\\\">\\n                                <input disabled=\\\"disabled\\\" type=\\\"radio\\\" name=\\\"gender\\\" value=\\\"M\\\" v-model=\\\"employee.gender\\\" id=\\\"gender[1]\\\"> Male\\n                            </label>\\n                            <label class=\\\"radio-inline i-checks\\\">\\n                                <input disabled=\\\"disabled\\\" type=\\\"radio\\\" name=\\\"gender\\\" value=\\\"F\\\" v-model=\\\"employee.gender\\\" id=\\\"gender[2]\\\"> Female\\n                            </label>\\n                        </div>\\n                        <label for=\\\"marital_status_id\\\" class=\\\"col-md-2 control-label\\\">Marital Status</label>\\n                        <div class=\\\"col-sm-4\\\">\\n                            <chosen id=\\\"marital_status_id\\\" disabled=\\\"disabled\\\" class=\\\"vue-chosen\\\" :options=\\\"marital_statuses_chosen\\\" :v-model.sync=\\\"marital_status_obj\\\" :chosen=\\\"{ width:'100%' }\\\" placeholder=\\\"--- Select ---\\\" text-key=\\\"name\\\"></chosen>\\n                        </div>\\n                    </div>\\n                    <!-- End - Gender & Marital Status -->\\n\\n                    <!-- Start - Nationality & DOB -->\\n                    <div class=\\\"form-group\\\">\\n                        <label for=\\\"nationality_id\\\" class=\\\"col-md-2 control-label\\\">Nationality</label>\\n                        <div class=\\\"col-sm-4\\\">\\n                            <chosen id=\\\"nationality_id\\\" disabled=\\\"disabled\\\" class=\\\"vue-chosen\\\" :options=\\\"nationalities_chosen\\\" :v-model.sync=\\\"nationality_obj\\\" :chosen=\\\"{ width:'100%' }\\\" placeholder=\\\"--- Select ---\\\" text-key=\\\"name\\\"></chosen>\\n                        </div>\\n                        <label for=\\\"birth_date\\\" class=\\\"col-md-2 control-label\\\">Date of Birth</label>\\n                        <div class=\\\"col-sm-4\\\" id=\\\"datepicker_birth_date\\\">\\n                            <div class=\\\"input-group date\\\">\\n                                <span class=\\\"input-group-addon\\\"><i class=\\\"fa fa-calendar\\\"></i></span><input class=\\\"form-control\\\" data-mask=\\\"9999-99-99\\\" disabled=\\\"disabled\\\" name=\\\"birth_date\\\" type=\\\"text\\\" v-model=\\\"employee.birth_date\\\" id=\\\"birth_date\\\">\\n                            </div>\\n                        </div>\\n                    </div>\\n                    <!-- End - Nationality & DOB -->\\n\\n                    <div class=\\\"hr-line-dashed\\\"></div>\\n\\n                    <!-- Start - Social Security & Tax Identification -->\\n                    <div class=\\\"form-group\\\">\\n                        <label for=\\\"social_security\\\" class=\\\"col-md-2 control-label\\\">Social Security</label>\\n                        <div class=\\\"col-sm-4\\\">\\n                            <input class=\\\"form-control\\\" data-mask=\\\"99-9999999-9\\\" disabled=\\\"disabled\\\" type=\\\"text\\\" v-model=\\\"employee.social_security\\\" id=\\\"social_security\\\">\\n                        </div>\\n                        <label for=\\\"tax_identification\\\" class=\\\"col-md-2 control-label\\\">Tax Identification</label>\\n                        <div class=\\\"col-sm-4\\\">\\n                            <input class=\\\"form-control\\\" data-mask=\\\"999-999-999\\\" disabled=\\\"disabled\\\" type=\\\"text\\\" v-model=\\\"employee.tax_identification\\\" id=\\\"tax_identification\\\">\\n                        </div>\\n                    </div>\\n                    <!-- End - Social Security & Tax Identification -->\\n\\n                    <!-- Start - PhilHealth & PagIbig -->\\n                    <div class=\\\"form-group\\\">\\n                        <label for=\\\"philhealth\\\" class=\\\"col-md-2 control-label\\\">PhilHealth</label>\\n                        <div class=\\\"col-sm-4\\\">\\n                            <input class=\\\"form-control\\\" data-mask=\\\"99-999999999-9\\\" disabled=\\\"disabled\\\" type=\\\"text\\\" v-model=\\\"employee.philhealth\\\" id=\\\"philhealth\\\">\\n                        </div>\\n                        <label for=\\\"hdmf_pagibig\\\" class=\\\"col-md-2 control-label\\\">HDMF / PagIbig</label>\\n                        <div class=\\\"col-sm-4\\\">\\n                            <input class=\\\"form-control\\\" data-mask=\\\"9999 9999 9999\\\" disabled=\\\"disabled\\\" type=\\\"text\\\" v-model=\\\"employee.hdmf_pagibig\\\" id=\\\"hdmf_pagibig\\\">\\n                        </div>\\n                    </div>\\n                    <!-- End - PhilHealth & PagIbig -->\\n\\n                    <div class=\\\"hr-line-dashed\\\"></div>\\n\\n                    <!-- Start - Control Buttons -->\\n                    <div class=\\\"form-group save-form\\\" style=\\\"display:none;\\\">\\n                        <div class=\\\"col-sm-4 col-sm-offset-2\\\">\\n                            <button class=\\\"btn btn-white btn-xs cancel-form\\\" type=\\\"button\\\" @click.prevent=\\\"cancelForm\\\">\\n                                Cancel\\n                            </button>\\n                            <button class=\\\"btn btn-primary btn-xs\\\" type=\\\"submit\\\" @click=\\\"submitForm\\\">Save changes\\n                            </button>\\n\\n                        </div>\\n                    </div>\\n                    <div class=\\\"form-group\\\" v-if=\\\"has_access &amp;&amp; has_access[permission + '.update']\\\">\\n                        <div class=\\\"col-sm-4 col-sm-offset-2\\\">\\n                            <button class=\\\"btn btn-primary btn-xs modify-form\\\" type=\\\"button\\\" @click.prevent=\\\"modifyForm\\\">Modify\\n                            </button>\\n                        </div>\\n                    </div>\\n                    <!-- End - Control Buttons -->\\n                </form>\\n            </div>\\n        </div>\\n    </div>\\n</div>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/pages/profile/personal-details.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],134:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    props: ['employee', 'job_titles', 'employment_statuses'],\n    route: {\n        canReuse: false\n    }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"col-sm-6\\\">\\n    <div class=\\\"profile-img\\\">\\n\\n        <img id=\\\"profile-image\\\" alt=\\\"avatar\\\" src=\\\"/images/profile/default/0.png\\\">\\n        <div class=\\\"profile-details\\\">\\n\\n            <h2 v-if=\\\"employee\\\">{{employee.first_name}} {{employee.last_name}}</h2>\\n            <h3 v-if=\\\"job_titles\\\">{{job_titles[employee.job_history.data.job_title_id]}}</h3>\\n\\n            <h4 class=\\\"avatar\\\" style=\\\"display: none;\\\">\\n                <span id=\\\"add_avatar\\\" class=\\\"label label-primary\\\">Edit Avatar</span>\\n            </h4>\\n            <h4 v-if=\\\"employment_statuses\\\" class=\\\"job-title\\\">\\n                <span v-if=\\\"employment_statuses[employee.job_history.data.employment_status_id-1]\\\" class=\\\"label {{employment_statuses[employee.job_history.data.employment_status_id-1].class}}\\\">{{employment_statuses[employee.job_history.data.employment_status_id-1].name}}\\n                </span>\\n            </h4>\\n        </div>\\n    </div>\\n</div>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/partials/action-area.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],135:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    data: function data() {\n        return {\n            changing: false\n        };\n    },\n    directives: {\n        jData: function jData(value) {\n            var el = this.el;\n            $(el).data('chosen', value);\n        }\n    },\n    props: {\n        options: null,\n        'v-model': { twoWay: true, 'default': null },\n        'selected-options': {\n            twoWay: true, 'default': function _default() {\n                return [];\n            }, type: Array\n        },\n        chosen: null,\n        'text-key': null,\n        placeholder: null,\n        multiple: { type: Boolean, required: false }\n    },\n    filters: {\n        toOptionData: function toOptionData(val) {\n            if (!val) return val;\n            var key = this.textKey;\n            if (!(val instanceof Array)) return val;\n            return val.map(function (x) {\n                if (key) return { text: x[key], value: x };else return { text: (x ? x : '').toString(), value: x };\n            });\n        }\n    },\n    methods: {\n        select: function select(objs) {\n            if (!objs) var objs = [];\n            this.changing = true;\n            try {\n                $(this.$el).find('option').each(function (i, e) {\n                    var data = $(e).data('chosen');\n                    if (!data) {\n                        return;\n                    }\n                    if (objs.indexOf(data.value) != -1) {\n                        $(e).attr('selected', 'selected');\n                    } else {\n                        $(e).removeAttr('selected');\n                    }\n                });\n                $(this.$el).trigger(\"chosen:updated\");\n            } finally {\n                this.changing = false;\n            }\n        }\n    },\n    ready: function ready() {\n        var _this = this;\n        // initialize\n        var coptions = $.extend({}, { width: '10em' }, this.chosen);\n        $(this.$el).chosen(coptions);\n        // initialize selection\n        if (this.vModel) this.select([this.vModel]);else this.select(this.selectedOptions);\n        // track changes\n        $(this.$el).on('change', function () {\n            if (_this.changing) return;\n            _this.changing = true;\n            try {\n                var target = _this.selectedOptions;\n                if (!target) {\n                    target = [];\n                    _this.selectedOptions = target;\n                }\n                target.splice(0, target.length);\n                $(_this.$el).find(':selected').each(function (i, e) {\n                    var data = $(e).data('chosen');\n                    if (data) target.push(data.value);\n                });\n                _this.vModel = target.length > 0 ? target[0] : null;\n            } finally {\n                _this.changing = false;\n            }\n        });\n    },\n    watch: {\n        'vModel': function vModel(value) {\n            if (this.changing) return;\n            if (value) {\n                this.select([value]);\n            } else this.select([]);\n        },\n        'selectedOptions': function selectedOptions(value) {\n            if (this.changing) return;\n            if (value) {\n                this.select(value);\n            } else this.select([]);\n        }\n    }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<select v-bind:data-placeholder=\\\"placeholder\\\" v-bind:multiple=\\\"multiple\\\" class=\\\"chosen-select\\\">\\n    <option v-if=\\\"placeholder\\\"></option>\\n    <option v-for=\\\"item in options | toOptionData\\\" v-j-data=\\\"item\\\" value=\\\"{{item.id}}\\\">{{item.text}}</option>\\n</select>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/partials/chosen.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],136:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<!--\\n ___.   ________\\n \\\\\\\\_ |__ \\\\\\\\_____  \\\\\\\\__________  ___\\n   | __ \\\\\\\\  _(__  <_  __ \\\\\\\\  \\\\\\\\/  /\\n   | \\\\\\\\_\\\\\\\\ \\\\\\\\/       \\\\\\\\  | \\\\\\\\/>    <\\n   |___  /______  /__|  /__/\\\\\\\\_ \\\\\\\\\\n       \\\\\\\\/       \\\\\\\\/ Studios    \\\\\\\\/\\n-->\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/partials/copyleft.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],137:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"col-lg-12 top-nav-b\\\">\\n    <div class=\\\"btn-group top-nav-li\\\">\\n        <ul>\\n            <li :class=\\\"{'active': $route.path.indexOf('/profile/personal-details') > -1 || $route.path.indexOf('/pim/employee-list/'+$route.params.employee_id+'/personal-details') > -1, 'navy': $route.path.indexOf('/pim') > -1 }\\\">\\n                <a v-if=\\\"$route.path.indexOf('/profile') > -1\\\" v-link=\\\"{name : 'profile-personal-details'}\\\">\\n                    <i class=\\\"fa fa-file-text-o  m-right-a\\\"></i>\\n                    Personal Details\\n                </a>\\n                <a v-if=\\\"$route.path.indexOf('/pim') > -1\\\" v-link=\\\"{name : 'pim-employee-list-personal-details', params: {employee_id: $route.params.employee_id}}\\\">\\n                    <i class=\\\"fa fa-file-text-o  m-right-a\\\"></i>\\n                    Personal Details\\n                </a>\\n            </li>\\n            <li :class=\\\"{'active': $route.path.indexOf('/profile/contact-details') > -1 || $route.path.indexOf('/pim/employee-list/'+$route.params.employee_id+'/contact-details') > -1, 'navy': $route.path.indexOf('/pim') > -1 }\\\">\\n                <a v-if=\\\"$route.path.indexOf('/profile') > -1\\\" v-link=\\\"{name : 'profile-contact-details'}\\\">\\n                    <i class=\\\"fa fa-phone-square m-right-a\\\"></i>\\n                    Contact Details\\n                </a>\\n                <a v-if=\\\"$route.path.indexOf('/pim') > -1\\\" v-link=\\\"{name : 'pim-employee-list-contact-details', params: {employee_id: $route.params.employee_id}}\\\">\\n                    <i class=\\\"fa fa-phone-square m-right-a\\\"></i>\\n                    Contact Details\\n                </a>\\n            </li>\\n            <li :class=\\\"{'active': $route.path.indexOf('/profile/emergency-contacts') > -1 || $route.path.indexOf('/pim/employee-list/'+$route.params.employee_id+'/emergency-contacts') > -1, 'navy': $route.path.indexOf('/pim') > -1 }\\\">\\n                <a v-if=\\\"$route.path.indexOf('/profile') > -1\\\" v-link=\\\"{name : 'profile-emergency-contacts'}\\\">\\n                    <i class=\\\"fa fa-plus-square  m-right-a\\\"></i>\\n                    Emergency Contacts\\n                </a>\\n                <a v-if=\\\"$route.path.indexOf('/pim') > -1\\\" v-link=\\\"{name : 'pim-employee-list-emergency-contacts', params: {employee_id: $route.params.employee_id}}\\\">\\n                    <i class=\\\"fa fa-plus-square  m-right-a\\\"></i>\\n                    Emergency Contacts\\n                </a>\\n            </li>\\n            <li :class=\\\"{'active': $route.path.indexOf('/profile/dependents') > -1 || $route.path.indexOf('/pim/employee-list/'+$route.params.employee_id+'/dependents') > -1, 'navy': $route.path.indexOf('/pim') > -1 }\\\">\\n                <a v-if=\\\"$route.path.indexOf('/profile') > -1\\\" v-link=\\\"{name : 'profile-dependents'}\\\">\\n                    <i class=\\\"fa fa-child m-right-a\\\"></i>\\n                    Dependents\\n                </a>\\n                <a v-if=\\\"$route.path.indexOf('/pim') > -1\\\" v-link=\\\"{name : 'pim-employee-list-dependents', params: {employee_id: $route.params.employee_id}}\\\">\\n                    <i class=\\\"fa fa-child m-right-a\\\"></i>\\n                    Dependents\\n                </a>\\n            </li>\\n            <li :class=\\\"{'active': $route.path.indexOf('/profile/job') > -1 || $route.path.indexOf('/pim/employee-list/'+$route.params.employee_id+'/job') > -1, 'navy': $route.path.indexOf('/pim') > -1 }\\\">\\n                <a v-if=\\\"$route.path.indexOf('/profile') > -1\\\" v-link=\\\"{name : 'profile-job'}\\\">\\n                    <i class=\\\"fa fa-briefcase m-right-a\\\"></i>\\n                    Job\\n                </a>\\n                <a v-if=\\\"$route.path.indexOf('/pim') > -1\\\" v-link=\\\"{name : 'pim-employee-list-job', params: {employee_id: $route.params.employee_id}}\\\">\\n                    <i class=\\\"fa fa-briefcase m-right-a\\\"></i>\\n                    Job\\n                </a>\\n            </li>\\n            <li :class=\\\"{'active': $route.path.indexOf('/profile/work-shifts') > -1 || $route.path.indexOf('/pim/employee-list/'+$route.params.employee_id+'/work-shifts') > -1, 'navy': $route.path.indexOf('/pim') > -1 }\\\">\\n                <a v-if=\\\"$route.path.indexOf('/profile') > -1\\\" v-link=\\\"{name : 'profile-work-shifts'}\\\">\\n                    <i class=\\\"fa fa-clock-o m-right-a\\\"></i>\\n                    Work Shifts\\n                </a>\\n                <a v-if=\\\"$route.path.indexOf('/pim') > -1\\\" v-link=\\\"{name : 'pim-employee-list-work-shifts', params: {employee_id: $route.params.employee_id}}\\\">\\n                    <i class=\\\"fa fa-clock-o m-right-a\\\"></i>\\n                    Work Shifts\\n                </a>\\n            </li>\\n            <li :class=\\\"{'active': $route.path.indexOf('/profile/salary') > -1 || $route.path.indexOf('/pim/employee-list/'+$route.params.employee_id+'/salary') > -1, 'navy': $route.path.indexOf('/pim') > -1 }\\\">\\n                <a v-if=\\\"$route.path.indexOf('/profile') > -1\\\" v-link=\\\"{name : 'profile-salary'}\\\">\\n                    <i class=\\\"fa fa-money m-right-a\\\"></i>\\n                    Salary\\n                </a>\\n                <a v-if=\\\"$route.path.indexOf('/pim') > -1\\\" v-link=\\\"{name : 'pim-employee-list-salary', params: {employee_id: $route.params.employee_id}}\\\">\\n                    <i class=\\\"fa fa-money m-right-a\\\"></i>\\n                    Salary\\n                </a>\\n            </li>\\n            <li :class=\\\"{'active': $route.path.indexOf('/profile/qualifications') > -1 || $route.path.indexOf('/pim/employee-list/'+$route.params.employee_id+'/qualifications') > -1, 'navy': $route.path.indexOf('/pim') > -1 }\\\">\\n                <a v-if=\\\"$route.path.indexOf('/profile') > -1\\\" v-link=\\\"{name : 'profile-qualifications'}\\\">\\n                    <i class=\\\"fa fa-bookmark m-right-a\\\"></i>\\n                    Qualifications\\n                </a>\\n                <a v-if=\\\"$route.path.indexOf('/pim') > -1\\\" v-link=\\\"{name : 'pim-employee-list-qualifications', params: {employee_id: $route.params.employee_id}}\\\">\\n                    <i class=\\\"fa fa-bookmark m-right-a\\\"></i>\\n                    Qualifications\\n                </a>\\n            </li>\\n        </ul>\\n    </div>\\n</div>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/partials/navbar-static-profile-top.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],138:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    data: function data() {\n        return {\n            navlinks: '',\n            employment_status: {},\n            job_titles: {},\n            employee: {}\n        };\n    },\n    ready: function ready() {\n        var that = this;\n        var that = this;\n        this.$on('set-sidebar', function () {\n            that.navlinks = JSON.parse(atob(localStorage.getItem('sidebar')));\n            $('#side-menu').metisMenu();\n        });\n    }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<li v-for=\\\"navlink in navlinks\\\" v-bind:class=\\\"{ 'active': $route.path.indexOf('/'+navlink.href) == 0, 'navy': navlink.href.indexOf('pim') == 0 || navlink.href.indexOf('admin') == 0 }\\\">\\n    <a v-link=\\\"{name: navlink.route}\\\">\\n        <i class=\\\"fa {{navlink.icon}}\\\"></i>\\n        <span class=\\\"nav-label\\\">{{navlink.name}}</span>\\n        <span v-if=\\\"navlink.children.length\\\" class=\\\"fa arrow\\\"></span>\\n    </a>\\n    <ul class=\\\"nav nav-second-level collapse\\\" v-bind:class=\\\"{ 'in': $route.path.indexOf('/'+navlink.href) == 0 }\\\" v-if=\\\"navlink.children.length\\\">\\n        <li v-for=\\\"child in navlink.children\\\" v-bind:class=\\\"{ 'active': $route.path.indexOf('/'+child.href) == 0, 'navy': child.href.indexOf('pim') == 0 || child.href.indexOf('admin') == 0 }\\\">\\n            <a v-link=\\\"{name : child.route}\\\">\\n                <i class=\\\"fa {{child.icon}}\\\"></i>\\n                <span class=\\\"nav-label\\\">{{child.name}}</span>\\n                <span v-if=\\\"child.children.length\\\" class=\\\"fa arrow\\\"></span>\\n            </a>\\n            <ul class=\\\"nav nav-third-level collapse\\\" v-bind:class=\\\"{ 'in': $route.path.indexOf('/'+child.href) == 0 }\\\" v-if=\\\"child.children.length\\\">\\n                <li v-for=\\\"grandchild in child.children\\\" v-bind:class=\\\"{ 'active': $route.path.indexOf('/'+grandchild.href) == 0, 'navy': grandchild.href.indexOf('pim') == 0 || grandchild.href.indexOf('admin') == 0 }\\\">\\n                    <a v-link=\\\"{name : grandchild.route}\\\">\\n                        <i class=\\\"fa {{grandchild.icon}}\\\"></i>\\n                        <span class=\\\"nav-label\\\">{{grandchild.name}}</span>\\n                        <span v-if=\\\"grandchild.children.length\\\" class=\\\"fa arrow\\\"></span>\\n                    </a>\\n                </li>\\n            </ul>\\n        </li>\\n    </ul>\\n</li>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/partials/navbar-static-side.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],139:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    methods: {\n        doLogout: function doLogout() {\n            var self = this;\n\n            client({\n                path: '/logout',\n                headers: { 'Authorization': localStorage.getItem('jwt-token') }\n            }).then(function (response) {\n                localStorage.removeItem('avatar');\n                localStorage.removeItem('employee_id');\n                localStorage.removeItem('jwt-token');\n                localStorage.removeItem('logged');\n                localStorage.removeItem('permissions');\n                localStorage.removeItem('sidebar');\n                self.$route.router.go({ name: 'login' });\n            });\n        }\n    }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<nav class=\\\"navbar navbar-static-top  \\\" role=\\\"navigation\\\" style=\\\"margin-bottom: 0\\\">\\n    <div class=\\\"navbar-header\\\">\\n        <a class=\\\"navbar-minimalize minimalize-styl-2 btn btn-ghost\\\" href=\\\"#\\\">\\n            <span></span>\\n            <span></span>\\n            <span></span>\\n        </a>\\n        <form role=\\\"search\\\" class=\\\"navbar-form-custom\\\" method=\\\"post\\\" action=\\\"search_results.html\\\">\\n            <div class=\\\"form-group\\\">\\n                <input type=\\\"text\\\" placeholder=\\\"Search for something...\\\" class=\\\"form-control\\\" name=\\\"top-search\\\" id=\\\"top-search\\\">\\n            </div>\\n        </form>\\n    </div>\\n    <ul class=\\\"nav navbar-top-links navbar-right\\\">\\n        <li>\\n            <span class=\\\"m-r-sm text-muted welcome-message visible-md-block visible-lg-block\\\">Welcome to HRis.</span>\\n        </li>\\n        <li class=\\\"dropdown\\\">\\n            <a class=\\\"dropdown-toggle count-info\\\" data-toggle=\\\"dropdown\\\" href=\\\"#\\\">\\n                <i class=\\\"fa fa-envelope\\\"></i> <span class=\\\"label label-warning\\\">16</span>\\n            </a>\\n            <ul class=\\\"dropdown-menu dropdown-messages\\\">\\n                <li>\\n                    <div class=\\\"dropdown-messages-box\\\">\\n                        <a href=\\\"profile.html\\\" class=\\\"pull-left\\\">\\n                            <!--<img alt=\\\"image\\\" class=\\\"img-circle\\\" src=\\\"/img/a7.jpg\\\">-->\\n                        </a>\\n                        <div class=\\\"media-body\\\">\\n                            <small class=\\\"pull-right\\\">46h ago</small>\\n                            <strong>Mike Loreipsum</strong> started following <strong>Monica Smith</strong>. <br>\\n                            <small class=\\\"text-muted\\\">3 days ago at 7:58 pm - 10.06.2014</small>\\n                        </div>\\n                    </div>\\n                </li>\\n                <li class=\\\"divider\\\"></li>\\n                <li>\\n                    <div class=\\\"dropdown-messages-box\\\">\\n                        <a href=\\\"profile.html\\\" class=\\\"pull-left\\\">\\n                            <!--<img alt=\\\"image\\\" class=\\\"img-circle\\\" src=\\\"/img/a4.jpg\\\">-->\\n                        </a>\\n                        <div class=\\\"media-body \\\">\\n                            <small class=\\\"pull-right text-navy\\\">5h ago</small>\\n                            <strong>Chris Johnatan Overtunk</strong> started following <strong>Monica Smith</strong>.\\n                            <br>\\n                            <small class=\\\"text-muted\\\">Yesterday 1:21 pm - 11.06.2014</small>\\n                        </div>\\n                    </div>\\n                </li>\\n                <li class=\\\"divider\\\"></li>\\n                <li>\\n                    <div class=\\\"dropdown-messages-box\\\">\\n                        <a href=\\\"profile.html\\\" class=\\\"pull-left\\\">\\n                            <!--<img alt=\\\"image\\\" class=\\\"img-circle\\\" src=\\\"/img/profile.jpg\\\">-->\\n                        </a>\\n                        <div class=\\\"media-body \\\">\\n                            <small class=\\\"pull-right\\\">23h ago</small>\\n                            <strong>Monica Smith</strong> love <strong>Kim Smith</strong>. <br>\\n                            <small class=\\\"text-muted\\\">2 days ago at 2:30 am - 11.06.2014</small>\\n                        </div>\\n                    </div>\\n                </li>\\n                <li class=\\\"divider\\\"></li>\\n                <li>\\n                    <div class=\\\"text-center link-block\\\">\\n                        <a href=\\\"mailbox.html\\\">\\n                            <i class=\\\"fa fa-envelope\\\"></i> <strong>Read All Messages</strong>\\n                        </a>\\n                    </div>\\n                </li>\\n            </ul>\\n        </li>\\n        <li class=\\\"dropdown\\\">\\n            <a class=\\\"dropdown-toggle count-info\\\" data-toggle=\\\"dropdown\\\" href=\\\"#\\\">\\n                <i class=\\\"fa fa-bell\\\"></i> <span class=\\\"label label-primary\\\">8</span>\\n            </a>\\n            <ul class=\\\"dropdown-menu dropdown-alerts\\\">\\n                <li>\\n                    <a href=\\\"mailbox.html\\\">\\n                        <div>\\n                            <i class=\\\"fa fa-envelope fa-fw\\\"></i> You have 16 messages\\n                            <span class=\\\"pull-right text-muted small\\\">4 minutes ago</span>\\n                        </div>\\n                    </a>\\n                </li>\\n                <li class=\\\"divider\\\"></li>\\n                <li>\\n                    <a href=\\\"profile.html\\\">\\n                        <div>\\n                            <i class=\\\"fa fa-twitter fa-fw\\\"></i> 3 New Followers\\n                            <span class=\\\"pull-right text-muted small\\\">12 minutes ago</span>\\n                        </div>\\n                    </a>\\n                </li>\\n                <li class=\\\"divider\\\"></li>\\n                <li>\\n                    <a href=\\\"grid_options.html\\\">\\n                        <div>\\n                            <i class=\\\"fa fa-upload fa-fw\\\"></i> Server Rebooted\\n                            <span class=\\\"pull-right text-muted small\\\">4 minutes ago</span>\\n                        </div>\\n                    </a>\\n                </li>\\n                <li class=\\\"divider\\\"></li>\\n                <li>\\n                    <div class=\\\"text-center link-block\\\">\\n                        <a href=\\\"notifications.html\\\">\\n                            <strong>See All Alerts</strong>\\n                            <i class=\\\"fa fa-angle-right\\\"></i>\\n                        </a>\\n                    </div>\\n                </li>\\n            </ul>\\n        </li>\\n\\n\\n        <li>\\n            <a @click=\\\"doLogout\\\">\\n                <i class=\\\"fa fa-sign-out\\\"></i> Log out\\n            </a>\\n        </li>\\n    </ul>\\n\\n</nav>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/partials/navbar-static-top.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],140:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"footer fixed\\\">\\n    <div class=\\\"pull-right\\\">\\n        10GB of <strong>250GB</strong> Free.\\n    </div>\\n    <div>\\n        <strong>Copyright</strong> b3 Studios © 2014\\n    </div>\\n</div>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/bkintanar/Sites/hris/web/resources/assets/js/compiled/partials/static-footer.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":102,\"vue-hot-reload-api\":27}],141:[function(require,module,exports){\n'use strict';\n\nvar config = {\n    env: 'development',\n    api: {\n        base_url: 'http://api.hris.dev/api',\n        defaultRequest: {\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        }\n    },\n    social: {\n        facebook: '',\n        twitter: '',\n        github: ''\n    },\n    debug: true\n};\n\nmodule.exports = config;\n\n},{}],142:[function(require,module,exports){\n(function (process){\n'use strict';\n\nvar env = process.env.APP_ENV || 'development';\n\nvar config = {\n    development: require('./development.config'),\n    production: require('./production.config'),\n    staging: require('./staging.config')\n};\n\nmodule.exports = config[env];\n\n}).call(this,require('_process'))\n\n},{\"./development.config\":141,\"./production.config\":143,\"./staging.config\":144,\"_process\":1}],143:[function(require,module,exports){\n'use strict';\n\nvar config = {\n  env: 'production',\n  api: {\n    base_url: 'http://localhost:8000/api',\n    defaultRequest: {\n      headers: {\n        'X-Requested-With': 'rest.js',\n        'Content-Type': 'application/json'\n      }\n    }\n  },\n  social: {\n    facebook: '',\n    twitter: '',\n    github: ''\n  },\n  debug: false\n};\n\nmodule.exports = config;\n\n},{}],144:[function(require,module,exports){\n'use strict';\n\nvar config = {\n    env: 'staging',\n    api: {\n        base_url: 'http://localhost:8000/api',\n        defaultRequest: {\n            headers: {\n                'X-Requested-With': 'rest.js',\n                'Content-Type': 'application/json'\n            }\n        }\n    },\n    social: {\n        facebook: '',\n        twitter: '',\n        github: ''\n    },\n    debug: true\n};\nmodule.exports = config;\n\n},{}],145:[function(require,module,exports){\n'use strict';\n\n(function (define) {\n    'use strict';\n\n    define(function (require) {\n\n        var interceptor;\n\n        interceptor = require('rest/interceptor');\n\n        /**\n         * Authenticates the request using JWT Authentication\n         *\n         * @param {Client} [client] client to wrap\n         * @param {Object} config\n         *\n         * @returns {Client}\n         */\n        return interceptor({\n            request: function request(_request, config) {\n                var token, headers;\n\n                token = localStorage.getItem('jwt-token');\n                headers = _request.headers || (_request.headers = {});\n\n                if (token !== null && token !== 'undefined') {\n                    headers.Authorization = token;\n                }\n\n                return _request;\n            },\n            response: function response(_response) {\n                if (_response.status && _response.status.code == 401) {\n                    localStorage.removeItem('jwt-token');\n                }\n                if (_response.headers && _response.headers.Authorization) {\n                    localStorage.setItem('jwt-token', _response.headers.Authorization);\n                }\n                if (_response.entity && _response.entity.token && _response.entity.token.length > 10) {\n                    localStorage.setItem('jwt-token', 'Bearer ' + _response.entity.token);\n                }\n                return _response;\n            }\n        });\n    });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n    module.exports = factory(require);\n}\n// Boilerplate for AMD and Node\n);\n\n},{\"rest/interceptor\":7}],146:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n    configRouter: function configRouter(router) {\n\n        router.map({\n            '*': {\n                component: require('./compiled/pages/404.vue')\n            },\n            'error-404': {\n                name: 'error-404',\n                component: require('./compiled/pages/404.vue')\n            },\n            '/': {\n                component: require('./compiled/pages/default-page.vue'),\n                subRoutes: {\n                    '/dashboard': {\n                        name: 'dashboard',\n                        component: require('./compiled/pages/dashboard.vue'),\n                        auth: true\n                    },\n                    '/profile': {\n                        name: 'profile',\n                        component: require('./compiled/pages/page.vue'),\n                        auth: true,\n                        subRoutes: {\n                            '/personal-details': {\n                                name: 'profile-personal-details',\n                                component: require('./compiled/pages/profile/personal-details.vue'),\n                                auth: true\n                            },\n                            '/contact-details': {\n                                name: 'profile-contact-details',\n                                component: require('./compiled/pages/profile/contact-details.vue'),\n                                auth: true\n                            },\n                            '/emergency-contacts': {\n                                name: 'profile-emergency-contacts',\n                                component: require('./compiled/pages/profile/emergency-contacts.vue'),\n                                auth: true\n                            },\n                            '/dependents': {\n                                name: 'profile-dependents',\n                                component: require('./compiled/pages/profile/dependents.vue'),\n                                auth: true\n                            },\n                            '/job': {\n                                name: 'profile-job',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            },\n                            '/work-shifts': {\n                                name: 'profile-work-shifts',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            },\n                            '/salary': {\n                                name: 'profile-salary',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            },\n                            '/qualifications': {\n                                name: 'profile-qualifications',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            }\n                        }\n                    },\n                    '/presence': {\n                        name: 'presence',\n                        component: require('./compiled/pages/page.vue'),\n                        auth: true\n                    },\n                    '/performance': {\n                        name: 'performance',\n                        component: require('./compiled/pages/page.vue'),\n                        auth: true,\n                        subRoutes: {\n                            '/my-tracker': {\n                                name: 'performance-my-tracker',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            },\n                            '/employee-tracker': {\n                                name: 'performance-employee-tracker',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            },\n                            '/configuration': {\n                                name: 'performance-configuration',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true,\n                                subRoutes: {\n                                    '/trackers': {\n                                        name: 'performance-configuration-trackers',\n                                        component: require('./compiled/pages/page.vue'),\n                                        auth: true\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    '/time': {\n                        name: 'time',\n                        component: require('./compiled/pages/page.vue'),\n                        auth: true,\n                        subRoutes: {\n                            '/attendance': {\n                                name: 'time-attendance',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true,\n                                subRoutes: {\n                                    '/employee-records': {\n                                        name: 'time-attendance-employee-records',\n                                        component: require('./compiled/pages/page.vue'),\n                                        auth: true\n                                    },\n                                    '/overtime-records': {\n                                        name: 'time-attendance-overtime-records',\n                                        component: require('./compiled/pages/page.vue'),\n                                        auth: true\n                                    }\n                                }\n                            },\n                            '/requisition': {\n                                name: 'time-requisition',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            },\n                            '/holidays': {\n                                name: 'time-holidays',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            },\n                            '/holidays-and-events': {\n                                name: 'time-holidays-and-events',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            }\n                        }\n                    },\n                    '/pim': {\n                        name: 'pim',\n                        component: require('./compiled/pages/page.vue'),\n                        auth: true,\n                        subRoutes: {\n                            '/employee-list': {\n                                name: 'pim-employee-list',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            },\n                            '/employee-list/:employee_id/personal-details': {\n                                name: 'pim-employee-list-personal-details',\n                                component: require('./compiled/pages/profile/personal-details.vue'),\n                                auth: true\n                            },\n                            '/employee-list/:employee_id/contact-details': {\n                                name: 'pim-employee-list-contact-details',\n                                component: require('./compiled/pages/profile/contact-details.vue'),\n                                auth: true\n                            },\n                            '/employee-list/:employee_id/emergency-contacts': {\n                                name: 'pim-employee-list-emergency-contacts',\n                                component: require('./compiled/pages/profile/emergency-contacts.vue'),\n                                auth: true\n                            },\n                            '/employee-list/:employee_id/dependents': {\n                                name: 'pim-employee-list-dependents',\n                                component: require('./compiled/pages/profile/dependents.vue'),\n                                auth: true\n                            },\n                            '/employee-list/:employee_id/job': {\n                                name: 'pim-employee-list-job',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            },\n                            '/employee-list/:employee_id/work-shifts': {\n                                name: 'pim-employee-list-work-shifts',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            },\n                            '/employee-list/:employee_id/salary': {\n                                name: 'pim-employee-list-salary',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            },\n                            '/employee-list/:employee_id/qualifications': {\n                                name: 'pim-employee-list-qualifications',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            },\n                            '/configuration': {\n                                name: 'pim-configuration',\n                                auth: true,\n                                component: require('./compiled/pages/page.vue'),\n                                subRoutes: {\n                                    '/termination-reasons': {\n                                        name: 'pim-configuration-termination-reasons',\n                                        component: require('./compiled/pages/page.vue'),\n                                        auth: true\n                                    },\n                                    '/custom-field-sections': {\n                                        name: 'pim-configuration-custom-field-sections',\n                                        component: require('./compiled/pages/page.vue'),\n                                        auth: true\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    '/admin': {\n                        name: 'admin',\n                        component: require('./compiled/pages/page.vue'),\n                        auth: true,\n                        subRoutes: {\n                            '/user-management': {\n                                name: 'admin-user-management',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true\n                            },\n                            '/job': {\n                                name: 'admin-job',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true,\n                                subRoutes: {\n                                    '/titles': {\n                                        name: 'admin-job-titles',\n                                        component: require('./compiled/pages/page.vue'),\n                                        auth: true\n                                    },\n                                    '/pay-grades': {\n                                        name: 'admin-job-pay-grades',\n                                        component: require('./compiled/pages/page.vue'),\n                                        auth: true\n                                    },\n                                    '/employment-status': {\n                                        name: 'admin-job-employment-status',\n                                        component: require('./compiled/pages/page.vue'),\n                                        auth: true\n                                    },\n                                    '/categories': {\n                                        name: 'admin-job-categories',\n                                        component: require('./compiled/pages/page.vue'),\n                                        auth: true\n                                    },\n                                    '/work-shifts': {\n                                        name: 'admin-job-work-shifts',\n                                        component: require('./compiled/pages/page.vue'),\n                                        auth: true\n                                    }\n                                }\n                            },\n                            '/qualifications': {\n                                name: 'admin-qualifications',\n                                component: require('./compiled/pages/page.vue'),\n                                auth: true,\n                                subRoutes: {\n                                    '/skills': {\n                                        name: 'admin-qualifications-skills',\n                                        component: require('./compiled/pages/page.vue'),\n                                        auth: true\n                                    },\n                                    '/educations': {\n                                        name: 'admin-qualifications-educations',\n                                        component: require('./compiled/pages/page.vue'),\n                                        auth: true\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            '/login': {\n                name: 'login',\n                component: require('./compiled/pages/auth/login.vue'),\n                guest: true\n            }\n        });\n\n        router.redirect({\n            '/': '/dashboard',\n            '/profile': '/profile/personal-details',\n            '/pim': '/pim/employee-list',\n            '/admin/job': '/admin/job/titles',\n            '/admin/qualifications': '/admin/qualifications/skills',\n            '/translator': '/translator/translations'\n        });\n\n        router.beforeEach(function (transition) {\n\n            var auth = localStorage.getItem('jwt-token');\n\n            if (transition.to.auth) {\n                if (auth) {\n\n                    var params = {\n                        path: '/auth/refresh',\n                        method: 'GET',\n                        headers: { 'Authorization': localStorage.getItem('jwt-token') }\n                    };\n\n                    client(params).then(function (response) {\n\n                        var token = response.request.headers.Authorization;\n\n                        localStorage.setItem('jwt-token', token);\n                        transition.next();\n                    }, function () {\n                        transition.redirect('/login');\n                    });\n                } else {\n                    transition.redirect('/login');\n                }\n            } else {\n                if (transition.to.path == '/login' && auth) {\n                    transition.redirect('/dashboard');\n                } else {\n                    transition.next();\n                }\n            }\n        });\n    }\n};\n\n},{\"./compiled/pages/404.vue\":125,\"./compiled/pages/auth/login.vue\":126,\"./compiled/pages/dashboard.vue\":127,\"./compiled/pages/default-page.vue\":128,\"./compiled/pages/page.vue\":129,\"./compiled/pages/profile/contact-details.vue\":130,\"./compiled/pages/profile/dependents.vue\":131,\"./compiled/pages/profile/emergency-contacts.vue\":132,\"./compiled/pages/profile/personal-details.vue\":133}]},{},[123])\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvVXJsQnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVzdC9jbGllbnQuanMiLCJub2RlX21vZHVsZXMvcmVzdC9jbGllbnQvZGVmYXVsdC5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L2NsaWVudC94aHIuanMiLCJub2RlX21vZHVsZXMvcmVzdC9pbnRlcmNlcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L2ludGVyY2VwdG9yL2RlZmF1bHRSZXF1ZXN0LmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvaW50ZXJjZXB0b3IvZXJyb3JDb2RlLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvaW50ZXJjZXB0b3IvbWltZS5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L2ludGVyY2VwdG9yL3BhdGhQcmVmaXguanMiLCJub2RlX21vZHVsZXMvcmVzdC9pbnRlcmNlcHRvci90ZW1wbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L21pbWUuanMiLCJub2RlX21vZHVsZXMvcmVzdC9taW1lL3JlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvbWltZS90eXBlL2FwcGxpY2F0aW9uL2hhbC5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L21pbWUvdHlwZS9hcHBsaWNhdGlvbi9qc29uLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvbWltZS90eXBlL2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZC5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L21pbWUvdHlwZS9tdWx0aXBhcnQvZm9ybS1kYXRhLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvbWltZS90eXBlL3RleHQvcGxhaW4uanMiLCJub2RlX21vZHVsZXMvcmVzdC91dGlsL2ZpbmQuanMiLCJub2RlX21vZHVsZXMvcmVzdC91dGlsL2xhenlQcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvdXRpbC9taXhpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L3V0aWwvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L3V0aWwvcmVzcG9uc2VQcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvdXRpbC91cmlFbmNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvdXRpbC91cmlUZW1wbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy9odHRwLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1yZXNvdXJjZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy9saWIvanNvbnAuanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy9saWIvcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUtcmVzb3VyY2Uvc3JjL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1yZXNvdXJjZS9zcmMvbGliL3hoci5qcyIsIm5vZGVfbW9kdWxlcy92dWUtcmVzb3VyY2Uvc3JjL3Jlc291cmNlLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1yZXNvdXJjZS9zcmMvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmNvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2FwaS9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvYXBpL2RvbS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2FwaS9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9hcGkvZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvYXBpL2xpZmVjeWNsZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2JhdGNoZXIuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2NvbXBpbGVyL2NvbXBpbGUtcHJvcHMuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9jb21waWxlci9jb21waWxlLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvY29tcGlsZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9jb21waWxlci90cmFuc2NsdWRlLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9lbGVtZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9lbGVtZW50L3BhcnRpYWwuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL2VsZW1lbnQvc2xvdC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvaW50ZXJuYWwvY2xhc3MuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL2ludGVybmFsL2NvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvaW50ZXJuYWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL2ludGVybmFsL3Byb3AuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL2ludGVybmFsL3N0eWxlLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9pbnRlcm5hbC90cmFuc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvYmluZC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL2Nsb2FrLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvZWwuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL3B1YmxpYy9mb3IuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL3B1YmxpYy9odG1sLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvaWYuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL3B1YmxpYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL21vZGVsL2NoZWNrYm94LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvbW9kZWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL3B1YmxpYy9tb2RlbC9yYWRpby5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL21vZGVsL3NlbGVjdC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL21vZGVsL3RleHQuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL3B1YmxpYy9vbi5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL3JlZi5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL3Nob3cuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL3B1YmxpYy90ZXh0LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZmlsdGVycy9hcnJheS1maWx0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZmlsdGVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2ZyYWdtZW50L2ZhY3RvcnkuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9mcmFnbWVudC9mcmFnbWVudC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2luc3RhbmNlL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2luc3RhbmNlL2luaXQuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9pbnN0YW5jZS9saWZlY3ljbGUuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9pbnN0YW5jZS9taXNjLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvaW5zdGFuY2Uvc3RhdGUuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9vYnNlcnZlci9hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL29ic2VydmVyL2RlcC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL29ic2VydmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvcGFyc2Vycy9kaXJlY3RpdmUuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9wYXJzZXJzL2V4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9wYXJzZXJzL3BhdGguanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9wYXJzZXJzL3RlbXBsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvcGFyc2Vycy90ZXh0LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvdHJhbnNpdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3RyYW5zaXRpb24vcXVldWUuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy90cmFuc2l0aW9uL3RyYW5zaXRpb24uanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy91dGlsL2NvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3V0aWwvZGVidWcuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy91dGlsL2RvbS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3V0aWwvZW52LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3V0aWwvbGFuZy5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3V0aWwvb3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3Z1ZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3dhdGNoZXIuanMiLCJub2RlX21vZHVsZXMvdnVlaWZ5LWluc2VydC1jc3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2hlbi9saWIvUHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy93aGVuL2xpYi9TY2hlZHVsZXIuanMiLCJub2RlX21vZHVsZXMvd2hlbi9saWIvVGltZW91dEVycm9yLmpzIiwibm9kZV9tb2R1bGVzL3doZW4vbGliL2FwcGx5LmpzIiwibm9kZV9tb2R1bGVzL3doZW4vbGliL2RlY29yYXRvcnMvYXJyYXkuanMiLCJub2RlX21vZHVsZXMvd2hlbi9saWIvZGVjb3JhdG9ycy9mbG93LmpzIiwibm9kZV9tb2R1bGVzL3doZW4vbGliL2RlY29yYXRvcnMvZm9sZC5qcyIsIm5vZGVfbW9kdWxlcy93aGVuL2xpYi9kZWNvcmF0b3JzL2luc3BlY3QuanMiLCJub2RlX21vZHVsZXMvd2hlbi9saWIvZGVjb3JhdG9ycy9pdGVyYXRlLmpzIiwibm9kZV9tb2R1bGVzL3doZW4vbGliL2RlY29yYXRvcnMvcHJvZ3Jlc3MuanMiLCJub2RlX21vZHVsZXMvd2hlbi9saWIvZGVjb3JhdG9ycy90aW1lZC5qcyIsIm5vZGVfbW9kdWxlcy93aGVuL2xpYi9kZWNvcmF0b3JzL3VuaGFuZGxlZFJlamVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy93aGVuL2xpYi9kZWNvcmF0b3JzL3dpdGguanMiLCJub2RlX21vZHVsZXMvd2hlbi9saWIvZW52LmpzIiwibm9kZV9tb2R1bGVzL3doZW4vbGliL2Zvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy93aGVuL2xpYi9tYWtlUHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy93aGVuL2xpYi9zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy93aGVuL3doZW4uanMiLCIvVXNlcnMvYmtpbnRhbmFyL1NpdGVzL2hyaXMvd2ViL3Jlc291cmNlcy9hc3NldHMvanMvYm9vdHN0cmFwLmpzIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9hcHAudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy80MDQudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9hdXRoL2xvZ2luLnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvZGFzaGJvYXJkLnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvZGVmYXVsdC1wYWdlLnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvcGFnZS52dWUiLCJyZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL3Byb2ZpbGUvY29udGFjdC1kZXRhaWxzLnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvcHJvZmlsZS9kZXBlbmRlbnRzLnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvcHJvZmlsZS9lbWVyZ2VuY3ktY29udGFjdHMudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9wcm9maWxlL3BlcnNvbmFsLWRldGFpbHMudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYXJ0aWFscy9hY3Rpb24tYXJlYS52dWUiLCJyZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhcnRpYWxzL2Nob3Nlbi52dWUiLCJyZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhcnRpYWxzL2NvcHlsZWZ0LnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFydGlhbHMvbmF2YmFyLXN0YXRpYy1wcm9maWxlLXRvcC52dWUiLCJyZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhcnRpYWxzL25hdmJhci1zdGF0aWMtc2lkZS52dWUiLCJyZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhcnRpYWxzL25hdmJhci1zdGF0aWMtdG9wLnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFydGlhbHMvc3RhdGljLWZvb3Rlci52dWUiLCIvVXNlcnMvYmtpbnRhbmFyL1NpdGVzL2hyaXMvd2ViL3Jlc291cmNlcy9hc3NldHMvanMvY29uZmlnL2RldmVsb3BtZW50LmNvbmZpZy5qcyIsIi9Vc2Vycy9ia2ludGFuYXIvU2l0ZXMvaHJpcy93ZWIvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb25maWcvaW5kZXguanMiLCIvVXNlcnMvYmtpbnRhbmFyL1NpdGVzL2hyaXMvd2ViL3Jlc291cmNlcy9hc3NldHMvanMvY29uZmlnL3Byb2R1Y3Rpb24uY29uZmlnLmpzIiwiL1VzZXJzL2JraW50YW5hci9TaXRlcy9ocmlzL3dlYi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbmZpZy9zdGFnaW5nLmNvbmZpZy5qcyIsIi9Vc2Vycy9ia2ludGFuYXIvU2l0ZXMvaHJpcy93ZWIvcmVzb3VyY2VzL2Fzc2V0cy9qcy9pbnRlcmNlcHRvcnMvand0QXV0aC5qcyIsIi9Vc2Vycy9ia2ludGFuYXIvU2l0ZXMvaHJpcy93ZWIvcmVzb3VyY2VzL2Fzc2V0cy9qcy9yb3V0ZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcitFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDenNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hVQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy81QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O3NCQzNONkIsVUFBVTs7O0FBUnZDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzVCLE1BQU0sQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDOztBQUV6QyxHQUFHLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEFBUWpDLElBQU0sTUFBTSxHQUFHLElBQUksU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDOzs7QUFHakMsMEJBQWEsTUFBTSxDQUFDLENBQUM7OztBQUdyQixNQUFNLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNwQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7OztBQUd4QixJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDM0IsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLDZCQUE2QixDQUFDLENBQUM7QUFDeEQsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLHVCQUF1QixDQUFDLENBQUM7QUFDNUMsSUFBSSxjQUFjLEdBQUcsT0FBTyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7QUFDaEUsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLDRCQUE0QixDQUFDLENBQUM7QUFDdEQsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDOUMsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUM7O0FBRWhELE1BQU0sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUMsQ0FBQyxDQUMvRCxJQUFJLENBQUMsSUFBSSxDQUFDLENBQ1YsSUFBSSxDQUFDLGNBQWMsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUMvQyxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUMsSUFBSSxFQUFFLEdBQUcsRUFBQyxDQUFDLENBQUM7Ozs7O0FBS2xDLEdBQUcsQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDLENBQUM7QUFDdkUsR0FBRyxDQUFDLFNBQVMsQ0FBQyxhQUFhLEVBQUUsT0FBTyxDQUFDLHFDQUFxQyxDQUFDLENBQUMsQ0FBQztBQUM3RSxHQUFHLENBQUMsU0FBUyxDQUFDLG9CQUFvQixFQUFFLE9BQU8sQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDLENBQUM7QUFDM0YsR0FBRyxDQUFDLFNBQVMsQ0FBQywyQkFBMkIsRUFBRSxPQUFPLENBQUMsbURBQW1ELENBQUMsQ0FBQyxDQUFDO0FBQ3pHLEdBQUcsQ0FBQyxTQUFTLENBQUMsbUJBQW1CLEVBQUUsT0FBTyxDQUFDLDJDQUEyQyxDQUFDLENBQUMsQ0FBQztBQUN6RixHQUFHLENBQUMsU0FBUyxDQUFDLGVBQWUsRUFBRSxPQUFPLENBQUMsdUNBQXVDLENBQUMsQ0FBQyxDQUFDO0FBQ2pGLEdBQUcsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDLENBQUM7O0FBRW5FLEdBQUcsQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFO0FBQ25CLFVBQU0sRUFBRSxnQkFBVSxLQUFLLEVBQUU7QUFDckIsYUFBSyxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN6QixZQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO0FBQ25CLGdCQUFRLEdBQUc7QUFDUCxpQkFBSyxhQUFhO0FBQ2Qsb0JBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztBQUM1QixzQkFBTTtBQUFBLEFBQ1YsaUJBQUssT0FBTztBQUNSLG9CQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDdEIsc0JBQU07QUFBQSxBQUNWLGlCQUFLLE1BQU07QUFDUCxvQkFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO0FBQzFCLHNCQUFNO0FBQUEsQUFDVjtBQUNJLG9CQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7QUFBQSxTQUNqQztLQUNKO0NBQ0osQ0FBQyxDQUFDOztBQUVILElBQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQztBQUN0RCxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUMxQixNQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQzs7O0FDcEV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDWEEsSUFBSSxNQUFNLEdBQUc7QUFDVCxPQUFHLEVBQUUsYUFBYTtBQUNsQixPQUFHLEVBQUU7QUFDRCxnQkFBUSxFQUFFLHlCQUF5QjtBQUNuQyxzQkFBYyxFQUFFO0FBQ1osbUJBQU8sRUFBRTtBQUNMLDhCQUFjLEVBQUUsa0JBQWtCO2FBQ3JDO1NBQ0o7S0FDSjtBQUNELFVBQU0sRUFBRTtBQUNKLGdCQUFRLEVBQUUsRUFBRTtBQUNaLGVBQU8sRUFBRSxFQUFFO0FBQ1gsY0FBTSxFQUFFLEVBQUU7S0FDYjtBQUNELFNBQUssRUFBRSxJQUFJO0NBQ2QsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQzs7Ozs7O0FDbEJ4QixJQUFJLEdBQUcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sSUFBSSxhQUFhLENBQUM7O0FBRS9DLElBQUksTUFBTSxHQUFHO0FBQ1QsZUFBVyxFQUFFLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQztBQUM1QyxjQUFVLEVBQUUsT0FBTyxDQUFDLHFCQUFxQixDQUFDO0FBQzFDLFdBQU8sRUFBRSxPQUFPLENBQUMsa0JBQWtCLENBQUM7Q0FDdkMsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQzs7Ozs7OztBQ1I3QixJQUFJLE1BQU0sR0FBRztBQUNYLEtBQUcsRUFBRSxZQUFZO0FBQ2pCLEtBQUcsRUFBRTtBQUNILFlBQVEsRUFBRSwyQkFBMkI7QUFDckMsa0JBQWMsRUFBRTtBQUNkLGFBQU8sRUFBRTtBQUNQLDBCQUFrQixFQUFFLFNBQVM7QUFDN0Isc0JBQWMsRUFBRSxrQkFBa0I7T0FDbkM7S0FDRjtHQUNGO0FBQ0QsUUFBTSxFQUFFO0FBQ04sWUFBUSxFQUFFLEVBQUU7QUFDWixXQUFPLEVBQUUsRUFBRTtBQUNYLFVBQU0sRUFBRSxFQUFFO0dBQ1g7QUFDRCxPQUFLLEVBQUUsS0FBSztDQUNiLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7Ozs7O0FDbkJ4QixJQUFJLE1BQU0sR0FBRztBQUNULE9BQUcsRUFBRSxTQUFTO0FBQ2QsT0FBRyxFQUFFO0FBQ0QsZ0JBQVEsRUFBRSwyQkFBMkI7QUFDckMsc0JBQWMsRUFBRTtBQUNaLG1CQUFPLEVBQUU7QUFDTCxrQ0FBa0IsRUFBRSxTQUFTO0FBQzdCLDhCQUFjLEVBQUUsa0JBQWtCO2FBQ3JDO1NBQ0o7S0FDSjtBQUNELFVBQU0sRUFBRTtBQUNKLGdCQUFRLEVBQUUsRUFBRTtBQUNaLGVBQU8sRUFBRSxFQUFFO0FBQ1gsY0FBTSxFQUFFLEVBQUU7S0FDYjtBQUNELFNBQUssRUFBRSxJQUFJO0NBQ2QsQ0FBQztBQUNGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDOzs7OztBQ2xCeEIsQUFBQyxDQUFBLFVBQVUsTUFBTSxFQUFFO0FBQ2YsZ0JBQVksQ0FBQzs7QUFFYixVQUFNLENBQUMsVUFBVSxPQUFPLEVBQUU7O0FBRXRCLFlBQUksV0FBVyxDQUFDOztBQUVoQixtQkFBVyxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDOzs7Ozs7Ozs7O0FBVTFDLGVBQU8sV0FBVyxDQUFDO0FBQ2YsbUJBQU8sRUFBRSxpQkFBVSxRQUFPLEVBQUUsTUFBTSxFQUFFO0FBQ2hDLG9CQUFJLEtBQUssRUFBRSxPQUFPLENBQUM7O0FBRW5CLHFCQUFLLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUMxQyx1QkFBTyxHQUFHLFFBQU8sQ0FBQyxPQUFPLEtBQUssUUFBTyxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUEsQUFBQyxDQUFDOztBQUVwRCxvQkFBSSxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxXQUFXLEVBQUU7QUFDekMsMkJBQU8sQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDO2lCQUNqQzs7QUFFRCx1QkFBTyxRQUFPLENBQUM7YUFDbEI7QUFDRCxvQkFBUSxFQUFFLGtCQUFVLFNBQVEsRUFBRTtBQUMxQixvQkFBSSxTQUFRLENBQUMsTUFBTSxJQUFJLFNBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLEdBQUcsRUFBRTtBQUNoRCxnQ0FBWSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztpQkFDeEM7QUFDRCxvQkFBSSxTQUFRLENBQUMsT0FBTyxJQUFJLFNBQVEsQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFO0FBQ3BELGdDQUFZLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxTQUFRLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFBO2lCQUNwRTtBQUNELG9CQUFJLFNBQVEsQ0FBQyxNQUFNLElBQUksU0FBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLElBQUksU0FBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEVBQUUsRUFBRTtBQUMvRSxnQ0FBWSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsU0FBUyxHQUFHLFNBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQ3hFO0FBQ0QsdUJBQU8sU0FBUSxDQUFDO2FBQ25CO1NBQ0osQ0FBQyxDQUFDO0tBRU4sQ0FBQyxDQUFDO0NBRU4sQ0FBQSxDQUNHLE9BQU8sTUFBTSxLQUFLLFVBQVUsSUFBSSxNQUFNLENBQUMsR0FBRyxHQUFHLE1BQU0sR0FBRyxVQUFVLE9BQU8sRUFBRTtBQUNyRSxVQUFNLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUNyQzs7Q0FFSixDQUFFOzs7OztBQ25ESCxNQUFNLENBQUMsT0FBTyxHQUFHOztBQUViLGdCQUFZLEVBQUUsc0JBQVUsTUFBTSxFQUFFOztBQUU1QixjQUFNLENBQUMsR0FBRyxDQUFDO0FBQ1AsZUFBRyxFQUFFO0FBQ0QseUJBQVMsRUFBRSxPQUFPLENBQUMsMEJBQTBCLENBQUM7YUFDakQ7QUFDRCx1QkFBVyxFQUFFO0FBQ1Qsb0JBQUksRUFBRSxXQUFXO0FBQ2pCLHlCQUFTLEVBQUUsT0FBTyxDQUFDLDBCQUEwQixDQUFDO2FBQ2pEO0FBQ0QsZUFBRyxFQUFFO0FBQ0QseUJBQVMsRUFBRSxPQUFPLENBQUMsbUNBQW1DLENBQUM7QUFDdkQseUJBQVMsRUFBRTtBQUNQLGdDQUFZLEVBQUU7QUFDViw0QkFBSSxFQUFFLFdBQVc7QUFDakIsaUNBQVMsRUFBRSxPQUFPLENBQUMsZ0NBQWdDLENBQUM7QUFDcEQsNEJBQUksRUFBRSxJQUFJO3FCQUNiO0FBQ0QsOEJBQVUsRUFBRTtBQUNSLDRCQUFJLEVBQUUsU0FBUztBQUNmLGlDQUFTLEVBQUUsT0FBTyxDQUFDLDJCQUEyQixDQUFDO0FBQy9DLDRCQUFJLEVBQUUsSUFBSTtBQUNWLGlDQUFTLEVBQUU7QUFDUCwrQ0FBbUIsRUFBRTtBQUNqQixvQ0FBSSxFQUFFLDBCQUEwQjtBQUNoQyx5Q0FBUyxFQUFFLE9BQU8sQ0FBQywrQ0FBK0MsQ0FBQztBQUNuRSxvQ0FBSSxFQUFFLElBQUk7NkJBQ2I7QUFDRCw4Q0FBa0IsRUFBRTtBQUNoQixvQ0FBSSxFQUFFLHlCQUF5QjtBQUMvQix5Q0FBUyxFQUFFLE9BQU8sQ0FBQyw4Q0FBOEMsQ0FBQztBQUNsRSxvQ0FBSSxFQUFFLElBQUk7NkJBQ2I7QUFDRCxpREFBcUIsRUFBRTtBQUNuQixvQ0FBSSxFQUFFLDRCQUE0QjtBQUNsQyx5Q0FBUyxFQUFFLE9BQU8sQ0FBQyxpREFBaUQsQ0FBQztBQUNyRSxvQ0FBSSxFQUFFLElBQUk7NkJBQ2I7QUFDRCx5Q0FBYSxFQUFFO0FBQ1gsb0NBQUksRUFBRSxvQkFBb0I7QUFDMUIseUNBQVMsRUFBRSxPQUFPLENBQUMseUNBQXlDLENBQUM7QUFDN0Qsb0NBQUksRUFBRSxJQUFJOzZCQUNiO0FBQ0Qsa0NBQU0sRUFBRTtBQUNKLG9DQUFJLEVBQUUsYUFBYTtBQUNuQix5Q0FBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyxvQ0FBSSxFQUFFLElBQUk7NkJBQ2I7QUFDRCwwQ0FBYyxFQUFFO0FBQ1osb0NBQUksRUFBRSxxQkFBcUI7QUFDM0IseUNBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0Msb0NBQUksRUFBRSxJQUFJOzZCQUNiO0FBQ0QscUNBQVMsRUFBRTtBQUNQLG9DQUFJLEVBQUUsZ0JBQWdCO0FBQ3RCLHlDQUFTLEVBQUUsT0FBTyxDQUFDLDJCQUEyQixDQUFDO0FBQy9DLG9DQUFJLEVBQUUsSUFBSTs2QkFDYjtBQUNELDZDQUFpQixFQUFFO0FBQ2Ysb0NBQUksRUFBRSx3QkFBd0I7QUFDOUIseUNBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0Msb0NBQUksRUFBRSxJQUFJOzZCQUNiO3lCQUNKO3FCQUNKO0FBQ0QsK0JBQVcsRUFBRTtBQUNULDRCQUFJLEVBQUUsVUFBVTtBQUNoQixpQ0FBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyw0QkFBSSxFQUFFLElBQUk7cUJBQ2I7QUFDRCxrQ0FBYyxFQUFFO0FBQ1osNEJBQUksRUFBRSxhQUFhO0FBQ25CLGlDQUFTLEVBQUUsT0FBTyxDQUFDLDJCQUEyQixDQUFDO0FBQy9DLDRCQUFJLEVBQUUsSUFBSTtBQUNWLGlDQUFTLEVBQUU7QUFDUCx5Q0FBYSxFQUFFO0FBQ1gsb0NBQUksRUFBRSx3QkFBd0I7QUFDOUIseUNBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0Msb0NBQUksRUFBRSxJQUFJOzZCQUNiO0FBQ0QsK0NBQW1CLEVBQUU7QUFDakIsb0NBQUksRUFBRSw4QkFBOEI7QUFDcEMseUNBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0Msb0NBQUksRUFBRSxJQUFJOzZCQUNiO0FBQ0QsNENBQWdCLEVBQUU7QUFDZCxvQ0FBSSxFQUFFLDJCQUEyQjtBQUNqQyx5Q0FBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyxvQ0FBSSxFQUFFLElBQUk7QUFDVix5Q0FBUyxFQUFFO0FBQ1AsK0NBQVcsRUFBRTtBQUNULDRDQUFJLEVBQUUsb0NBQW9DO0FBQzFDLGlEQUFTLEVBQUUsT0FBTyxDQUFDLDJCQUEyQixDQUFDO0FBQy9DLDRDQUFJLEVBQUUsSUFBSTtxQ0FDYjtpQ0FDSjs2QkFDSjt5QkFDSjtxQkFDSjtBQUNELDJCQUFPLEVBQUU7QUFDTCw0QkFBSSxFQUFFLE1BQU07QUFDWixpQ0FBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyw0QkFBSSxFQUFFLElBQUk7QUFDVixpQ0FBUyxFQUFFO0FBQ1AseUNBQWEsRUFBRTtBQUNYLG9DQUFJLEVBQUUsaUJBQWlCO0FBQ3ZCLHlDQUFTLEVBQUUsT0FBTyxDQUFDLDJCQUEyQixDQUFDO0FBQy9DLG9DQUFJLEVBQUUsSUFBSTtBQUNWLHlDQUFTLEVBQUU7QUFDUCx1REFBbUIsRUFBRTtBQUNqQiw0Q0FBSSxFQUFFLGtDQUFrQztBQUN4QyxpREFBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyw0Q0FBSSxFQUFFLElBQUk7cUNBQ2I7QUFDRCx1REFBbUIsRUFBRTtBQUNqQiw0Q0FBSSxFQUFFLGtDQUFrQztBQUN4QyxpREFBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyw0Q0FBSSxFQUFFLElBQUk7cUNBQ2I7aUNBQ0o7NkJBQ0o7QUFDRCwwQ0FBYyxFQUFFO0FBQ1osb0NBQUksRUFBRSxrQkFBa0I7QUFDeEIseUNBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0Msb0NBQUksRUFBRSxJQUFJOzZCQUNiO0FBQ0QsdUNBQVcsRUFBRTtBQUNULG9DQUFJLEVBQUUsZUFBZTtBQUNyQix5Q0FBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyxvQ0FBSSxFQUFFLElBQUk7NkJBQ2I7QUFDRCxrREFBc0IsRUFBRTtBQUNwQixvQ0FBSSxFQUFFLDBCQUEwQjtBQUNoQyx5Q0FBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyxvQ0FBSSxFQUFFLElBQUk7NkJBQ2I7eUJBQ0o7cUJBQ0o7QUFDRCwwQkFBTSxFQUFFO0FBQ0osNEJBQUksRUFBRSxLQUFLO0FBQ1gsaUNBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0MsNEJBQUksRUFBRSxJQUFJO0FBQ1YsaUNBQVMsRUFBRTtBQUNQLDRDQUFnQixFQUFFO0FBQ2Qsb0NBQUksRUFBRSxtQkFBbUI7QUFDekIseUNBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0Msb0NBQUksRUFBRSxJQUFJOzZCQUNiO0FBQ0QsMEVBQThDLEVBQUU7QUFDNUMsb0NBQUksRUFBRSxvQ0FBb0M7QUFDMUMseUNBQVMsRUFBRSxPQUFPLENBQUMsK0NBQStDLENBQUM7QUFDbkUsb0NBQUksRUFBRSxJQUFJOzZCQUNiO0FBQ0QseUVBQTZDLEVBQUU7QUFDM0Msb0NBQUksRUFBRSxtQ0FBbUM7QUFDekMseUNBQVMsRUFBRSxPQUFPLENBQUMsOENBQThDLENBQUM7QUFDbEUsb0NBQUksRUFBRSxJQUFJOzZCQUNiO0FBQ0QsNEVBQWdELEVBQUU7QUFDOUMsb0NBQUksRUFBRSxzQ0FBc0M7QUFDNUMseUNBQVMsRUFBRSxPQUFPLENBQUMsaURBQWlELENBQUM7QUFDckUsb0NBQUksRUFBRSxJQUFJOzZCQUNiO0FBQ0Qsb0VBQXdDLEVBQUU7QUFDdEMsb0NBQUksRUFBRSw4QkFBOEI7QUFDcEMseUNBQVMsRUFBRSxPQUFPLENBQUMseUNBQXlDLENBQUM7QUFDN0Qsb0NBQUksRUFBRSxJQUFJOzZCQUNiO0FBQ0QsNkRBQWlDLEVBQUU7QUFDL0Isb0NBQUksRUFBRSx1QkFBdUI7QUFDN0IseUNBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0Msb0NBQUksRUFBRSxJQUFJOzZCQUNiO0FBQ0QscUVBQXlDLEVBQUU7QUFDdkMsb0NBQUksRUFBRSwrQkFBK0I7QUFDckMseUNBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0Msb0NBQUksRUFBRSxJQUFJOzZCQUNiO0FBQ0QsZ0VBQW9DLEVBQUU7QUFDbEMsb0NBQUksRUFBRSwwQkFBMEI7QUFDaEMseUNBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0Msb0NBQUksRUFBRSxJQUFJOzZCQUNiO0FBQ0Qsd0VBQTRDLEVBQUU7QUFDMUMsb0NBQUksRUFBRSxrQ0FBa0M7QUFDeEMseUNBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0Msb0NBQUksRUFBRSxJQUFJOzZCQUNiO0FBQ0QsNENBQWdCLEVBQUU7QUFDZCxvQ0FBSSxFQUFFLG1CQUFtQjtBQUN6QixvQ0FBSSxFQUFFLElBQUk7QUFDVix5Q0FBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyx5Q0FBUyxFQUFFO0FBQ1AsMERBQXNCLEVBQUU7QUFDcEIsNENBQUksRUFBRSx1Q0FBdUM7QUFDN0MsaURBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0MsNENBQUksRUFBRSxJQUFJO3FDQUNiO0FBQ0QsNERBQXdCLEVBQUU7QUFDdEIsNENBQUksRUFBRSx5Q0FBeUM7QUFDL0MsaURBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0MsNENBQUksRUFBRSxJQUFJO3FDQUNiO2lDQUNKOzZCQUNKO3lCQUNKO3FCQUNKO0FBQ0QsNEJBQVEsRUFBRTtBQUNOLDRCQUFJLEVBQUUsT0FBTztBQUNiLGlDQUFTLEVBQUUsT0FBTyxDQUFDLDJCQUEyQixDQUFDO0FBQy9DLDRCQUFJLEVBQUUsSUFBSTtBQUNWLGlDQUFTLEVBQUU7QUFDUCw4Q0FBa0IsRUFBRTtBQUNoQixvQ0FBSSxFQUFFLHVCQUF1QjtBQUM3Qix5Q0FBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyxvQ0FBSSxFQUFFLElBQUk7NkJBQ2I7QUFDRCxrQ0FBTSxFQUFFO0FBQ0osb0NBQUksRUFBRSxXQUFXO0FBQ2pCLHlDQUFTLEVBQUUsT0FBTyxDQUFDLDJCQUEyQixDQUFDO0FBQy9DLG9DQUFJLEVBQUUsSUFBSTtBQUNWLHlDQUFTLEVBQUU7QUFDUCw2Q0FBUyxFQUFFO0FBQ1AsNENBQUksRUFBRSxrQkFBa0I7QUFDeEIsaURBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0MsNENBQUksRUFBRSxJQUFJO3FDQUNiO0FBQ0QsaURBQWEsRUFBRTtBQUNYLDRDQUFJLEVBQUUsc0JBQXNCO0FBQzVCLGlEQUFTLEVBQUUsT0FBTyxDQUFDLDJCQUEyQixDQUFDO0FBQy9DLDRDQUFJLEVBQUUsSUFBSTtxQ0FDYjtBQUNELHdEQUFvQixFQUFFO0FBQ2xCLDRDQUFJLEVBQUUsNkJBQTZCO0FBQ25DLGlEQUFTLEVBQUUsT0FBTyxDQUFDLDJCQUEyQixDQUFDO0FBQy9DLDRDQUFJLEVBQUUsSUFBSTtxQ0FDYjtBQUNELGlEQUFhLEVBQUU7QUFDWCw0Q0FBSSxFQUFFLHNCQUFzQjtBQUM1QixpREFBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyw0Q0FBSSxFQUFFLElBQUk7cUNBQ2I7QUFDRCxrREFBYyxFQUFFO0FBQ1osNENBQUksRUFBRSx1QkFBdUI7QUFDN0IsaURBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDL0MsNENBQUksRUFBRSxJQUFJO3FDQUNiO2lDQUNKOzZCQUNKO0FBQ0QsNkNBQWlCLEVBQUU7QUFDZixvQ0FBSSxFQUFFLHNCQUFzQjtBQUM1Qix5Q0FBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyxvQ0FBSSxFQUFFLElBQUk7QUFDVix5Q0FBUyxFQUFFO0FBQ1AsNkNBQVMsRUFBRTtBQUNQLDRDQUFJLEVBQUUsNkJBQTZCO0FBQ25DLGlEQUFTLEVBQUUsT0FBTyxDQUFDLDJCQUEyQixDQUFDO0FBQy9DLDRDQUFJLEVBQUUsSUFBSTtxQ0FDYjtBQUNELGlEQUFhLEVBQUU7QUFDWCw0Q0FBSSxFQUFFLGlDQUFpQztBQUN2QyxpREFBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyw0Q0FBSSxFQUFFLElBQUk7cUNBQ2I7aUNBQ0o7NkJBQ0o7eUJBQ0o7cUJBQ0o7aUJBQ0o7YUFDSjtBQUNELG9CQUFRLEVBQUU7QUFDTixvQkFBSSxFQUFFLE9BQU87QUFDYix5QkFBUyxFQUFFLE9BQU8sQ0FBQyxpQ0FBaUMsQ0FBQztBQUNyRCxxQkFBSyxFQUFFLElBQUk7YUFDZDtTQUNKLENBQUMsQ0FBQzs7QUFFSCxjQUFNLENBQUMsUUFBUSxDQUFDO0FBQ1osZUFBRyxFQUFFLFlBQVk7QUFDakIsc0JBQVUsRUFBRSwyQkFBMkI7QUFDdkMsa0JBQU0sRUFBRSxvQkFBb0I7QUFDNUIsd0JBQVksRUFBRSxtQkFBbUI7QUFDakMsbUNBQXVCLEVBQUUsOEJBQThCO0FBQ3ZELHlCQUFhLEVBQUUsMEJBQTBCO1NBQzVDLENBQUMsQ0FBQzs7QUFFSCxjQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsVUFBVSxFQUFFOztBQUVwQyxnQkFBSSxJQUFJLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQzs7QUFFN0MsZ0JBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUU7QUFDcEIsb0JBQUksSUFBSSxFQUFFOztBQUVOLHdCQUFJLE1BQU0sR0FBRztBQUNULDRCQUFJLEVBQUUsZUFBZTtBQUNyQiw4QkFBTSxFQUFFLEtBQUs7QUFDYiwrQkFBTyxFQUFFLEVBQUMsZUFBZSxFQUFFLFlBQVksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUM7cUJBQ2hFLENBQUM7O0FBRUYsMEJBQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQ2YsVUFBVSxRQUFRLEVBQUU7O0FBRWhCLDRCQUFJLEtBQUssR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7O0FBRW5ELG9DQUFZLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUN6QyxrQ0FBVSxDQUFDLElBQUksRUFBRSxDQUFDO3FCQUNyQixFQUNELFlBQVc7QUFDUCxrQ0FBVSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztxQkFDakMsQ0FDSixDQUFDO2lCQUNMLE1BQU07QUFDSCw4QkFBVSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDakM7YUFDSixNQUFNO0FBQ0gsb0JBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksUUFBUSxJQUFJLElBQUksRUFBRTtBQUN4Qyw4QkFBVSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQztpQkFDckMsTUFBTTtBQUNILDhCQUFVLENBQUMsSUFBSSxFQUFFLENBQUM7aUJBQ3JCO2FBQ0o7U0FDSixDQUFDLENBQUE7S0FDTDtDQUNKLENBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTItMjAxMyB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUsIGxvY2F0aW9uKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgdW5kZWY7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgbWl4aW4sIG9yaWdpbiwgdXJsUkUsIGFic29sdXRlVXJsUkUsIGZ1bGx5UXVhbGlmaWVkVXJsUkU7XG5cblx0XHRtaXhpbiA9IHJlcXVpcmUoJy4vdXRpbC9taXhpbicpO1xuXG5cdFx0dXJsUkUgPSAvKFthLXpdW2EtejAtOVxcK1xcLVxcLl0qOilcXC9cXC8oW15AXStAKT8oKFteOlxcL10rKSg6KFswLTldKykpPyk/KFxcL1tePyNdKik/KFxcP1teI10qKT8oI1xcUyopPy9pO1xuXHRcdGFic29sdXRlVXJsUkUgPSAvXihbYS16XVthLXowLTlcXC1cXCtcXC5dKjpcXC9cXC98XFwvKS9pO1xuXHRcdGZ1bGx5UXVhbGlmaWVkVXJsUkUgPSAvKFthLXpdW2EtejAtOVxcK1xcLVxcLl0qOilcXC9cXC8oW15AXStAKT8oKFteOlxcL10rKSg6KFswLTldKykpPyk/XFwvL2k7XG5cblx0XHQvKipcblx0XHQgKiBBcHBseSBwYXJhbXMgdG8gdGhlIHRlbXBsYXRlIHRvIGNyZWF0ZSBhIFVSTC5cblx0XHQgKlxuXHRcdCAqIFBhcmFtZXRlcnMgdGhhdCBhcmUgbm90IGFwcGxpZWQgZGlyZWN0bHkgdG8gdGhlIHRlbXBsYXRlLCBhcmUgYXBwZW5kZWRcblx0XHQgKiB0byB0aGUgVVJMIGFzIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIHRoZSBVUkkgdGVtcGxhdGVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnMgdG8gYXBwbHkgdG8gdGhlIHRlbXBsYXRlXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVzdWx0aW5nIFVSTFxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGJ1aWxkVXJsKHRlbXBsYXRlLCBwYXJhbXMpIHtcblx0XHRcdC8vIGludGVybmFsIGJ1aWxkZXIgdG8gY29udmVydCB0ZW1wbGF0ZSB3aXRoIHBhcmFtcy5cblx0XHRcdHZhciB1cmwsIG5hbWUsIHF1ZXJ5U3RyaW5nUGFyYW1zLCByZTtcblxuXHRcdFx0dXJsID0gdGVtcGxhdGU7XG5cdFx0XHRxdWVyeVN0cmluZ1BhcmFtcyA9IHt9O1xuXG5cdFx0XHRpZiAocGFyYW1zKSB7XG5cdFx0XHRcdGZvciAobmFtZSBpbiBwYXJhbXMpIHtcblx0XHRcdFx0XHQvKmpzaGludCBmb3JpbjpmYWxzZSAqL1xuXHRcdFx0XHRcdHJlID0gbmV3IFJlZ0V4cCgnXFxcXHsnICsgbmFtZSArICdcXFxcfScpO1xuXHRcdFx0XHRcdGlmIChyZS50ZXN0KHVybCkpIHtcblx0XHRcdFx0XHRcdHVybCA9IHVybC5yZXBsYWNlKHJlLCBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW25hbWVdKSwgJ2cnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRxdWVyeVN0cmluZ1BhcmFtc1tuYW1lXSA9IHBhcmFtc1tuYW1lXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChuYW1lIGluIHF1ZXJ5U3RyaW5nUGFyYW1zKSB7XG5cdFx0XHRcdFx0dXJsICs9IHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnO1xuXHRcdFx0XHRcdHVybCArPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSk7XG5cdFx0XHRcdFx0aWYgKHF1ZXJ5U3RyaW5nUGFyYW1zW25hbWVdICE9PSBudWxsICYmIHF1ZXJ5U3RyaW5nUGFyYW1zW25hbWVdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHVybCArPSAnPSc7XG5cdFx0XHRcdFx0XHR1cmwgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5U3RyaW5nUGFyYW1zW25hbWVdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB1cmw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHRlc3QpIHtcblx0XHRcdHJldHVybiBzdHIuaW5kZXhPZih0ZXN0KSA9PT0gMDtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBuZXcgVVJMIEJ1aWxkZXJcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfFVybEJ1aWxkZXJ9IHRlbXBsYXRlIHRoZSBiYXNlIHRlbXBsYXRlIHRvIGJ1aWxkIGZyb20sIG1heSBiZSBhbm90aGVyIFVybEJ1aWxkZXJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gYmFzZSBwYXJhbWV0ZXJzXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gVXJsQnVpbGRlcih0ZW1wbGF0ZSwgcGFyYW1zKSB7XG5cdFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgVXJsQnVpbGRlcikpIHtcblx0XHRcdFx0Ly8gaW52b2tlIGFzIGEgY29uc3RydWN0b3Jcblx0XHRcdFx0cmV0dXJuIG5ldyBVcmxCdWlsZGVyKHRlbXBsYXRlLCBwYXJhbXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGVtcGxhdGUgaW5zdGFuY2VvZiBVcmxCdWlsZGVyKSB7XG5cdFx0XHRcdHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGUudGVtcGxhdGU7XG5cdFx0XHRcdHRoaXMuX3BhcmFtcyA9IG1peGluKHt9LCB0aGlzLl9wYXJhbXMsIHBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpcy5fdGVtcGxhdGUgPSAodGVtcGxhdGUgfHwgJycpLnRvU3RyaW5nKCk7XG5cdFx0XHRcdHRoaXMuX3BhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRVcmxCdWlsZGVyLnByb3RvdHlwZSA9IHtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDcmVhdGUgYSBuZXcgVXJsQnVpbGRlciBpbnN0YW5jZSB0aGF0IGV4dGVuZHMgdGhlIGN1cnJlbnQgYnVpbGRlci5cblx0XHRcdCAqIFRoZSBjdXJyZW50IGJ1aWxkZXIgaXMgdW5tb2RpZmllZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW3RlbXBsYXRlXSBVUkwgdGVtcGxhdGUgdG8gYXBwZW5kIHRvIHRoZSBjdXJyZW50IHRlbXBsYXRlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gcGFyYW1zIHRvIGNvbWJpbmUgd2l0aCBjdXJyZW50IHBhcmFtcy4gIE5ldyBwYXJhbXMgb3ZlcnJpZGUgZXhpc3RpbmcgcGFyYW1zXG5cdFx0XHQgKiBAcmV0dXJuIHtVcmxCdWlsZGVyfSB0aGUgbmV3IGJ1aWxkZXJcblx0XHRcdCAqL1xuXHRcdFx0YXBwZW5kOiBmdW5jdGlvbiAodGVtcGxhdGUsICBwYXJhbXMpIHtcblx0XHRcdFx0Ly8gVE9ETyBjb25zaWRlciBxdWVyeSBzdHJpbmdzIGFuZCBmcmFnbWVudHNcblx0XHRcdFx0cmV0dXJuIG5ldyBVcmxCdWlsZGVyKHRoaXMuX3RlbXBsYXRlICsgdGVtcGxhdGUsIG1peGluKHt9LCB0aGlzLl9wYXJhbXMsIHBhcmFtcykpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDcmVhdGUgYSBuZXcgVXJsQnVpbGRlciB3aXRoIGEgZnVsbHkgcXVhbGlmaWVkIFVSTCBiYXNlZCBvbiB0aGVcblx0XHRcdCAqIHdpbmRvdydzIGxvY2F0aW9uIG9yIGJhc2UgaHJlZiBhbmQgdGhlIGN1cnJlbnQgdGVtcGxhdGVzIHJlbGF0aXZlIFVSTC5cblx0XHRcdCAqXG5cdFx0XHQgKiBQYXRoIHZhcmlhYmxlcyBhcmUgcHJlc2VydmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqICpCcm93c2VyIG9ubHkqXG5cdFx0XHQgKlxuXHRcdFx0ICogQHJldHVybiB7VXJsQnVpbGRlcn0gdGhlIGZ1bGx5IHF1YWxpZmllZCBVUkwgdGVtcGxhdGVcblx0XHRcdCAqL1xuXHRcdFx0ZnVsbHlRdWFsaWZ5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICghbG9jYXRpb24pIHsgcmV0dXJuIHRoaXM7IH1cblx0XHRcdFx0aWYgKHRoaXMuaXNGdWxseVF1YWxpZmllZCgpKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHRcdFx0dmFyIHRlbXBsYXRlID0gdGhpcy5fdGVtcGxhdGU7XG5cblx0XHRcdFx0aWYgKHN0YXJ0c1dpdGgodGVtcGxhdGUsICcvLycpKSB7XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSBvcmlnaW4ucHJvdG9jb2wgKyB0ZW1wbGF0ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChzdGFydHNXaXRoKHRlbXBsYXRlLCAnLycpKSB7XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSBvcmlnaW4ub3JpZ2luICsgdGVtcGxhdGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIXRoaXMuaXNBYnNvbHV0ZSgpKSB7XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSBvcmlnaW4ub3JpZ2luICsgb3JpZ2luLnBhdGhuYW1lLnN1YnN0cmluZygwLCBvcmlnaW4ucGF0aG5hbWUubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRlbXBsYXRlLmluZGV4T2YoJy8nLCA4KSA9PT0gLTEpIHtcblx0XHRcdFx0XHQvLyBkZWZhdWx0IHRoZSBwYXRobmFtZSB0byAnLydcblx0XHRcdFx0XHR0ZW1wbGF0ZSA9IHRlbXBsYXRlICsgJy8nO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBVcmxCdWlsZGVyKHRlbXBsYXRlLCB0aGlzLl9wYXJhbXMpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUcnVlIGlmIHRoZSBVUkwgaXMgYWJzb2x1dGVcblx0XHRcdCAqXG5cdFx0XHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHRcdFx0ICovXG5cdFx0XHRpc0Fic29sdXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBhYnNvbHV0ZVVybFJFLnRlc3QodGhpcy5idWlsZCgpKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVHJ1ZSBpZiB0aGUgVVJMIGlzIGZ1bGx5IHF1YWxpZmllZFxuXHRcdFx0ICpcblx0XHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdFx0XHQgKi9cblx0XHRcdGlzRnVsbHlRdWFsaWZpZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGZ1bGx5UXVhbGlmaWVkVXJsUkUudGVzdCh0aGlzLmJ1aWxkKCkpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUcnVlIGlmIHRoZSBVUkwgaXMgY3Jvc3Mgb3JpZ2luLiBUaGUgcHJvdG9jb2wsIGhvc3QgYW5kIHBvcnQgbXVzdCBub3QgYmVcblx0XHRcdCAqIHRoZSBzYW1lIGluIG9yZGVyIHRvIGJlIGNyb3NzIG9yaWdpbixcblx0XHRcdCAqXG5cdFx0XHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHRcdFx0ICovXG5cdFx0XHRpc0Nyb3NzT3JpZ2luOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICghb3JpZ2luKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHVybCA9IHRoaXMucGFydHMoKTtcblx0XHRcdFx0cmV0dXJuIHVybC5wcm90b2NvbCAhPT0gb3JpZ2luLnByb3RvY29sIHx8XG5cdFx0XHRcdCAgICAgICB1cmwuaG9zdG5hbWUgIT09IG9yaWdpbi5ob3N0bmFtZSB8fFxuXHRcdFx0XHQgICAgICAgdXJsLnBvcnQgIT09IG9yaWdpbi5wb3J0O1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTcGxpdCBhIFVSTCBpbnRvIGl0cyBjb25zaXR1ZW50IHBhcnRzIGZvbGxvd2luZyB0aGUgbmFtaW5nIGNvbnZlbnRpb24gb2Zcblx0XHRcdCAqICd3aW5kb3cubG9jYXRpb24nLiBPbmUgZGlmZmVyZW5jZSBpcyB0aGF0IHRoZSBwb3J0IHdpbGwgY29udGFpbiB0aGVcblx0XHRcdCAqIHByb3RvY29sIGRlZmF1bHQgaWYgbm90IHNwZWNpZmllZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL3dpbmRvdy5sb2NhdGlvblxuXHRcdFx0ICpcblx0XHRcdCAqIEByZXR1cm5zIHtPYmplY3R9IGEgJ3dpbmRvdy5sb2NhdGlvbictbGlrZSBvYmplY3Rcblx0XHRcdCAqL1xuXHRcdFx0cGFydHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Lypqc2hpbnQgbWF4Y29tcGxleGl0eToyMCAqL1xuXHRcdFx0XHR2YXIgdXJsLCBwYXJ0cztcblx0XHRcdFx0dXJsID0gdGhpcy5mdWxseVF1YWxpZnkoKS5idWlsZCgpLm1hdGNoKHVybFJFKTtcblx0XHRcdFx0cGFydHMgPSB7XG5cdFx0XHRcdFx0aHJlZjogdXJsWzBdLFxuXHRcdFx0XHRcdHByb3RvY29sOiB1cmxbMV0sXG5cdFx0XHRcdFx0aG9zdDogdXJsWzNdIHx8ICcnLFxuXHRcdFx0XHRcdGhvc3RuYW1lOiB1cmxbNF0gfHwgJycsXG5cdFx0XHRcdFx0cG9ydDogdXJsWzZdLFxuXHRcdFx0XHRcdHBhdGhuYW1lOiB1cmxbN10gfHwgJycsXG5cdFx0XHRcdFx0c2VhcmNoOiB1cmxbOF0gfHwgJycsXG5cdFx0XHRcdFx0aGFzaDogdXJsWzldIHx8ICcnXG5cdFx0XHRcdH07XG5cdFx0XHRcdHBhcnRzLm9yaWdpbiA9IHBhcnRzLnByb3RvY29sICsgJy8vJyArIHBhcnRzLmhvc3Q7XG5cdFx0XHRcdHBhcnRzLnBvcnQgPSBwYXJ0cy5wb3J0IHx8IChwYXJ0cy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnNDQzJyA6IHBhcnRzLnByb3RvY29sID09PSAnaHR0cDonID8gJzgwJyA6ICcnKTtcblx0XHRcdFx0cmV0dXJuIHBhcnRzO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBFeHBhbmQgdGhlIHRlbXBsYXRlIHJlcGxhY2luZyBwYXRoIHZhcmlhYmxlcyB3aXRoIHBhcmFtZXRlcnNcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gcGFyYW1zIHRvIGNvbWJpbmUgd2l0aCBjdXJyZW50IHBhcmFtcy4gIE5ldyBwYXJhbXMgb3ZlcnJpZGUgZXhpc3RpbmcgcGFyYW1zXG5cdFx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBleHBhbmRlZCBVUkxcblx0XHRcdCAqL1xuXHRcdFx0YnVpbGQ6IGZ1bmN0aW9uIChwYXJhbXMpIHtcblx0XHRcdFx0cmV0dXJuIGJ1aWxkVXJsKHRoaXMuX3RlbXBsYXRlLCBtaXhpbih7fSwgdGhpcy5fcGFyYW1zLCBwYXJhbXMpKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHNlZSBidWlsZFxuXHRcdFx0ICovXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5idWlsZCgpO1xuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdG9yaWdpbiA9IGxvY2F0aW9uID8gbmV3IFVybEJ1aWxkZXIobG9jYXRpb24uaHJlZikucGFydHMoKSA6IHVuZGVmO1xuXG5cdFx0cmV0dXJuIFVybEJ1aWxkZXI7XG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0sXG5cdHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmxvY2F0aW9uIDogdm9pZCAwXG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE0IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgcmVzdCA9IHJlcXVpcmUoJy4vY2xpZW50L2RlZmF1bHQnKSxcblx0XHQgICAgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2xpZW50L3hocicpO1xuXG5cdFx0cmVzdC5zZXRQbGF0Zm9ybURlZmF1bHRDbGllbnQoYnJvd3Nlcik7XG5cblx0XHRyZXR1cm4gcmVzdDtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE0IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uICgvKiByZXF1aXJlICovKSB7XG5cblx0XHQvKipcblx0XHQgKiBBZGQgY29tbW9uIGhlbHBlciBtZXRob2RzIHRvIGEgY2xpZW50IGltcGxcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGltcGwgdGhlIGNsaWVudCBpbXBsZW1lbnRhdGlvblxuXHRcdCAqIEBwYXJhbSB7Q2xpZW50fSBbdGFyZ2V0XSB0YXJnZXQgb2YgdGhpcyBjbGllbnQsIHVzZWQgd2hlbiB3cmFwcGluZyBvdGhlciBjbGllbnRzXG5cdFx0ICogQHJldHVybnMge0NsaWVudH0gdGhlIGNsaWVudCBpbXBsIHdpdGggYWRkaXRpb25hbCBtZXRob2RzXG5cdFx0ICovXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNsaWVudChpbXBsLCB0YXJnZXQpIHtcblxuXHRcdFx0aWYgKHRhcmdldCkge1xuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBAcmV0dXJucyB7Q2xpZW50fSB0aGUgdGFyZ2V0IGNsaWVudFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0aW1wbC5za2lwID0gZnVuY3Rpb24gc2tpcCgpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQWxsb3cgYSBjbGllbnQgdG8gZWFzaWx5IGJlIHdyYXBwZWQgYnkgYW4gaW50ZXJjZXB0b3Jcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0ludGVyY2VwdG9yfSBpbnRlcmNlcHRvciB0aGUgaW50ZXJjZXB0b3IgdG8gd3JhcCB0aGlzIGNsaWVudCB3aXRoXG5cdFx0XHQgKiBAcGFyYW0gW2NvbmZpZ10gY29uZmlndXJhdGlvbiBmb3IgdGhlIGludGVyY2VwdG9yXG5cdFx0XHQgKiBAcmV0dXJucyB7Q2xpZW50fSB0aGUgbmV3bHkgd3JhcHBlZCBjbGllbnRcblx0XHRcdCAqL1xuXHRcdFx0aW1wbC53cmFwID0gZnVuY3Rpb24gd3JhcChpbnRlcmNlcHRvciwgY29uZmlnKSB7XG5cdFx0XHRcdHJldHVybiBpbnRlcmNlcHRvcihpbXBsLCBjb25maWcpO1xuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAZGVwcmVjYXRlZFxuXHRcdFx0ICovXG5cdFx0XHRpbXBsLmNoYWluID0gZnVuY3Rpb24gY2hhaW4oKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygncmVzdC5qczogY2xpZW50LmNoYWluKCkgaXMgZGVwcmVjYXRlZCwgdXNlIGNsaWVudC53cmFwKCkgaW5zdGVhZCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGltcGwud3JhcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIGltcGw7XG5cblx0XHR9O1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTQgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgdW5kZWY7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHQvKipcblx0XHQgKiBQbGFpbiBKUyBPYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRoYXQgcmVwcmVzZW50IGFuIEhUVFAgcmVxdWVzdC5cblx0XHQgKlxuXHRcdCAqIERlcGVuZGluZyBvbiB0aGUgY2FwYWJpbGl0aWVzIG9mIHRoZSB1bmRlcmx5aW5nIGNsaWVudCwgYSByZXF1ZXN0XG5cdFx0ICogbWF5IGJlIGNhbmNlbGFibGUuIElmIGEgcmVxdWVzdCBtYXkgYmUgY2FuY2VsZWQsIHRoZSBjbGllbnQgd2lsbCBhZGRcblx0XHQgKiBhIGNhbmNlbGVkIGZsYWcgYW5kIGNhbmNlbCBmdW5jdGlvbiB0byB0aGUgcmVxdWVzdCBvYmplY3QuIENhbmNlbGluZ1xuXHRcdCAqIHRoZSByZXF1ZXN0IHdpbGwgcHV0IHRoZSByZXNwb25zZSBpbnRvIGFuIGVycm9yIHN0YXRlLlxuXHRcdCAqXG5cdFx0ICogQGZpZWxkIHtzdHJpbmd9IFttZXRob2Q9J0dFVCddIEhUVFAgbWV0aG9kLCBjb21tb25seSBHRVQsIFBPU1QsIFBVVCwgREVMRVRFIG9yIEhFQURcblx0XHQgKiBAZmllbGQge3N0cmluZ3xVcmxCdWlsZGVyfSBbcGF0aD0nJ10gcGF0aCB0ZW1wbGF0ZSB3aXRoIG9wdGlvbmFsIHBhdGggdmFyaWFibGVzXG5cdFx0ICogQGZpZWxkIHtPYmplY3R9IFtwYXJhbXNdIHBhcmFtZXRlcnMgZm9yIHRoZSBwYXRoIHRlbXBsYXRlIGFuZCBxdWVyeSBzdHJpbmdcblx0XHQgKiBAZmllbGQge09iamVjdH0gW2hlYWRlcnNdIGN1c3RvbSBIVFRQIGhlYWRlcnMgdG8gc2VuZCwgaW4gYWRkaXRpb24gdG8gdGhlIGNsaWVudHMgZGVmYXVsdCBoZWFkZXJzXG5cdFx0ICogQGZpZWxkIFtlbnRpdHldIHRoZSBIVFRQIGVudGl0eSwgY29tbW9uIGZvciBQT1NUIG9yIFBVVCByZXF1ZXN0c1xuXHRcdCAqIEBmaWVsZCB7Ym9vbGVhbn0gW2NhbmNlbGVkXSB0cnVlIGlmIHRoZSByZXF1ZXN0IGhhcyBiZWVuIGNhbmNlbGVkLCBzZXQgYnkgdGhlIGNsaWVudFxuXHRcdCAqIEBmaWVsZCB7RnVuY3Rpb259IFtjYW5jZWxdIGNhbmNlbHMgdGhlIHJlcXVlc3QgaWYgaW52b2tlZCwgcHJvdmlkZWQgYnkgdGhlIGNsaWVudFxuXHRcdCAqIEBmaWVsZCB7Q2xpZW50fSBbb3JpZ2luYXRvcl0gdGhlIGNsaWVudCB0aGF0IGZpcnN0IGhhbmRsZWQgdGhpcyByZXF1ZXN0LCBwcm92aWRlZCBieSB0aGUgaW50ZXJjZXB0b3Jcblx0XHQgKlxuXHRcdCAqIEBjbGFzcyBSZXF1ZXN0XG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBQbGFpbiBKUyBPYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRoYXQgcmVwcmVzZW50IGFuIEhUVFAgcmVzcG9uc2Vcblx0XHQgKlxuXHRcdCAqIEBmaWVsZCB7T2JqZWN0fSBbcmVxdWVzdF0gdGhlIHJlcXVlc3Qgb2JqZWN0IGFzIHJlY2VpdmVkIGJ5IHRoZSByb290IGNsaWVudFxuXHRcdCAqIEBmaWVsZCB7T2JqZWN0fSBbcmF3XSB0aGUgdW5kZXJseWluZyByZXF1ZXN0IG9iamVjdCwgbGlrZSBYbWxIdHRwUmVxdWVzdCBpbiBhIGJyb3dzZXJcblx0XHQgKiBAZmllbGQge251bWJlcn0gW3N0YXR1cy5jb2RlXSBzdGF0dXMgY29kZSBvZiB0aGUgcmVzcG9uc2UgKGkuZS4gMjAwLCA0MDQpXG5cdFx0ICogQGZpZWxkIHtzdHJpbmd9IFtzdGF0dXMudGV4dF0gc3RhdHVzIHBocmFzZSBvZiB0aGUgcmVzcG9uc2Vcblx0XHQgKiBAZmllbGQge09iamVjdF0gW2hlYWRlcnNdIHJlc3BvbnNlIGhlYWRlcnMgaGFzaCBvZiBub3JtYWxpemVkIG5hbWUsIHZhbHVlIHBhaXJzXG5cdFx0ICogQGZpZWxkIFtlbnRpdHldIHRoZSByZXNwb25zZSBib2R5XG5cdFx0ICpcblx0XHQgKiBAY2xhc3MgUmVzcG9uc2Vcblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIEhUVFAgY2xpZW50IHBhcnRpY3VsYXJseSBzdWl0ZWQgZm9yIFJFU1RmdWwgb3BlcmF0aW9ucy5cblx0XHQgKlxuXHRcdCAqIEBmaWVsZCB7ZnVuY3Rpb259IHdyYXAgd3JhcHMgdGhpcyBjbGllbnQgd2l0aCBhIG5ldyBpbnRlcmNlcHRvciByZXR1cm5pbmcgdGhlIHdyYXBwZWQgY2xpZW50XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1JlcXVlc3R9IHRoZSBIVFRQIHJlcXVlc3Rcblx0XHQgKiBAcmV0dXJucyB7UmVzcG9uc2VQcm9taXNlPFJlc3BvbnNlPn0gYSBwcm9taXNlIHRoZSByZXNvbHZlcyB0byB0aGUgSFRUUCByZXNwb25zZVxuXHRcdCAqXG5cdFx0ICogQGNsYXNzIENsaWVudFxuXHRcdCAqL1xuXG5cdFx0IC8qKlxuXHRcdCAgKiBFeHRlbmRlZCB3aGVuLmpzIFByb21pc2VzL0ErIHByb21pc2Ugd2l0aCBIVFRQIHNwZWNpZmljIGhlbHBlcnNcblx0XHQgICpxXG5cdFx0ICAqIEBtZXRob2QgZW50aXR5IHByb21pc2UgZm9yIHRoZSBIVFRQIGVudGl0eVxuXHRcdCAgKiBAbWV0aG9kIHN0YXR1cyBwcm9taXNlIGZvciB0aGUgSFRUUCBzdGF0dXMgY29kZVxuXHRcdCAgKiBAbWV0aG9kIGhlYWRlcnMgcHJvbWlzZSBmb3IgdGhlIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdCAgKiBAbWV0aG9kIGhlYWRlciBwcm9taXNlIGZvciBhIHNwZWNpZmljIEhUVFAgcmVzcG9uc2UgaGVhZGVyXG5cdFx0ICAqXG5cdFx0ICAqIEBjbGFzcyBSZXNwb25zZVByb21pc2Vcblx0XHQgICogQGV4dGVuZHMgUHJvbWlzZVxuXHRcdCAgKi9cblxuXHRcdHZhciBjbGllbnQsIHRhcmdldCwgcGxhdGZvcm1EZWZhdWx0O1xuXG5cdFx0Y2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50Jyk7XG5cblx0XHQvKipcblx0XHQgKiBNYWtlIGEgcmVxdWVzdCB3aXRoIHRoZSBkZWZhdWx0IGNsaWVudFxuXHRcdCAqIEBwYXJhbSB7UmVxdWVzdH0gdGhlIEhUVFAgcmVxdWVzdFxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3BvbnNlPn0gYSBwcm9taXNlIHRoZSByZXNvbHZlcyB0byB0aGUgSFRUUCByZXNwb25zZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGRlZmF1bHRDbGllbnQoKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmFwcGx5KHVuZGVmLCBhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIENoYW5nZSB0aGUgZGVmYXVsdCBjbGllbnRcblx0XHQgKiBAcGFyYW0ge0NsaWVudH0gY2xpZW50IHRoZSBuZXcgZGVmYXVsdCBjbGllbnRcblx0XHQgKi9cblx0XHRkZWZhdWx0Q2xpZW50LnNldERlZmF1bHRDbGllbnQgPSBmdW5jdGlvbiBzZXREZWZhdWx0Q2xpZW50KGNsaWVudCkge1xuXHRcdFx0dGFyZ2V0ID0gY2xpZW50O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBPYnRhaW4gYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGRlZmF1bHQgY2xpZW50XG5cdFx0ICogQHJldHVybnMge0NsaWVudH0gdGhlIGRlZmF1bHQgY2xpZW50XG5cdFx0ICovXG5cdFx0ZGVmYXVsdENsaWVudC5nZXREZWZhdWx0Q2xpZW50ID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENsaWVudCgpIHtcblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlc2V0IHRoZSBkZWZhdWx0IGNsaWVudCB0byB0aGUgcGxhdGZvcm0gZGVmYXVsdFxuXHRcdCAqL1xuXHRcdGRlZmF1bHRDbGllbnQucmVzZXREZWZhdWx0Q2xpZW50ID0gZnVuY3Rpb24gcmVzZXREZWZhdWx0Q2xpZW50KCkge1xuXHRcdFx0dGFyZ2V0ID0gcGxhdGZvcm1EZWZhdWx0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGRlZmF1bHRDbGllbnQuc2V0UGxhdGZvcm1EZWZhdWx0Q2xpZW50ID0gZnVuY3Rpb24gc2V0UGxhdGZvcm1EZWZhdWx0Q2xpZW50KGNsaWVudCkge1xuXHRcdFx0aWYgKHBsYXRmb3JtRGVmYXVsdCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZWRlZmluZSBwbGF0Zm9ybURlZmF1bHRDbGllbnQnKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldCA9IHBsYXRmb3JtRGVmYXVsdCA9IGNsaWVudDtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIGNsaWVudChkZWZhdWx0Q2xpZW50KTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEyLTIwMTQgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lLCBnbG9iYWwpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIHdoZW4sIFVybEJ1aWxkZXIsIG5vcm1hbGl6ZUhlYWRlck5hbWUsIHJlc3BvbnNlUHJvbWlzZSwgY2xpZW50LCBoZWFkZXJTcGxpdFJFO1xuXG5cdFx0d2hlbiA9IHJlcXVpcmUoJ3doZW4nKTtcblx0XHRVcmxCdWlsZGVyID0gcmVxdWlyZSgnLi4vVXJsQnVpbGRlcicpO1xuXHRcdG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuLi91dGlsL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblx0XHRyZXNwb25zZVByb21pc2UgPSByZXF1aXJlKCcuLi91dGlsL3Jlc3BvbnNlUHJvbWlzZScpO1xuXHRcdGNsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudCcpO1xuXG5cdFx0Ly8gYWNjb3JkaW5nIHRvIHRoZSBzcGVjLCB0aGUgbGluZSBicmVhayBpcyAnXFxyXFxuJywgYnV0IGRvZXNuJ3QgaG9sZCB0cnVlIGluIHByYWN0aWNlXG5cdFx0aGVhZGVyU3BsaXRSRSA9IC9bXFxyfFxcbl0rLztcblxuXHRcdGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXcpIHtcblx0XHRcdC8vIE5vdGU6IFNldC1Db29raWUgd2lsbCBiZSByZW1vdmVkIGJ5IHRoZSBicm93c2VyXG5cdFx0XHR2YXIgaGVhZGVycyA9IHt9O1xuXG5cdFx0XHRpZiAoIXJhdykgeyByZXR1cm4gaGVhZGVyczsgfVxuXG5cdFx0XHRyYXcudHJpbSgpLnNwbGl0KGhlYWRlclNwbGl0UkUpLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdFx0XHR2YXIgYm91bmRhcnksIG5hbWUsIHZhbHVlO1xuXHRcdFx0XHRib3VuZGFyeSA9IGhlYWRlci5pbmRleE9mKCc6Jyk7XG5cdFx0XHRcdG5hbWUgPSBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlci5zdWJzdHJpbmcoMCwgYm91bmRhcnkpLnRyaW0oKSk7XG5cdFx0XHRcdHZhbHVlID0gaGVhZGVyLnN1YnN0cmluZyhib3VuZGFyeSArIDEpLnRyaW0oKTtcblx0XHRcdFx0aWYgKGhlYWRlcnNbbmFtZV0pIHtcblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzW25hbWVdKSkge1xuXHRcdFx0XHRcdFx0Ly8gYWRkIHRvIGFuIGV4aXN0aW5nIGFycmF5XG5cdFx0XHRcdFx0XHRoZWFkZXJzW25hbWVdLnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGNvbnZlcnQgc2luZ2xlIHZhbHVlIHRvIGFycmF5XG5cdFx0XHRcdFx0XHRoZWFkZXJzW25hbWVdID0gW2hlYWRlcnNbbmFtZV0sIHZhbHVlXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbmV3LCBzaW5nbGUgdmFsdWVcblx0XHRcdFx0XHRoZWFkZXJzW25hbWVdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gaGVhZGVycztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzYWZlTWl4aW4odGFyZ2V0LCBzb3VyY2UpIHtcblx0XHRcdE9iamVjdC5rZXlzKHNvdXJjZSB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuXHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhlIHByb3BlcnR5IGFscmVhZHkgZXhpc3RzIGFzXG5cdFx0XHRcdC8vIElFIDYgd2lsbCBibG93IHVwIGlmIHdlIGFkZCBhIG5ldyBwcm9wXG5cdFx0XHRcdGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgcHJvcCBpbiB0YXJnZXQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0Ly8gaWdub3JlLCBleHBlY3RlZCBmb3Igc29tZSBwcm9wZXJ0aWVzIGF0IHNvbWUgcG9pbnRzIGluIHRoZSByZXF1ZXN0IGxpZmVjeWNsZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsaWVudChmdW5jdGlvbiB4aHIocmVxdWVzdCkge1xuXHRcdFx0cmV0dXJuIHJlc3BvbnNlUHJvbWlzZS5wcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0Lypqc2hpbnQgbWF4Y29tcGxleGl0eToyMCAqL1xuXG5cdFx0XHRcdHZhciBjbGllbnQsIG1ldGhvZCwgdXJsLCBoZWFkZXJzLCBlbnRpdHksIGhlYWRlck5hbWUsIHJlc3BvbnNlLCBYTUxIdHRwUmVxdWVzdDtcblxuXHRcdFx0XHRyZXF1ZXN0ID0gdHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnID8geyBwYXRoOiByZXF1ZXN0IH0gOiByZXF1ZXN0IHx8IHt9O1xuXHRcdFx0XHRyZXNwb25zZSA9IHsgcmVxdWVzdDogcmVxdWVzdCB9O1xuXG5cdFx0XHRcdGlmIChyZXF1ZXN0LmNhbmNlbGVkKSB7XG5cdFx0XHRcdFx0cmVzcG9uc2UuZXJyb3IgPSAncHJlY2FuY2VsZWQnO1xuXHRcdFx0XHRcdHJlamVjdChyZXNwb25zZSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0WE1MSHR0cFJlcXVlc3QgPSByZXF1ZXN0LmVuZ2luZSB8fCBnbG9iYWwuWE1MSHR0cFJlcXVlc3Q7XG5cdFx0XHRcdGlmICghWE1MSHR0cFJlcXVlc3QpIHtcblx0XHRcdFx0XHRyZWplY3QoeyByZXF1ZXN0OiByZXF1ZXN0LCBlcnJvcjogJ3hoci1ub3QtYXZhaWxhYmxlJyB9KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbnRpdHkgPSByZXF1ZXN0LmVudGl0eTtcblx0XHRcdFx0cmVxdWVzdC5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZCB8fCAoZW50aXR5ID8gJ1BPU1QnIDogJ0dFVCcpO1xuXHRcdFx0XHRtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcblx0XHRcdFx0dXJsID0gbmV3IFVybEJ1aWxkZXIocmVxdWVzdC5wYXRoIHx8ICcnLCByZXF1ZXN0LnBhcmFtcykuYnVpbGQoKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNsaWVudCA9IHJlc3BvbnNlLnJhdyA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG5cdFx0XHRcdFx0Ly8gbWl4aW4gZXh0cmEgcmVxdWVzdCBwcm9wZXJ0aWVzIGJlZm9yZSBhbmQgYWZ0ZXIgb3BlbmluZyB0aGUgcmVxdWVzdCBhcyBzb21lIHByb3BlcnRpZXMgcmVxdWlyZSBiZWluZyBzZXQgYXQgZGlmZmVyZW50IHBoYXNlcyBvZiB0aGUgcmVxdWVzdFxuXHRcdFx0XHRcdHNhZmVNaXhpbihjbGllbnQsIHJlcXVlc3QubWl4aW4pO1xuXHRcdFx0XHRcdGNsaWVudC5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcblx0XHRcdFx0XHRzYWZlTWl4aW4oY2xpZW50LCByZXF1ZXN0Lm1peGluKTtcblxuXHRcdFx0XHRcdGhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnM7XG5cdFx0XHRcdFx0Zm9yIChoZWFkZXJOYW1lIGluIGhlYWRlcnMpIHtcblx0XHRcdFx0XHRcdC8qanNoaW50IGZvcmluOmZhbHNlICovXG5cdFx0XHRcdFx0XHRpZiAoaGVhZGVyTmFtZSA9PT0gJ0NvbnRlbnQtVHlwZScgJiYgaGVhZGVyc1toZWFkZXJOYW1lXSA9PT0gJ211bHRpcGFydC9mb3JtLWRhdGEnKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFhNTEh0dHBSZXF1ZXN0IGdlbmVyYXRlcyBpdHMgb3duIENvbnRlbnQtVHlwZSBoZWFkZXIgd2l0aCB0aGVcblx0XHRcdFx0XHRcdFx0Ly8gYXBwcm9wcmlhdGUgbXVsdGlwYXJ0IGJvdW5kYXJ5IHdoZW4gc2VuZGluZyBtdWx0aXBhcnQvZm9ybS1kYXRhLlxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y2xpZW50LnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgaGVhZGVyc1toZWFkZXJOYW1lXSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVxdWVzdC5jYW5jZWxlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdHJlcXVlc3QuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuXHRcdFx0XHRcdFx0cmVxdWVzdC5jYW5jZWxlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRjbGllbnQuYWJvcnQoKTtcblx0XHRcdFx0XHRcdHJlamVjdChyZXNwb25zZSk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGNsaWVudC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoLyogZSAqLykge1xuXHRcdFx0XHRcdFx0aWYgKHJlcXVlc3QuY2FuY2VsZWQpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0XHRpZiAoY2xpZW50LnJlYWR5U3RhdGUgPT09IChYTUxIdHRwUmVxdWVzdC5ET05FIHx8IDQpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlLnN0YXR1cyA9IHtcblx0XHRcdFx0XHRcdFx0XHRjb2RlOiBjbGllbnQuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdHRleHQ6IGNsaWVudC5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMoY2xpZW50LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UuZW50aXR5ID0gY2xpZW50LnJlc3BvbnNlVGV4dDtcblxuXHRcdFx0XHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzLmNvZGUgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gY2hlY2sgc3RhdHVzIGNvZGUgYXMgcmVhZHlzdGF0ZWNoYW5nZSBmaXJlcyBiZWZvcmUgZXJyb3IgZXZlbnRcblx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBnaXZlIHRoZSBlcnJvciBjYWxsYmFjayBhIGNoYW5jZSB0byBmaXJlIGJlZm9yZSByZXNvbHZpbmdcblx0XHRcdFx0XHRcdFx0XHQvLyByZXF1ZXN0cyBmb3IgZmlsZTovLyBVUkxzIGRvIG5vdCBoYXZlIGEgc3RhdHVzIGNvZGVcblx0XHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRcdFx0XHRcdH0sIDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRjbGllbnQub25lcnJvciA9IGZ1bmN0aW9uICgvKiBlICovKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlLmVycm9yID0gJ2xvYWRlcnJvcic7XG5cdFx0XHRcdFx0XHRcdHJlamVjdChyZXNwb25zZSk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0Ly8gSUUgNiB3aWxsIG5vdCBzdXBwb3J0IGVycm9yIGhhbmRsaW5nXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2xpZW50LnNlbmQoZW50aXR5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRcdHJlc3BvbnNlLmVycm9yID0gJ2xvYWRlcnJvcic7XG5cdFx0XHRcdFx0cmVqZWN0KHJlc3BvbnNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9LFxuXHR0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHZvaWQgMFxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgZGVmYXVsdENsaWVudCwgbWl4aW4sIHJlc3BvbnNlUHJvbWlzZSwgY2xpZW50LCB3aGVuO1xuXG5cdFx0ZGVmYXVsdENsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50L2RlZmF1bHQnKTtcblx0XHRtaXhpbiA9IHJlcXVpcmUoJy4vdXRpbC9taXhpbicpO1xuXHRcdHJlc3BvbnNlUHJvbWlzZSA9IHJlcXVpcmUoJy4vdXRpbC9yZXNwb25zZVByb21pc2UnKTtcblx0XHRjbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpO1xuXHRcdHdoZW4gPSByZXF1aXJlKCd3aGVuJyk7XG5cblx0XHQvKipcblx0XHQgKiBJbnRlcmNlcHRvcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBpbnRlcmNlcHQgdGhlIHJlcXVlc3QgYW5kL29yZyByZXNwb25zZVxuXHRcdCAqIG9iamVjdHMuICBUaGV5IG1heSBhdWdtZW50LCBwcnVuZSwgdHJhbnNmb3JtIG9yIHJlcGxhY2UgdGhlXG5cdFx0ICogcmVxdWVzdC9yZXNwb25zZSBhcyBuZWVkZWQuICBDbGllbnRzIG1heSBiZSBjb21wb3NlZCBieSB3cmFwcGluZ1xuXHRcdCAqIHRvZ2V0aGVyIG11bHRpcGxlIGludGVyY2VwdG9ycy5cblx0XHQgKlxuXHRcdCAqIENvbmZpZ3VyZWQgaW50ZXJjZXB0b3JzIGFyZSBmdW5jdGlvbmFsIGluIG5hdHVyZS4gIFdyYXBwaW5nIGEgY2xpZW50IGluXG5cdFx0ICogYW4gaW50ZXJjZXB0b3Igd2lsbCBub3QgYWZmZWN0IHRoZSBjbGllbnQsIG1lcmVseSB0aGUgZGF0YSB0aGF0IGZsb3dzIGluXG5cdFx0ICogYW5kIG91dCBvZiB0aGF0IGNsaWVudC4gIEEgY29tbW9uIGNvbmZpZ3VyYXRpb24gY2FuIGJlIGNyZWF0ZWQgb25jZSBhbmRcblx0XHQgKiBzaGFyZWQ7IHNwZWNpYWxpemF0aW9uIGNhbiBiZSBjcmVhdGVkIGJ5IGZ1cnRoZXIgd3JhcHBpbmcgdGhhdCBjbGllbnRcblx0XHQgKiB3aXRoIGN1c3RvbSBpbnRlcmNlcHRvcnMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0NsaWVudH0gW3RhcmdldF0gY2xpZW50IHRvIHdyYXBcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gY29uZmlndXJhdGlvbiBmb3IgdGhlIGludGVyY2VwdG9yLCBwcm9wZXJ0aWVzIHdpbGwgYmUgc3BlY2lmaWMgdG8gdGhlIGludGVyY2VwdG9yIGltcGxlbWVudGF0aW9uXG5cdFx0ICogQHJldHVybnMge0NsaWVudH0gQSBjbGllbnQgd3JhcHBlZCB3aXRoIHRoZSBpbnRlcmNlcHRvclxuXHRcdCAqXG5cdFx0ICogQGNsYXNzIEludGVyY2VwdG9yXG5cdFx0ICovXG5cblx0XHRmdW5jdGlvbiBkZWZhdWx0SW5pdEhhbmRsZXIoY29uZmlnKSB7XG5cdFx0XHRyZXR1cm4gY29uZmlnO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlZmF1bHRSZXF1ZXN0SGFuZGxlcihyZXF1ZXN0IC8qLCBjb25maWcsIG1ldGEgKi8pIHtcblx0XHRcdHJldHVybiByZXF1ZXN0O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlZmF1bHRSZXNwb25zZUhhbmRsZXIocmVzcG9uc2UgLyosIGNvbmZpZywgbWV0YSAqLykge1xuXHRcdFx0cmV0dXJuIHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJhY2UocHJvbWlzZXNPclZhbHVlcykge1xuXHRcdFx0Ly8gdGhpcyBmdW5jdGlvbiBpcyBkaWZmZXJlbnQgdGhhbiB3aGVuLmFueSBhcyB0aGUgZmlyc3QgdG8gcmVqZWN0IGFsc28gd2luc1xuXHRcdFx0cmV0dXJuIHdoZW4ucHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdHByb21pc2VzT3JWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvbWlzZU9yVmFsdWUpIHtcblx0XHRcdFx0XHR3aGVuKHByb21pc2VPclZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEFsdGVybmF0ZSByZXR1cm4gdHlwZSBmb3IgdGhlIHJlcXVlc3QgaGFuZGxlciB0aGF0IGFsbG93cyBmb3IgbW9yZSBjb21wbGV4IGludGVyYWN0aW9ucy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSBwcm9wZXJ0aWVzLnJlcXVlc3QgdGhlIHRyYWRpdGlvbmFsIHJlcXVlc3QgcmV0dXJuIG9iamVjdFxuXHRcdCAqIEBwYXJhbSB7UHJvbWlzZX0gW3Byb3BlcnRpZXMuYWJvcnRdIHByb21pc2UgdGhhdCByZXNvbHZlcyBpZi93aGVuIHRoZSByZXF1ZXN0IGlzIGFib3J0ZWRcblx0XHQgKiBAcGFyYW0ge0NsaWVudH0gW3Byb3BlcnRpZXMuY2xpZW50XSBvdmVycmlkZSB0aGUgZGVmaW5lZCBjbGllbnQgd2l0aCBhbiBhbHRlcm5hdGUgY2xpZW50XG5cdFx0ICogQHBhcmFtIFtwcm9wZXJ0aWVzLnJlc3BvbnNlXSByZXNwb25zZSBmb3IgdGhlIHJlcXVlc3QsIHNob3J0IGNpcmN1aXQgdGhlIHJlcXVlc3Rcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBDb21wbGV4UmVxdWVzdChwcm9wZXJ0aWVzKSB7XG5cdFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29tcGxleFJlcXVlc3QpKSB7XG5cdFx0XHRcdC8vIGluIGNhc2UgdXNlcnMgZm9yZ2V0IHRoZSAnbmV3JyBkb24ndCBtaXggaW50byB0aGUgaW50ZXJjZXB0b3Jcblx0XHRcdFx0cmV0dXJuIG5ldyBDb21wbGV4UmVxdWVzdChwcm9wZXJ0aWVzKTtcblx0XHRcdH1cblx0XHRcdG1peGluKHRoaXMsIHByb3BlcnRpZXMpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBhIG5ldyBpbnRlcmNlcHRvciBmb3IgdGhlIHByb3ZpZGVkIGhhbmRsZXJzLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJzLmluaXRdIG9uZSB0aW1lIGludGlhbGl6YXRpb24sIG11c3QgcmV0dXJuIHRoZSBjb25maWcgb2JqZWN0XG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJzLnJlcXVlc3RdIHJlcXVlc3QgaGFuZGxlclxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVycy5yZXNwb25zZV0gcmVzcG9uc2UgaGFuZGxlciByZWdhcmRsZXNzIG9mIGVycm9yIHN0YXRlXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJzLnN1Y2Nlc3NdIHJlc3BvbnNlIGhhbmRsZXIgd2hlbiB0aGUgcmVxdWVzdCBpcyBub3QgaW4gZXJyb3Jcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcnMuZXJyb3JdIHJlc3BvbnNlIGhhbmRsZXIgd2hlbiB0aGUgcmVxdWVzdCBpcyBpbiBlcnJvciwgbWF5IGJlIHVzZWQgdG8gJ3VucmVqZWN0JyBhbiBlcnJvciBzdGF0ZVxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVycy5jbGllbnRdIHRoZSBjbGllbnQgdG8gdXNlIGlmIG90aGVyd2lzZSBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBwbGF0Zm9ybSBkZWZhdWx0IGNsaWVudFxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge0ludGVyY2VwdG9yfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGludGVyY2VwdG9yKGhhbmRsZXJzKSB7XG5cblx0XHRcdHZhciBpbml0SGFuZGxlciwgcmVxdWVzdEhhbmRsZXIsIHN1Y2Nlc3NSZXNwb25zZUhhbmRsZXIsIGVycm9yUmVzcG9uc2VIYW5kbGVyO1xuXG5cdFx0XHRoYW5kbGVycyA9IGhhbmRsZXJzIHx8IHt9O1xuXG5cdFx0XHRpbml0SGFuZGxlciAgICAgICAgICAgID0gaGFuZGxlcnMuaW5pdCAgICB8fCBkZWZhdWx0SW5pdEhhbmRsZXI7XG5cdFx0XHRyZXF1ZXN0SGFuZGxlciAgICAgICAgID0gaGFuZGxlcnMucmVxdWVzdCB8fCBkZWZhdWx0UmVxdWVzdEhhbmRsZXI7XG5cdFx0XHRzdWNjZXNzUmVzcG9uc2VIYW5kbGVyID0gaGFuZGxlcnMuc3VjY2VzcyB8fCBoYW5kbGVycy5yZXNwb25zZSB8fCBkZWZhdWx0UmVzcG9uc2VIYW5kbGVyO1xuXHRcdFx0ZXJyb3JSZXNwb25zZUhhbmRsZXIgICA9IGhhbmRsZXJzLmVycm9yICAgfHwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBQcm9wYWdhdGUgdGhlIHJlamVjdGlvbiwgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBoYW5kbGVyXG5cdFx0XHRcdHJldHVybiB3aGVuKChoYW5kbGVycy5yZXNwb25zZSB8fCBkZWZhdWx0UmVzcG9uc2VIYW5kbGVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB3aGVuLnJlamVjdCwgd2hlbi5yZWplY3QpO1xuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGNvbmZpZykge1xuXG5cdFx0XHRcdGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdGNvbmZpZyA9IHRhcmdldDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHRhcmdldCA9IGhhbmRsZXJzLmNsaWVudCB8fCBkZWZhdWx0Q2xpZW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uZmlnID0gaW5pdEhhbmRsZXIoY29uZmlnIHx8IHt9KTtcblxuXHRcdFx0XHRmdW5jdGlvbiBpbnRlcmNlcHRlZENsaWVudChyZXF1ZXN0KSB7XG5cdFx0XHRcdFx0dmFyIGNvbnRleHQsIG1ldGE7XG5cdFx0XHRcdFx0Y29udGV4dCA9IHt9O1xuXHRcdFx0XHRcdG1ldGEgPSB7ICdhcmd1bWVudHMnOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLCBjbGllbnQ6IGludGVyY2VwdGVkQ2xpZW50IH07XG5cdFx0XHRcdFx0cmVxdWVzdCA9IHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJyA/IHsgcGF0aDogcmVxdWVzdCB9IDogcmVxdWVzdCB8fCB7fTtcblx0XHRcdFx0XHRyZXF1ZXN0Lm9yaWdpbmF0b3IgPSByZXF1ZXN0Lm9yaWdpbmF0b3IgfHwgaW50ZXJjZXB0ZWRDbGllbnQ7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlUHJvbWlzZShcblx0XHRcdFx0XHRcdHJlcXVlc3RIYW5kbGVyLmNhbGwoY29udGV4dCwgcmVxdWVzdCwgY29uZmlnLCBtZXRhKSxcblx0XHRcdFx0XHRcdGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cdFx0XHRcdFx0XHRcdHZhciByZXNwb25zZSwgYWJvcnQsIG5leHQ7XG5cdFx0XHRcdFx0XHRcdG5leHQgPSB0YXJnZXQ7XG5cdFx0XHRcdFx0XHRcdGlmIChyZXF1ZXN0IGluc3RhbmNlb2YgQ29tcGxleFJlcXVlc3QpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB1bnBhY2sgcmVxdWVzdFxuXHRcdFx0XHRcdFx0XHRcdGFib3J0ID0gcmVxdWVzdC5hYm9ydDtcblx0XHRcdFx0XHRcdFx0XHRuZXh0ID0gcmVxdWVzdC5jbGllbnQgfHwgbmV4dDtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gbm9ybWFsaXplIHJlcXVlc3QsIG11c3QgYmUgbGFzdFxuXHRcdFx0XHRcdFx0XHRcdHJlcXVlc3QgPSByZXF1ZXN0LnJlcXVlc3Q7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSByZXNwb25zZSB8fCB3aGVuKHJlcXVlc3QsIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHdoZW4oXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0KHJlcXVlc3QpLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBzdWNjZXNzUmVzcG9uc2VIYW5kbGVyLmNhbGwoY29udGV4dCwgcmVzcG9uc2UsIGNvbmZpZywgbWV0YSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBlcnJvclJlc3BvbnNlSGFuZGxlci5jYWxsKGNvbnRleHQsIHJlc3BvbnNlLCBjb25maWcsIG1ldGEpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYWJvcnQgPyByYWNlKFtyZXNwb25zZSwgYWJvcnRdKSA6IHJlc3BvbnNlO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gd2hlbi5yZWplY3QoeyByZXF1ZXN0OiByZXF1ZXN0LCBlcnJvcjogZXJyb3IgfSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBjbGllbnQoaW50ZXJjZXB0ZWRDbGllbnQsIHRhcmdldCk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGludGVyY2VwdG9yLkNvbXBsZXhSZXF1ZXN0ID0gQ29tcGxleFJlcXVlc3Q7XG5cblx0XHRyZXR1cm4gaW50ZXJjZXB0b3I7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMyB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIGludGVyY2VwdG9yLCBtaXhpblV0aWwsIGRlZmF1bHRlcjtcblxuXHRcdGludGVyY2VwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJjZXB0b3InKTtcblx0XHRtaXhpblV0aWwgPSByZXF1aXJlKCcuLi91dGlsL21peGluJyk7XG5cblx0XHRkZWZhdWx0ZXIgPSAoZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRmdW5jdGlvbiBtaXhpbihwcm9wLCB0YXJnZXQsIGRlZmF1bHRzKSB7XG5cdFx0XHRcdGlmIChwcm9wIGluIHRhcmdldCB8fCBwcm9wIGluIGRlZmF1bHRzKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gbWl4aW5VdGlsKHt9LCBkZWZhdWx0c1twcm9wXSwgdGFyZ2V0W3Byb3BdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjb3B5KHByb3AsIHRhcmdldCwgZGVmYXVsdHMpIHtcblx0XHRcdFx0aWYgKHByb3AgaW4gZGVmYXVsdHMgJiYgIShwcm9wIGluIHRhcmdldCkpIHtcblx0XHRcdFx0XHR0YXJnZXRbcHJvcF0gPSBkZWZhdWx0c1twcm9wXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWFwcGluZ3MgPSB7XG5cdFx0XHRcdG1ldGhvZDogY29weSxcblx0XHRcdFx0cGF0aDogY29weSxcblx0XHRcdFx0cGFyYW1zOiBtaXhpbixcblx0XHRcdFx0aGVhZGVyczogbWl4aW4sXG5cdFx0XHRcdGVudGl0eTogY29weSxcblx0XHRcdFx0bWl4aW46IG1peGluXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgZGVmYXVsdHMpIHtcblx0XHRcdFx0Zm9yICh2YXIgcHJvcCBpbiBtYXBwaW5ncykge1xuXHRcdFx0XHRcdC8qanNoaW50IGZvcmluOiBmYWxzZSAqL1xuXHRcdFx0XHRcdG1hcHBpbmdzW3Byb3BdKHByb3AsIHRhcmdldCwgZGVmYXVsdHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0XHR9O1xuXG5cdFx0fSgpKTtcblxuXHRcdC8qKlxuXHRcdCAqIFByb3ZpZGUgZGVmYXVsdCB2YWx1ZXMgZm9yIGEgcmVxdWVzdC4gVGhlc2UgdmFsdWVzIHdpbGwgYmUgYXBwbGllZCB0byB0aGVcblx0XHQgKiByZXF1ZXN0IGlmIHRoZSByZXF1ZXN0IG9iamVjdCBkb2VzIG5vdCBhbHJlYWR5IGNvbnRhaW4gYW4gZXhwbGljaXQgdmFsdWUuXG5cdFx0ICpcblx0XHQgKiBGb3IgJ3BhcmFtcycsICdoZWFkZXJzJywgYW5kICdtaXhpbicsIGluZGl2aWR1YWwgdmFsdWVzIGFyZSBtaXhlZCBpbiB3aXRoIHRoZVxuXHRcdCAqIHJlcXVlc3QncyB2YWx1ZXMuIFRoZSByZXN1bHQgaXMgYSBuZXcgb2JqZWN0IHJlcHJlc2VudGlpbmcgdGhlIGNvbWJpbmVkXG5cdFx0ICogcmVxdWVzdCBhbmQgY29uZmlnIHZhbHVlcy4gTmVpdGhlciBpbnB1dCBvYmplY3QgaXMgbXV0YXRlZC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Q2xpZW50fSBbY2xpZW50XSBjbGllbnQgdG8gd3JhcFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1ldGhvZF0gdGhlIGRlZmF1bHQgbWV0aG9kXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcucGF0aF0gdGhlIGRlZmF1bHQgcGF0aFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnBhcmFtc10gdGhlIGRlZmF1bHQgcGFyYW1zLCBtaXhlZCB3aXRoIHRoZSByZXF1ZXN0J3MgZXhpc3RpbmcgcGFyYW1zXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuaGVhZGVyc10gdGhlIGRlZmF1bHQgaGVhZGVycywgbWl4ZWQgd2l0aCB0aGUgcmVxdWVzdCdzIGV4aXN0aW5nIGhlYWRlcnNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5taXhpbl0gdGhlIGRlZmF1bHQgXCJtaXhpbnNcIiAoaHR0cC9odHRwcyBvcHRpb25zKSwgbWl4ZWQgd2l0aCB0aGUgcmVxdWVzdCdzIGV4aXN0aW5nIFwibWl4aW5zXCJcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtDbGllbnR9XG5cdFx0ICovXG5cdFx0cmV0dXJuIGludGVyY2VwdG9yKHtcblx0XHRcdHJlcXVlc3Q6IGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QocmVxdWVzdCwgY29uZmlnKSB7XG5cdFx0XHRcdHJldHVybiBkZWZhdWx0ZXIocmVxdWVzdCwgY29uZmlnKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHRcdHZhciBpbnRlcmNlcHRvciwgd2hlbjtcblxuXHRcdGludGVyY2VwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJjZXB0b3InKTtcblx0XHR3aGVuID0gcmVxdWlyZSgnd2hlbicpO1xuXG5cdFx0LyoqXG5cdFx0ICogUmVqZWN0cyB0aGUgcmVzcG9uc2UgcHJvbWlzZSBiYXNlZCBvbiB0aGUgc3RhdHVzIGNvZGUuXG5cdFx0ICpcblx0XHQgKiBDb2RlcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIHZhbHVlIGFyZSByZWplY3RlZC4gIERlZmF1bHRcblx0XHQgKiB2YWx1ZSA0MDAuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0NsaWVudH0gW2NsaWVudF0gY2xpZW50IHRvIHdyYXBcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5jb2RlPTQwMF0gY29kZSB0byBpbmRpY2F0ZSBhIHJlamVjdGlvblxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge0NsaWVudH1cblx0XHQgKi9cblx0XHRyZXR1cm4gaW50ZXJjZXB0b3Ioe1xuXHRcdFx0aW5pdDogZnVuY3Rpb24gKGNvbmZpZykge1xuXHRcdFx0XHRjb25maWcuY29kZSA9IGNvbmZpZy5jb2RlIHx8IDQwMDtcblx0XHRcdFx0cmV0dXJuIGNvbmZpZztcblx0XHRcdH0sXG5cdFx0XHRyZXNwb25zZTogZnVuY3Rpb24gKHJlc3BvbnNlLCBjb25maWcpIHtcblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyAmJiByZXNwb25zZS5zdGF0dXMuY29kZSA+PSBjb25maWcuY29kZSkge1xuXHRcdFx0XHRcdHJldHVybiB3aGVuLnJlamVjdChyZXNwb25zZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTItMjAxNCB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIGludGVyY2VwdG9yLCBtaW1lLCByZWdpc3RyeSwgbm9vcENvbnZlcnRlciwgd2hlbjtcblxuXHRcdGludGVyY2VwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJjZXB0b3InKTtcblx0XHRtaW1lID0gcmVxdWlyZSgnLi4vbWltZScpO1xuXHRcdHJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi4vbWltZS9yZWdpc3RyeScpO1xuXHRcdHdoZW4gPSByZXF1aXJlKCd3aGVuJyk7XG5cblx0XHRub29wQ29udmVydGVyID0ge1xuXHRcdFx0cmVhZDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqOyB9LFxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iajsgfVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBNSU1FIHR5cGUgc3VwcG9ydCBmb3IgcmVxdWVzdCBhbmQgcmVzcG9uc2UgZW50aXRpZXMuICBFbnRpdGllcyBhcmVcblx0XHQgKiAoZGUpc2VyaWFsaXplZCB1c2luZyB0aGUgY29udmVydGVyIGZvciB0aGUgTUlNRSB0eXBlLlxuXHRcdCAqXG5cdFx0ICogUmVxdWVzdCBlbnRpdGllcyBhcmUgY29udmVydGVkIHVzaW5nIHRoZSBkZXNpcmVkIGNvbnZlcnRlciBhbmQgdGhlXG5cdFx0ICogJ0FjY2VwdCcgcmVxdWVzdCBoZWFkZXIgcHJlZmVycyB0aGlzIE1JTUUuXG5cdFx0ICpcblx0XHQgKiBSZXNwb25zZSBlbnRpdGllcyBhcmUgY29udmVydGVkIGJhc2VkIG9uIHRoZSBDb250ZW50LVR5cGUgcmVzcG9uc2UgaGVhZGVyLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtDbGllbnR9IFtjbGllbnRdIGNsaWVudCB0byB3cmFwXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubWltZT0ndGV4dC9wbGFpbiddIE1JTUUgdHlwZSB0byBlbmNvZGUgdGhlIHJlcXVlc3Rcblx0XHQgKiAgIGVudGl0eVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmFjY2VwdF0gQWNjZXB0IGhlYWRlciBmb3IgdGhlIHJlcXVlc3Rcblx0XHQgKiBAcGFyYW0ge0NsaWVudH0gW2NvbmZpZy5jbGllbnQ9PHJlcXVlc3Qub3JpZ2luYXRvcj5dIGNsaWVudCBwYXNzZWQgdG8gdGhlXG5cdFx0ICogICBjb252ZXJ0ZXIsIGRlZmF1bHRzIHRvIHRoZSBjbGllbnQgb3JpZ2luYXRpbmcgdGhlIHJlcXVlc3Rcblx0XHQgKiBAcGFyYW0ge1JlZ2lzdHJ5fSBbY29uZmlnLnJlZ2lzdHJ5XSBNSU1FIHJlZ2lzdHJ5LCBkZWZhdWx0cyB0byB0aGUgcm9vdFxuXHRcdCAqICAgcmVnaXN0cnlcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb25maWcucGVybWlzc2l2ZV0gQWxsb3cgYW4gdW5rb3duIHJlcXVlc3QgTUlNRSB0eXBlXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7Q2xpZW50fVxuXHRcdCAqL1xuXHRcdHJldHVybiBpbnRlcmNlcHRvcih7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdFx0XHRcdGNvbmZpZy5yZWdpc3RyeSA9IGNvbmZpZy5yZWdpc3RyeSB8fCByZWdpc3RyeTtcblx0XHRcdFx0cmV0dXJuIGNvbmZpZztcblx0XHRcdH0sXG5cdFx0XHRyZXF1ZXN0OiBmdW5jdGlvbiAocmVxdWVzdCwgY29uZmlnKSB7XG5cdFx0XHRcdHZhciB0eXBlLCBoZWFkZXJzO1xuXG5cdFx0XHRcdGhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnMgfHwgKHJlcXVlc3QuaGVhZGVycyA9IHt9KTtcblx0XHRcdFx0dHlwZSA9IG1pbWUucGFyc2UoaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSBoZWFkZXJzWydDb250ZW50LVR5cGUnXSB8fCBjb25maWcubWltZSB8fCAndGV4dC9wbGFpbicpO1xuXHRcdFx0XHRoZWFkZXJzLkFjY2VwdCA9IGhlYWRlcnMuQWNjZXB0IHx8IGNvbmZpZy5hY2NlcHQgfHwgdHlwZS5yYXcgKyAnLCBhcHBsaWNhdGlvbi9qc29uO3E9MC44LCB0ZXh0L3BsYWluO3E9MC41LCAqLyo7cT0wLjInO1xuXG5cdFx0XHRcdGlmICghKCdlbnRpdHknIGluIHJlcXVlc3QpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlcXVlc3Q7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gY29uZmlnLnJlZ2lzdHJ5Lmxvb2t1cCh0eXBlKS5vdGhlcndpc2UoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdC8vIGZhaWxlZCB0byByZXNvbHZlIGNvbnZlcnRlclxuXHRcdFx0XHRcdGlmIChjb25maWcucGVybWlzc2l2ZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5vb3BDb252ZXJ0ZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRocm93ICdtaW1lLXVua25vd24nO1xuXHRcdFx0XHR9KS50aGVuKGZ1bmN0aW9uIChjb252ZXJ0ZXIpIHtcblx0XHRcdFx0XHR2YXIgY2xpZW50ID0gY29uZmlnLmNsaWVudCB8fCByZXF1ZXN0Lm9yaWdpbmF0b3I7XG5cblx0XHRcdFx0XHRyZXR1cm4gd2hlbi5hdHRlbXB0KGNvbnZlcnRlci53cml0ZSwgcmVxdWVzdC5lbnRpdHksIHsgY2xpZW50OiBjbGllbnQsIHJlcXVlc3Q6IHJlcXVlc3QsIG1pbWU6IHR5cGUsIHJlZ2lzdHJ5OiBjb25maWcucmVnaXN0cnkgfSlcblx0XHRcdFx0XHRcdC5vdGhlcndpc2UoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93ICdtaW1lLXNlcmlhbGl6YXRpb24nO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC50aGVuKGZ1bmN0aW9uKGVudGl0eSkge1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0LmVudGl0eSA9IGVudGl0eTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlcXVlc3Q7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0cmVzcG9uc2U6IGZ1bmN0aW9uIChyZXNwb25zZSwgY29uZmlnKSB7XG5cdFx0XHRcdGlmICghKHJlc3BvbnNlLmhlYWRlcnMgJiYgcmVzcG9uc2UuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gJiYgcmVzcG9uc2UuZW50aXR5KSkge1xuXHRcdFx0XHRcdHJldHVybiByZXNwb25zZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0eXBlID0gbWltZS5wYXJzZShyZXNwb25zZS5oZWFkZXJzWydDb250ZW50LVR5cGUnXSk7XG5cblx0XHRcdFx0cmV0dXJuIGNvbmZpZy5yZWdpc3RyeS5sb29rdXAodHlwZSkub3RoZXJ3aXNlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5vb3BDb252ZXJ0ZXI7IH0pLnRoZW4oZnVuY3Rpb24gKGNvbnZlcnRlcikge1xuXHRcdFx0XHRcdHZhciBjbGllbnQgPSBjb25maWcuY2xpZW50IHx8IHJlc3BvbnNlLnJlcXVlc3QgJiYgcmVzcG9uc2UucmVxdWVzdC5vcmlnaW5hdG9yO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHdoZW4uYXR0ZW1wdChjb252ZXJ0ZXIucmVhZCwgcmVzcG9uc2UuZW50aXR5LCB7IGNsaWVudDogY2xpZW50LCByZXNwb25zZTogcmVzcG9uc2UsIG1pbWU6IHR5cGUsIHJlZ2lzdHJ5OiBjb25maWcucmVnaXN0cnkgfSlcblx0XHRcdFx0XHRcdC5vdGhlcndpc2UoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UuZXJyb3IgPSAnbWltZS1kZXNlcmlhbGl6YXRpb24nO1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZS5jYXVzZSA9IGU7XG5cdFx0XHRcdFx0XHRcdHRocm93IHJlc3BvbnNlO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC50aGVuKGZ1bmN0aW9uIChlbnRpdHkpIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UuZW50aXR5ID0gZW50aXR5O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgaW50ZXJjZXB0b3IsIFVybEJ1aWxkZXI7XG5cblx0XHRpbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4uL2ludGVyY2VwdG9yJyk7XG5cdFx0VXJsQnVpbGRlciA9IHJlcXVpcmUoJy4uL1VybEJ1aWxkZXInKTtcblxuXHRcdGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBwcmVmaXgpIHtcblx0XHRcdHJldHVybiBzdHIuaW5kZXhPZihwcmVmaXgpID09PSAwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc3VmZml4KSB7XG5cdFx0XHRyZXR1cm4gc3RyLmxhc3RJbmRleE9mKHN1ZmZpeCkgKyBzdWZmaXgubGVuZ3RoID09PSBzdHIubGVuZ3RoO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFByZWZpeGVzIHRoZSByZXF1ZXN0IHBhdGggd2l0aCBhIGNvbW1vbiB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Q2xpZW50fSBbY2xpZW50XSBjbGllbnQgdG8gd3JhcFxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLnByZWZpeF0gcGF0aCBwcmVmaXhcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtDbGllbnR9XG5cdFx0ICovXG5cdFx0cmV0dXJuIGludGVyY2VwdG9yKHtcblx0XHRcdHJlcXVlc3Q6IGZ1bmN0aW9uIChyZXF1ZXN0LCBjb25maWcpIHtcblx0XHRcdFx0dmFyIHBhdGg7XG5cblx0XHRcdFx0aWYgKGNvbmZpZy5wcmVmaXggJiYgIShuZXcgVXJsQnVpbGRlcihyZXF1ZXN0LnBhdGgpLmlzRnVsbHlRdWFsaWZpZWQoKSkpIHtcblx0XHRcdFx0XHRwYXRoID0gY29uZmlnLnByZWZpeDtcblx0XHRcdFx0XHRpZiAocmVxdWVzdC5wYXRoKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWVuZHNXaXRoKHBhdGgsICcvJykgJiYgIXN0YXJ0c1dpdGgocmVxdWVzdC5wYXRoLCAnLycpKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGFkZCBtaXNzaW5nICcvJyBiZXR3ZWVuIHBhdGggc2VjdGlvbnNcblx0XHRcdFx0XHRcdFx0cGF0aCArPSAnLyc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYXRoICs9IHJlcXVlc3QucGF0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVxdWVzdC5wYXRoID0gcGF0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByZXF1ZXN0O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTUgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHRcdHZhciBpbnRlcmNlcHRvciwgdXJpVGVtcGxhdGUsIG1peGluO1xuXG5cdFx0aW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcmNlcHRvcicpO1xuXHRcdHVyaVRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdXRpbC91cmlUZW1wbGF0ZScpO1xuXHRcdG1peGluID0gcmVxdWlyZSgnLi4vdXRpbC9taXhpbicpO1xuXG5cdFx0LyoqXG5cdFx0ICogQXBwbGllcyByZXF1ZXN0IHBhcmFtcyB0byB0aGUgcGF0aCBhcyBhIFVSSSBUZW1wbGF0ZVxuXHRcdCAqXG5cdFx0ICogUGFyYW1zIGFyZSByZW1vdmVkIGZyb20gdGhlIHJlcXVlc3Qgb2JqZWN0LCBhcyB0aGV5IGhhdmUgYmVlbiBjb25zdW1lZC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Q2xpZW50fSBbY2xpZW50XSBjbGllbnQgdG8gd3JhcFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnBhcmFtc10gZGVmYXVsdCBwYXJhbSB2YWx1ZXNcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy50ZW1wbGF0ZV0gZGVmYXVsdCB0ZW1wbGF0ZVxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge0NsaWVudH1cblx0XHQgKi9cblx0XHRyZXR1cm4gaW50ZXJjZXB0b3Ioe1xuXHRcdFx0aW5pdDogZnVuY3Rpb24gKGNvbmZpZykge1xuXHRcdFx0XHRjb25maWcucGFyYW1zID0gY29uZmlnLnBhcmFtcyB8fCB7fTtcblx0XHRcdFx0Y29uZmlnLnRlbXBsYXRlID0gY29uZmlnLnRlbXBsYXRlIHx8ICcnO1xuXHRcdFx0XHRyZXR1cm4gY29uZmlnO1xuXHRcdFx0fSxcblx0XHRcdHJlcXVlc3Q6IGZ1bmN0aW9uIChyZXF1ZXN0LCBjb25maWcpIHtcblx0XHRcdFx0dmFyIHRlbXBsYXRlLCBwYXJhbXM7XG5cblx0XHRcdFx0dGVtcGxhdGUgPSByZXF1ZXN0LnBhdGggfHwgY29uZmlnLnRlbXBsYXRlO1xuXHRcdFx0XHRwYXJhbXMgPSBtaXhpbih7fSwgcmVxdWVzdC5wYXJhbXMsIGNvbmZpZy5wYXJhbXMpO1xuXG5cdFx0XHRcdHJlcXVlc3QucGF0aCA9IHVyaVRlbXBsYXRlLmV4cGFuZCh0ZW1wbGF0ZSwgcGFyYW1zKTtcblx0XHRcdFx0ZGVsZXRlIHJlcXVlc3QucGFyYW1zO1xuXG5cdFx0XHRcdHJldHVybiByZXF1ZXN0O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuKiBDb3B5cmlnaHQgMjAxNCB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbipcbiogQGF1dGhvciBTY290dCBBbmRyZXdzXG4qL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHVuZGVmO1xuXG5cdGRlZmluZShmdW5jdGlvbiAoLyogcmVxdWlyZSAqLykge1xuXG5cdFx0LyoqXG5cdFx0ICogUGFyc2UgYSBNSU1FIHR5cGUgaW50byBpdCdzIGNvbnN0aXR1ZW50IHBhcnRzXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbWltZSBNSU1FIHR5cGUgdG8gcGFyc2Vcblx0XHQgKiBAcmV0dXJuIHt7XG5cdFx0ICogICB7c3RyaW5nfSByYXcgdGhlIG9yaWdpbmFsIE1JTUUgdHlwZVxuXHRcdCAqICAge3N0cmluZ30gdHlwZSB0aGUgdHlwZSBhbmQgc3VidHlwZVxuXHRcdCAqICAge3N0cmluZ30gW3N1ZmZpeF0gbWltZSBzdWZmaXgsIGluY2x1ZGluZyB0aGUgcGx1cywgaWYgYW55XG5cdFx0ICogICB7T2JqZWN0fSBwYXJhbXMga2V5L3ZhbHVlIHBhaXIgb2YgYXR0cmlidXRlc1xuXHRcdCAqIH19XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcGFyc2UobWltZSkge1xuXHRcdFx0dmFyIHBhcmFtcywgdHlwZTtcblxuXHRcdFx0cGFyYW1zID0gbWltZS5zcGxpdCgnOycpO1xuXHRcdFx0dHlwZSA9IHBhcmFtc1swXS50cmltKCkuc3BsaXQoJysnKTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cmF3OiBtaW1lLFxuXHRcdFx0XHR0eXBlOiB0eXBlWzBdLFxuXHRcdFx0XHRzdWZmaXg6IHR5cGVbMV0gPyAnKycgKyB0eXBlWzFdIDogJycsXG5cdFx0XHRcdHBhcmFtczogcGFyYW1zLnNsaWNlKDEpLnJlZHVjZShmdW5jdGlvbiAocGFyYW1zLCBwYWlyKSB7XG5cdFx0XHRcdFx0cGFpciA9IHBhaXIuc3BsaXQoJz0nKTtcblx0XHRcdFx0XHRwYXJhbXNbcGFpclswXS50cmltKCldID0gcGFpclsxXSA/IHBhaXJbMV0udHJpbSgpIDogdW5kZWY7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmFtcztcblx0XHRcdFx0fSwge30pXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRwYXJzZTogcGFyc2Vcblx0XHR9O1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTItMjAxNCB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIG1pbWUsIHdoZW4sIHJlZ2lzdHJ5O1xuXG5cdFx0bWltZSA9IHJlcXVpcmUoJy4uL21pbWUnKTtcblx0XHR3aGVuID0gcmVxdWlyZSgnd2hlbicpO1xuXG5cdFx0ZnVuY3Rpb24gUmVnaXN0cnkobWltZXMpIHtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBMb29rdXAgdGhlIGNvbnZlcnRlciBmb3IgYSBNSU1FIHR5cGVcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSB0aGUgTUlNRSB0eXBlXG5cdFx0XHQgKiBAcmV0dXJuIGEgcHJvbWlzZSBmb3IgdGhlIGNvbnZlcnRlclxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cCh0eXBlKSB7XG5cdFx0XHRcdHZhciBwYXJzZWQ7XG5cblx0XHRcdFx0cGFyc2VkID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gbWltZS5wYXJzZSh0eXBlKSA6IHR5cGU7XG5cblx0XHRcdFx0aWYgKG1pbWVzW3BhcnNlZC5yYXddKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1pbWVzW3BhcnNlZC5yYXddO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtaW1lc1twYXJzZWQudHlwZSArIHBhcnNlZC5zdWZmaXhdKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1pbWVzW3BhcnNlZC50eXBlICsgcGFyc2VkLnN1ZmZpeF07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG1pbWVzW3BhcnNlZC50eXBlXSkge1xuXHRcdFx0XHRcdHJldHVybiBtaW1lc1twYXJzZWQudHlwZV07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG1pbWVzW3BhcnNlZC5zdWZmaXhdKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1pbWVzW3BhcnNlZC5zdWZmaXhdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHdoZW4ucmVqZWN0KG5ldyBFcnJvcignVW5hYmxlIHRvIGxvY2F0ZSBjb252ZXJ0ZXIgZm9yIG1pbWUgXCInICsgcGFyc2VkLnJhdyArICdcIicpKTtcblx0XHRcdH07XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ3JlYXRlIGEgbGF0ZSBkaXNwYXRjaGVkIHByb3h5IHRvIHRoZSB0YXJnZXQgY29udmVydGVyLlxuXHRcdFx0ICpcblx0XHRcdCAqIENvbW1vbiB3aGVuIGEgY29udmVydGVyIGlzIHJlZ2lzdGVyZWQgdW5kZXIgbXVsdGlwbGUgbmFtZXMgYW5kXG5cdFx0XHQgKiBzaG91bGQgYmUga2VwdCBpbiBzeW5jIGlmIHVwZGF0ZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgbWltZSBjb252ZXJ0ZXIgdG8gZGlzcGF0Y2ggdG9cblx0XHRcdCAqIEByZXR1cm5zIGNvbnZlcnRlciB3aG9zZSByZWFkL3dyaXRlIG1ldGhvZHMgdGFyZ2V0IHRoZSBkZXNpcmVkIG1pbWUgY29udmVydGVyXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMuZGVsZWdhdGUgPSBmdW5jdGlvbiBkZWxlZ2F0ZSh0eXBlKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5sb29rdXAodHlwZSkudGhlbihmdW5jdGlvbiAoY29udmVydGVyKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBjb252ZXJ0ZXIucmVhZC5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHRcdFx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0XHRcdFx0fS5iaW5kKHRoaXMpLFxuXHRcdFx0XHRcdHdyaXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmxvb2t1cCh0eXBlKS50aGVuKGZ1bmN0aW9uIChjb252ZXJ0ZXIpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbnZlcnRlci53cml0ZS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHRcdFx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0XHRcdFx0fS5iaW5kKHRoaXMpXG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJlZ2lzdGVyIGEgY3VzdG9tIGNvbnZlcnRlciBmb3IgYSBNSU1FIHR5cGVcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSB0aGUgTUlNRSB0eXBlXG5cdFx0XHQgKiBAcGFyYW0gY29udmVydGVyIHRoZSBjb252ZXJ0ZXIgZm9yIHRoZSBNSU1FIHR5cGVcblx0XHRcdCAqIEByZXR1cm4gYSBwcm9taXNlIGZvciB0aGUgY29udmVydGVyXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcih0eXBlLCBjb252ZXJ0ZXIpIHtcblx0XHRcdFx0bWltZXNbdHlwZV0gPSB3aGVuKGNvbnZlcnRlcik7XG5cdFx0XHRcdHJldHVybiBtaW1lc1t0eXBlXTtcblx0XHRcdH07XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ3JlYXRlIGEgY2hpbGQgcmVnaXN0cnkgd2hvZXMgcmVnaXN0ZXJlZCBjb252ZXJ0ZXJzIHJlbWFpbiBsb2NhbCwgd2hpbGVcblx0XHRcdCAqIGFibGUgdG8gbG9va3VwIGNvbnZlcnRlcnMgZnJvbSBpdHMgcGFyZW50LlxuXHRcdFx0ICpcblx0XHRcdCAqIEByZXR1cm5zIGNoaWxkIE1JTUUgcmVnaXN0cnlcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy5jaGlsZCA9IGZ1bmN0aW9uIGNoaWxkKCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFJlZ2lzdHJ5KE9iamVjdC5jcmVhdGUobWltZXMpKTtcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRyZWdpc3RyeSA9IG5ldyBSZWdpc3RyeSh7fSk7XG5cblx0XHQvLyBpbmNsdWRlIHByb3ZpZGVkIHNlcmlhbGl6ZXJzXG5cdFx0cmVnaXN0cnkucmVnaXN0ZXIoJ2FwcGxpY2F0aW9uL2hhbCcsIHJlcXVpcmUoJy4vdHlwZS9hcHBsaWNhdGlvbi9oYWwnKSk7XG5cdFx0cmVnaXN0cnkucmVnaXN0ZXIoJ2FwcGxpY2F0aW9uL2pzb24nLCByZXF1aXJlKCcuL3R5cGUvYXBwbGljYXRpb24vanNvbicpKTtcblx0XHRyZWdpc3RyeS5yZWdpc3RlcignYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJywgcmVxdWlyZSgnLi90eXBlL2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpKTtcblx0XHRyZWdpc3RyeS5yZWdpc3RlcignbXVsdGlwYXJ0L2Zvcm0tZGF0YScsIHJlcXVpcmUoJy4vdHlwZS9tdWx0aXBhcnQvZm9ybS1kYXRhJykpO1xuXHRcdHJlZ2lzdHJ5LnJlZ2lzdGVyKCd0ZXh0L3BsYWluJywgcmVxdWlyZSgnLi90eXBlL3RleHQvcGxhaW4nKSk7XG5cblx0XHRyZWdpc3RyeS5yZWdpc3RlcignK2pzb24nLCByZWdpc3RyeS5kZWxlZ2F0ZSgnYXBwbGljYXRpb24vanNvbicpKTtcblxuXHRcdHJldHVybiByZWdpc3RyeTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHRcdHZhciBwYXRoUHJlZml4LCB0ZW1wbGF0ZSwgZmluZCwgbGF6eVByb21pc2UsIHJlc3BvbnNlUHJvbWlzZSwgd2hlbjtcblxuXHRcdHBhdGhQcmVmaXggPSByZXF1aXJlKCcuLi8uLi8uLi9pbnRlcmNlcHRvci9wYXRoUHJlZml4Jyk7XG5cdFx0dGVtcGxhdGUgPSByZXF1aXJlKCcuLi8uLi8uLi9pbnRlcmNlcHRvci90ZW1wbGF0ZScpO1xuXHRcdGZpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL2ZpbmQnKTtcblx0XHRsYXp5UHJvbWlzZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvbGF6eVByb21pc2UnKTtcblx0XHRyZXNwb25zZVByb21pc2UgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL3Jlc3BvbnNlUHJvbWlzZScpO1xuXHRcdHdoZW4gPSByZXF1aXJlKCd3aGVuJyk7XG5cblx0XHRmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG5cdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0d3JpdGVhYmxlOiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBIeXBlcnRleHQgQXBwbGljYXRpb24gTGFuZ3VhZ2Ugc2VyaWFsaXplclxuXHRcdCAqXG5cdFx0ICogSW1wbGVtZW50ZWQgdG8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWtlbGx5LWpzb24taGFsLTA2XG5cdFx0ICpcblx0XHQgKiBBcyB0aGUgc3BlYyBpcyBzdGlsbCBhIGRyYWZ0LCB0aGlzIGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXBkYXRlZCBhcyB0aGVcblx0XHQgKiBzcGVjIGV2b2x2ZXNcblx0XHQgKlxuXHRcdCAqIE9iamVjdHMgYXJlIHJlYWQgYXMgSEFMIGluZGV4aW5nIGxpbmtzIGFuZCBlbWJlZGRlZCBvYmplY3RzIG9uIHRvIHRoZVxuXHRcdCAqIHJlc291cmNlLiBPYmplY3RzIGFyZSB3cml0dGVuIGFzIHBsYWluIEpTT04uXG5cdFx0ICpcblx0XHQgKiBFbWJlZGRlZCByZWxhdGlvbnNoaXBzIGFyZSBpbmRleGVkIG9udG8gdGhlIHJlc291cmNlIGJ5IHRoZSByZWxhdGlvbnNoaXBcblx0XHQgKiBhcyBhIHByb21pc2UgZm9yIHRoZSByZWxhdGVkIHJlc291cmNlLlxuXHRcdCAqXG5cdFx0ICogTGlua3MgYXJlIGluZGV4ZWQgb250byB0aGUgcmVzb3VyY2UgYXMgYSBsYXp5IHByb21pc2UgdGhhdCB3aWxsIEdFVCB0aGVcblx0XHQgKiByZXNvdXJjZSB3aGVuIGEgaGFuZGxlciBpcyBmaXJzdCByZWdpc3RlcmVkIG9uIHRoZSBwcm9taXNlLlxuXHRcdCAqXG5cdFx0ICogQSBgcmVxdWVzdEZvcmAgbWV0aG9kIGlzIGFkZGVkIHRvIHRoZSBlbnRpdHkgdG8gbWFrZSBhIHJlcXVlc3QgZm9yIHRoZVxuXHRcdCAqIHJlbGF0aW9uc2hpcC5cblx0XHQgKlxuXHRcdCAqIEEgYGNsaWVudEZvcmAgbWV0aG9kIGlzIGFkZGVkIHRvIHRoZSBlbnRpdHkgdG8gZ2V0IGEgZnVsbCBDbGllbnQgZm9yIGFcblx0XHQgKiByZWxhdGlvbnNoaXAuXG5cdFx0ICpcblx0XHQgKiBUaGUgYF9saW5rc2AgYW5kIGBfZW1iZWRkZWRgIHByb3BlcnRpZXMgb24gdGhlIHJlc291cmNlIGFyZSBtYWRlXG5cdFx0ICogbm9uLWVudW1lcmFibGUuXG5cdFx0ICovXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0cmVhZDogZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuXHRcdFx0XHR2YXIgY2xpZW50LCBjb25zb2xlO1xuXG5cdFx0XHRcdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcdFx0XHRjbGllbnQgPSBvcHRzLmNsaWVudDtcblx0XHRcdFx0Y29uc29sZSA9IG9wdHMuY29uc29sZSB8fCBjb25zb2xlO1xuXG5cdFx0XHRcdGZ1bmN0aW9uIGRlcHJlY2F0aW9uV2FybmluZyhyZWxhdGlvbnNoaXAsIGRlcHJlY2F0aW9uKSB7XG5cdFx0XHRcdFx0aWYgKGRlcHJlY2F0aW9uICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuIHx8IGNvbnNvbGUubG9nKSB7XG5cdFx0XHRcdFx0XHQoY29uc29sZS53YXJuIHx8IGNvbnNvbGUubG9nKS5jYWxsKGNvbnNvbGUsICdSZWxhdGlvbnNoaXAgXFwnJyArIHJlbGF0aW9uc2hpcCArICdcXCcgaXMgZGVwcmVjYXRlZCwgc2VlICcgKyBkZXByZWNhdGlvbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG9wdHMucmVnaXN0cnkubG9va3VwKG9wdHMubWltZS5zdWZmaXgpLnRoZW4oZnVuY3Rpb24gKGNvbnZlcnRlcikge1xuXHRcdFx0XHRcdHJldHVybiB3aGVuKGNvbnZlcnRlci5yZWFkKHN0ciwgb3B0cykpLnRoZW4oZnVuY3Rpb24gKHJvb3QpIHtcblxuXHRcdFx0XHRcdFx0ZmluZC5maW5kUHJvcGVydGllcyhyb290LCAnX2VtYmVkZGVkJywgZnVuY3Rpb24gKGVtYmVkZGVkLCByZXNvdXJjZSwgbmFtZSkge1xuXHRcdFx0XHRcdFx0XHRPYmplY3Qua2V5cyhlbWJlZGRlZCkuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpb25zaGlwKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHJlbGF0aW9uc2hpcCBpbiByZXNvdXJjZSkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRcdFx0XHR2YXIgcmVsYXRlZCA9IHJlc3BvbnNlUHJvbWlzZSh7XG5cdFx0XHRcdFx0XHRcdFx0XHRlbnRpdHk6IGVtYmVkZGVkW3JlbGF0aW9uc2hpcF1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShyZXNvdXJjZSwgcmVsYXRpb25zaGlwLCByZWxhdGVkKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc291cmNlLCBuYW1lLCBlbWJlZGRlZCk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGZpbmQuZmluZFByb3BlcnRpZXMocm9vdCwgJ19saW5rcycsIGZ1bmN0aW9uIChsaW5rcywgcmVzb3VyY2UsIG5hbWUpIHtcblx0XHRcdFx0XHRcdFx0T2JqZWN0LmtleXMobGlua3MpLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aW9uc2hpcCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBsaW5rID0gbGlua3NbcmVsYXRpb25zaGlwXTtcblx0XHRcdFx0XHRcdFx0XHRpZiAocmVsYXRpb25zaGlwIGluIHJlc291cmNlKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc291cmNlLCByZWxhdGlvbnNoaXAsIHJlc3BvbnNlUHJvbWlzZS5tYWtlKGxhenlQcm9taXNlKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChsaW5rLmRlcHJlY2F0aW9uKSB7IGRlcHJlY2F0aW9uV2FybmluZyhyZWxhdGlvbnNoaXAsIGxpbmsuZGVwcmVjYXRpb24pOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAobGluay50ZW1wbGF0ZWQgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRlbXBsYXRlKGNsaWVudCkoeyBwYXRoOiBsaW5rLmhyZWYgfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gY2xpZW50KHsgcGF0aDogbGluay5ocmVmIH0pO1xuXHRcdFx0XHRcdFx0XHRcdH0pKSk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShyZXNvdXJjZSwgbmFtZSwgbGlua3MpO1xuXHRcdFx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShyZXNvdXJjZSwgJ2NsaWVudEZvcicsIGZ1bmN0aW9uIChyZWxhdGlvbnNoaXAsIGNsaWVudE92ZXJyaWRlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGxpbmsgPSBsaW5rc1tyZWxhdGlvbnNoaXBdO1xuXHRcdFx0XHRcdFx0XHRcdGlmICghbGluaykge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHJlbGF0aW9uc2hpcDogJyArIHJlbGF0aW9uc2hpcCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChsaW5rLmRlcHJlY2F0aW9uKSB7IGRlcHJlY2F0aW9uV2FybmluZyhyZWxhdGlvbnNoaXAsIGxpbmsuZGVwcmVjYXRpb24pOyB9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGxpbmsudGVtcGxhdGVkID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGVtcGxhdGUoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNsaWVudE92ZXJyaWRlIHx8IGNsaWVudCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZW1wbGF0ZTogbGluay5ocmVmIH1cblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBwYXRoUHJlZml4KFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xpZW50T3ZlcnJpZGUgfHwgY2xpZW50LFxuXHRcdFx0XHRcdFx0XHRcdFx0eyBwcmVmaXg6IGxpbmsuaHJlZiB9XG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc291cmNlLCAncmVxdWVzdEZvcicsIGZ1bmN0aW9uIChyZWxhdGlvbnNoaXAsIHJlcXVlc3QsIGNsaWVudE92ZXJyaWRlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGNsaWVudCA9IHRoaXMuY2xpZW50Rm9yKHJlbGF0aW9uc2hpcCwgY2xpZW50T3ZlcnJpZGUpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBjbGllbnQocmVxdWVzdCk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHJldHVybiByb290O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0fSxcblxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcblx0XHRcdFx0cmV0dXJuIG9wdHMucmVnaXN0cnkubG9va3VwKG9wdHMubWltZS5zdWZmaXgpLnRoZW4oZnVuY3Rpb24gKGNvbnZlcnRlcikge1xuXHRcdFx0XHRcdHJldHVybiBjb252ZXJ0ZXIud3JpdGUob2JqLCBvcHRzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHR9O1xuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKC8qIHJlcXVpcmUgKi8pIHtcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBhIG5ldyBKU09OIGNvbnZlcnRlciB3aXRoIGN1c3RvbSByZXZpdmVyL3JlcGxhY2VyLlxuXHRcdCAqXG5cdFx0ICogVGhlIGV4dGVuZGVkIGNvbnZlcnRlciBtdXN0IGJlIHB1Ymxpc2hlZCB0byBhIE1JTUUgcmVnaXN0cnkgaW4gb3JkZXJcblx0XHQgKiB0byBiZSB1c2VkLiBUaGUgZXhpc3RpbmcgY29udmVydGVyIHdpbGwgbm90IGJlIG1vZGlmaWVkLlxuXHRcdCAqXG5cdFx0ICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9KU09OXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmV2aXZlcj11bmRlZmluZWRdIGN1c3RvbSBKU09OLnBhcnNlIHJldml2ZXJcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufEFycmF5fSBbcmVwbGFjZXI9dW5kZWZpbmVkXSBjdXN0b20gSlNPTi5zdHJpbmdpZnkgcmVwbGFjZXJcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBjcmVhdGVDb252ZXJ0ZXIocmV2aXZlciwgcmVwbGFjZXIpIHtcblx0XHRcdHJldHVybiB7XG5cblx0XHRcdFx0cmVhZDogZnVuY3Rpb24gKHN0cikge1xuXHRcdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKHN0ciwgcmV2aXZlcik7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlcik7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0ZXh0ZW5kOiBjcmVhdGVDb252ZXJ0ZXJcblxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlQ29udmVydGVyKCk7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMiB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAoLyogcmVxdWlyZSAqLykge1xuXG5cdFx0dmFyIGVuY29kZWRTcGFjZVJFLCB1cmxFbmNvZGVkU3BhY2VSRTtcblxuXHRcdGVuY29kZWRTcGFjZVJFID0gLyUyMC9nO1xuXHRcdHVybEVuY29kZWRTcGFjZVJFID0gL1xcKy9nO1xuXG5cdFx0ZnVuY3Rpb24gdXJsRW5jb2RlKHN0cikge1xuXHRcdFx0c3RyID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cik7XG5cdFx0XHQvLyBzcGVjIHNheXMgc3BhY2Ugc2hvdWxkIGJlIGVuY29kZWQgYXMgJysnXG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoZW5jb2RlZFNwYWNlUkUsICcrJyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXJsRGVjb2RlKHN0cikge1xuXHRcdFx0Ly8gc3BlYyBzYXlzIHNwYWNlIHNob3VsZCBiZSBlbmNvZGVkIGFzICcrJ1xuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UodXJsRW5jb2RlZFNwYWNlUkUsICcgJyk7XG5cdFx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cik7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYXBwZW5kKHN0ciwgbmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHR2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRcdHN0ciA9IGFwcGVuZChzdHIsIG5hbWUsIHZhbHVlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKHN0ci5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0c3RyICs9ICcmJztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdHIgKz0gdXJsRW5jb2RlKG5hbWUpO1xuXHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHN0ciArPSAnPScgKyB1cmxFbmNvZGUodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cblx0XHRcdHJlYWQ6IGZ1bmN0aW9uIChzdHIpIHtcblx0XHRcdFx0dmFyIG9iaiA9IHt9O1xuXHRcdFx0XHRzdHIuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuXHRcdFx0XHRcdHZhciBwYWlyLCBuYW1lLCB2YWx1ZTtcblx0XHRcdFx0XHRwYWlyID0gZW50cnkuc3BsaXQoJz0nKTtcblx0XHRcdFx0XHRuYW1lID0gdXJsRGVjb2RlKHBhaXJbMF0pO1xuXHRcdFx0XHRcdGlmIChwYWlyLmxlbmd0aCA9PT0gMikge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB1cmxEZWNvZGUocGFpclsxXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobmFtZSBpbiBvYmopIHtcblx0XHRcdFx0XHRcdGlmICghQXJyYXkuaXNBcnJheShvYmpbbmFtZV0pKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGNvbnZlcnQgdG8gYW4gYXJyYXksIHBlcnNlcnZpbmcgY3Vycm5lbnQgdmFsdWVcblx0XHRcdFx0XHRcdFx0b2JqW25hbWVdID0gW29ialtuYW1lXV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRvYmpbbmFtZV0ucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0b2JqW25hbWVdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sXG5cblx0XHRcdHdyaXRlOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdHZhciBzdHIgPSAnJztcblx0XHRcdFx0T2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdFx0c3RyID0gYXBwZW5kKHN0ciwgbmFtZSwgb2JqW25hbWVdKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBzdHI7XG5cdFx0XHR9XG5cblx0XHR9O1xuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE0IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIE1pY2hhZWwgSmFja3NvblxuICovXG5cbi8qIGdsb2JhbCBGb3JtRGF0YSwgRmlsZSwgQmxvYiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uICgvKiByZXF1aXJlICovKSB7XG5cblx0XHRmdW5jdGlvbiBpc0Zvcm1FbGVtZW50KG9iamVjdCkge1xuXHRcdFx0cmV0dXJuIG9iamVjdCAmJlxuXHRcdFx0XHRvYmplY3Qubm9kZVR5cGUgPT09IDEgJiYgLy8gTm9kZS5FTEVNRU5UX05PREVcblx0XHRcdFx0b2JqZWN0LnRhZ05hbWUgPT09ICdGT1JNJztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVGb3JtRGF0YUZyb21PYmplY3Qob2JqZWN0KSB7XG5cdFx0XHR2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuXHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuXG5cdFx0XHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRmlsZSkge1xuXHRcdFx0XHRcdFx0Zm9ybURhdGEuYXBwZW5kKHByb3BlcnR5LCB2YWx1ZSwgdmFsdWUubmFtZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0XHRcdGZvcm1EYXRhLmFwcGVuZChwcm9wZXJ0eSwgdmFsdWUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQocHJvcGVydHksIFN0cmluZyh2YWx1ZSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm9ybURhdGE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChvYmplY3QpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBGb3JtRGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBtdWx0aXBhcnQvZm9ybS1kYXRhIG1pbWUgc2VyaWFsaXplciByZXF1aXJlcyBGb3JtRGF0YSBzdXBwb3J0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0IEZvcm1EYXRhIGRpcmVjdGx5LlxuXHRcdFx0XHRpZiAob2JqZWN0IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqZWN0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydCA8Zm9ybT4gZWxlbWVudHMuXG5cdFx0XHRcdGlmIChpc0Zvcm1FbGVtZW50KG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEZvcm1EYXRhKG9iamVjdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0IHBsYWluIG9iamVjdHMsIG1heSBjb250YWluIEZpbGUvQmxvYiBhcyB2YWx1ZS5cblx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBjcmVhdGVGb3JtRGF0YUZyb21PYmplY3Qob2JqZWN0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNyZWF0ZSBGb3JtRGF0YSBmcm9tIG9iamVjdCAnICsgb2JqZWN0KTtcblx0XHRcdH1cblxuXHRcdH07XG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTIgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKC8qIHJlcXVpcmUgKi8pIHtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdHJlYWQ6IGZ1bmN0aW9uIChzdHIpIHtcblx0XHRcdFx0cmV0dXJuIHN0cjtcblx0XHRcdH0sXG5cblx0XHRcdHdyaXRlOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdHJldHVybiBvYmoudG9TdHJpbmcoKTtcblx0XHRcdH1cblxuXHRcdH07XG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTMgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKC8qIHJlcXVpcmUgKi8pIHtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRmluZCBvYmplY3RzIHdpdGhpbiBhIGdyYXBoIHRoZSBjb250YWluIGEgcHJvcGVydHkgb2YgYSBjZXJ0YWluIG5hbWUuXG5cdFx0XHQgKlxuXHRcdFx0ICogTk9URTogdGhpcyBtZXRob2Qgd2lsbCBub3QgZGlzY292ZXIgb2JqZWN0IGdyYXBoIGN5Y2xlcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0geyp9IG9iaiBvYmplY3QgdG8gc2VhcmNoIG9uXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBzZWFyY2ggZm9yXG5cdFx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byByZWNlaXZlIHRoZSBmb3VuZCBwcm9wZXJ0aWVzIGFuZCB0aGVpciBwYXJlbnRcblx0XHRcdCAqL1xuXHRcdFx0ZmluZFByb3BlcnRpZXM6IGZ1bmN0aW9uIGZpbmRQcm9wZXJ0aWVzKG9iaiwgcHJvcCwgY2FsbGJhY2spIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkgeyByZXR1cm47IH1cblx0XHRcdFx0aWYgKHByb3AgaW4gb2JqKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sob2JqW3Byb3BdLCBvYmosIHByb3ApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdFx0ZmluZFByb3BlcnRpZXMob2JqW2tleV0sIHByb3AsIGNhbGxiYWNrKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTMgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHRcdHZhciB3aGVuO1xuXG5cdFx0d2hlbiA9IHJlcXVpcmUoJ3doZW4nKTtcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBhIHByb21pc2Ugd2hvc2Ugd29yayBpcyBzdGFydGVkIG9ubHkgd2hlbiBhIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZC5cblx0XHQgKlxuXHRcdCAqIFRoZSB3b3JrIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UuIFRocm93biB2YWx1ZXMgd2lsbCByZXN1bHRcblx0XHQgKiBpbiBwcm9taXNlIHJlamVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IHdvcmsgZnVuY3Rpb24gd2hvc2Ugb3VwdXQgaXMgdXNlZCB0byByZXNvbHZlIHRoZVxuXHRcdCAqICAgcmV0dXJuZWQgcHJvbWlzZS5cblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBsYXp5IHByb21pc2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBsYXp5UHJvbWlzZSh3b3JrKSB7XG5cdFx0XHR2YXIgZGVmZXIsIHN0YXJ0ZWQsIHJlc29sdmVyLCBwcm9taXNlLCB0aGVuO1xuXG5cdFx0XHRkZWZlciA9IHdoZW4uZGVmZXIoKTtcblx0XHRcdHN0YXJ0ZWQgPSBmYWxzZTtcblxuXHRcdFx0cmVzb2x2ZXIgPSBkZWZlci5yZXNvbHZlcjtcblx0XHRcdHByb21pc2UgPSBkZWZlci5wcm9taXNlO1xuXHRcdFx0dGhlbiA9IHByb21pc2UudGhlbjtcblxuXHRcdFx0cHJvbWlzZS50aGVuID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoIXN0YXJ0ZWQpIHtcblx0XHRcdFx0XHRzdGFydGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR3aGVuLmF0dGVtcHQod29yaykudGhlbihyZXNvbHZlci5yZXNvbHZlLCByZXNvbHZlci5yZWplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGVuLmFwcGx5KHByb21pc2UsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGF6eVByb21pc2U7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0Ly8gZGVyaXZlZCBmcm9tIGRvam8ubWl4aW5cblx0ZGVmaW5lKGZ1bmN0aW9uICgvKiByZXF1aXJlICovKSB7XG5cblx0XHR2YXIgZW1wdHkgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIE1peCB0aGUgcHJvcGVydGllcyBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cblx0XHQgKiBXaGVuIHRoZSBzYW1lIHByb3BlcnR5IG9jY3VycyBpbiBtb3JlIHRoZW4gb25lIG9iamVjdCwgdGhlIHJpZ2h0IG1vc3Rcblx0XHQgKiB2YWx1ZSB3aW5zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGRlc3QgdGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc291cmNlcyB0aGUgb2JqZWN0cyB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS4gIE1heSBiZSAxIHRvIE4gYXJndW1lbnRzLCBidXQgbm90IGFuIEFycmF5LlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gdGhlIGRlc3RpbmF0aW9uIG9iamVjdFxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIG1peGluKGRlc3QgLyosIHNvdXJjZXMuLi4gKi8pIHtcblx0XHRcdHZhciBpLCBsLCBzb3VyY2UsIG5hbWU7XG5cblx0XHRcdGlmICghZGVzdCkgeyBkZXN0ID0ge307IH1cblx0XHRcdGZvciAoaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XG5cdFx0XHRcdHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0Zm9yIChuYW1lIGluIHNvdXJjZSkge1xuXHRcdFx0XHRcdGlmICghKG5hbWUgaW4gZGVzdCkgfHwgKGRlc3RbbmFtZV0gIT09IHNvdXJjZVtuYW1lXSAmJiAoIShuYW1lIGluIGVtcHR5KSB8fCBlbXB0eVtuYW1lXSAhPT0gc291cmNlW25hbWVdKSkpIHtcblx0XHRcdFx0XHRcdGRlc3RbbmFtZV0gPSBzb3VyY2VbbmFtZV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkZXN0OyAvLyBPYmplY3Rcblx0XHR9XG5cblx0XHRyZXR1cm4gbWl4aW47XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMiB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAoLyogcmVxdWlyZSAqLykge1xuXG5cdFx0LyoqXG5cdFx0ICogTm9ybWFsaXplIEhUVFAgaGVhZGVyIG5hbWVzIHVzaW5nIHRoZSBwc2V1ZG8gY2FtZWwgY2FzZS5cblx0XHQgKlxuXHRcdCAqIEZvciBleGFtcGxlOlxuXHRcdCAqICAgY29udGVudC10eXBlICAgICAgICAgLT4gQ29udGVudC1UeXBlXG5cdFx0ICogICBhY2NlcHRzICAgICAgICAgICAgICAtPiBBY2NlcHRzXG5cdFx0ICogICB4LWN1c3RvbS1oZWFkZXItbmFtZSAtPiBYLUN1c3RvbS1IZWFkZXItTmFtZVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHJhdyBoZWFkZXIgbmFtZVxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ30gdGhlIG5vcm1hbGl6ZWQgaGVhZGVyIG5hbWVcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKG5hbWUpIHtcblx0XHRcdHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0LnNwbGl0KCctJylcblx0XHRcdFx0Lm1hcChmdW5jdGlvbiAoY2h1bmspIHsgcmV0dXJuIGNodW5rLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2h1bmsuc2xpY2UoMSk7IH0pXG5cdFx0XHRcdC5qb2luKCctJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vcm1hbGl6ZUhlYWRlck5hbWU7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgd2hlbiA9IHJlcXVpcmUoJ3doZW4nKSxcblx0XHRcdG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxuXHRcdGZ1bmN0aW9uIHByb3BlcnR5KHByb21pc2UsIG5hbWUpIHtcblx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oXG5cdFx0XHRcdGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSAmJiB2YWx1ZVtuYW1lXTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHdoZW4ucmVqZWN0KHZhbHVlICYmIHZhbHVlW25hbWVdKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBPYnRhaW4gdGhlIHJlc3BvbnNlIGVudGl0eVxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IGZvciB0aGUgcmVzcG9uc2UgZW50aXR5XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZW50aXR5KCkge1xuXHRcdFx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblx0XHRcdHJldHVybiBwcm9wZXJ0eSh0aGlzLCAnZW50aXR5Jyk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogT2J0YWluIHRoZSByZXNwb25zZSBzdGF0dXNcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBmb3IgdGhlIHJlc3BvbnNlIHN0YXR1c1xuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHN0YXR1cygpIHtcblx0XHRcdC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG5cdFx0XHRyZXR1cm4gcHJvcGVydHkocHJvcGVydHkodGhpcywgJ3N0YXR1cycpLCAnY29kZScpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIE9idGFpbiB0aGUgcmVzcG9uc2UgaGVhZGVycyBtYXBcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBmb3IgdGhlIHJlc3BvbnNlIGhlYWRlcnMgbWFwXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaGVhZGVycygpIHtcblx0XHRcdC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG5cdFx0XHRyZXR1cm4gcHJvcGVydHkodGhpcywgJ2hlYWRlcnMnKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBPYnRhaW4gYSBzcGVjaWZpYyByZXNwb25zZSBoZWFkZXJcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJOYW1lIHRoZSBoZWFkZXIgdG8gcmV0cmlldmVcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gZm9yIHRoZSByZXNwb25zZSBoZWFkZXIncyB2YWx1ZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGhlYWRlcihoZWFkZXJOYW1lKSB7XG5cdFx0XHQvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuXHRcdFx0aGVhZGVyTmFtZSA9IG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVyTmFtZSk7XG5cdFx0XHRyZXR1cm4gcHJvcGVydHkodGhpcy5oZWFkZXJzKCksIGhlYWRlck5hbWUpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEZvbGxvdyBhIHJlbGF0ZWQgcmVzb3VyY2Vcblx0XHQgKlxuXHRcdCAqIFRoZSByZWxhdGlvbnNoaXAgdG8gZm9sbG93IG1heSBiZSBkZWZpbmUgYXMgYSBwbGFpbiBzdHJpbmcsIGFuIG9iamVjdFxuXHRcdCAqIHdpdGggdGhlIHJlbCBhbmQgcGFyYW1zLCBvciBhbiBhcnJheSBjb250YWluaW5nIG9uZSBvciBtb3JlIGVudHJpZXNcblx0XHQgKiB3aXRoIHRoZSBwcmV2aW91cyBmb3Jtcy5cblx0XHQgKlxuXHRcdCAqIEV4YW1wbGVzOlxuXHRcdCAqICAgcmVzcG9uc2UuZm9sbG93KCduZXh0Jylcblx0XHQgKlxuXHRcdCAqICAgcmVzcG9uc2UuZm9sbG93KHsgcmVsOiAnbmV4dCcsIHBhcmFtczogeyBwYWdlU2l6ZTogMTAwIH0gfSlcblx0XHQgKlxuXHRcdCAqICAgcmVzcG9uc2UuZm9sbG93KFtcblx0XHQgKiAgICAgICB7IHJlbDogJ2l0ZW1zJywgcGFyYW1zOiB7IHByb2plY3Rpb246ICdub0ltYWdlcycgfSB9LFxuXHRcdCAqICAgICAgICdzZWFyY2gnLFxuXHRcdCAqICAgICAgIHsgcmVsOiAnZmluZEJ5R2FsbGVyeUlzTnVsbCcsIHBhcmFtczogeyBwcm9qZWN0aW9uOiAnbm9JbWFnZXMnIH0gfSxcblx0XHQgKiAgICAgICAnaXRlbXMnXG5cdFx0ICogICBdKVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEFycmF5fSByZWxzIG9uZSwgb3IgbW9yZSwgcmVsYXRpb25zaGlwcyB0byBmb2xsb3dcblx0XHQgKiBAcmV0dXJucyBSZXNwb25zZVByb21pc2U8UmVzcG9uc2U+IHJlbGF0ZWQgcmVzb3VyY2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBmb2xsb3cocmVscykge1xuXHRcdFx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblx0XHRcdHJlbHMgPSBbXS5jb25jYXQocmVscyk7XG5cdFx0XHRyZXR1cm4gbWFrZSh3aGVuLnJlZHVjZShyZWxzLCBmdW5jdGlvbiAocmVzcG9uc2UsIHJlbCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIHJlbCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRyZWwgPSB7IHJlbDogcmVsIH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZiByZXNwb25zZS5lbnRpdHkuY2xpZW50Rm9yICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdIeXBlcm1lZGlhIHJlc3BvbnNlIGV4cGVjdGVkJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGNsaWVudCA9IHJlc3BvbnNlLmVudGl0eS5jbGllbnRGb3IocmVsLnJlbCk7XG5cdFx0XHRcdHJldHVybiBjbGllbnQoeyBwYXJhbXM6IHJlbC5wYXJhbXMgfSk7XG5cdFx0XHR9LCB0aGlzKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogV3JhcCBhIFByb21pc2UgYXMgYW4gUmVzcG9uc2VQcm9taXNlXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1Byb21pc2U8UmVzcG9uc2U+fSBwcm9taXNlIHRoZSBwcm9taXNlIGZvciBhbiBIVFRQIFJlc3BvbnNlXG5cdFx0ICogQHJldHVybnMge1Jlc3BvbnNlUHJvbWlzZTxSZXNwb25zZT59IHdyYXBwZWQgcHJvbWlzZSBmb3IgUmVzcG9uc2Ugd2l0aCBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbWFrZShwcm9taXNlKSB7XG5cdFx0XHRwcm9taXNlLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdHByb21pc2UuaGVhZGVycyA9IGhlYWRlcnM7XG5cdFx0XHRwcm9taXNlLmhlYWRlciA9IGhlYWRlcjtcblx0XHRcdHByb21pc2UuZW50aXR5ID0gZW50aXR5O1xuXHRcdFx0cHJvbWlzZS5mb2xsb3cgPSBmb2xsb3c7XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNwb25zZVByb21pc2UoKSB7XG5cdFx0XHRyZXR1cm4gbWFrZSh3aGVuLmFwcGx5KHdoZW4sIGFyZ3VtZW50cykpO1xuXHRcdH1cblxuXHRcdHJlc3BvbnNlUHJvbWlzZS5tYWtlID0gbWFrZTtcblx0XHRyZXNwb25zZVByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0cmV0dXJuIG1ha2Uod2hlbi5yZWplY3QodmFsKSk7XG5cdFx0fTtcblx0XHRyZXNwb25zZVByb21pc2UucHJvbWlzZSA9IGZ1bmN0aW9uIChmdW5jKSB7XG5cdFx0XHRyZXR1cm4gbWFrZSh3aGVuLnByb21pc2UoZnVuYykpO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gcmVzcG9uc2VQcm9taXNlO1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTUgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKC8qIHJlcXVpcmUgKi8pIHtcblxuXHRcdHZhciBjaGFyTWFwO1xuXG5cdFx0Y2hhck1hcCA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc3RyaW5ncyA9IHtcblx0XHRcdFx0YWxwaGE6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jyxcblx0XHRcdFx0ZGlnaXQ6ICcwMTIzNDU2Nzg5J1xuXHRcdFx0fTtcblxuXHRcdFx0c3RyaW5ncy5nZW5EZWxpbXMgPSAnOi8/I1tdQCc7XG5cdFx0XHRzdHJpbmdzLnN1YkRlbGltcyA9ICchJCZcXCcoKSorLDs9Jztcblx0XHRcdHN0cmluZ3MucmVzZXJ2ZWQgPSBzdHJpbmdzLmdlbkRlbGltcyArIHN0cmluZ3Muc3ViRGVsaW1zO1xuXHRcdFx0c3RyaW5ncy51bnJlc2VydmVkID0gc3RyaW5ncy5hbHBoYSArIHN0cmluZ3MuZGlnaXQgKyAnLS5ffic7XG5cdFx0XHRzdHJpbmdzLnVybCA9IHN0cmluZ3MucmVzZXJ2ZWQgKyBzdHJpbmdzLnVucmVzZXJ2ZWQ7XG5cdFx0XHRzdHJpbmdzLnNjaGVtZSA9IHN0cmluZ3MuYWxwaGEgKyBzdHJpbmdzLmRpZ2l0ICsgJystLic7XG5cdFx0XHRzdHJpbmdzLnVzZXJpbmZvID0gc3RyaW5ncy51bnJlc2VydmVkICsgc3RyaW5ncy5zdWJEZWxpbXMgKyAnOic7XG5cdFx0XHRzdHJpbmdzLmhvc3QgPSBzdHJpbmdzLnVucmVzZXJ2ZWQgKyBzdHJpbmdzLnN1YkRlbGltcztcblx0XHRcdHN0cmluZ3MucG9ydCA9IHN0cmluZ3MuZGlnaXQ7XG5cdFx0XHRzdHJpbmdzLnBjaGFyID0gc3RyaW5ncy51bnJlc2VydmVkICsgc3RyaW5ncy5zdWJEZWxpbXMgKyAnOkAnO1xuXHRcdFx0c3RyaW5ncy5zZWdtZW50ID0gc3RyaW5ncy5wY2hhcjtcblx0XHRcdHN0cmluZ3MucGF0aCA9IHN0cmluZ3Muc2VnbWVudCArICcvJztcblx0XHRcdHN0cmluZ3MucXVlcnkgPSBzdHJpbmdzLnBjaGFyICsgJy8/Jztcblx0XHRcdHN0cmluZ3MuZnJhZ21lbnQgPSBzdHJpbmdzLnBjaGFyICsgJy8/JztcblxuXHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKHN0cmluZ3MpLnJlZHVjZShmdW5jdGlvbiAoY2hhck1hcCwgc2V0KSB7XG5cdFx0XHRcdGNoYXJNYXBbc2V0XSA9IHN0cmluZ3Nbc2V0XS5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uIChjaGFycywgbXlDaGFyKSB7XG5cdFx0XHRcdFx0Y2hhcnNbbXlDaGFyXSA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuIGNoYXJzO1xuXHRcdFx0XHR9LCB7fSk7XG5cdFx0XHRcdHJldHVybiBjaGFyTWFwO1xuXHRcdFx0fSwge30pO1xuXHRcdH0oKSk7XG5cblx0XHRmdW5jdGlvbiBlbmNvZGUoc3RyLCBhbGxvd2VkKSB7XG5cdFx0XHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgcmVxdWlyZWQgZm9yIFVSTCBlbmNvZGluZycpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0ci5zcGxpdCgnJykubWFwKGZ1bmN0aW9uIChteUNoYXIpIHtcblx0XHRcdFx0aWYgKGFsbG93ZWQuaGFzT3duUHJvcGVydHkobXlDaGFyKSkge1xuXHRcdFx0XHRcdHJldHVybiBteUNoYXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGNvZGUgPSBteUNoYXIuY2hhckNvZGVBdCgwKTtcblx0XHRcdFx0aWYgKGNvZGUgPD0gMTI3KSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJyArIGNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChteUNoYXIpLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pLmpvaW4oJycpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG1ha2VFbmNvZGVyKGFsbG93ZWQpIHtcblx0XHRcdGFsbG93ZWQgPSBhbGxvd2VkIHx8IGNoYXJNYXAudW5yZXNlcnZlZDtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG5cdFx0XHRcdHJldHVybiBlbmNvZGUoc3RyLCBhbGxvd2VkKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuXHRcdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cblx0XHRcdC8qXG5cdFx0XHQgKiBEZWNvZGUgVVJMIGVuY29kZWQgc3RyaW5nc1xuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBVUkwgZW5jb2RlZCBzdHJpbmdcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBkZWNvZGVkIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRkZWNvZGU6IGRlY29kZSxcblxuXHRcdFx0Lypcblx0XHRcdCAqIFVSTCBlbmNvZGUgYSBzdHJpbmdcblx0XHRcdCAqXG5cdFx0XHQgKiBBbGwgYnV0IGFscGhhLW51bWVyaWNzIGFuZCBhIHZlcnkgbGltaXRlZCBzZXQgb2YgcHVuY3R1YXRpb24gLSAuIF8gfiBhcmVcblx0XHRcdCAqIGVuY29kZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBlbmNvZGVcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBlbmNvZGVkIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRlbmNvZGU6IG1ha2VFbmNvZGVyKCksXG5cblx0XHRcdC8qXG5cdFx0XHQqIFVSTCBlbmNvZGUgYSBVUkxcblx0XHRcdCpcblx0XHRcdCogQWxsIGNoYXJhY3RlciBwZXJtaXR0ZWQgYW55d2hlcmUgaW4gYSBVUkwgYXJlIGxlZnQgdW5lbmNvZGVkIGV2ZW5cblx0XHRcdCogaWYgdGhhdCBjaGFyYWN0ZXIgaXMgbm90IHBlcm1pdHRlZCBpbiB0aGF0IHBvcnRpb24gb2YgYSBVUkwuXG5cdFx0XHQqXG5cdFx0XHQqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIHR5cGljYWxseSBub3Qgd2hhdCB5b3Ugd2FudC5cblx0XHRcdCpcblx0XHRcdCogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBlbmNvZGVcblx0XHRcdCogQHJldHVybnMge3N0cmluZ30gVVJMIGVuY29kZWQgc3RyaW5nXG5cdFx0XHQqL1xuXHRcdFx0ZW5jb2RlVVJMOiBtYWtlRW5jb2RlcihjaGFyTWFwLnVybCksXG5cblx0XHRcdC8qXG5cdFx0XHQgKiBVUkwgZW5jb2RlIHRoZSBzY2hlbWUgcG9ydGlvbiBvZiBhIFVSTFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgdG8gZW5jb2RlXG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSBVUkwgZW5jb2RlZCBzdHJpbmdcblx0XHRcdCAqL1xuXHRcdFx0ZW5jb2RlU2NoZW1lOiBtYWtlRW5jb2RlcihjaGFyTWFwLnNjaGVtZSksXG5cblx0XHRcdC8qXG5cdFx0XHQgKiBVUkwgZW5jb2RlIHRoZSB1c2VyIGluZm8gcG9ydGlvbiBvZiBhIFVSTFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgdG8gZW5jb2RlXG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSBVUkwgZW5jb2RlZCBzdHJpbmdcblx0XHRcdCAqL1xuXHRcdFx0ZW5jb2RlVXNlckluZm86IG1ha2VFbmNvZGVyKGNoYXJNYXAudXNlcmluZm8pLFxuXG5cdFx0XHQvKlxuXHRcdFx0ICogVVJMIGVuY29kZSB0aGUgaG9zdCBwb3J0aW9uIG9mIGEgVVJMXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBlbmNvZGVcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBlbmNvZGVkIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRlbmNvZGVIb3N0OiBtYWtlRW5jb2RlcihjaGFyTWFwLmhvc3QpLFxuXG5cdFx0XHQvKlxuXHRcdFx0ICogVVJMIGVuY29kZSB0aGUgcG9ydCBwb3J0aW9uIG9mIGEgVVJMXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBlbmNvZGVcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBlbmNvZGVkIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRlbmNvZGVQb3J0OiBtYWtlRW5jb2RlcihjaGFyTWFwLnBvcnQpLFxuXG5cdFx0XHQvKlxuXHRcdFx0ICogVVJMIGVuY29kZSBhIHBhdGggc2VnbWVudCBwb3J0aW9uIG9mIGEgVVJMXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBlbmNvZGVcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBlbmNvZGVkIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRlbmNvZGVQYXRoU2VnbWVudDogbWFrZUVuY29kZXIoY2hhck1hcC5zZWdtZW50KSxcblxuXHRcdFx0Lypcblx0XHRcdCAqIFVSTCBlbmNvZGUgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgdG8gZW5jb2RlXG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSBVUkwgZW5jb2RlZCBzdHJpbmdcblx0XHRcdCAqL1xuXHRcdFx0ZW5jb2RlUGF0aDogbWFrZUVuY29kZXIoY2hhck1hcC5wYXRoKSxcblxuXHRcdFx0Lypcblx0XHRcdCAqIFVSTCBlbmNvZGUgdGhlIHF1ZXJ5IHBvcnRpb24gb2YgYSBVUkxcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRvIGVuY29kZVxuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ30gVVJMIGVuY29kZWQgc3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdGVuY29kZVF1ZXJ5OiBtYWtlRW5jb2RlcihjaGFyTWFwLnF1ZXJ5KSxcblxuXHRcdFx0Lypcblx0XHRcdCAqIFVSTCBlbmNvZGUgdGhlIGZyYWdtZW50IHBvcnRpb24gb2YgYSBVUkxcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRvIGVuY29kZVxuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ30gVVJMIGVuY29kZWQgc3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdGVuY29kZUZyYWdtZW50OiBtYWtlRW5jb2RlcihjaGFyTWFwLmZyYWdtZW50KVxuXG5cdFx0fTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE1IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHVuZGVmO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIHVyaUVuY29kZXIsIG9wZXJhdGlvbnMsIHByZWZpeFJFO1xuXG5cdFx0dXJpRW5jb2RlciA9IHJlcXVpcmUoJy4vdXJpRW5jb2RlcicpO1xuXG5cdFx0cHJlZml4UkUgPSAvXihbXjpdKik6KFswLTldKykkLztcblx0XHRvcGVyYXRpb25zID0ge1xuXHRcdFx0Jyc6ICB7IGZpcnN0OiAnJywgIHNlcGFyYXRvcjogJywnLCBuYW1lZDogZmFsc2UsIGVtcHR5OiAnJywgIGVuY29kZXI6IHVyaUVuY29kZXIuZW5jb2RlIH0sXG5cdFx0XHQnKyc6IHsgZmlyc3Q6ICcnLCAgc2VwYXJhdG9yOiAnLCcsIG5hbWVkOiBmYWxzZSwgZW1wdHk6ICcnLCAgZW5jb2RlcjogdXJpRW5jb2Rlci5lbmNvZGVVUkwgfSxcblx0XHRcdCcjJzogeyBmaXJzdDogJyMnLCBzZXBhcmF0b3I6ICcsJywgbmFtZWQ6IGZhbHNlLCBlbXB0eTogJycsICBlbmNvZGVyOiB1cmlFbmNvZGVyLmVuY29kZVVSTCB9LFxuXHRcdFx0Jy4nOiB7IGZpcnN0OiAnLicsIHNlcGFyYXRvcjogJy4nLCBuYW1lZDogZmFsc2UsIGVtcHR5OiAnJywgIGVuY29kZXI6IHVyaUVuY29kZXIuZW5jb2RlIH0sXG5cdFx0XHQnLyc6IHsgZmlyc3Q6ICcvJywgc2VwYXJhdG9yOiAnLycsIG5hbWVkOiBmYWxzZSwgZW1wdHk6ICcnLCAgZW5jb2RlcjogdXJpRW5jb2Rlci5lbmNvZGUgfSxcblx0XHRcdCc7JzogeyBmaXJzdDogJzsnLCBzZXBhcmF0b3I6ICc7JywgbmFtZWQ6IHRydWUsICBlbXB0eTogJycsICBlbmNvZGVyOiB1cmlFbmNvZGVyLmVuY29kZSB9LFxuXHRcdFx0Jz8nOiB7IGZpcnN0OiAnPycsIHNlcGFyYXRvcjogJyYnLCBuYW1lZDogdHJ1ZSwgIGVtcHR5OiAnPScsIGVuY29kZXI6IHVyaUVuY29kZXIuZW5jb2RlIH0sXG5cdFx0XHQnJic6IHsgZmlyc3Q6ICcmJywgc2VwYXJhdG9yOiAnJicsIG5hbWVkOiB0cnVlLCAgZW1wdHk6ICc9JywgZW5jb2RlcjogdXJpRW5jb2Rlci5lbmNvZGUgfSxcblx0XHRcdCc9JzogeyByZXNlcnZlZDogdHJ1ZSB9LFxuXHRcdFx0JywnOiB7IHJlc2VydmVkOiB0cnVlIH0sXG5cdFx0XHQnISc6IHsgcmVzZXJ2ZWQ6IHRydWUgfSxcblx0XHRcdCdAJzogeyByZXNlcnZlZDogdHJ1ZSB9LFxuXHRcdFx0J3wnOiB7IHJlc2VydmVkOiB0cnVlIH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gYXBwbHkob3BlcmF0aW9uLCBleHByZXNzaW9uLCBwYXJhbXMpIHtcblx0XHRcdC8qanNoaW50IG1heGNvbXBsZXhpdHk6MTEgKi9cblx0XHRcdHJldHVybiBleHByZXNzaW9uLnNwbGl0KCcsJykucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHZhcmlhYmxlKSB7XG5cdFx0XHRcdHZhciBvcHRzLCB2YWx1ZTtcblxuXHRcdFx0XHRvcHRzID0ge307XG5cdFx0XHRcdGlmICh2YXJpYWJsZS5zbGljZSgtMSkgPT09ICcqJykge1xuXHRcdFx0XHRcdHZhcmlhYmxlID0gdmFyaWFibGUuc2xpY2UoMCwgLTEpO1xuXHRcdFx0XHRcdG9wdHMuZXhwbG9kZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByZWZpeFJFLnRlc3QodmFyaWFibGUpKSB7XG5cdFx0XHRcdFx0dmFyIHByZWZpeCA9IHByZWZpeFJFLmV4ZWModmFyaWFibGUpO1xuXHRcdFx0XHRcdHZhcmlhYmxlID0gcHJlZml4WzFdO1xuXHRcdFx0XHRcdG9wdHMubWF4TGVuZ3RoID0gcGFyc2VJbnQocHJlZml4WzJdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhcmlhYmxlID0gdXJpRW5jb2Rlci5kZWNvZGUodmFyaWFibGUpO1xuXHRcdFx0XHR2YWx1ZSA9IHBhcmFtc1t2YXJpYWJsZV07XG5cblx0XHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0cmVzdWx0ICs9IHZhbHVlLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCB2YWx1ZSkge1xuXHRcdFx0XHRcdFx0aWYgKHJlc3VsdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0ICs9IG9wdHMuZXhwbG9kZSA/IG9wZXJhdGlvbi5zZXBhcmF0b3IgOiAnLCc7XG5cdFx0XHRcdFx0XHRcdGlmIChvcGVyYXRpb24ubmFtZWQgJiYgb3B0cy5leHBsb2RlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0ICs9IG9wZXJhdGlvbi5lbmNvZGVyKHZhcmlhYmxlKTtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gdmFsdWUubGVuZ3RoID8gJz0nIDogb3BlcmF0aW9uLmVtcHR5O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0ICs9IG9wZXJhdGlvbi5maXJzdDtcblx0XHRcdFx0XHRcdFx0aWYgKG9wZXJhdGlvbi5uYW1lZCkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdCArPSBvcGVyYXRpb24uZW5jb2Rlcih2YXJpYWJsZSk7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0ICs9IHZhbHVlLmxlbmd0aCA/ICc9JyA6IG9wZXJhdGlvbi5lbXB0eTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IG9wZXJhdGlvbi5lbmNvZGVyKHZhbHVlKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdFx0fSwgJycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRyZXN1bHQgKz0gT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBuYW1lKSB7XG5cdFx0XHRcdFx0XHRpZiAocmVzdWx0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gb3B0cy5leHBsb2RlID8gb3BlcmF0aW9uLnNlcGFyYXRvciA6ICcsJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gb3BlcmF0aW9uLmZpcnN0O1xuXHRcdFx0XHRcdFx0XHRpZiAob3BlcmF0aW9uLm5hbWVkICYmICFvcHRzLmV4cGxvZGUpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gb3BlcmF0aW9uLmVuY29kZXIodmFyaWFibGUpO1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdCArPSB2YWx1ZVtuYW1lXS5sZW5ndGggPyAnPScgOiBvcGVyYXRpb24uZW1wdHk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlc3VsdCArPSBvcGVyYXRpb24uZW5jb2RlcihuYW1lKTtcblx0XHRcdFx0XHRcdHJlc3VsdCArPSBvcHRzLmV4cGxvZGUgPyAnPScgOiAnLCc7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gb3BlcmF0aW9uLmVuY29kZXIodmFsdWVbbmFtZV0pO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0XHR9LCAnJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuXHRcdFx0XHRcdGlmIChvcHRzLm1heExlbmd0aCkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBvcHRzLm1heExlbmd0aCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCArPSByZXN1bHQubGVuZ3RoID8gb3BlcmF0aW9uLnNlcGFyYXRvciA6IG9wZXJhdGlvbi5maXJzdDtcblx0XHRcdFx0XHRpZiAob3BlcmF0aW9uLm5hbWVkKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gb3BlcmF0aW9uLmVuY29kZXIodmFyaWFibGUpO1xuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IHZhbHVlLmxlbmd0aCA/ICc9JyA6IG9wZXJhdGlvbi5lbXB0eTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0ICs9IG9wZXJhdGlvbi5lbmNvZGVyKHZhbHVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9LCAnJyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXhwYW5kRXhwcmVzc2lvbihleHByZXNzaW9uLCBwYXJhbXMpIHtcblx0XHRcdHZhciBvcGVyYXRpb247XG5cblx0XHRcdG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbZXhwcmVzc2lvbi5zbGljZSgwLDEpXTtcblx0XHRcdGlmIChvcGVyYXRpb24pIHtcblx0XHRcdFx0ZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uc2xpY2UoMSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0b3BlcmF0aW9uID0gb3BlcmF0aW9uc1snJ107XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcGVyYXRpb24ucmVzZXJ2ZWQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdSZXNlcnZlZCBleHByZXNzaW9uIG9wZXJhdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFwcGx5KG9wZXJhdGlvbiwgZXhwcmVzc2lvbiwgcGFyYW1zKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHBhbmRUZW1wbGF0ZSh0ZW1wbGF0ZSwgcGFyYW1zKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGVuZCwgdXJpO1xuXG5cdFx0XHR1cmkgPSAnJztcblx0XHRcdGVuZCA9IDA7XG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0XHRzdGFydCA9IHRlbXBsYXRlLmluZGV4T2YoJ3snLCBlbmQpO1xuXHRcdFx0XHRpZiAoc3RhcnQgPT09IC0xKSB7XG5cdFx0XHRcdFx0Ly8gbm8gbW9yZSBleHByZXNzaW9uc1xuXHRcdFx0XHRcdHVyaSArPSB0ZW1wbGF0ZS5zbGljZShlbmQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHVyaSArPSB0ZW1wbGF0ZS5zbGljZShlbmQsIHN0YXJ0KTtcblx0XHRcdFx0ZW5kID0gdGVtcGxhdGUuaW5kZXhPZignfScsIHN0YXJ0KSArIDE7XG5cdFx0XHRcdHVyaSArPSBleHBhbmRFeHByZXNzaW9uKHRlbXBsYXRlLnNsaWNlKHN0YXJ0ICsgMSwgZW5kIC0gMSksIHBhcmFtcyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1cmk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBFeHBhbmQgYSBVUkkgVGVtcGxhdGUgd2l0aCBwYXJhbWV0ZXJzIHRvIGZvcm0gYSBVUkkuXG5cdFx0XHQgKlxuXHRcdFx0ICogRnVsbCBpbXBsZW1lbnRhdGlvbiAobGV2ZWwgNCkgb2YgcmZjNjU3MC5cblx0XHRcdCAqIEBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgVVJJIHRlbXBsYXRlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gcGFyYW1zIHRvIGFwcGx5IHRvIHRoZSB0ZW1wbGF0ZSBkdXJyaW5nIGV4cGFudGlvblxuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ30gZXhwYW5kZWQgVVJJXG5cdFx0XHQgKi9cblx0XHRcdGV4cGFuZDogZXhwYW5kVGVtcGxhdGVcblxuXHRcdH07XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsInZhciBWdWUgLy8gbGF0ZSBiaW5kXG52YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKVxudmFyIHNoaW1tZWQgPSBmYWxzZVxudmFyIGlzQnJvd3NlcmlmeSA9IGZhbHNlXG5cbi8qKlxuICogRGV0ZXJtaW5lIGNvbXBhdGliaWxpdHkgYW5kIGFwcGx5IHBhdGNoLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHZ1ZVxuICogQHBhcmFtIHtCb29sZWFufSBicm93c2VyaWZ5XG4gKi9cblxuZXhwb3J0cy5pbnN0YWxsID0gZnVuY3Rpb24gKHZ1ZSwgYnJvd3NlcmlmeSkge1xuICBpZiAoc2hpbW1lZCkgcmV0dXJuXG4gIHNoaW1tZWQgPSB0cnVlXG5cbiAgVnVlID0gdnVlXG4gIGlzQnJvd3NlcmlmeSA9IGJyb3dzZXJpZnlcblxuICBleHBvcnRzLmNvbXBhdGlibGUgPSAhIVZ1ZS5pbnRlcm5hbERpcmVjdGl2ZXNcbiAgaWYgKCFleHBvcnRzLmNvbXBhdGlibGUpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnW0hNUl0gdnVlLWxvYWRlciBob3QgcmVsb2FkIGlzIG9ubHkgY29tcGF0aWJsZSB3aXRoICcgK1xuICAgICAgJ1Z1ZS5qcyAxLjAuMCsuJ1xuICAgIClcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIHBhdGNoIHZpZXcgZGlyZWN0aXZlXG4gIHBhdGNoVmlldyhWdWUuaW50ZXJuYWxEaXJlY3RpdmVzLmNvbXBvbmVudClcbiAgY29uc29sZS5sb2coJ1tITVJdIFZ1ZSBjb21wb25lbnQgaG90IHJlbG9hZCBzaGltIGFwcGxpZWQuJylcbiAgLy8gc2hpbSByb3V0ZXItdmlldyBpZiBwcmVzZW50XG4gIHZhciByb3V0ZXJWaWV3ID0gVnVlLmVsZW1lbnREaXJlY3RpdmUoJ3JvdXRlci12aWV3JylcbiAgaWYgKHJvdXRlclZpZXcpIHtcbiAgICBwYXRjaFZpZXcocm91dGVyVmlldylcbiAgICBjb25zb2xlLmxvZygnW0hNUl0gdnVlLXJvdXRlciA8cm91dGVyLXZpZXc+IGhvdCByZWxvYWQgc2hpbSBhcHBsaWVkLicpXG4gIH1cbn1cblxuLyoqXG4gKiBTaGltIHRoZSB2aWV3IGRpcmVjdGl2ZSAoY29tcG9uZW50IG9yIHJvdXRlci12aWV3KS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gVmlld1xuICovXG5cbmZ1bmN0aW9uIHBhdGNoVmlldyAoVmlldykge1xuICB2YXIgdW5idWlsZCA9IFZpZXcudW5idWlsZFxuICBWaWV3LnVuYnVpbGQgPSBmdW5jdGlvbiAoZGVmZXIpIHtcbiAgICBpZiAoIXRoaXMuaG90VXBkYXRpbmcpIHtcbiAgICAgIHZhciBwcmV2Q29tcG9uZW50ID0gdGhpcy5jaGlsZFZNICYmIHRoaXMuY2hpbGRWTS5jb25zdHJ1Y3RvclxuICAgICAgcmVtb3ZlVmlldyhwcmV2Q29tcG9uZW50LCB0aGlzKVxuICAgICAgLy8gZGVmZXIgPSB0cnVlIG1lYW5zIHdlIGFyZSB0cmFuc2l0aW9uaW5nIHRvIGEgbmV3XG4gICAgICAvLyBDb21wb25lbnQuIFJlZ2lzdGVyIHRoaXMgbmV3IGNvbXBvbmVudCB0byB0aGUgbGlzdC5cbiAgICAgIGlmIChkZWZlcikge1xuICAgICAgICBhZGRWaWV3KHRoaXMuQ29tcG9uZW50LCB0aGlzKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBjYWxsIG9yaWdpbmFsXG4gICAgcmV0dXJuIHVuYnVpbGQuY2FsbCh0aGlzLCBkZWZlcilcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBhIGNvbXBvbmVudCB2aWV3IHRvIGEgQ29tcG9uZW50J3MgaG90IGxpc3RcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb21wb25lbnRcbiAqIEBwYXJhbSB7RGlyZWN0aXZlfSB2aWV3IC0gdmlldyBkaXJlY3RpdmUgaW5zdGFuY2VcbiAqL1xuXG5mdW5jdGlvbiBhZGRWaWV3IChDb21wb25lbnQsIHZpZXcpIHtcbiAgdmFyIGlkID0gQ29tcG9uZW50ICYmIENvbXBvbmVudC5vcHRpb25zLmhvdElEXG4gIGlmIChpZCkge1xuICAgIGlmICghbWFwW2lkXSkge1xuICAgICAgbWFwW2lkXSA9IHtcbiAgICAgICAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gICAgICAgIHZpZXdzOiBbXSxcbiAgICAgICAgaW5zdGFuY2VzOiBbXVxuICAgICAgfVxuICAgIH1cbiAgICBtYXBbaWRdLnZpZXdzLnB1c2godmlldylcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNvbXBvbmVudCB2aWV3IGZyb20gYSBDb21wb25lbnQncyBob3QgbGlzdFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvbXBvbmVudFxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHZpZXcgLSB2aWV3IGRpcmVjdGl2ZSBpbnN0YW5jZVxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZVZpZXcgKENvbXBvbmVudCwgdmlldykge1xuICB2YXIgaWQgPSBDb21wb25lbnQgJiYgQ29tcG9uZW50Lm9wdGlvbnMuaG90SURcbiAgaWYgKGlkKSB7XG4gICAgbWFwW2lkXS52aWV3cy4kcmVtb3ZlKHZpZXcpXG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZWNvcmQgZm9yIGEgaG90IG1vZHVsZSwgd2hpY2gga2VlcHMgdHJhY2sgb2YgaXRzIGNvbnN0cnVjb3RyLFxuICogaW5zdG5hY2VzIGFuZCB2aWV3cyAoY29tcG9uZW50IGRpcmVjdGl2ZXMgb3Igcm91dGVyLXZpZXdzKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZXhwb3J0cy5jcmVhdGVSZWNvcmQgPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMub3B0aW9uc1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5lbCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIG9wdGlvbnMuZGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICBtYWtlT3B0aW9uc0hvdChpZCwgb3B0aW9ucylcbiAgICBtYXBbaWRdID0ge1xuICAgICAgQ29tcG9uZW50OiBudWxsLFxuICAgICAgdmlld3M6IFtdLFxuICAgICAgaW5zdGFuY2VzOiBbXVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1ha2UgYSBDb21wb25lbnQgb3B0aW9ucyBvYmplY3QgaG90LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBtYWtlT3B0aW9uc0hvdCAoaWQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5ob3RJRCA9IGlkXG4gIGluamVjdEhvb2sob3B0aW9ucywgJ2NyZWF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlY29yZCA9IG1hcFtpZF1cbiAgICBpZiAoIXJlY29yZC5Db21wb25lbnQpIHtcbiAgICAgIHJlY29yZC5Db21wb25lbnQgPSB0aGlzLmNvbnN0cnVjdG9yXG4gICAgfVxuICAgIHJlY29yZC5pbnN0YW5jZXMucHVzaCh0aGlzKVxuICB9KVxuICBpbmplY3RIb29rKG9wdGlvbnMsICdiZWZvcmVEZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgIG1hcFtpZF0uaW5zdGFuY2VzLiRyZW1vdmUodGhpcylcbiAgfSlcbn1cblxuLyoqXG4gKiBJbmplY3QgYSBob29rIHRvIGEgaG90IHJlbG9hZGFibGUgY29tcG9uZW50IHNvIHRoYXRcbiAqIHdlIGNhbiBrZWVwIHRyYWNrIG9mIGl0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va1xuICovXG5cbmZ1bmN0aW9uIGluamVjdEhvb2sgKG9wdGlvbnMsIG5hbWUsIGhvb2spIHtcbiAgdmFyIGV4aXN0aW5nID0gb3B0aW9uc1tuYW1lXVxuICBvcHRpb25zW25hbWVdID0gZXhpc3RpbmdcbiAgICA/IEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpXG4gICAgICA/IGV4aXN0aW5nLmNvbmNhdChob29rKVxuICAgICAgOiBbZXhpc3RpbmcsIGhvb2tdXG4gICAgOiBbaG9va11cbn1cblxuLyoqXG4gKiBVcGRhdGUgYSBob3QgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R8bnVsbH0gbmV3T3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gbmV3VGVtcGxhdGVcbiAqL1xuXG5leHBvcnRzLnVwZGF0ZSA9IGZ1bmN0aW9uIChpZCwgbmV3T3B0aW9ucywgbmV3VGVtcGxhdGUpIHtcbiAgdmFyIHJlY29yZCA9IG1hcFtpZF1cbiAgLy8gZm9yY2UgZnVsbC1yZWxvYWQgaWYgYW4gaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCBpcyBhY3RpdmUgYnV0IGlzIG5vdFxuICAvLyBtYW5hZ2VkIGJ5IGEgdmlld1xuICBpZiAoIXJlY29yZCB8fCAocmVjb3JkLmluc3RhbmNlcy5sZW5ndGggJiYgIXJlY29yZC52aWV3cy5sZW5ndGgpKSB7XG4gICAgY29uc29sZS5sb2coJ1tITVJdIFJvb3Qgb3IgbWFudWFsbHktbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgbWF5IGJlIHJlcXVpcmVkLicpXG4gICAgaWYgKCFpc0Jyb3dzZXJpZnkpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBicm93c2VyaWZ5LWhtciBzb21laG93IHNlbmRzIGluY29tcGxldGUgYnVuZGxlIGlmIHdlIHJlbG9hZCBoZXJlXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCFpc0Jyb3dzZXJpZnkpIHtcbiAgICAvLyBicm93c2VyaWZ5LWhtciBhbHJlYWR5IGxvZ3MgdGhpc1xuICAgIGNvbnNvbGUubG9nKCdbSE1SXSBVcGRhdGluZyBjb21wb25lbnQ6ICcgKyBmb3JtYXQoaWQpKVxuICB9XG4gIHZhciBDb21wb25lbnQgPSByZWNvcmQuQ29tcG9uZW50XG4gIC8vIHVwZGF0ZSBjb25zdHJ1Y3RvclxuICBpZiAobmV3T3B0aW9ucykge1xuICAgIC8vIGluIGNhc2UgdGhlIHVzZXIgZXhwb3J0cyBhIGNvbnN0cnVjdG9yXG4gICAgQ29tcG9uZW50ID0gcmVjb3JkLkNvbXBvbmVudCA9IHR5cGVvZiBuZXdPcHRpb25zID09PSAnZnVuY3Rpb24nXG4gICAgICA/IG5ld09wdGlvbnNcbiAgICAgIDogVnVlLmV4dGVuZChuZXdPcHRpb25zKVxuICAgIG1ha2VPcHRpb25zSG90KGlkLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBpZiAobmV3VGVtcGxhdGUpIHtcbiAgICBDb21wb25lbnQub3B0aW9ucy50ZW1wbGF0ZSA9IG5ld1RlbXBsYXRlXG4gIH1cbiAgLy8gaGFuZGxlIHJlY3Vyc2l2ZSBsb29rdXBcbiAgaWYgKENvbXBvbmVudC5vcHRpb25zLm5hbWUpIHtcbiAgICBDb21wb25lbnQub3B0aW9ucy5jb21wb25lbnRzW0NvbXBvbmVudC5vcHRpb25zLm5hbWVdID0gQ29tcG9uZW50XG4gIH1cbiAgLy8gcmVzZXQgY29uc3RydWN0b3IgY2FjaGVkIGxpbmtlclxuICBDb21wb25lbnQubGlua2VyID0gbnVsbFxuICAvLyByZWxvYWQgYWxsIHZpZXdzXG4gIHJlY29yZC52aWV3cy5mb3JFYWNoKGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgdXBkYXRlVmlldyh2aWV3LCBDb21wb25lbnQpXG4gIH0pXG59XG5cbi8qKlxuICogVXBkYXRlIGEgY29tcG9uZW50IHZpZXcgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlld1xuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29tcG9uZW50XG4gKi9cblxuZnVuY3Rpb24gdXBkYXRlVmlldyAodmlldywgQ29tcG9uZW50KSB7XG4gIGlmICghdmlldy5fYm91bmQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2aWV3LkNvbXBvbmVudCA9IENvbXBvbmVudFxuICB2aWV3LmhvdFVwZGF0aW5nID0gdHJ1ZVxuICAvLyBkaXNhYmxlIHRyYW5zaXRpb25zXG4gIHZpZXcudm0uX2lzQ29tcGlsZWQgPSBmYWxzZVxuICAvLyBzYXZlIHN0YXRlXG4gIHZhciBzdGF0ZSA9IHZpZXcuY2hpbGRWTS4kZGF0YVxuICAvLyByZW1vdW50LCBtYWtlIHN1cmUgdG8gZGlzYWJsZSBrZWVwLWFsaXZlXG4gIHZhciBrZWVwQWxpdmUgPSB2aWV3LmtlZXBBbGl2ZVxuICB2aWV3LmtlZXBBbGl2ZSA9IGZhbHNlXG4gIHZpZXcubW91bnRDb21wb25lbnQoKVxuICB2aWV3LmtlZXBBbGl2ZSA9IGtlZXBBbGl2ZVxuICAvLyByZXN0b3JlIHN0YXRlXG4gIHZpZXcuY2hpbGRWTS4kZGF0YSA9IHN0YXRlXG4gIC8vIHJlLWVhbmJsZSB0cmFuc2l0aW9uc1xuICB2aWV3LnZtLl9pc0NvbXBpbGVkID0gdHJ1ZVxuICB2aWV3LmhvdFVwZGF0aW5nID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZm9ybWF0IChpZCkge1xuICByZXR1cm4gaWQubWF0Y2goL1teXFwvXStcXC52dWUkLylbMF1cbn1cbiIsIi8qKlxuICogU2VydmljZSBmb3Igc2VuZGluZyBuZXR3b3JrIHJlcXVlc3RzLlxuICovXG5cbnZhciB4aHIgPSByZXF1aXJlKCcuL2xpYi94aHInKTtcbnZhciBqc29ucCA9IHJlcXVpcmUoJy4vbGliL2pzb25wJyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vbGliL3Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoXykge1xuXG4gICAgdmFyIG9yaWdpblVybCA9IF8udXJsLnBhcnNlKGxvY2F0aW9uLmhyZWYpO1xuICAgIHZhciBqc29uVHlwZSA9IHsnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCd9O1xuXG4gICAgZnVuY3Rpb24gSHR0cCh1cmwsIG9wdGlvbnMpIHtcblxuICAgICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHVybCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1cmw7XG4gICAgICAgICAgICB1cmwgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7dXJsOiB1cmx9LCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHRydWUsIHt9LFxuICAgICAgICAgICAgSHR0cC5vcHRpb25zLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luKG9wdGlvbnMudXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gb3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0gXy5leHRlbmQoe30sIEh0dHAuaGVhZGVycy5jb21tb24sXG4gICAgICAgICAgICAhb3B0aW9ucy5jcm9zc09yaWdpbiA/IEh0dHAuaGVhZGVycy5jdXN0b20gOiB7fSxcbiAgICAgICAgICAgIEh0dHAuaGVhZGVyc1tvcHRpb25zLm1ldGhvZC50b0xvd2VyQ2FzZSgpXSxcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy5kYXRhKSAmJiAvXihHRVR8SlNPTlApJC9pLnRlc3Qob3B0aW9ucy5tZXRob2QpKSB7XG4gICAgICAgICAgICBfLmV4dGVuZChvcHRpb25zLnBhcmFtcywgb3B0aW9ucy5kYXRhKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5lbXVsYXRlSFRUUCAmJiAhb3B0aW9ucy5jcm9zc09yaWdpbiAmJiAvXihQVVR8UEFUQ0h8REVMRVRFKSQvaS50ZXN0KG9wdGlvbnMubWV0aG9kKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJ10gPSBvcHRpb25zLm1ldGhvZDtcbiAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04gJiYgXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMuZGF0YSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IF8udXJsLnBhcmFtcyhvcHRpb25zLmRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uaXNPYmplY3Qob3B0aW9ucy5kYXRhKSAmJiAvRm9ybURhdGEvaS50ZXN0KG9wdGlvbnMuZGF0YS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMuZGF0YSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9taXNlID0gKG9wdGlvbnMubWV0aG9kID09ICdKU09OUCcgPyBqc29ucCA6IHhocikuY2FsbCh0aGlzLnZtLCBfLCBvcHRpb25zKTtcbiAgICAgICAgcHJvbWlzZSA9IGV4dGVuZFByb21pc2UocHJvbWlzZS50aGVuKHRyYW5zZm9ybVJlc3BvbnNlLCB0cmFuc2Zvcm1SZXNwb25zZSksIHRoaXMudm0pO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnN1Y2Nlc3Mob3B0aW9ucy5zdWNjZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmVycm9yKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS5lcnJvcihvcHRpb25zLmVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZFByb21pc2UocHJvbWlzZSwgdm0pIHtcblxuICAgICAgICBwcm9taXNlLnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZm4pIHtcblxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZFByb21pc2UocHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHZtLCByZXNwb25zZS5kYXRhLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlKSB8fCByZXNwb25zZTtcbiAgICAgICAgICAgIH0pLCB2bSk7XG5cbiAgICAgICAgfTtcblxuICAgICAgICBwcm9taXNlLmVycm9yID0gZnVuY3Rpb24gKGZuKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBleHRlbmRQcm9taXNlKHByb21pc2UudGhlbih1bmRlZmluZWQsIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHZtLCByZXNwb25zZS5kYXRhLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlKSB8fCByZXNwb25zZTtcbiAgICAgICAgICAgIH0pLCB2bSk7XG5cbiAgICAgICAgfTtcblxuICAgICAgICBwcm9taXNlLmFsd2F5cyA9IGZ1bmN0aW9uIChmbikge1xuXG4gICAgICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh2bSwgcmVzcG9uc2UuZGF0YSwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZSkgfHwgcmVzcG9uc2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kUHJvbWlzZShwcm9taXNlLnRoZW4oY2IsIGNiKSwgdm0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSByZXNwb25zZS5yZXNwb25zZVRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2sgPyByZXNwb25zZSA6IFByb21pc2UucmVqZWN0KHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcm9zc09yaWdpbih1cmwpIHtcblxuICAgICAgICB2YXIgcmVxdWVzdFVybCA9IF8udXJsLnBhcnNlKHVybCk7XG5cbiAgICAgICAgcmV0dXJuIChyZXF1ZXN0VXJsLnByb3RvY29sICE9PSBvcmlnaW5VcmwucHJvdG9jb2wgfHwgcmVxdWVzdFVybC5ob3N0ICE9PSBvcmlnaW5VcmwuaG9zdCk7XG4gICAgfVxuXG4gICAgSHR0cC5vcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6ICdnZXQnLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBkYXRhOiAnJyxcbiAgICAgICAgeGhyOiBudWxsLFxuICAgICAgICBqc29ucDogJ2NhbGxiYWNrJyxcbiAgICAgICAgYmVmb3JlU2VuZDogbnVsbCxcbiAgICAgICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgICAgIGVtdWxhdGVIVFRQOiBmYWxzZSxcbiAgICAgICAgZW11bGF0ZUpTT046IGZhbHNlXG4gICAgfTtcblxuICAgIEh0dHAuaGVhZGVycyA9IHtcbiAgICAgICAgcHV0OiBqc29uVHlwZSxcbiAgICAgICAgcG9zdDoganNvblR5cGUsXG4gICAgICAgIHBhdGNoOiBqc29uVHlwZSxcbiAgICAgICAgZGVsZXRlOiBqc29uVHlwZSxcbiAgICAgICAgY29tbW9uOiB7J0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonfSxcbiAgICAgICAgY3VzdG9tOiB7J1gtUmVxdWVzdGVkLVdpdGgnOiAnWE1MSHR0cFJlcXVlc3QnfVxuICAgIH07XG5cbiAgICBbJ2dldCcsICdwdXQnLCAncG9zdCcsICdwYXRjaCcsICdkZWxldGUnLCAnanNvbnAnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcblxuICAgICAgICBIdHRwW21ldGhvZF0gPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBzdWNjZXNzLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gc3VjY2VzcztcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcyh1cmwsIF8uZXh0ZW5kKHttZXRob2Q6IG1ldGhvZCwgZGF0YTogZGF0YSwgc3VjY2Vzczogc3VjY2Vzc30sIG9wdGlvbnMpKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBfLmh0dHAgPSBIdHRwO1xufTtcbiIsIi8qKlxuICogSW5zdGFsbCBwbHVnaW4uXG4gKi9cblxuZnVuY3Rpb24gaW5zdGFsbChWdWUpIHtcblxuICAgIHZhciBfID0gcmVxdWlyZSgnLi9saWIvdXRpbCcpKFZ1ZSk7XG5cbiAgICBWdWUudXJsID0gcmVxdWlyZSgnLi91cmwnKShfKTtcbiAgICBWdWUuaHR0cCA9IHJlcXVpcmUoJy4vaHR0cCcpKF8pO1xuICAgIFZ1ZS5yZXNvdXJjZSA9IHJlcXVpcmUoJy4vcmVzb3VyY2UnKShfKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFZ1ZS5wcm90b3R5cGUsIHtcblxuICAgICAgICAkdXJsOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5vcHRpb25zKFZ1ZS51cmwsIHRoaXMsIHRoaXMuJG9wdGlvbnMudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAkaHR0cDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ub3B0aW9ucyhWdWUuaHR0cCwgdGhpcywgdGhpcy4kb3B0aW9ucy5odHRwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAkcmVzb3VyY2U6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBWdWUucmVzb3VyY2UuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG59XG5cbmlmICh3aW5kb3cuVnVlKSB7XG4gICAgVnVlLnVzZShpbnN0YWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnN0YWxsOyIsIi8qKlxuICogSlNPTlAgcmVxdWVzdC5cbiAqL1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vcHJvbWlzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfLCBvcHRpb25zKSB7XG5cbiAgICB2YXIgY2FsbGJhY2sgPSAnX2pzb25wJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyKSwgcmVzcG9uc2UgPSB7fSwgc2NyaXB0LCBib2R5O1xuXG4gICAgb3B0aW9ucy5wYXJhbXNbb3B0aW9ucy5qc29ucF0gPSBjYWxsYmFjaztcblxuICAgIGlmIChfLmlzRnVuY3Rpb24ob3B0aW9ucy5iZWZvcmVTZW5kKSkge1xuICAgICAgICBvcHRpb25zLmJlZm9yZVNlbmQuY2FsbCh0aGlzLCB7fSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IF8udXJsKG9wdGlvbnMpO1xuICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuXG4gICAgICAgIHdpbmRvd1tjYWxsYmFja10gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgYm9keSA9IGRhdGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgZGVsZXRlIHdpbmRvd1tjYWxsYmFja107XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAnbG9hZCcgJiYgIWJvZHkpIHtcbiAgICAgICAgICAgICAgICBldmVudC50eXBlID0gJ2Vycm9yJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzcG9uc2Uub2sgPSBldmVudC50eXBlICE9PSAnZXJyb3InO1xuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzID0gcmVzcG9uc2Uub2sgPyAyMDAgOiA0MDQ7XG4gICAgICAgICAgICByZXNwb25zZS5yZXNwb25zZVRleHQgPSBib2R5ID8gYm9keSA6IGV2ZW50LnR5cGU7XG5cbiAgICAgICAgICAgIChyZXNwb25zZS5vayA/IHJlc29sdmUgOiByZWplY3QpKHJlc3BvbnNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzY3JpcHQub25sb2FkID0gaGFuZGxlcjtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBoYW5kbGVyO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9KTtcblxufTtcbiIsIi8qKlxuICogUHJvbWlzZXMvQSsgcG9seWZpbGwgdjEuMS4wIChodHRwczovL2dpdGh1Yi5jb20vYnJhbXN0ZWluL3Byb21pcylcbiAqL1xuXG52YXIgUkVTT0xWRUQgPSAwO1xudmFyIFJFSkVDVEVEID0gMTtcbnZhciBQRU5ESU5HICA9IDI7XG5cbmZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcblxuICAgIHRoaXMuc3RhdGUgPSBQRU5ESU5HO1xuICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kZWZlcnJlZCA9IFtdO1xuXG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0b3IoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSh4KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KHIpO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbn1cblxuUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAocikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlamVjdChyKTtcbiAgICB9KTtcbn07XG5cblByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmVzb2x2ZSh4KTtcbiAgICB9KTtcbn07XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmIChpdGVyYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVyKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHg7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaXRlcmFibGVbaV0udGhlbihyZXNvbHZlcihpKSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZXJhYmxlW2ldLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxudmFyIHAgPSBQcm9taXNlLnByb3RvdHlwZTtcblxucC5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgaWYgKHByb21pc2Uuc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgaWYgKHggPT09IHByb21pc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2Ugc2V0dGxlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRoZW4gPSB4ICYmIHhbJ3RoZW4nXTtcblxuICAgICAgICAgICAgaWYgKHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhlbi5jYWxsKHgsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9taXNlLnN0YXRlID0gUkVTT0xWRUQ7XG4gICAgICAgIHByb21pc2UudmFsdWUgPSB4O1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH1cbn07XG5cbnAucmVqZWN0ID0gZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcblxuICAgIGlmIChwcm9taXNlLnN0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgICAgIGlmIChyZWFzb24gPT09IHByb21pc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2Ugc2V0dGxlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2Uuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHJlYXNvbjtcbiAgICAgICAgcHJvbWlzZS5ub3RpZnkoKTtcbiAgICB9XG59O1xuXG5wLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICBhc3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwcm9taXNlLnN0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICAgICAgICB3aGlsZSAocHJvbWlzZS5kZWZlcnJlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSBwcm9taXNlLmRlZmVycmVkLnNoaWZ0KCksXG4gICAgICAgICAgICAgICAgICAgIG9uUmVzb2x2ZWQgPSBkZWZlcnJlZFswXSxcbiAgICAgICAgICAgICAgICAgICAgb25SZWplY3RlZCA9IGRlZmVycmVkWzFdLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gZGVmZXJyZWRbMl0sXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCA9IGRlZmVycmVkWzNdO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2Uuc3RhdGUgPT09IFJFU09MVkVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uUmVzb2x2ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG9uUmVzb2x2ZWQuY2FsbCh1bmRlZmluZWQsIHByb21pc2UudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwcm9taXNlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvblJlamVjdGVkLmNhbGwodW5kZWZpbmVkLCBwcm9taXNlLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChwcm9taXNlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxucC5jYXRjaCA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xufTtcblxucC50aGVuID0gZnVuY3Rpb24gdGhlbihvblJlc29sdmVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcHJvbWlzZS5kZWZlcnJlZC5wdXNoKFtvblJlc29sdmVkLCBvblJlamVjdGVkLCByZXNvbHZlLCByZWplY3RdKTtcbiAgICAgICAgcHJvbWlzZS5ub3RpZnkoKTtcbiAgICB9KTtcbn07XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFzeW5jID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgcXVldWUucHVzaChjYWxsYmFjayk7XG5cbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGFzeW5jLmFzeW5jKCk7XG4gICAgfVxufTtcblxuYXN5bmMucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWVbMF0oKTtcbiAgICAgICAgcXVldWUuc2hpZnQoKTtcbiAgICB9XG59O1xuXG5pZiAod2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgbW8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcihhc3luYy5ydW4pO1xuXG4gICAgbW8ub2JzZXJ2ZShlbCwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlXG4gICAgfSk7XG5cbiAgICBhc3luYy5hc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwieFwiLCAwKTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBhc3luYy5hc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChhc3luYy5ydW4pO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luZG93LlByb21pc2UgfHwgUHJvbWlzZTtcbiIsIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVnVlKSB7XG5cbiAgICB2YXIgXyA9IFZ1ZS51dGlsLmV4dGVuZCh7fSwgVnVlLnV0aWwpO1xuXG4gICAgXy5pc1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9O1xuXG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgfTtcblxuICAgIF8ub3B0aW9ucyA9IGZ1bmN0aW9uIChmbiwgb2JqLCBvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMuY2FsbChvYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKGZuLmJpbmQoe3ZtOiBvYmosIG9wdGlvbnM6IG9wdGlvbnN9KSwgZm4sIHtvcHRpb25zOiBvcHRpb25zfSk7XG4gICAgfTtcblxuICAgIF8uZWFjaCA9IGZ1bmN0aW9uIChvYmosIGl0ZXJhdG9yKSB7XG5cbiAgICAgICAgdmFyIGksIGtleTtcblxuICAgICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKG9ialtpXSwgb2JqW2ldLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKG9ialtrZXldLCBvYmpba2V5XSwga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICBfLmV4dGVuZCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblxuICAgICAgICB2YXIgYXJyYXkgPSBbXSwgYXJncyA9IGFycmF5LnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZGVlcDtcblxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGRlZXAgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0YXJnZXQgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgZXh0ZW5kKHRhcmdldCwgYXJnLCBkZWVwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlLCBkZWVwKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChkZWVwICYmIChfLmlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pIHx8IF8uaXNBcnJheShzb3VyY2Vba2V5XSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgJiYgIV8uaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNBcnJheShzb3VyY2Vba2V5XSkgJiYgIV8uaXNBcnJheSh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXh0ZW5kKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgZGVlcCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF87XG59O1xuIiwiLyoqXG4gKiBYTUxIdHRwIHJlcXVlc3QuXG4gKi9cblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL3Byb21pc2UnKTtcbnZhciBYRG9tYWluID0gd2luZG93LlhEb21haW5SZXF1ZXN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfLCBvcHRpb25zKSB7XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLCBwcm9taXNlO1xuXG4gICAgaWYgKFhEb21haW4gJiYgb3B0aW9ucy5jcm9zc09yaWdpbikge1xuICAgICAgICByZXF1ZXN0ID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7IG9wdGlvbnMuaGVhZGVycyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy54aHIpKSB7XG4gICAgICAgIF8uZXh0ZW5kKHJlcXVlc3QsIG9wdGlvbnMueGhyKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9wdGlvbnMuYmVmb3JlU2VuZCkpIHtcbiAgICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kLmNhbGwodGhpcywgcmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICByZXF1ZXN0Lm9wZW4ob3B0aW9ucy5tZXRob2QsIF8udXJsKG9wdGlvbnMpLCB0cnVlKTtcblxuICAgICAgICBfLmVhY2gob3B0aW9ucy5oZWFkZXJzLCBmdW5jdGlvbiAodmFsdWUsIGhlYWRlcikge1xuICAgICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9rID0gZXZlbnQudHlwZSA9PT0gJ2xvYWQnO1xuXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5vayAmJiByZXF1ZXN0LnN0YXR1cykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub2sgPSByZXF1ZXN0LnN0YXR1cyA+PSAyMDAgJiYgcmVxdWVzdC5zdGF0dXMgPCAzMDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIChyZXF1ZXN0Lm9rID8gcmVzb2x2ZSA6IHJlamVjdCkocmVxdWVzdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBoYW5kbGVyO1xuICAgICAgICByZXF1ZXN0Lm9uYWJvcnQgPSBoYW5kbGVyO1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBoYW5kbGVyO1xuXG4gICAgICAgIHJlcXVlc3Quc2VuZChvcHRpb25zLmRhdGEpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuIiwiLyoqXG4gKiBTZXJ2aWNlIGZvciBpbnRlcmFjdGluZyB3aXRoIFJFU1RmdWwgc2VydmljZXMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoXykge1xuXG4gICAgZnVuY3Rpb24gUmVzb3VyY2UodXJsLCBwYXJhbXMsIGFjdGlvbnMsIG9wdGlvbnMpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIHJlc291cmNlID0ge307XG5cbiAgICAgICAgYWN0aW9ucyA9IF8uZXh0ZW5kKHt9LFxuICAgICAgICAgICAgUmVzb3VyY2UuYWN0aW9ucyxcbiAgICAgICAgICAgIGFjdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICBfLmVhY2goYWN0aW9ucywgZnVuY3Rpb24gKGFjdGlvbiwgbmFtZSkge1xuXG4gICAgICAgICAgICBhY3Rpb24gPSBfLmV4dGVuZCh0cnVlLCB7dXJsOiB1cmwsIHBhcmFtczogcGFyYW1zIHx8IHt9fSwgb3B0aW9ucywgYWN0aW9uKTtcblxuICAgICAgICAgICAgcmVzb3VyY2VbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzZWxmLiRodHRwIHx8IF8uaHR0cCkob3B0cyhhY3Rpb24sIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc291cmNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9wdHMoYWN0aW9uLCBhcmdzKSB7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgYWN0aW9uKSwgcGFyYW1zID0ge30sIGRhdGEsIHN1Y2Nlc3MsIGVycm9yO1xuXG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgY2FzZSA0OlxuXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBhcmdzWzNdO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBhcmdzWzJdO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlIDI6XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGFyZ3NbMV0pKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihhcmdzWzBdKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gYXJnc1sxXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gYXJnc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBhcmdzWzJdO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXJnc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IGFyZ3NbMl07XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIDE6XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoL14oUE9TVHxQVVR8UEFUQ0gpJC9pLnRlc3Qob3B0aW9ucy5tZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMDpcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHVwIHRvIDQgYXJndW1lbnRzIFtwYXJhbXMsIGRhdGEsIHN1Y2Nlc3MsIGVycm9yXSwgZ290ICcgKyBhcmdzLmxlbmd0aCArICcgYXJndW1lbnRzJztcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMuZGF0YSA9IGRhdGE7XG4gICAgICAgIG9wdGlvbnMucGFyYW1zID0gXy5leHRlbmQoe30sIG9wdGlvbnMucGFyYW1zLCBwYXJhbXMpO1xuXG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBzdWNjZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBvcHRpb25zLmVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBSZXNvdXJjZS5hY3Rpb25zID0ge1xuXG4gICAgICAgIGdldDoge21ldGhvZDogJ0dFVCd9LFxuICAgICAgICBzYXZlOiB7bWV0aG9kOiAnUE9TVCd9LFxuICAgICAgICBxdWVyeToge21ldGhvZDogJ0dFVCd9LFxuICAgICAgICB1cGRhdGU6IHttZXRob2Q6ICdQVVQnfSxcbiAgICAgICAgcmVtb3ZlOiB7bWV0aG9kOiAnREVMRVRFJ30sXG4gICAgICAgIGRlbGV0ZToge21ldGhvZDogJ0RFTEVURSd9XG5cbiAgICB9O1xuXG4gICAgcmV0dXJuIF8ucmVzb3VyY2UgPSBSZXNvdXJjZTtcbn07XG4iLCIvKipcbiAqIFNlcnZpY2UgZm9yIFVSTCB0ZW1wbGF0aW5nLlxuICovXG5cbnZhciBpZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbnZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoXykge1xuXG4gICAgZnVuY3Rpb24gVXJsKHVybCwgcGFyYW1zKSB7XG5cbiAgICAgICAgdmFyIHVybFBhcmFtcyA9IHt9LCBxdWVyeVBhcmFtcyA9IHt9LCBvcHRpb25zID0gdXJsLCBxdWVyeTtcblxuICAgICAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt1cmw6IHVybCwgcGFyYW1zOiBwYXJhbXN9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHRydWUsIHt9LFxuICAgICAgICAgICAgVXJsLm9wdGlvbnMsIHRoaXMub3B0aW9ucywgb3B0aW9uc1xuICAgICAgICApO1xuXG4gICAgICAgIHVybCA9IG9wdGlvbnMudXJsLnJlcGxhY2UoLyhcXC8/KTooW2Etel1cXHcqKS9naSwgZnVuY3Rpb24gKG1hdGNoLCBzbGFzaCwgbmFtZSkge1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJhbXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzbGFzaCArIGVuY29kZVVyaVNlZ21lbnQob3B0aW9ucy5wYXJhbXNbbmFtZV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChfLmlzU3RyaW5nKG9wdGlvbnMucm9vdCkgJiYgIXVybC5tYXRjaCgvXihodHRwcz86KT9cXC8vKSkge1xuICAgICAgICAgICAgdXJsID0gb3B0aW9ucy5yb290ICsgJy8nICsgdXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5lYWNoKG9wdGlvbnMucGFyYW1zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgaWYgKCF1cmxQYXJhbXNba2V5XSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcXVlcnkgPSBVcmwucGFyYW1zKHF1ZXJ5UGFyYW1zKTtcblxuICAgICAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PSAtMSA/ICc/JyA6ICcmJykgKyBxdWVyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXJsIG9wdGlvbnMuXG4gICAgICovXG5cbiAgICBVcmwub3B0aW9ucyA9IHtcbiAgICAgICAgdXJsOiAnJyxcbiAgICAgICAgcm9vdDogbnVsbCxcbiAgICAgICAgcGFyYW1zOiB7fVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGEgVXJsIHBhcmFtZXRlciBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICovXG5cbiAgICBVcmwucGFyYW1zID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgICAgICBwYXJhbXMuYWRkID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblxuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbiAodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnB1c2goZW5jb2RlVXJpU2VnbWVudChrZXkpICsgJz0nICsgZW5jb2RlVXJpU2VnbWVudCh2YWx1ZSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlcmlhbGl6ZShwYXJhbXMsIG9iaik7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5qb2luKCcmJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgVVJMIGFuZCByZXR1cm4gaXRzIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAgICovXG5cbiAgICBVcmwucGFyc2UgPSBmdW5jdGlvbiAodXJsKSB7XG5cbiAgICAgICAgaWYgKGllKSB7XG4gICAgICAgICAgICBlbC5ocmVmID0gdXJsO1xuICAgICAgICAgICAgdXJsID0gZWwuaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLmhyZWYgPSB1cmw7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhyZWY6IGVsLmhyZWYsXG4gICAgICAgICAgICBwcm90b2NvbDogZWwucHJvdG9jb2wgPyBlbC5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgICAgcG9ydDogZWwucG9ydCxcbiAgICAgICAgICAgIGhvc3Q6IGVsLmhvc3QsXG4gICAgICAgICAgICBob3N0bmFtZTogZWwuaG9zdG5hbWUsXG4gICAgICAgICAgICBwYXRobmFtZTogZWwucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycgPyBlbC5wYXRobmFtZSA6ICcvJyArIGVsLnBhdGhuYW1lLFxuICAgICAgICAgICAgc2VhcmNoOiBlbC5zZWFyY2ggPyBlbC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgICAgaGFzaDogZWwuaGFzaCA/IGVsLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJ1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXJpYWxpemUocGFyYW1zLCBvYmosIHNjb3BlKSB7XG5cbiAgICAgICAgdmFyIGFycmF5ID0gXy5pc0FycmF5KG9iaiksIHBsYWluID0gXy5pc1BsYWluT2JqZWN0KG9iaiksIGhhc2g7XG5cbiAgICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblxuICAgICAgICAgICAgaGFzaCA9IF8uaXNPYmplY3QodmFsdWUpIHx8IF8uaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgICAgIGtleSA9IHNjb3BlICsgJ1snICsgKHBsYWluIHx8IGhhc2ggPyBrZXkgOiAnJykgKyAnXSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc2NvcGUgJiYgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYWRkKHZhbHVlLm5hbWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzaCkge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZShwYXJhbXMsIHZhbHVlLCBrZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYWRkKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmNvZGVVcmlTZWdtZW50KHZhbHVlKSB7XG5cbiAgICAgICAgcmV0dXJuIGVuY29kZVVyaVF1ZXJ5KHZhbHVlLCB0cnVlKS5cbiAgICAgICAgICAgIHJlcGxhY2UoLyUyNi9naSwgJyYnKS5cbiAgICAgICAgICAgIHJlcGxhY2UoLyUzRC9naSwgJz0nKS5cbiAgICAgICAgICAgIHJlcGxhY2UoLyUyQi9naSwgJysnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmNvZGVVcmlRdWVyeSh2YWx1ZSwgc3BhY2VzKSB7XG5cbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkuXG4gICAgICAgICAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgICAgICAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgICAgICAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICAgICAgICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICAgICAgICAgIHJlcGxhY2UoLyUyMC9nLCAoc3BhY2VzID8gJyUyMCcgOiAnKycpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXy51cmwgPSBVcmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmFiZWxIZWxwZXJzID0ge307XG5cbmJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gVGFyZ2V0KHBhdGgsIG1hdGNoZXIsIGRlbGVnYXRlKSB7XG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIHRoaXMubWF0Y2hlciA9IG1hdGNoZXI7XG4gIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbn1cblxuVGFyZ2V0LnByb3RvdHlwZSA9IHtcbiAgdG86IGZ1bmN0aW9uIHRvKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGVsZWdhdGUgPSB0aGlzLmRlbGVnYXRlO1xuXG4gICAgaWYgKGRlbGVnYXRlICYmIGRlbGVnYXRlLndpbGxBZGRSb3V0ZSkge1xuICAgICAgdGFyZ2V0ID0gZGVsZWdhdGUud2lsbEFkZFJvdXRlKHRoaXMubWF0Y2hlci50YXJnZXQsIHRhcmdldCk7XG4gICAgfVxuXG4gICAgdGhpcy5tYXRjaGVyLmFkZCh0aGlzLnBhdGgsIHRhcmdldCk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGlmIChjYWxsYmFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgaGF2ZSBhbiBhcmd1bWVudCBpbiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGB0b2BcIik7XG4gICAgICB9XG4gICAgICB0aGlzLm1hdGNoZXIuYWRkQ2hpbGQodGhpcy5wYXRoLCB0YXJnZXQsIGNhbGxiYWNrLCB0aGlzLmRlbGVnYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIE1hdGNoZXIodGFyZ2V0KSB7XG4gIHRoaXMucm91dGVzID0ge307XG4gIHRoaXMuY2hpbGRyZW4gPSB7fTtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbk1hdGNoZXIucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChwYXRoLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5yb3V0ZXNbcGF0aF0gPSBoYW5kbGVyO1xuICB9LFxuXG4gIGFkZENoaWxkOiBmdW5jdGlvbiBhZGRDaGlsZChwYXRoLCB0YXJnZXQsIGNhbGxiYWNrLCBkZWxlZ2F0ZSkge1xuICAgIHZhciBtYXRjaGVyID0gbmV3IE1hdGNoZXIodGFyZ2V0KTtcbiAgICB0aGlzLmNoaWxkcmVuW3BhdGhdID0gbWF0Y2hlcjtcblxuICAgIHZhciBtYXRjaCA9IGdlbmVyYXRlTWF0Y2gocGF0aCwgbWF0Y2hlciwgZGVsZWdhdGUpO1xuXG4gICAgaWYgKGRlbGVnYXRlICYmIGRlbGVnYXRlLmNvbnRleHRFbnRlcmVkKSB7XG4gICAgICBkZWxlZ2F0ZS5jb250ZXh0RW50ZXJlZCh0YXJnZXQsIG1hdGNoKTtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhtYXRjaCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTWF0Y2goc3RhcnRpbmdQYXRoLCBtYXRjaGVyLCBkZWxlZ2F0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHBhdGgsIG5lc3RlZENhbGxiYWNrKSB7XG4gICAgdmFyIGZ1bGxQYXRoID0gc3RhcnRpbmdQYXRoICsgcGF0aDtcblxuICAgIGlmIChuZXN0ZWRDYWxsYmFjaykge1xuICAgICAgbmVzdGVkQ2FsbGJhY2soZ2VuZXJhdGVNYXRjaChmdWxsUGF0aCwgbWF0Y2hlciwgZGVsZWdhdGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoc3RhcnRpbmdQYXRoICsgcGF0aCwgbWF0Y2hlciwgZGVsZWdhdGUpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkUm91dGUocm91dGVBcnJheSwgcGF0aCwgaGFuZGxlcikge1xuICB2YXIgbGVuID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSByb3V0ZUFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxlbiArPSByb3V0ZUFycmF5W2ldLnBhdGgubGVuZ3RoO1xuICB9XG5cbiAgcGF0aCA9IHBhdGguc3Vic3RyKGxlbik7XG4gIHZhciByb3V0ZSA9IHsgcGF0aDogcGF0aCwgaGFuZGxlcjogaGFuZGxlciB9O1xuICByb3V0ZUFycmF5LnB1c2gocm91dGUpO1xufVxuXG5mdW5jdGlvbiBlYWNoUm91dGUoYmFzZVJvdXRlLCBtYXRjaGVyLCBjYWxsYmFjaywgYmluZGluZykge1xuICB2YXIgcm91dGVzID0gbWF0Y2hlci5yb3V0ZXM7XG5cbiAgZm9yICh2YXIgcGF0aCBpbiByb3V0ZXMpIHtcbiAgICBpZiAocm91dGVzLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgICB2YXIgcm91dGVBcnJheSA9IGJhc2VSb3V0ZS5zbGljZSgpO1xuICAgICAgYWRkUm91dGUocm91dGVBcnJheSwgcGF0aCwgcm91dGVzW3BhdGhdKTtcblxuICAgICAgaWYgKG1hdGNoZXIuY2hpbGRyZW5bcGF0aF0pIHtcbiAgICAgICAgZWFjaFJvdXRlKHJvdXRlQXJyYXksIG1hdGNoZXIuY2hpbGRyZW5bcGF0aF0sIGNhbGxiYWNrLCBiaW5kaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwoYmluZGluZywgcm91dGVBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcCAoY2FsbGJhY2ssIGFkZFJvdXRlQ2FsbGJhY2spIHtcbiAgdmFyIG1hdGNoZXIgPSBuZXcgTWF0Y2hlcigpO1xuXG4gIGNhbGxiYWNrKGdlbmVyYXRlTWF0Y2goXCJcIiwgbWF0Y2hlciwgdGhpcy5kZWxlZ2F0ZSkpO1xuXG4gIGVhY2hSb3V0ZShbXSwgbWF0Y2hlciwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgaWYgKGFkZFJvdXRlQ2FsbGJhY2spIHtcbiAgICAgIGFkZFJvdXRlQ2FsbGJhY2sodGhpcywgcm91dGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChyb3V0ZSk7XG4gICAgfVxuICB9LCB0aGlzKTtcbn1cblxudmFyIHNwZWNpYWxzID0gWycvJywgJy4nLCAnKicsICcrJywgJz8nLCAnfCcsICcoJywgJyknLCAnWycsICddJywgJ3snLCAnfScsICdcXFxcJ107XG5cbnZhciBlc2NhcGVSZWdleCA9IG5ldyBSZWdFeHAoJyhcXFxcJyArIHNwZWNpYWxzLmpvaW4oJ3xcXFxcJykgKyAnKScsICdnJyk7XG5cbmZ1bmN0aW9uIGlzQXJyYXkodGVzdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRlc3QpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG59XG5cbi8vIEEgU2VnbWVudCByZXByZXNlbnRzIGEgc2VnbWVudCBpbiB0aGUgb3JpZ2luYWwgcm91dGUgZGVzY3JpcHRpb24uXG4vLyBFYWNoIFNlZ21lbnQgdHlwZSBwcm92aWRlcyBhbiBgZWFjaENoYXJgIGFuZCBgcmVnZXhgIG1ldGhvZC5cbi8vXG4vLyBUaGUgYGVhY2hDaGFyYCBtZXRob2QgaW52b2tlcyB0aGUgY2FsbGJhY2sgd2l0aCBvbmUgb3IgbW9yZSBjaGFyYWN0ZXJcbi8vIHNwZWNpZmljYXRpb25zLiBBIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGNvbnN1bWVzIG9uZSBvciBtb3JlIGlucHV0XG4vLyBjaGFyYWN0ZXJzLlxuLy9cbi8vIFRoZSBgcmVnZXhgIG1ldGhvZCByZXR1cm5zIGEgcmVnZXggZnJhZ21lbnQgZm9yIHRoZSBzZWdtZW50LiBJZiB0aGVcbi8vIHNlZ21lbnQgaXMgYSBkeW5hbWljIG9mIHN0YXIgc2VnbWVudCwgdGhlIHJlZ2V4IGZyYWdtZW50IGFsc28gaW5jbHVkZXNcbi8vIGEgY2FwdHVyZS5cbi8vXG4vLyBBIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGNvbnRhaW5zOlxuLy9cbi8vICogYHZhbGlkQ2hhcnNgOiBhIFN0cmluZyB3aXRoIGEgbGlzdCBvZiBhbGwgdmFsaWQgY2hhcmFjdGVycywgb3Jcbi8vICogYGludmFsaWRDaGFyc2A6IGEgU3RyaW5nIHdpdGggYSBsaXN0IG9mIGFsbCBpbnZhbGlkIGNoYXJhY3RlcnNcbi8vICogYHJlcGVhdGA6IHRydWUgaWYgdGhlIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGNhbiByZXBlYXRcblxuZnVuY3Rpb24gU3RhdGljU2VnbWVudChzdHJpbmcpIHtcbiAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG59XG5TdGF0aWNTZWdtZW50LnByb3RvdHlwZSA9IHtcbiAgZWFjaENoYXI6IGZ1bmN0aW9uIGVhY2hDaGFyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0cmluZyA9IHRoaXMuc3RyaW5nLFxuICAgICAgICBjaDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2ggPSBzdHJpbmcuY2hhckF0KGkpO1xuICAgICAgY2FsbGJhY2soeyB2YWxpZENoYXJzOiBjaCB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnZXg6IGZ1bmN0aW9uIHJlZ2V4KCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZy5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAnXFxcXCQxJyk7XG4gIH0sXG5cbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZztcbiAgfVxufTtcblxuZnVuY3Rpb24gRHluYW1pY1NlZ21lbnQobmFtZSkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xufVxuRHluYW1pY1NlZ21lbnQucHJvdG90eXBlID0ge1xuICBlYWNoQ2hhcjogZnVuY3Rpb24gZWFjaENoYXIoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh7IGludmFsaWRDaGFyczogXCIvXCIsIHJlcGVhdDogdHJ1ZSB9KTtcbiAgfSxcblxuICByZWdleDogZnVuY3Rpb24gcmVnZXgoKSB7XG4gICAgcmV0dXJuIFwiKFteL10rKVwiO1xuICB9LFxuXG4gIGdlbmVyYXRlOiBmdW5jdGlvbiBnZW5lcmF0ZShwYXJhbXMpIHtcbiAgICByZXR1cm4gcGFyYW1zW3RoaXMubmFtZV07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFN0YXJTZWdtZW50KG5hbWUpIHtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbn1cblN0YXJTZWdtZW50LnByb3RvdHlwZSA9IHtcbiAgZWFjaENoYXI6IGZ1bmN0aW9uIGVhY2hDaGFyKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soeyBpbnZhbGlkQ2hhcnM6IFwiXCIsIHJlcGVhdDogdHJ1ZSB9KTtcbiAgfSxcblxuICByZWdleDogZnVuY3Rpb24gcmVnZXgoKSB7XG4gICAgcmV0dXJuIFwiKC4rKVwiO1xuICB9LFxuXG4gIGdlbmVyYXRlOiBmdW5jdGlvbiBnZW5lcmF0ZShwYXJhbXMpIHtcbiAgICByZXR1cm4gcGFyYW1zW3RoaXMubmFtZV07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIEVwc2lsb25TZWdtZW50KCkge31cbkVwc2lsb25TZWdtZW50LnByb3RvdHlwZSA9IHtcbiAgZWFjaENoYXI6IGZ1bmN0aW9uIGVhY2hDaGFyKCkge30sXG4gIHJlZ2V4OiBmdW5jdGlvbiByZWdleCgpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfSxcbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXJzZShyb3V0ZSwgbmFtZXMsIHNwZWNpZmljaXR5KSB7XG4gIC8vIG5vcm1hbGl6ZSByb3V0ZSBhcyBub3Qgc3RhcnRpbmcgd2l0aCBhIFwiL1wiLiBSZWNvZ25pdGlvbiB3aWxsXG4gIC8vIGFsc28gbm9ybWFsaXplLlxuICBpZiAocm91dGUuY2hhckF0KDApID09PSBcIi9cIikge1xuICAgIHJvdXRlID0gcm91dGUuc3Vic3RyKDEpO1xuICB9XG5cbiAgdmFyIHNlZ21lbnRzID0gcm91dGUuc3BsaXQoXCIvXCIpLFxuICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gIC8vIEEgcm91dGVzIGhhcyBzcGVjaWZpY2l0eSBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGF0IGl0cyBkaWZmZXJlbnQgc2VnbWVudHNcbiAgLy8gYXBwZWFyIGluLiBUaGlzIHN5c3RlbSBtaXJyb3JzIGhvdyB0aGUgbWFnbml0dWRlIG9mIG51bWJlcnMgd3JpdHRlbiBhcyBzdHJpbmdzXG4gIC8vIHdvcmtzLlxuICAvLyBDb25zaWRlciBhIG51bWJlciB3cml0dGVuIGFzOiBcImFiY1wiLiBBbiBleGFtcGxlIHdvdWxkIGJlIFwiMjAwXCIuIEFueSBvdGhlciBudW1iZXIgd3JpdHRlblxuICAvLyBcInh5elwiIHdpbGwgYmUgc21hbGxlciB0aGFuIFwiYWJjXCIgc28gbG9uZyBhcyBgYSA+IHpgLiBGb3IgaW5zdGFuY2UsIFwiMTk5XCIgaXMgc21hbGxlclxuICAvLyB0aGVuIFwiMjAwXCIsIGV2ZW4gdGhvdWdoIFwieVwiIGFuZCBcInpcIiAod2hpY2ggYXJlIGJvdGggOSkgYXJlIGxhcmdlciB0aGFuIFwiMFwiICh0aGUgdmFsdWVcbiAgLy8gb2YgKGBiYCBhbmQgYGNgKS4gVGhpcyBpcyBiZWNhdXNlIHRoZSBsZWFkaW5nIHN5bWJvbCwgXCIyXCIsIGlzIGxhcmdlciB0aGFuIHRoZSBvdGhlclxuICAvLyBsZWFkaW5nIHN5bWJvbCwgXCIxXCIuXG4gIC8vIFRoZSBydWxlIGlzIHRoYXQgc3ltYm9scyB0byB0aGUgbGVmdCBjYXJyeSBtb3JlIHdlaWdodCB0aGFuIHN5bWJvbHMgdG8gdGhlIHJpZ2h0XG4gIC8vIHdoZW4gYSBudW1iZXIgaXMgd3JpdHRlbiBvdXQgYXMgYSBzdHJpbmcuIEluIHRoZSBhYm92ZSBzdHJpbmdzLCB0aGUgbGVhZGluZyBkaWdpdFxuICAvLyByZXByZXNlbnRzIGhvdyBtYW55IDEwMCdzIGFyZSBpbiB0aGUgbnVtYmVyLCBhbmQgaXQgY2FycmllcyBtb3JlIHdlaWdodCB0aGFuIHRoZSBtaWRkbGVcbiAgLy8gbnVtYmVyIHdoaWNoIHJlcHJlc2VudHMgaG93IG1hbnkgMTAncyBhcmUgaW4gdGhlIG51bWJlci5cbiAgLy8gVGhpcyBzeXN0ZW0gb2YgbnVtYmVyIG1hZ25pdHVkZSB3b3JrcyB3ZWxsIGZvciByb3V0ZSBzcGVjaWZpY2l0eSwgdG9vLiBBIHJvdXRlIHdyaXR0ZW4gYXNcbiAgLy8gYGEvYi9jYCB3aWxsIGJlIG1vcmUgc3BlY2lmaWMgdGhhbiBgeC95L3pgIGFzIGxvbmcgYXMgYGFgIGlzIG1vcmUgc3BlY2lmaWMgdGhhblxuICAvLyBgeGAsIGlycmVzcGVjdGl2ZSBvZiB0aGUgb3RoZXIgcGFydHMuXG4gIC8vIEJlY2F1c2Ugb2YgdGhpcyBzaW1pbGFyaXR5LCB3ZSBhc3NpZ24gZWFjaCB0eXBlIG9mIHNlZ21lbnQgYSBudW1iZXIgdmFsdWUgd3JpdHRlbiBhcyBhXG4gIC8vIHN0cmluZy4gV2UgY2FuIGZpbmQgdGhlIHNwZWNpZmljaXR5IG9mIGNvbXBvdW5kIHJvdXRlcyBieSBjb25jYXRlbmF0aW5nIHRoZXNlIHN0cmluZ3NcbiAgLy8gdG9nZXRoZXIsIGZyb20gbGVmdCB0byByaWdodC4gQWZ0ZXIgd2UgaGF2ZSBsb29wZWQgdGhyb3VnaCBhbGwgb2YgdGhlIHNlZ21lbnRzLFxuICAvLyB3ZSBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gYSBudW1iZXIuXG4gIHNwZWNpZmljaXR5LnZhbCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXSxcbiAgICAgICAgbWF0Y2g7XG5cbiAgICBpZiAobWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eOihbXlxcL10rKSQvKSkge1xuICAgICAgcmVzdWx0cy5wdXNoKG5ldyBEeW5hbWljU2VnbWVudChtYXRjaFsxXSkpO1xuICAgICAgbmFtZXMucHVzaChtYXRjaFsxXSk7XG4gICAgICBzcGVjaWZpY2l0eS52YWwgKz0gJzMnO1xuICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eXFwqKFteXFwvXSspJC8pKSB7XG4gICAgICByZXN1bHRzLnB1c2gobmV3IFN0YXJTZWdtZW50KG1hdGNoWzFdKSk7XG4gICAgICBzcGVjaWZpY2l0eS52YWwgKz0gJzInO1xuICAgICAgbmFtZXMucHVzaChtYXRjaFsxXSk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ID09PSBcIlwiKSB7XG4gICAgICByZXN1bHRzLnB1c2gobmV3IEVwc2lsb25TZWdtZW50KCkpO1xuICAgICAgc3BlY2lmaWNpdHkudmFsICs9ICcxJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0cy5wdXNoKG5ldyBTdGF0aWNTZWdtZW50KHNlZ21lbnQpKTtcbiAgICAgIHNwZWNpZmljaXR5LnZhbCArPSAnNCc7XG4gICAgfVxuICB9XG5cbiAgc3BlY2lmaWNpdHkudmFsID0gK3NwZWNpZmljaXR5LnZhbDtcblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuLy8gQSBTdGF0ZSBoYXMgYSBjaGFyYWN0ZXIgc3BlY2lmaWNhdGlvbiBhbmQgKGBjaGFyU3BlY2ApIGFuZCBhIGxpc3Qgb2YgcG9zc2libGVcbi8vIHN1YnNlcXVlbnQgc3RhdGVzIChgbmV4dFN0YXRlc2ApLlxuLy9cbi8vIElmIGEgU3RhdGUgaXMgYW4gYWNjZXB0aW5nIHN0YXRlLCBpdCB3aWxsIGFsc28gaGF2ZSBzZXZlcmFsIGFkZGl0aW9uYWxcbi8vIHByb3BlcnRpZXM6XG4vL1xuLy8gKiBgcmVnZXhgOiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IGlzIHVzZWQgdG8gZXh0cmFjdCBwYXJhbWV0ZXJzIGZyb20gcGF0aHNcbi8vICAgdGhhdCByZWFjaGVkIHRoaXMgYWNjZXB0aW5nIHN0YXRlLlxuLy8gKiBgaGFuZGxlcnNgOiBJbmZvcm1hdGlvbiBvbiBob3cgdG8gY29udmVydCB0aGUgbGlzdCBvZiBjYXB0dXJlcyBpbnRvIGNhbGxzXG4vLyAgIHRvIHJlZ2lzdGVyZWQgaGFuZGxlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnNcbi8vICogYHR5cGVzYDogSG93IG1hbnkgc3RhdGljLCBkeW5hbWljIG9yIHN0YXIgc2VnbWVudHMgaW4gdGhpcyByb3V0ZS4gVXNlZCB0b1xuLy8gICBkZWNpZGUgd2hpY2ggcm91dGUgdG8gdXNlIGlmIG11bHRpcGxlIHJlZ2lzdGVyZWQgcm91dGVzIG1hdGNoIGEgcGF0aC5cbi8vXG4vLyBDdXJyZW50bHksIFN0YXRlIGlzIGltcGxlbWVudGVkIG5haXZlbHkgYnkgbG9vcGluZyBvdmVyIGBuZXh0U3RhdGVzYCBhbmRcbi8vIGNvbXBhcmluZyBhIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGFnYWluc3QgYSBjaGFyYWN0ZXIuIEEgbW9yZSBlZmZpY2llbnRcbi8vIGltcGxlbWVudGF0aW9uIHdvdWxkIHVzZSBhIGhhc2ggb2Yga2V5cyBwb2ludGluZyBhdCBvbmUgb3IgbW9yZSBuZXh0IHN0YXRlcy5cblxuZnVuY3Rpb24gU3RhdGUoY2hhclNwZWMpIHtcbiAgdGhpcy5jaGFyU3BlYyA9IGNoYXJTcGVjO1xuICB0aGlzLm5leHRTdGF0ZXMgPSBbXTtcbn1cblxuU3RhdGUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uIGdldChjaGFyU3BlYykge1xuICAgIHZhciBuZXh0U3RhdGVzID0gdGhpcy5uZXh0U3RhdGVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBuZXh0U3RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbmV4dFN0YXRlc1tpXTtcblxuICAgICAgdmFyIGlzRXF1YWwgPSBjaGlsZC5jaGFyU3BlYy52YWxpZENoYXJzID09PSBjaGFyU3BlYy52YWxpZENoYXJzO1xuICAgICAgaXNFcXVhbCA9IGlzRXF1YWwgJiYgY2hpbGQuY2hhclNwZWMuaW52YWxpZENoYXJzID09PSBjaGFyU3BlYy5pbnZhbGlkQ2hhcnM7XG5cbiAgICAgIGlmIChpc0VxdWFsKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcHV0OiBmdW5jdGlvbiBwdXQoY2hhclNwZWMpIHtcbiAgICB2YXIgc3RhdGU7XG5cbiAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIHNwZWNpZmljYXRpb24gYWxyZWFkeSBleGlzdHMgaW4gYSBjaGlsZCBvZiB0aGUgY3VycmVudFxuICAgIC8vIHN0YXRlLCBqdXN0IHJldHVybiB0aGF0IHN0YXRlLlxuICAgIGlmIChzdGF0ZSA9IHRoaXMuZ2V0KGNoYXJTcGVjKSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIC8vIE1ha2UgYSBuZXcgc3RhdGUgZm9yIHRoZSBjaGFyYWN0ZXIgc3BlY1xuICAgIHN0YXRlID0gbmV3IFN0YXRlKGNoYXJTcGVjKTtcblxuICAgIC8vIEluc2VydCB0aGUgbmV3IHN0YXRlIGFzIGEgY2hpbGQgb2YgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICB0aGlzLm5leHRTdGF0ZXMucHVzaChzdGF0ZSk7XG5cbiAgICAvLyBJZiB0aGlzIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIHJlcGVhdHMsIGluc2VydCB0aGUgbmV3IHN0YXRlIGFzIGEgY2hpbGRcbiAgICAvLyBvZiBpdHNlbGYuIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IHRyaWdnZXIgYW4gaW5maW5pdGUgbG9vcCBiZWNhdXNlIGVhY2hcbiAgICAvLyB0cmFuc2l0aW9uIGR1cmluZyByZWNvZ25pdGlvbiBjb25zdW1lcyBhIGNoYXJhY3Rlci5cbiAgICBpZiAoY2hhclNwZWMucmVwZWF0KSB7XG4gICAgICBzdGF0ZS5uZXh0U3RhdGVzLnB1c2goc3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgbmV3IHN0YXRlXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9LFxuXG4gIC8vIEZpbmQgYSBsaXN0IG9mIGNoaWxkIHN0YXRlcyBtYXRjaGluZyB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKGNoKSB7XG4gICAgLy8gREVCVUcgXCJQcm9jZXNzaW5nIGBcIiArIGNoICsgXCJgOlwiXG4gICAgdmFyIG5leHRTdGF0ZXMgPSB0aGlzLm5leHRTdGF0ZXMsXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBjaGFyU3BlYyxcbiAgICAgICAgY2hhcnM7XG5cbiAgICAvLyBERUJVRyBcIiAgXCIgKyBkZWJ1Z1N0YXRlKHRoaXMpXG4gICAgdmFyIHJldHVybmVkID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5leHRTdGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IG5leHRTdGF0ZXNbaV07XG5cbiAgICAgIGNoYXJTcGVjID0gY2hpbGQuY2hhclNwZWM7XG5cbiAgICAgIGlmICh0eXBlb2YgKGNoYXJzID0gY2hhclNwZWMudmFsaWRDaGFycykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChjaGFycy5pbmRleE9mKGNoKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm5lZC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKGNoYXJzID0gY2hhclNwZWMuaW52YWxpZENoYXJzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKGNoYXJzLmluZGV4T2YoY2gpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybmVkLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVybmVkO1xuICB9XG5cbiAgLyoqIElGIERFQlVHXG4gICwgZGVidWc6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaGFyU3BlYyA9IHRoaXMuY2hhclNwZWMsXG4gICAgICAgIGRlYnVnID0gXCJbXCIsXG4gICAgICAgIGNoYXJzID0gY2hhclNwZWMudmFsaWRDaGFycyB8fCBjaGFyU3BlYy5pbnZhbGlkQ2hhcnM7XG4gICAgIGlmIChjaGFyU3BlYy5pbnZhbGlkQ2hhcnMpIHsgZGVidWcgKz0gXCJeXCI7IH1cbiAgICBkZWJ1ZyArPSBjaGFycztcbiAgICBkZWJ1ZyArPSBcIl1cIjtcbiAgICAgaWYgKGNoYXJTcGVjLnJlcGVhdCkgeyBkZWJ1ZyArPSBcIitcIjsgfVxuICAgICByZXR1cm4gZGVidWc7XG4gIH1cbiAgRU5EIElGICoqL1xufTtcblxuLyoqIElGIERFQlVHXG5mdW5jdGlvbiBkZWJ1Zyhsb2cpIHtcbiAgY29uc29sZS5sb2cobG9nKTtcbn1cblxuZnVuY3Rpb24gZGVidWdTdGF0ZShzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubmV4dFN0YXRlcy5tYXAoZnVuY3Rpb24obikge1xuICAgIGlmIChuLm5leHRTdGF0ZXMubGVuZ3RoID09PSAwKSB7IHJldHVybiBcIiggXCIgKyBuLmRlYnVnKCkgKyBcIiBbYWNjZXB0aW5nXSApXCI7IH1cbiAgICByZXR1cm4gXCIoIFwiICsgbi5kZWJ1ZygpICsgXCIgPHRoZW4+IFwiICsgbi5uZXh0U3RhdGVzLm1hcChmdW5jdGlvbihzKSB7IHJldHVybiBzLmRlYnVnKCkgfSkuam9pbihcIiBvciBcIikgKyBcIiApXCI7XG4gIH0pLmpvaW4oXCIsIFwiKVxufVxuRU5EIElGICoqL1xuXG4vLyBTb3J0IHRoZSByb3V0ZXMgYnkgc3BlY2lmaWNpdHlcbmZ1bmN0aW9uIHNvcnRTb2x1dGlvbnMoc3RhdGVzKSB7XG4gIHJldHVybiBzdGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnNwZWNpZmljaXR5LnZhbCAtIGEuc3BlY2lmaWNpdHkudmFsO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVjb2duaXplQ2hhcihzdGF0ZXMsIGNoKSB7XG4gIHZhciBuZXh0U3RhdGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHN0YXRlID0gc3RhdGVzW2ldO1xuXG4gICAgbmV4dFN0YXRlcyA9IG5leHRTdGF0ZXMuY29uY2F0KHN0YXRlLm1hdGNoKGNoKSk7XG4gIH1cblxuICByZXR1cm4gbmV4dFN0YXRlcztcbn1cblxudmFyIG9DcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90bykge1xuICBmdW5jdGlvbiBGKCkge31cbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGKCk7XG59O1xuXG5mdW5jdGlvbiBSZWNvZ25pemVSZXN1bHRzKHF1ZXJ5UGFyYW1zKSB7XG4gIHRoaXMucXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcyB8fCB7fTtcbn1cblJlY29nbml6ZVJlc3VsdHMucHJvdG90eXBlID0gb0NyZWF0ZSh7XG4gIHNwbGljZTogQXJyYXkucHJvdG90eXBlLnNwbGljZSxcbiAgc2xpY2U6IEFycmF5LnByb3RvdHlwZS5zbGljZSxcbiAgcHVzaDogQXJyYXkucHJvdG90eXBlLnB1c2gsXG4gIGxlbmd0aDogMCxcbiAgcXVlcnlQYXJhbXM6IG51bGxcbn0pO1xuXG5mdW5jdGlvbiBmaW5kSGFuZGxlcihzdGF0ZSwgcGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgdmFyIGhhbmRsZXJzID0gc3RhdGUuaGFuZGxlcnMsXG4gICAgICByZWdleCA9IHN0YXRlLnJlZ2V4O1xuICB2YXIgY2FwdHVyZXMgPSBwYXRoLm1hdGNoKHJlZ2V4KSxcbiAgICAgIGN1cnJlbnRDYXB0dXJlID0gMTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBSZWNvZ25pemVSZXN1bHRzKHF1ZXJ5UGFyYW1zKTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbaV0sXG4gICAgICAgIG5hbWVzID0gaGFuZGxlci5uYW1lcyxcbiAgICAgICAgcGFyYW1zID0ge307XG5cbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IG5hbWVzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgcGFyYW1zW25hbWVzW2pdXSA9IGNhcHR1cmVzW2N1cnJlbnRDYXB0dXJlKytdO1xuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKHsgaGFuZGxlcjogaGFuZGxlci5oYW5kbGVyLCBwYXJhbXM6IHBhcmFtcywgaXNEeW5hbWljOiAhIW5hbWVzLmxlbmd0aCB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGFkZFNlZ21lbnQoY3VycmVudFN0YXRlLCBzZWdtZW50KSB7XG4gIHNlZ21lbnQuZWFjaENoYXIoZnVuY3Rpb24gKGNoKSB7XG4gICAgdmFyIHN0YXRlO1xuXG4gICAgY3VycmVudFN0YXRlID0gY3VycmVudFN0YXRlLnB1dChjaCk7XG4gIH0pO1xuXG4gIHJldHVybiBjdXJyZW50U3RhdGU7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVF1ZXJ5UGFyYW1QYXJ0KHBhcnQpIHtcbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDQwMS9pbnRlcmFjdC9mb3Jtcy5odG1sI2gtMTcuMTMuNC4xXG4gIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL1xcKy9nbSwgJyUyMCcpO1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnQpO1xufVxuXG4vLyBUaGUgbWFpbiBpbnRlcmZhY2VcblxudmFyIFJvdXRlUmVjb2duaXplciA9IGZ1bmN0aW9uIFJvdXRlUmVjb2duaXplcigpIHtcbiAgdGhpcy5yb290U3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgdGhpcy5uYW1lcyA9IHt9O1xufTtcblxuUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbiBhZGQocm91dGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMucm9vdFN0YXRlLFxuICAgICAgICByZWdleCA9IFwiXlwiLFxuICAgICAgICBzcGVjaWZpY2l0eSA9IHt9LFxuICAgICAgICBoYW5kbGVycyA9IFtdLFxuICAgICAgICBhbGxTZWdtZW50cyA9IFtdLFxuICAgICAgICBuYW1lO1xuXG4gICAgdmFyIGlzRW1wdHkgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSByb3V0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgcm91dGUgPSByb3V0ZXNbaV0sXG4gICAgICAgICAgbmFtZXMgPSBbXTtcblxuICAgICAgdmFyIHNlZ21lbnRzID0gcGFyc2Uocm91dGUucGF0aCwgbmFtZXMsIHNwZWNpZmljaXR5KTtcblxuICAgICAgYWxsU2VnbWVudHMgPSBhbGxTZWdtZW50cy5jb25jYXQoc2VnbWVudHMpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgbSA9IHNlZ21lbnRzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2pdO1xuXG4gICAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgRXBzaWxvblNlZ21lbnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcblxuICAgICAgICAvLyBBZGQgYSBcIi9cIiBmb3IgdGhlIG5ldyBzZWdtZW50XG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRTdGF0ZS5wdXQoeyB2YWxpZENoYXJzOiBcIi9cIiB9KTtcbiAgICAgICAgcmVnZXggKz0gXCIvXCI7XG5cbiAgICAgICAgLy8gQWRkIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNlZ21lbnQgdG8gdGhlIE5GQSBhbmQgcmVnZXhcbiAgICAgICAgY3VycmVudFN0YXRlID0gYWRkU2VnbWVudChjdXJyZW50U3RhdGUsIHNlZ21lbnQpO1xuICAgICAgICByZWdleCArPSBzZWdtZW50LnJlZ2V4KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYW5kbGVyID0geyBoYW5kbGVyOiByb3V0ZS5oYW5kbGVyLCBuYW1lczogbmFtZXMgfTtcbiAgICAgIGhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgfVxuXG4gICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRTdGF0ZS5wdXQoeyB2YWxpZENoYXJzOiBcIi9cIiB9KTtcbiAgICAgIHJlZ2V4ICs9IFwiL1wiO1xuICAgIH1cblxuICAgIGN1cnJlbnRTdGF0ZS5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIGN1cnJlbnRTdGF0ZS5yZWdleCA9IG5ldyBSZWdFeHAocmVnZXggKyBcIiRcIik7XG4gICAgY3VycmVudFN0YXRlLnNwZWNpZmljaXR5ID0gc3BlY2lmaWNpdHk7XG5cbiAgICBpZiAobmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hcykge1xuICAgICAgdGhpcy5uYW1lc1tuYW1lXSA9IHtcbiAgICAgICAgc2VnbWVudHM6IGFsbFNlZ21lbnRzLFxuICAgICAgICBoYW5kbGVyczogaGFuZGxlcnNcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZXJzRm9yOiBmdW5jdGlvbiBoYW5kbGVyc0ZvcihuYW1lKSB7XG4gICAgdmFyIHJvdXRlID0gdGhpcy5uYW1lc1tuYW1lXSxcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgaWYgKCFyb3V0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgbm8gcm91dGUgbmFtZWQgXCIgKyBuYW1lKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJvdXRlLmhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2gocm91dGUuaGFuZGxlcnNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgaGFzUm91dGU6IGZ1bmN0aW9uIGhhc1JvdXRlKG5hbWUpIHtcbiAgICByZXR1cm4gISF0aGlzLm5hbWVzW25hbWVdO1xuICB9LFxuXG4gIGdlbmVyYXRlOiBmdW5jdGlvbiBnZW5lcmF0ZShuYW1lLCBwYXJhbXMpIHtcbiAgICB2YXIgcm91dGUgPSB0aGlzLm5hbWVzW25hbWVdLFxuICAgICAgICBvdXRwdXQgPSBcIlwiO1xuICAgIGlmICghcm91dGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIHJvdXRlIG5hbWVkIFwiICsgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHNlZ21lbnRzID0gcm91dGUuc2VnbWVudHM7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblxuICAgICAgaWYgKHNlZ21lbnQgaW5zdGFuY2VvZiBFcHNpbG9uU2VnbWVudCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0ICs9IFwiL1wiO1xuICAgICAgb3V0cHV0ICs9IHNlZ21lbnQuZ2VuZXJhdGUocGFyYW1zKTtcbiAgICB9XG5cbiAgICBpZiAob3V0cHV0LmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBvdXRwdXQgPSAnLycgKyBvdXRwdXQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMucXVlcnlQYXJhbXMpIHtcbiAgICAgIG91dHB1dCArPSB0aGlzLmdlbmVyYXRlUXVlcnlTdHJpbmcocGFyYW1zLnF1ZXJ5UGFyYW1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuXG4gIGdlbmVyYXRlUXVlcnlTdHJpbmc6IGZ1bmN0aW9uIGdlbmVyYXRlUXVlcnlTdHJpbmcocGFyYW1zKSB7XG4gICAgdmFyIHBhaXJzID0gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGtleXMuc29ydCgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYWlyID0gZW5jb2RlVVJJQ29tcG9uZW50KGtleSk7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICB2YXIgYXJyYXlQYWlyID0ga2V5ICsgJ1tdJyArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVtqXSk7XG4gICAgICAgICAgcGFpcnMucHVzaChhcnJheVBhaXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWlyICs9IFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgcGFpcnMucHVzaChwYWlyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFpcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiP1wiICsgcGFpcnMuam9pbihcIiZcIik7XG4gIH0sXG5cbiAgcGFyc2VRdWVyeVN0cmluZzogZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZyhxdWVyeVN0cmluZykge1xuICAgIHZhciBwYWlycyA9IHF1ZXJ5U3RyaW5nLnNwbGl0KFwiJlwiKSxcbiAgICAgICAgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9JyksXG4gICAgICAgICAga2V5ID0gZGVjb2RlUXVlcnlQYXJhbVBhcnQocGFpclswXSksXG4gICAgICAgICAga2V5TGVuZ3RoID0ga2V5Lmxlbmd0aCxcbiAgICAgICAgICBpc0FycmF5ID0gZmFsc2UsXG4gICAgICAgICAgdmFsdWU7XG4gICAgICBpZiAocGFpci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFsdWUgPSAndHJ1ZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL0hhbmRsZSBhcnJheXNcbiAgICAgICAgaWYgKGtleUxlbmd0aCA+IDIgJiYga2V5LnNsaWNlKGtleUxlbmd0aCAtIDIpID09PSAnW10nKSB7XG4gICAgICAgICAgaXNBcnJheSA9IHRydWU7XG4gICAgICAgICAga2V5ID0ga2V5LnNsaWNlKDAsIGtleUxlbmd0aCAtIDIpO1xuICAgICAgICAgIGlmICghcXVlcnlQYXJhbXNba2V5XSkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXNba2V5XSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHBhaXJbMV0gPyBkZWNvZGVRdWVyeVBhcmFtUGFydChwYWlyWzFdKSA6ICcnO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgcXVlcnlQYXJhbXNba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5UGFyYW1zO1xuICB9LFxuXG4gIHJlY29nbml6ZTogZnVuY3Rpb24gcmVjb2duaXplKHBhdGgpIHtcbiAgICB2YXIgc3RhdGVzID0gW3RoaXMucm9vdFN0YXRlXSxcbiAgICAgICAgcGF0aExlbixcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgcXVlcnlTdGFydCxcbiAgICAgICAgcXVlcnlQYXJhbXMgPSB7fSxcbiAgICAgICAgaXNTbGFzaERyb3BwZWQgPSBmYWxzZTtcblxuICAgIHF1ZXJ5U3RhcnQgPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgICBpZiAocXVlcnlTdGFydCAhPT0gLTEpIHtcbiAgICAgIHZhciBxdWVyeVN0cmluZyA9IHBhdGguc3Vic3RyKHF1ZXJ5U3RhcnQgKyAxLCBwYXRoLmxlbmd0aCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcXVlcnlTdGFydCk7XG4gICAgICBxdWVyeVBhcmFtcyA9IHRoaXMucGFyc2VRdWVyeVN0cmluZyhxdWVyeVN0cmluZyk7XG4gICAgfVxuXG4gICAgcGF0aCA9IGRlY29kZVVSSShwYXRoKTtcblxuICAgIC8vIERFQlVHIEdST1VQIHBhdGhcblxuICAgIGlmIChwYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgIHBhdGggPSBcIi9cIiArIHBhdGg7XG4gICAgfVxuXG4gICAgcGF0aExlbiA9IHBhdGgubGVuZ3RoO1xuICAgIGlmIChwYXRoTGVuID4gMSAmJiBwYXRoLmNoYXJBdChwYXRoTGVuIC0gMSkgPT09IFwiL1wiKSB7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcGF0aExlbiAtIDEpO1xuICAgICAgaXNTbGFzaERyb3BwZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGwgPSBwYXRoLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc3RhdGVzID0gcmVjb2duaXplQ2hhcihzdGF0ZXMsIHBhdGguY2hhckF0KGkpKTtcbiAgICAgIGlmICghc3RhdGVzLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFTkQgREVCVUcgR1JPVVBcblxuICAgIHZhciBzb2x1dGlvbnMgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gc3RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHN0YXRlc1tpXS5oYW5kbGVycykge1xuICAgICAgICBzb2x1dGlvbnMucHVzaChzdGF0ZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlcyA9IHNvcnRTb2x1dGlvbnMoc29sdXRpb25zKTtcblxuICAgIHZhciBzdGF0ZSA9IHNvbHV0aW9uc1swXTtcblxuICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5oYW5kbGVycykge1xuICAgICAgLy8gaWYgYSB0cmFpbGluZyBzbGFzaCB3YXMgZHJvcHBlZCBhbmQgYSBzdGFyIHNlZ21lbnQgaXMgdGhlIGxhc3Qgc2VnbWVudFxuICAgICAgLy8gc3BlY2lmaWVkLCBwdXQgdGhlIHRyYWlsaW5nIHNsYXNoIGJhY2tcbiAgICAgIGlmIChpc1NsYXNoRHJvcHBlZCAmJiBzdGF0ZS5yZWdleC5zb3VyY2Uuc2xpY2UoLTUpID09PSBcIiguKykkXCIpIHtcbiAgICAgICAgcGF0aCA9IHBhdGggKyBcIi9cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5kSGFuZGxlcihzdGF0ZSwgcGF0aCwgcXVlcnlQYXJhbXMpO1xuICAgIH1cbiAgfVxufTtcblxuUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5tYXAgPSBtYXA7XG5cblJvdXRlUmVjb2duaXplci5WRVJTSU9OID0gJzAuMS45JztcblxudmFyIGdlblF1ZXJ5ID0gUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5nZW5lcmF0ZVF1ZXJ5U3RyaW5nO1xuXG4vLyBleHBvcnQgZGVmYXVsdCBmb3IgaG9sZGluZyB0aGUgVnVlIHJlZmVyZW5jZVxudmFyIGV4cG9ydHMkMSA9IHt9O1xuLyoqXG4gKiBXYXJuIHN0dWZmLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2dcbiAqL1xuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICBjb25zb2xlLndhcm4oJ1t2dWUtcm91dGVyXSAnICsgbXNnKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWV4cG9ydHMkMS5WdWUgfHwgZXhwb3J0cyQxLlZ1ZS5jb25maWcuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUud2FybihuZXcgRXJyb3IoJ3dhcm5pbmcgc3RhY2sgdHJhY2U6Jykuc3RhY2spO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBwYXRoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYXBwZW5kXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgoYmFzZSwgcmVsYXRpdmUsIGFwcGVuZCkge1xuICB2YXIgcXVlcnkgPSBiYXNlLm1hdGNoKC8oXFw/LiopJC8pO1xuICBpZiAocXVlcnkpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5WzFdO1xuICAgIGJhc2UgPSBiYXNlLnNsaWNlKDAsIC1xdWVyeS5sZW5ndGgpO1xuICB9XG4gIC8vIGEgcXVlcnkhXG4gIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgPT09ICc/Jykge1xuICAgIHJldHVybiBiYXNlICsgcmVsYXRpdmU7XG4gIH1cbiAgdmFyIHN0YWNrID0gYmFzZS5zcGxpdCgnLycpO1xuICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcbiAgLy8gLSBub3QgYXBwZW5kaW5nXG4gIC8vIC0gYXBwZW5kaW5nIHRvIHRyYWlsaW5nIHNsYXNoIChsYXN0IHNlZ21lbnQgaXMgZW1wdHkpXG4gIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgIHN0YWNrLnBvcCgpO1xuICB9XG4gIC8vIHJlc29sdmUgcmVsYXRpdmUgcGF0aFxuICB2YXIgc2VnbWVudHMgPSByZWxhdGl2ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmIChzZWdtZW50ID09PSAnLicpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCA9PT0gJy4uJykge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9XG4gIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXG4gIGlmIChzdGFja1swXSAhPT0gJycpIHtcbiAgICBzdGFjay51bnNoaWZ0KCcnKTtcbiAgfVxuICByZXR1cm4gc3RhY2suam9pbignLycpO1xufVxuXG4vKipcbiAqIEZvcmdpdmluZyBjaGVjayBmb3IgYSBwcm9taXNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNQcm9taXNlKHApIHtcbiAgcmV0dXJuIHAgJiYgdHlwZW9mIHAudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXRyaXZlIGEgcm91dGUgY29uZmlnIGZpZWxkIGZyb20gYSBjb21wb25lbnQgaW5zdGFuY2VcbiAqIE9SIGEgY29tcG9uZW50IGNvbnRydWN0b3IuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxWdWV9IGNvbXBvbmVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuZnVuY3Rpb24gZ2V0Um91dGVDb25maWcoY29tcG9uZW50LCBuYW1lKSB7XG4gIHZhciBvcHRpb25zID0gY29tcG9uZW50ICYmIChjb21wb25lbnQuJG9wdGlvbnMgfHwgY29tcG9uZW50Lm9wdGlvbnMpO1xuICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGVbbmFtZV07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeS4gSGF2ZSB0byBkbyBhIGRpcnR5XG4gKiBtb2NrIGhlcmUgYmVjYXVzZSBvZiBWdWUgY29yZSdzIGludGVybmFsIEFQSSBkZXBlbmRzIG9uXG4gKiBhbiBJRCBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG52YXIgcmVzb2x2ZXIgPSB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudChoYW5kbGVyLCBjYikge1xuICBpZiAoIXJlc29sdmVyKSB7XG4gICAgcmVzb2x2ZXIgPSB7XG4gICAgICByZXNvbHZlOiBleHBvcnRzJDEuVnVlLnByb3RvdHlwZS5fcmVzb2x2ZUNvbXBvbmVudCxcbiAgICAgICRvcHRpb25zOiB7XG4gICAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgICBfOiBoYW5kbGVyLmNvbXBvbmVudFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXNvbHZlci4kb3B0aW9ucy5jb21wb25lbnRzLl8gPSBoYW5kbGVyLmNvbXBvbmVudDtcbiAgfVxuICByZXNvbHZlci5yZXNvbHZlKCdfJywgZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgIGhhbmRsZXIuY29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgIGNiKENvbXBvbmVudCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIE1hcCB0aGUgZHluYW1pYyBzZWdtZW50cyBpbiBhIHBhdGggdG8gcGFyYW1zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcnlcbiAqL1xuXG5mdW5jdGlvbiBtYXBQYXJhbXMocGF0aCwgcGFyYW1zLCBxdWVyeSkge1xuICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHBhcmFtcyA9IHt9O1xuXG4gIHBhdGggPSBwYXRoLnJlcGxhY2UoLzooW15cXC9dKykvZywgZnVuY3Rpb24gKF8sIGtleSkge1xuICAgIHZhciB2YWwgPSBwYXJhbXNba2V5XTtcbiAgICBpZiAoIXZhbCkge1xuICAgICAgd2FybigncGFyYW0gXCInICsga2V5ICsgJ1wiIG5vdCBmb3VuZCB3aGVuIGdlbmVyYXRpbmcgJyArICdwYXRoIGZvciBcIicgKyBwYXRoICsgJ1wiIHdpdGggcGFyYW1zICcgKyBKU09OLnN0cmluZ2lmeShwYXJhbXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbCB8fCAnJztcbiAgfSk7XG4gIGlmIChxdWVyeSkge1xuICAgIHBhdGggKz0gZ2VuUXVlcnkocXVlcnkpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuXG52YXIgaGFzaFJFID0gLyMuKiQvO1xuXG52YXIgSFRNTDVIaXN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSFRNTDVIaXN0b3J5KF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcbiAgICB2YXIgb25DaGFuZ2UgPSBfcmVmLm9uQ2hhbmdlO1xuICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBIVE1MNUhpc3RvcnkpO1xuXG4gICAgaWYgKHJvb3QpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIHRoZSBzdGFydGluZyBzbGFzaFxuICAgICAgaWYgKHJvb3QuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgICAgcm9vdCA9ICcvJyArIHJvb3Q7XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgICAgIHRoaXMucm9vdCA9IHJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAgIHRoaXMucm9vdFJFID0gbmV3IFJlZ0V4cCgnXlxcXFwnICsgdGhpcy5yb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgIC8vIGNoZWNrIGJhc2UgdGFnXG4gICAgdmFyIGJhc2VFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICB0aGlzLmJhc2UgPSBiYXNlRWwgJiYgYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICB9XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciB1cmwgPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgaWYgKF90aGlzLnJvb3QpIHtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoX3RoaXMucm9vdFJFLCAnJyk7XG4gICAgICB9XG4gICAgICBfdGhpcy5vbkNoYW5nZSh1cmwsIGUgJiYgZS5zdGF0ZSwgbG9jYXRpb24uaGFzaCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB0aGlzLmxpc3RlbmVyKCk7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLmxpc3RlbmVyKTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28ocGF0aCwgcmVwbGFjZSwgYXBwZW5kKSB7XG4gICAgdmFyIHVybCA9IHRoaXMuZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpO1xuICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgJycsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlY29yZCBzY3JvbGwgcG9zaXRpb24gYnkgcmVwbGFjaW5nIGN1cnJlbnQgc3RhdGVcbiAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHtcbiAgICAgICAgcG9zOiB7XG4gICAgICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgICAgICB9XG4gICAgICB9LCAnJyk7XG4gICAgICAvLyB0aGVuIHB1c2ggbmV3IHN0YXRlXG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsIHVybCk7XG4gICAgfVxuICAgIHZhciBoYXNoTWF0Y2ggPSBwYXRoLm1hdGNoKGhhc2hSRSk7XG4gICAgdmFyIGhhc2ggPSBoYXNoTWF0Y2ggJiYgaGFzaE1hdGNoWzBdO1xuICAgIHBhdGggPSB1cmxcbiAgICAvLyBzdHJpcCBoYXNoIHNvIGl0IGRvZXNuJ3QgbWVzcyB1cCBwYXJhbXNcbiAgICAucmVwbGFjZShoYXNoUkUsICcnKVxuICAgIC8vIHJlbW92ZSByb290IGJlZm9yZSBtYXRjaGluZ1xuICAgIC5yZXBsYWNlKHRoaXMucm9vdFJFLCAnJyk7XG4gICAgdGhpcy5vbkNoYW5nZShwYXRoLCBudWxsLCBoYXNoKTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmZvcm1hdFBhdGggPSBmdW5jdGlvbiBmb3JtYXRQYXRoKHBhdGgsIGFwcGVuZCkge1xuICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgLy8gYWJzb2x1dGUgcGF0aFxuICAgID8gdGhpcy5yb290ID8gdGhpcy5yb290ICsgJy8nICsgcGF0aC5yZXBsYWNlKC9eXFwvLywgJycpIDogcGF0aCA6IHJlc29sdmVQYXRoKHRoaXMuYmFzZSB8fCBsb2NhdGlvbi5wYXRobmFtZSwgcGF0aCwgYXBwZW5kKTtcbiAgfTtcblxuICByZXR1cm4gSFRNTDVIaXN0b3J5O1xufSkoKTtcblxudmFyIEhhc2hIaXN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSGFzaEhpc3RvcnkoX3JlZikge1xuICAgIHZhciBoYXNoYmFuZyA9IF9yZWYuaGFzaGJhbmc7XG4gICAgdmFyIG9uQ2hhbmdlID0gX3JlZi5vbkNoYW5nZTtcbiAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgSGFzaEhpc3RvcnkpO1xuXG4gICAgdGhpcy5oYXNoYmFuZyA9IGhhc2hiYW5nO1xuICAgIHRoaXMub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgfVxuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhdGggPSBsb2NhdGlvbi5oYXNoO1xuICAgICAgdmFyIHJhdyA9IHBhdGgucmVwbGFjZSgvXiMhPy8sICcnKTtcbiAgICAgIC8vIGFsd2F5c1xuICAgICAgaWYgKHJhdy5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgICByYXcgPSAnLycgKyByYXc7XG4gICAgICB9XG4gICAgICB2YXIgZm9ybWF0dGVkUGF0aCA9IHNlbGYuZm9ybWF0UGF0aChyYXcpO1xuICAgICAgaWYgKGZvcm1hdHRlZFBhdGggIT09IHBhdGgpIHtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShmb3JtYXR0ZWRQYXRoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gZGV0ZXJtaW5lIHF1ZXJ5XG4gICAgICAvLyBub3RlIGl0J3MgcG9zc2libGUgdG8gaGF2ZSBxdWVyaWVzIGluIGJvdGggdGhlIGFjdHVhbCBVUkxcbiAgICAgIC8vIGFuZCB0aGUgaGFzaCBmcmFnbWVudCBpdHNlbGYuXG4gICAgICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5zZWFyY2ggJiYgcGF0aC5pbmRleE9mKCc/JykgPiAtMSA/ICcmJyArIGxvY2F0aW9uLnNlYXJjaC5zbGljZSgxKSA6IGxvY2F0aW9uLnNlYXJjaDtcbiAgICAgIHNlbGYub25DaGFuZ2UoZGVjb2RlVVJJKHBhdGgucmVwbGFjZSgvXiMhPy8sICcnKSArIHF1ZXJ5KSk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuICAgIHRoaXMubGlzdGVuZXIoKTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyhwYXRoLCByZXBsYWNlLCBhcHBlbmQpIHtcbiAgICBwYXRoID0gdGhpcy5mb3JtYXRQYXRoKHBhdGgsIGFwcGVuZCk7XG4gICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgIGxvY2F0aW9uLnJlcGxhY2UocGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLmhhc2ggPSBwYXRoO1xuICAgIH1cbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZm9ybWF0UGF0aCA9IGZ1bmN0aW9uIGZvcm1hdFBhdGgocGF0aCwgYXBwZW5kKSB7XG4gICAgdmFyIGlzQWJzb2xvdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgICB2YXIgcHJlZml4ID0gJyMnICsgKHRoaXMuaGFzaGJhbmcgPyAnIScgOiAnJyk7XG4gICAgcmV0dXJuIGlzQWJzb2xvdXRlID8gcHJlZml4ICsgcGF0aCA6IHByZWZpeCArIHJlc29sdmVQYXRoKGxvY2F0aW9uLmhhc2gucmVwbGFjZSgvXiMhPy8sICcnKSwgcGF0aCwgYXBwZW5kKTtcbiAgfTtcblxuICByZXR1cm4gSGFzaEhpc3Rvcnk7XG59KSgpO1xuXG52YXIgQWJzdHJhY3RIaXN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQWJzdHJhY3RIaXN0b3J5KF9yZWYpIHtcbiAgICB2YXIgb25DaGFuZ2UgPSBfcmVmLm9uQ2hhbmdlO1xuICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBBYnN0cmFjdEhpc3RvcnkpO1xuXG4gICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSAnLyc7XG4gIH1cblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgdGhpcy5vbkNoYW5nZSgnLycpO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgLy8gbm9vcFxuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyhwYXRoLCByZXBsYWNlLCBhcHBlbmQpIHtcbiAgICBwYXRoID0gdGhpcy5jdXJyZW50UGF0aCA9IHRoaXMuZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpO1xuICAgIHRoaXMub25DaGFuZ2UocGF0aCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5mb3JtYXRQYXRoID0gZnVuY3Rpb24gZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpIHtcbiAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGggOiByZXNvbHZlUGF0aCh0aGlzLmN1cnJlbnRQYXRoLCBwYXRoLCBhcHBlbmQpO1xuICB9O1xuXG4gIHJldHVybiBBYnN0cmFjdEhpc3Rvcnk7XG59KSgpO1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgcmV1c2FiaWxpdHkgb2YgYW4gZXhpc3Rpbmcgcm91dGVyIHZpZXcuXG4gKlxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHZpZXdcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gKiBAcGFyYW0ge1RyYW5zaXRpb259IHRyYW5zaXRpb25cbiAqL1xuXG5mdW5jdGlvbiBjYW5SZXVzZSh2aWV3LCBoYW5kbGVyLCB0cmFuc2l0aW9uKSB7XG4gIHZhciBjb21wb25lbnQgPSB2aWV3LmNoaWxkVk07XG4gIGlmICghY29tcG9uZW50IHx8ICFoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGltcG9ydGFudDogY2hlY2sgdmlldy5Db21wb25lbnQgaGVyZSBiZWNhdXNlIGl0IG1heVxuICAvLyBoYXZlIGJlZW4gY2hhbmdlZCBpbiBhY3RpdmF0ZSBob29rXG4gIGlmICh2aWV3LkNvbXBvbmVudCAhPT0gaGFuZGxlci5jb21wb25lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGNhblJldXNlRm4gPSBnZXRSb3V0ZUNvbmZpZyhjb21wb25lbnQsICdjYW5SZXVzZScpO1xuICByZXR1cm4gdHlwZW9mIGNhblJldXNlRm4gPT09ICdib29sZWFuJyA/IGNhblJldXNlRm4gOiBjYW5SZXVzZUZuID8gY2FuUmV1c2VGbi5jYWxsKGNvbXBvbmVudCwge1xuICAgIHRvOiB0cmFuc2l0aW9uLnRvLFxuICAgIGZyb206IHRyYW5zaXRpb24uZnJvbVxuICB9KSA6IHRydWU7IC8vIGRlZmF1bHRzIHRvIHRydWVcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNvbXBvbmVudCBjYW4gZGVhY3RpdmF0ZS5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlld1xuICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKi9cblxuZnVuY3Rpb24gY2FuRGVhY3RpdmF0ZSh2aWV3LCB0cmFuc2l0aW9uLCBuZXh0KSB7XG4gIHZhciBmcm9tQ29tcG9uZW50ID0gdmlldy5jaGlsZFZNO1xuICB2YXIgaG9vayA9IGdldFJvdXRlQ29uZmlnKGZyb21Db21wb25lbnQsICdjYW5EZWFjdGl2YXRlJyk7XG4gIGlmICghaG9vaykge1xuICAgIG5leHQoKTtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2l0aW9uLmNhbGxIb29rKGhvb2ssIGZyb21Db21wb25lbnQsIG5leHQsIHtcbiAgICAgIGV4cGVjdEJvb2xlYW46IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY29tcG9uZW50IGNhbiBhY3RpdmF0ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlclxuICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKi9cblxuZnVuY3Rpb24gY2FuQWN0aXZhdGUoaGFuZGxlciwgdHJhbnNpdGlvbiwgbmV4dCkge1xuICByZXNvbHZlQXN5bmNDb21wb25lbnQoaGFuZGxlciwgZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgIC8vIGhhdmUgdG8gY2hlY2sgZHVlIHRvIGFzeW5jLW5lc3NcbiAgICBpZiAodHJhbnNpdGlvbi5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGRldGVybWluZSBpZiB0aGlzIGNvbXBvbmVudCBjYW4gYmUgYWN0aXZhdGVkXG4gICAgdmFyIGhvb2sgPSBnZXRSb3V0ZUNvbmZpZyhDb21wb25lbnQsICdjYW5BY3RpdmF0ZScpO1xuICAgIGlmICghaG9vaykge1xuICAgICAgbmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2l0aW9uLmNhbGxIb29rKGhvb2ssIG51bGwsIG5leHQsIHtcbiAgICAgICAgZXhwZWN0Qm9vbGVhbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBDYWxsIGRlYWN0aXZhdGUgaG9va3MgZm9yIGV4aXN0aW5nIHJvdXRlci12aWV3cy5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlld1xuICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKi9cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZSh2aWV3LCB0cmFuc2l0aW9uLCBuZXh0KSB7XG4gIHZhciBjb21wb25lbnQgPSB2aWV3LmNoaWxkVk07XG4gIHZhciBob29rID0gZ2V0Um91dGVDb25maWcoY29tcG9uZW50LCAnZGVhY3RpdmF0ZScpO1xuICBpZiAoIWhvb2spIHtcbiAgICBuZXh0KCk7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNpdGlvbi5jYWxsSG9va3MoaG9vaywgY29tcG9uZW50LCBuZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjdGl2YXRlIC8gc3dpdGNoIGNvbXBvbmVudCBmb3IgYSByb3V0ZXItdmlldy5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlld1xuICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gZGVwdGhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiBhY3RpdmF0ZSh2aWV3LCB0cmFuc2l0aW9uLCBkZXB0aCwgY2IsIHJldXNlKSB7XG4gIHZhciBoYW5kbGVyID0gdHJhbnNpdGlvbi5hY3RpdmF0ZVF1ZXVlW2RlcHRoXTtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgLy8gZml4IDEuMC4wLWFscGhhLjMgY29tcGF0XG4gICAgaWYgKHZpZXcuX2JvdW5kKSB7XG4gICAgICB2aWV3LnNldENvbXBvbmVudChudWxsKTtcbiAgICB9XG4gICAgY2IgJiYgY2IoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgQ29tcG9uZW50ID0gdmlldy5Db21wb25lbnQgPSBoYW5kbGVyLmNvbXBvbmVudDtcbiAgdmFyIGFjdGl2YXRlSG9vayA9IGdldFJvdXRlQ29uZmlnKENvbXBvbmVudCwgJ2FjdGl2YXRlJyk7XG4gIHZhciBkYXRhSG9vayA9IGdldFJvdXRlQ29uZmlnKENvbXBvbmVudCwgJ2RhdGEnKTtcbiAgdmFyIHdhaXRGb3JEYXRhID0gZ2V0Um91dGVDb25maWcoQ29tcG9uZW50LCAnd2FpdEZvckRhdGEnKTtcblxuICB2aWV3LmRlcHRoID0gZGVwdGg7XG4gIHZpZXcuYWN0aXZhdGVkID0gZmFsc2U7XG5cbiAgdmFyIGNvbXBvbmVudCA9IHVuZGVmaW5lZDtcbiAgdmFyIGxvYWRpbmcgPSAhIShkYXRhSG9vayAmJiAhd2FpdEZvckRhdGEpO1xuXG4gIC8vIFwicmV1c2VcIiBpcyBhIGZsYWcgcGFzc2VkIGRvd24gd2hlbiB0aGUgcGFyZW50IHZpZXcgaXNcbiAgLy8gZWl0aGVyIHJldXNlZCB2aWEga2VlcC1hbGl2ZSBvciBhcyBhIGNoaWxkIG9mIGEga2VwdC1hbGl2ZSB2aWV3LlxuICAvLyBvZiBjb3Vyc2Ugd2UgY2FuIG9ubHkgcmV1c2UgaWYgdGhlIGN1cnJlbnQga2VwdC1hbGl2ZSBpbnN0YW5jZVxuICAvLyBpcyBvZiB0aGUgY29ycmVjdCB0eXBlLlxuICByZXVzZSA9IHJldXNlICYmIHZpZXcuY2hpbGRWTSAmJiB2aWV3LmNoaWxkVk0uY29uc3RydWN0b3IgPT09IENvbXBvbmVudDtcblxuICBpZiAocmV1c2UpIHtcbiAgICAvLyBqdXN0IHJldXNlXG4gICAgY29tcG9uZW50ID0gdmlldy5jaGlsZFZNO1xuICAgIGNvbXBvbmVudC4kbG9hZGluZ1JvdXRlRGF0YSA9IGxvYWRpbmc7XG4gIH0gZWxzZSB7XG4gICAgLy8gdW5idWlsZCBjdXJyZW50IGNvbXBvbmVudC4gdGhpcyBzdGVwIGFsc28gZGVzdHJveXNcbiAgICAvLyBhbmQgcmVtb3ZlcyBhbGwgbmVzdGVkIGNoaWxkIHZpZXdzLlxuICAgIHZpZXcudW5idWlsZCh0cnVlKTtcbiAgICAvLyBoYW5kbGUga2VlcC1hbGl2ZS5cbiAgICAvLyBpZiB0aGUgdmlldyBoYXMga2VlcC1hbGl2ZSwgdGhlIGNoaWxkIHZtIGlzIG5vdCBhY3R1YWxseVxuICAgIC8vIGRlc3Ryb3llZCAtIGl0cyBuZXN0ZWQgdmlld3Mgd2lsbCBzdGlsbCBiZSBpbiByb3V0ZXInc1xuICAgIC8vIHZpZXcgbGlzdC4gV2UgbmVlZCB0byByZW1vdmVkIHRoZXNlIGNoaWxkIHZpZXdzIGFuZFxuICAgIC8vIGNhY2hlIHRoZW0gb24gdGhlIGNoaWxkIHZtLlxuICAgIGlmICh2aWV3LmtlZXBBbGl2ZSkge1xuICAgICAgdmFyIHZpZXdzID0gdHJhbnNpdGlvbi5yb3V0ZXIuX3ZpZXdzO1xuICAgICAgdmFyIGkgPSB2aWV3cy5pbmRleE9mKHZpZXcpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHRyYW5zaXRpb24ucm91dGVyLl92aWV3cyA9IHZpZXdzLnNsaWNlKGkpO1xuICAgICAgICBpZiAodmlldy5jaGlsZFZNKSB7XG4gICAgICAgICAgdmlldy5jaGlsZFZNLl9yb3V0ZXJWaWV3cyA9IHZpZXdzLnNsaWNlKDAsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgdGhlIG5ldyBjb21wb25lbnQuIHRoaXMgd2lsbCBhbHNvIGNyZWF0ZSB0aGVcbiAgICAvLyBkaXJlY3QgY2hpbGQgdmlldyBvZiB0aGUgY3VycmVudCBvbmUuIGl0IHdpbGwgcmVnaXN0ZXJcbiAgICAvLyBpdHNlbGYgYXMgdmlldy5jaGlsZFZpZXcuXG4gICAgY29tcG9uZW50ID0gdmlldy5idWlsZCh7XG4gICAgICBfbWV0YToge1xuICAgICAgICAkbG9hZGluZ1JvdXRlRGF0YTogbG9hZGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGhhbmRsZSBrZWVwLWFsaXZlLlxuICAgIC8vIHdoZW4gYSBrZXB0LWFsaXZlIGNoaWxkIHZtIGlzIHJlc3RvcmVkLCB3ZSBuZWVkIHRvXG4gICAgLy8gYWRkIGl0cyBjYWNoZWQgY2hpbGQgdmlld3MgaW50byB0aGUgcm91dGVyJ3MgdmlldyBsaXN0LFxuICAgIC8vIGFuZCBhbHNvIHByb3Blcmx5IHVwZGF0ZSBjdXJyZW50IHZpZXcncyBjaGlsZCB2aWV3LlxuICAgIGlmICh2aWV3LmtlZXBBbGl2ZSkge1xuICAgICAgY29tcG9uZW50LiRsb2FkaW5nUm91dGVEYXRhID0gbG9hZGluZztcbiAgICAgIHZhciBjYWNoZWRWaWV3cyA9IGNvbXBvbmVudC5fcm91dGVyVmlld3M7XG4gICAgICBpZiAoY2FjaGVkVmlld3MpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5yb3V0ZXIuX3ZpZXdzID0gY2FjaGVkVmlld3MuY29uY2F0KHRyYW5zaXRpb24ucm91dGVyLl92aWV3cyk7XG4gICAgICAgIHZpZXcuY2hpbGRWaWV3ID0gY2FjaGVkVmlld3NbY2FjaGVkVmlld3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbXBvbmVudC5fcm91dGVyVmlld3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNsZWFudXAgdGhlIGNvbXBvbmVudCBpbiBjYXNlIHRoZSB0cmFuc2l0aW9uIGlzIGFib3J0ZWRcbiAgLy8gYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgZXZlciBpbnNlcnRlZC5cbiAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGNvbXBvbmVudC4kZGVzdHJveSgpO1xuICB9O1xuXG4gIC8vIGFjdHVhbGx5IGluc2VydCB0aGUgY29tcG9uZW50IGFuZCB0cmlnZ2VyIHRyYW5zaXRpb25cbiAgdmFyIGluc2VydCA9IGZ1bmN0aW9uIGluc2VydCgpIHtcbiAgICBpZiAocmV1c2UpIHtcbiAgICAgIGNiICYmIGNiKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByb3V0ZXIgPSB0cmFuc2l0aW9uLnJvdXRlcjtcbiAgICBpZiAocm91dGVyLl9yZW5kZXJlZCB8fCByb3V0ZXIuX3RyYW5zaXRpb25PbkxvYWQpIHtcbiAgICAgIHZpZXcudHJhbnNpdGlvbihjb21wb25lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBubyB0cmFuc2l0aW9uIG9uIGZpcnN0IHJlbmRlciwgbWFudWFsIHRyYW5zaXRpb25cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHZpZXcuc2V0Q3VycmVudCkge1xuICAgICAgICAvLyAwLjEyIGNvbXBhdFxuICAgICAgICB2aWV3LnNldEN1cnJlbnQoY29tcG9uZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDEuMFxuICAgICAgICB2aWV3LmNoaWxkVk0gPSBjb21wb25lbnQ7XG4gICAgICB9XG4gICAgICBjb21wb25lbnQuJGJlZm9yZSh2aWV3LmFuY2hvciwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICBjYiAmJiBjYigpO1xuICB9O1xuXG4gIC8vIGNhbGxlZCBhZnRlciBhY3RpdmF0aW9uIGhvb2sgaXMgcmVzb2x2ZWRcbiAgdmFyIGFmdGVyQWN0aXZhdGUgPSBmdW5jdGlvbiBhZnRlckFjdGl2YXRlKCkge1xuICAgIHZpZXcuYWN0aXZhdGVkID0gdHJ1ZTtcbiAgICAvLyBhY3RpdmF0ZSB0aGUgY2hpbGQgdmlld1xuICAgIGlmICh2aWV3LmNoaWxkVmlldykge1xuICAgICAgYWN0aXZhdGUodmlldy5jaGlsZFZpZXcsIHRyYW5zaXRpb24sIGRlcHRoICsgMSwgbnVsbCwgcmV1c2UgfHwgdmlldy5rZWVwQWxpdmUpO1xuICAgIH1cbiAgICBpZiAoZGF0YUhvb2sgJiYgd2FpdEZvckRhdGEpIHtcbiAgICAgIC8vIHdhaXQgdW50aWwgZGF0YSBsb2FkZWQgdG8gaW5zZXJ0XG4gICAgICBsb2FkRGF0YShjb21wb25lbnQsIHRyYW5zaXRpb24sIGRhdGFIb29rLCBpbnNlcnQsIGNsZWFudXApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2FkIGRhdGEgYW5kIGluc2VydCBhdCB0aGUgc2FtZSB0aW1lXG4gICAgICBpZiAoZGF0YUhvb2spIHtcbiAgICAgICAgbG9hZERhdGEoY29tcG9uZW50LCB0cmFuc2l0aW9uLCBkYXRhSG9vayk7XG4gICAgICB9XG4gICAgICBpbnNlcnQoKTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKGFjdGl2YXRlSG9vaykge1xuICAgIHRyYW5zaXRpb24uY2FsbEhvb2tzKGFjdGl2YXRlSG9vaywgY29tcG9uZW50LCBhZnRlckFjdGl2YXRlLCB7XG4gICAgICBjbGVhbnVwOiBjbGVhbnVwXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYWZ0ZXJBY3RpdmF0ZSgpO1xuICB9XG59XG5cbi8qKlxuICogUmV1c2UgYSB2aWV3LCBqdXN0IHJlbG9hZCBkYXRhIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlld1xuICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gKi9cblxuZnVuY3Rpb24gcmV1c2UodmlldywgdHJhbnNpdGlvbikge1xuICB2YXIgY29tcG9uZW50ID0gdmlldy5jaGlsZFZNO1xuICB2YXIgZGF0YUhvb2sgPSBnZXRSb3V0ZUNvbmZpZyhjb21wb25lbnQsICdkYXRhJyk7XG4gIGlmIChkYXRhSG9vaykge1xuICAgIGxvYWREYXRhKGNvbXBvbmVudCwgdHJhbnNpdGlvbiwgZGF0YUhvb2spO1xuICB9XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgbG9hZCBhbmQgYXBwbHkgZGF0YSB0byBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtWdWV9IGNvbXBvbmVudFxuICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xlYW51cFxuICovXG5cbmZ1bmN0aW9uIGxvYWREYXRhKGNvbXBvbmVudCwgdHJhbnNpdGlvbiwgaG9vaywgY2IsIGNsZWFudXApIHtcbiAgY29tcG9uZW50LiRsb2FkaW5nUm91dGVEYXRhID0gdHJ1ZTtcbiAgdHJhbnNpdGlvbi5jYWxsSG9va3MoaG9vaywgY29tcG9uZW50LCBmdW5jdGlvbiAoZGF0YSwgb25FcnJvcikge1xuICAgIC8vIG1lcmdlIGRhdGEgZnJvbSBtdWx0aXBsZSBkYXRhIGhvb2tzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgJiYgZGF0YS5fbmVlZE1lcmdlKSB7XG4gICAgICBkYXRhID0gZGF0YS5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgb2JqKSB7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KG9iaikpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmVzW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgfVxuICAgIC8vIGhhbmRsZSBwcm9taXNlIHN1Z2FyIHN5bnRheFxuICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRhdGFba2V5XTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZSh2YWwpKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh2YWwudGhlbihmdW5jdGlvbiAocmVzb2x2ZWRWYWwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC4kc2V0KGtleSwgcmVzb2x2ZWRWYWwpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wb25lbnQuJHNldChrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXByb21pc2VzLmxlbmd0aCkge1xuICAgICAgY29tcG9uZW50LiRsb2FkaW5nUm91dGVEYXRhID0gZmFsc2U7XG4gICAgICBjYiAmJiBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlc1swXS5jb25zdHJ1Y3Rvci5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgY29tcG9uZW50LiRsb2FkaW5nUm91dGVEYXRhID0gZmFsc2U7XG4gICAgICAgIGNiICYmIGNiKCk7XG4gICAgICB9LCBvbkVycm9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBjbGVhbnVwOiBjbGVhbnVwLFxuICAgIGV4cGVjdERhdGE6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogQSBSb3V0ZVRyYW5zaXRpb24gb2JqZWN0IG1hbmFnZXMgdGhlIHBpcGVsaW5lIG9mIGFcbiAqIHJvdXRlci12aWV3IHN3aXRjaGluZyBwcm9jZXNzLiBUaGlzIGlzIGFsc28gdGhlIG9iamVjdFxuICogcGFzc2VkIGludG8gdXNlciByb3V0ZSBob29rcy5cbiAqXG4gKiBAcGFyYW0ge1JvdXRlcn0gcm91dGVyXG4gKiBAcGFyYW0ge1JvdXRlfSB0b1xuICogQHBhcmFtIHtSb3V0ZX0gZnJvbVxuICovXG5cbnZhciBSb3V0ZVRyYW5zaXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSb3V0ZVRyYW5zaXRpb24ocm91dGVyLCB0bywgZnJvbSkge1xuICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3V0ZVRyYW5zaXRpb24pO1xuXG4gICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgdGhpcy50byA9IHRvO1xuICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRvbmUgPSBmYWxzZTtcblxuICAgIC8vIHN0YXJ0IGJ5IGRldGVybWluZSB0aGUgcXVldWVzXG5cbiAgICAvLyB0aGUgZGVhY3RpdmF0ZSBxdWV1ZSBpcyBhbiBhcnJheSBvZiByb3V0ZXItdmlld1xuICAgIC8vIGRpcmVjdGl2ZSBpbnN0YW5jZXMgdGhhdCBuZWVkIHRvIGJlIGRlYWN0aXZhdGVkLFxuICAgIC8vIGRlZXBlc3QgZmlyc3QuXG4gICAgdGhpcy5kZWFjdGl2YXRlUXVldWUgPSByb3V0ZXIuX3ZpZXdzO1xuXG4gICAgLy8gY2hlY2sgdGhlIGRlZmF1bHQgaGFuZGxlciBvZiB0aGUgZGVlcGVzdCBtYXRjaFxuICAgIHZhciBtYXRjaGVkID0gdG8ubWF0Y2hlZCA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRvLm1hdGNoZWQpIDogW107XG5cbiAgICAvLyB0aGUgYWN0aXZhdGUgcXVldWUgaXMgYW4gYXJyYXkgb2Ygcm91dGUgaGFuZGxlcnNcbiAgICAvLyB0aGF0IG5lZWQgdG8gYmUgYWN0aXZhdGVkXG4gICAgdGhpcy5hY3RpdmF0ZVF1ZXVlID0gbWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2guaGFuZGxlcjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYm9ydCBjdXJyZW50IHRyYW5zaXRpb24gYW5kIHJldHVybiB0byBwcmV2aW91cyBsb2NhdGlvbi5cbiAgICovXG5cbiAgUm91dGVUcmFuc2l0aW9uLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGlmICghdGhpcy5hYm9ydGVkKSB7XG4gICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgLy8gaWYgdGhlIHJvb3QgcGF0aCB0aHJvd3MgYW4gZXJyb3IgZHVyaW5nIHZhbGlkYXRpb25cbiAgICAgIC8vIG9uIGluaXRpYWwgbG9hZCwgaXQgZ2V0cyBjYXVnaHQgaW4gYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgIHZhciBhYm9ydGluZ09uTG9hZCA9ICF0aGlzLmZyb20ucGF0aCAmJiB0aGlzLnRvLnBhdGggPT09ICcvJztcbiAgICAgIGlmICghYWJvcnRpbmdPbkxvYWQpIHtcbiAgICAgICAgdGhpcy5yb3V0ZXIucmVwbGFjZSh0aGlzLmZyb20ucGF0aCB8fCAnLycpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWJvcnQgY3VycmVudCB0cmFuc2l0aW9uIGFuZCByZWRpcmVjdCB0byBhIG5ldyBsb2NhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICovXG5cbiAgUm91dGVUcmFuc2l0aW9uLnByb3RvdHlwZS5yZWRpcmVjdCA9IGZ1bmN0aW9uIHJlZGlyZWN0KHBhdGgpIHtcbiAgICBpZiAoIXRoaXMuYWJvcnRlZCkge1xuICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCA9IG1hcFBhcmFtcyhwYXRoLCB0aGlzLnRvLnBhcmFtcywgdGhpcy50by5xdWVyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoLnBhcmFtcyA9IHBhdGgucGFyYW1zIHx8IHRoaXMudG8ucGFyYW1zO1xuICAgICAgICBwYXRoLnF1ZXJ5ID0gcGF0aC5xdWVyeSB8fCB0aGlzLnRvLnF1ZXJ5O1xuICAgICAgfVxuICAgICAgdGhpcy5yb3V0ZXIucmVwbGFjZShwYXRoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgcm91dGVyIHZpZXcgdHJhbnNpdGlvbidzIHBpcGVsaW5lIGNhbiBiZSBkZXNjcmliZWQgYXNcbiAgICogZm9sbG93cywgYXNzdW1pbmcgd2UgYXJlIHRyYW5zaXRpb25pbmcgZnJvbSBhbiBleGlzdGluZ1xuICAgKiA8cm91dGVyLXZpZXc+IGNoYWluIFtDb21wb25lbnQgQSwgQ29tcG9uZW50IEJdIHRvIGEgbmV3XG4gICAqIGNoYWluIFtDb21wb25lbnQgQSwgQ29tcG9uZW50IENdOlxuICAgKlxuICAgKiAgQSAgICBBXG4gICAqICB8ID0+IHxcbiAgICogIEIgICAgQ1xuICAgKlxuICAgKiAxLiBSZXVzYWJsaXR5IHBoYXNlOlxuICAgKiAgIC0+IGNhblJldXNlKEEsIEEpXG4gICAqICAgLT4gY2FuUmV1c2UoQiwgQylcbiAgICogICAtPiBkZXRlcm1pbmUgbmV3IHF1ZXVlczpcbiAgICogICAgICAtIGRlYWN0aXZhdGlvbjogW0JdXG4gICAqICAgICAgLSBhY3RpdmF0aW9uOiBbQ11cbiAgICpcbiAgICogMi4gVmFsaWRhdGlvbiBwaGFzZTpcbiAgICogICAtPiBjYW5EZWFjdGl2YXRlKEIpXG4gICAqICAgLT4gY2FuQWN0aXZhdGUoQylcbiAgICpcbiAgICogMy4gQWN0aXZhdGlvbiBwaGFzZTpcbiAgICogICAtPiBkZWFjdGl2YXRlKEIpXG4gICAqICAgLT4gYWN0aXZhdGUoQylcbiAgICpcbiAgICogRWFjaCBvZiB0aGVzZSBzdGVwcyBjYW4gYmUgYXN5bmNocm9ub3VzLCBhbmQgYW55XG4gICAqIHN0ZXAgY2FuIHBvdGVudGlhbGx5IGFib3J0IHRoZSB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICBSb3V0ZVRyYW5zaXRpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoY2IpIHtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXM7XG4gICAgdmFyIGRhcSA9IHRoaXMuZGVhY3RpdmF0ZVF1ZXVlO1xuICAgIHZhciBhcSA9IHRoaXMuYWN0aXZhdGVRdWV1ZTtcbiAgICB2YXIgcmRhcSA9IGRhcS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB2YXIgcmV1c2VRdWV1ZSA9IHVuZGVmaW5lZDtcblxuICAgIC8vIDEuIFJldXNhYmlsaXR5IHBoYXNlXG4gICAgdmFyIGkgPSB1bmRlZmluZWQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHJkYXEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghY2FuUmV1c2UocmRhcVtpXSwgYXFbaV0sIHRyYW5zaXRpb24pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA+IDApIHtcbiAgICAgIHJldXNlUXVldWUgPSByZGFxLnNsaWNlKDAsIGkpO1xuICAgICAgZGFxID0gcmRhcS5zbGljZShpKS5yZXZlcnNlKCk7XG4gICAgICBhcSA9IGFxLnNsaWNlKGkpO1xuICAgIH1cblxuICAgIC8vIDIuIFZhbGlkYXRpb24gcGhhc2VcbiAgICB0cmFuc2l0aW9uLnJ1blF1ZXVlKGRhcSwgY2FuRGVhY3RpdmF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdHJhbnNpdGlvbi5ydW5RdWV1ZShhcSwgY2FuQWN0aXZhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5ydW5RdWV1ZShkYXEsIGRlYWN0aXZhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAzLiBBY3RpdmF0aW9uIHBoYXNlXG5cbiAgICAgICAgICAvLyBVcGRhdGUgcm91dGVyIGN1cnJlbnQgcm91dGVcbiAgICAgICAgICB0cmFuc2l0aW9uLnJvdXRlci5fb25UcmFuc2l0aW9uVmFsaWRhdGVkKHRyYW5zaXRpb24pO1xuXG4gICAgICAgICAgLy8gdHJpZ2dlciByZXVzZSBmb3IgYWxsIHJldXNlZCB2aWV3c1xuICAgICAgICAgIHJldXNlUXVldWUgJiYgcmV1c2VRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgICAgICByZXVzZSh2aWV3LCB0cmFuc2l0aW9uKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHRoZSByb290IG9mIHRoZSBjaGFpbiB0aGF0IG5lZWRzIHRvIGJlIHJlcGxhY2VkXG4gICAgICAgICAgLy8gaXMgdGhlIHRvcC1tb3N0IG5vbi1yZXVzYWJsZSB2aWV3LlxuICAgICAgICAgIGlmIChkYXEubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IGRhcVtkYXEubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgZGVwdGggPSByZXVzZVF1ZXVlID8gcmV1c2VRdWV1ZS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgYWN0aXZhdGUodmlldywgdHJhbnNpdGlvbiwgZGVwdGgsIGNiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5IGFuZCBzZXF1ZW50aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiB0byBhXG4gICAqIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBxdWV1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICBSb3V0ZVRyYW5zaXRpb24ucHJvdG90eXBlLnJ1blF1ZXVlID0gZnVuY3Rpb24gcnVuUXVldWUocXVldWUsIGZuLCBjYikge1xuICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcztcbiAgICBzdGVwKDApO1xuICAgIGZ1bmN0aW9uIHN0ZXAoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA+PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuKHF1ZXVlW2luZGV4XSwgdHJhbnNpdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIGEgdXNlciBwcm92aWRlZCByb3V0ZSB0cmFuc2l0aW9uIGhvb2sgYW5kIGhhbmRsZVxuICAgKiB0aGUgcmVzcG9uc2UgKGUuZy4gaWYgdGhlIHVzZXIgcmV0dXJucyBhIHByb21pc2UpLlxuICAgKlxuICAgKiBJZiB0aGUgdXNlciBuZWl0aGVyIGV4cGVjdHMgYW4gYXJndW1lbnQgbm9yIHJldHVybnMgYVxuICAgKiBwcm9taXNlLCB0aGUgaG9vayBpcyBhc3N1bWVkIHRvIGJlIHN5bmNocm9ub3VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gZXhwZWN0Qm9vbGVhblxuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gZXhwZWN0RGF0YVxuICAgKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IGNsZWFudXBcbiAgICovXG5cbiAgUm91dGVUcmFuc2l0aW9uLnByb3RvdHlwZS5jYWxsSG9vayA9IGZ1bmN0aW9uIGNhbGxIb29rKGhvb2ssIGNvbnRleHQsIGNiKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1szXTtcblxuICAgIHZhciBfcmVmJGV4cGVjdEJvb2xlYW4gPSBfcmVmLmV4cGVjdEJvb2xlYW47XG4gICAgdmFyIGV4cGVjdEJvb2xlYW4gPSBfcmVmJGV4cGVjdEJvb2xlYW4gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRleHBlY3RCb29sZWFuO1xuICAgIHZhciBfcmVmJGV4cGVjdERhdGEgPSBfcmVmLmV4cGVjdERhdGE7XG4gICAgdmFyIGV4cGVjdERhdGEgPSBfcmVmJGV4cGVjdERhdGEgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRleHBlY3REYXRhO1xuICAgIHZhciBjbGVhbnVwID0gX3JlZi5jbGVhbnVwO1xuXG4gICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzO1xuICAgIHZhciBuZXh0Q2FsbGVkID0gZmFsc2U7XG5cbiAgICAvLyBhYm9ydCB0aGUgdHJhbnNpdGlvblxuICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgY2xlYW51cCAmJiBjbGVhbnVwKCk7XG4gICAgICB0cmFuc2l0aW9uLmFib3J0KCk7XG4gICAgfTtcblxuICAgIC8vIGhhbmRsZSBlcnJvcnNcbiAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgICAvLyBjbGVhbnVwIGluZGljYXRlcyBhbiBhZnRlci1hY3RpdmF0aW9uIGhvb2ssXG4gICAgICAvLyBzbyBpbnN0ZWFkIG9mIGFib3J0aW5nIHdlIGp1c3QgbGV0IHRoZSB0cmFuc2l0aW9uXG4gICAgICAvLyBmaW5pc2guXG4gICAgICBjbGVhbnVwID8gbmV4dCgpIDogYWJvcnQoKTtcbiAgICAgIGlmIChlcnIgJiYgIXRyYW5zaXRpb24ucm91dGVyLl9zdXBwcmVzcykge1xuICAgICAgICB3YXJuKCdVbmNhdWdodCBlcnJvciBkdXJpbmcgdHJhbnNpdGlvbjogJyk7XG4gICAgICAgIHRocm93IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKGVycik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGFkdmFuY2UgdGhlIHRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RlcFxuICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gbmV4dChkYXRhKSB7XG4gICAgICBpZiAobmV4dENhbGxlZCkge1xuICAgICAgICB3YXJuKCd0cmFuc2l0aW9uLm5leHQoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZS4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbmV4dENhbGxlZCA9IHRydWU7XG4gICAgICBpZiAodHJhbnNpdGlvbi5hYm9ydGVkKSB7XG4gICAgICAgIGNsZWFudXAgJiYgY2xlYW51cCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYiAmJiBjYihkYXRhLCBvbkVycm9yKTtcbiAgICB9O1xuXG4gICAgLy8gZXhwb3NlIGEgY2xvbmUgb2YgdGhlIHRyYW5zaXRpb24gb2JqZWN0LCBzbyB0aGF0IGVhY2hcbiAgICAvLyBob29rIGdldHMgYSBjbGVhbiBjb3B5IGFuZCBwcmV2ZW50IHRoZSB1c2VyIGZyb21cbiAgICAvLyBtZXNzaW5nIHdpdGggdGhlIGludGVybmFscy5cbiAgICB2YXIgZXhwb3NlZCA9IHtcbiAgICAgIHRvOiB0cmFuc2l0aW9uLnRvLFxuICAgICAgZnJvbTogdHJhbnNpdGlvbi5mcm9tLFxuICAgICAgYWJvcnQ6IGFib3J0LFxuICAgICAgbmV4dDogbmV4dCxcbiAgICAgIHJlZGlyZWN0OiBmdW5jdGlvbiByZWRpcmVjdCgpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5yZWRpcmVjdC5hcHBseSh0cmFuc2l0aW9uLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBhY3R1YWxseSBjYWxsIHRoZSBob29rXG4gICAgdmFyIHJlcyA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgcmVzID0gaG9vay5jYWxsKGNvbnRleHQsIGV4cG9zZWQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIG9uRXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgYm9vbGVhbi9wcm9taXNlIHJldHVybiB2YWx1ZXNcbiAgICB2YXIgcmVzSXNQcm9taXNlID0gaXNQcm9taXNlKHJlcyk7XG4gICAgaWYgKGV4cGVjdEJvb2xlYW4pIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmVzID8gbmV4dCgpIDogYWJvcnQoKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzSXNQcm9taXNlKSB7XG4gICAgICAgIHJlcy50aGVuKGZ1bmN0aW9uIChvaykge1xuICAgICAgICAgIG9rID8gbmV4dCgpIDogYWJvcnQoKTtcbiAgICAgICAgfSwgb25FcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKCFob29rLmxlbmd0aCkge1xuICAgICAgICBuZXh0KHJlcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZXNJc1Byb21pc2UpIHtcbiAgICAgIHJlcy50aGVuKG5leHQsIG9uRXJyb3IpO1xuICAgIH0gZWxzZSBpZiAoZXhwZWN0RGF0YSAmJiBpc1BsYWluT2piZWN0KHJlcykgfHwgIWhvb2subGVuZ3RoKSB7XG4gICAgICBuZXh0KHJlcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIGEgc2luZ2xlIGhvb2sgb3IgYW4gYXJyYXkgb2YgYXN5bmMgaG9va3MgaW4gc2VyaWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBob29rc1xuICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cblxuICBSb3V0ZVRyYW5zaXRpb24ucHJvdG90eXBlLmNhbGxIb29rcyA9IGZ1bmN0aW9uIGNhbGxIb29rcyhob29rcywgY29udGV4dCwgY2IsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaG9va3MpKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHJlcy5fbmVlZE1lcmdlID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9uRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLnJ1blF1ZXVlKGhvb2tzLCBmdW5jdGlvbiAoaG9vaywgXywgbmV4dCkge1xuICAgICAgICAgIGlmICghX3RoaXMuYWJvcnRlZCkge1xuICAgICAgICAgICAgX3RoaXMuY2FsbEhvb2soaG9vaywgY29udGV4dCwgZnVuY3Rpb24gKHIsIG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKHIpIHJlcy5wdXNoKHIpO1xuICAgICAgICAgICAgICBvbkVycm9yID0gb25FcnJvcjtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2IocmVzLCBvbkVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhbGxIb29rKGhvb2tzLCBjb250ZXh0LCBjYiwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSb3V0ZVRyYW5zaXRpb247XG59KSgpO1xuXG5mdW5jdGlvbiBpc1BsYWluT2piZWN0KHZhbCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG52YXIgaW50ZXJuYWxLZXlzUkUgPSAvXihjb21wb25lbnR8c3ViUm91dGVzKSQvO1xuXG4vKipcbiAqIFJvdXRlIENvbnRleHQgT2JqZWN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7Um91dGVyfSByb3V0ZXJcbiAqL1xuXG52YXIgUm91dGUgPSBmdW5jdGlvbiBSb3V0ZShwYXRoLCByb3V0ZXIpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGUpO1xuXG4gIHZhciBtYXRjaGVkID0gcm91dGVyLl9yZWNvZ25pemVyLnJlY29nbml6ZShwYXRoKTtcbiAgaWYgKG1hdGNoZWQpIHtcbiAgICAvLyBjb3B5IGFsbCBjdXN0b20gZmllbGRzIGZyb20gcm91dGUgY29uZmlnc1xuICAgIFtdLmZvckVhY2guY2FsbChtYXRjaGVkLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtYXRjaC5oYW5kbGVyKSB7XG4gICAgICAgIGlmICghaW50ZXJuYWxLZXlzUkUudGVzdChrZXkpKSB7XG4gICAgICAgICAgX3RoaXNba2V5XSA9IG1hdGNoLmhhbmRsZXJba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHNldCBxdWVyeSBhbmQgcGFyYW1zXG4gICAgdGhpcy5xdWVyeSA9IG1hdGNoZWQucXVlcnlQYXJhbXM7XG4gICAgdGhpcy5wYXJhbXMgPSBbXS5yZWR1Y2UuY2FsbChtYXRjaGVkLCBmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgICBpZiAoY3VyLnBhcmFtcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY3VyLnBhcmFtcykge1xuICAgICAgICAgIHByZXZba2V5XSA9IGN1ci5wYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xuICB9XG4gIC8vIGV4cG9zZSBwYXRoIGFuZCByb3V0ZXJcbiAgdGhpcy5wYXRoID0gcGF0aDtcbiAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gIC8vIGZvciBpbnRlcm5hbCB1c2VcbiAgdGhpcy5tYXRjaGVkID0gbWF0Y2hlZCB8fCByb3V0ZXIuX25vdEZvdW5kSGFuZGxlcjtcbiAgLy8gSW1wb3J0YW50OiBmcmVlemUgc2VsZiB0byBwcmV2ZW50IG9ic2VydmF0aW9uXG4gIE9iamVjdC5mcmVlemUodGhpcyk7XG59O1xuXG5mdW5jdGlvbiBhcHBseU92ZXJyaWRlIChWdWUpIHtcblxuICB2YXIgXyA9IFZ1ZS51dGlsO1xuXG4gIC8vIG92ZXJyaWRlIFZ1ZSdzIGluaXQgYW5kIGRlc3Ryb3kgcHJvY2VzcyB0byBrZWVwIHRyYWNrIG9mIHJvdXRlciBpbnN0YW5jZXNcbiAgdmFyIGluaXQgPSBWdWUucHJvdG90eXBlLl9pbml0O1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgcm9vdCA9IG9wdGlvbnMuX3BhcmVudCB8fCBvcHRpb25zLnBhcmVudCB8fCB0aGlzO1xuICAgIHZhciByb3V0ZSA9IHJvb3QuJHJvdXRlO1xuICAgIGlmIChyb3V0ZSkge1xuICAgICAgcm91dGUucm91dGVyLl9jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgaWYgKCF0aGlzLiRyb3V0ZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMuX2RlZmluZU1ldGEpIHtcbiAgICAgICAgICAvLyAwLjEyXG4gICAgICAgICAgdGhpcy5fZGVmaW5lTWV0YSgnJHJvdXRlJywgcm91dGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDEuMFxuICAgICAgICAgIF8uZGVmaW5lUmVhY3RpdmUodGhpcywgJyRyb3V0ZScsIHJvdXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIGRlc3Ryb3kgPSBWdWUucHJvdG90eXBlLl9kZXN0cm95O1xuICBWdWUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgdmFyIHJvdXRlID0gdGhpcy4kcm9vdC4kcm91dGU7XG4gICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgcm91dGUucm91dGVyLl9jaGlsZHJlbi4kcmVtb3ZlKHRoaXMpO1xuICAgICAgfVxuICAgICAgZGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcblxuICAvLyAxLjAgb25seTogZW5hYmxlIHJvdXRlIG1peGluc1xuICB2YXIgc3RyYXRzID0gVnVlLmNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG4gIHZhciBob29rc1RvTWVyZ2VSRSA9IC9eKGRhdGF8YWN0aXZhdGV8ZGVhY3RpdmF0ZSkkLztcblxuICBpZiAoc3RyYXRzKSB7XG4gICAgc3RyYXRzLnJvdXRlID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICAgIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWw7XG4gICAgICBpZiAoIXBhcmVudFZhbCkgcmV0dXJuIGNoaWxkVmFsO1xuICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgXy5leHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgICAgIHZhciBhID0gcmV0W2tleV07XG4gICAgICAgIHZhciBiID0gY2hpbGRWYWxba2V5XTtcbiAgICAgICAgLy8gZm9yIGRhdGEsIGFjdGl2YXRlIGFuZCBkZWFjdGl2YXRlLCB3ZSBuZWVkIHRvIG1lcmdlIHRoZW0gaW50b1xuICAgICAgICAvLyBhcnJheXMgc2ltaWxhciB0byBsaWZlY3ljbGUgaG9va3MuXG4gICAgICAgIGlmIChhICYmIGhvb2tzVG9NZXJnZVJFLnRlc3Qoa2V5KSkge1xuICAgICAgICAgIHJldFtrZXldID0gKF8uaXNBcnJheShhKSA/IGEgOiBbYV0pLmNvbmNhdChiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRba2V5XSA9IGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBWaWV3IChWdWUpIHtcblxuICB2YXIgXyA9IFZ1ZS51dGlsO1xuICB2YXIgY29tcG9uZW50RGVmID1cbiAgLy8gMC4xMlxuICBWdWUuZGlyZWN0aXZlKCdfY29tcG9uZW50JykgfHxcbiAgLy8gMS4wXG4gIFZ1ZS5pbnRlcm5hbERpcmVjdGl2ZXMuY29tcG9uZW50O1xuICAvLyA8cm91dGVyLXZpZXc+IGV4dGVuZHMgdGhlIGludGVybmFsIGNvbXBvbmVudCBkaXJlY3RpdmVcbiAgdmFyIHZpZXdEZWYgPSBfLmV4dGVuZCh7fSwgY29tcG9uZW50RGVmKTtcblxuICAvLyB3aXRoIHNvbWUgb3ZlcnJpZGVzXG4gIF8uZXh0ZW5kKHZpZXdEZWYsIHtcblxuICAgIF9pc1JvdXRlclZpZXc6IHRydWUsXG5cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgdmFyIHJvdXRlID0gdGhpcy52bS4kcm91dGU7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghcm91dGUpIHtcbiAgICAgICAgd2FybignPHJvdXRlci12aWV3PiBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhICcgKyAncm91dGVyLWVuYWJsZWQgYXBwLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBmb3JjZSBkeW5hbWljIGRpcmVjdGl2ZSBzbyB2LWNvbXBvbmVudCBkb2Vzbid0XG4gICAgICAvLyBhdHRlbXB0IHRvIGJ1aWxkIHJpZ2h0IG5vd1xuICAgICAgdGhpcy5faXNEeW5hbWljTGl0ZXJhbCA9IHRydWU7XG4gICAgICAvLyBmaW5hbGx5LCBpbml0IGJ5IGRlbGVnYXRpbmcgdG8gdi1jb21wb25lbnRcbiAgICAgIGNvbXBvbmVudERlZi5iaW5kLmNhbGwodGhpcyk7XG5cbiAgICAgIC8vIGFsbCB3ZSBuZWVkIHRvIGRvIGhlcmUgaXMgcmVnaXN0ZXJpbmcgdGhpcyB2aWV3XG4gICAgICAvLyBpbiB0aGUgcm91dGVyLiBhY3R1YWwgY29tcG9uZW50IHN3aXRjaGluZyB3aWxsIGJlXG4gICAgICAvLyBtYW5hZ2VkIGJ5IHRoZSBwaXBlbGluZS5cbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnJvdXRlciA9IHJvdXRlLnJvdXRlcjtcbiAgICAgIHJvdXRlci5fdmlld3MudW5zaGlmdCh0aGlzKTtcblxuICAgICAgLy8gbm90ZSB0aGUgdmlld3MgYXJlIGluIHJldmVyc2Ugb3JkZXIuXG4gICAgICB2YXIgcGFyZW50VmlldyA9IHJvdXRlci5fdmlld3NbMV07XG4gICAgICBpZiAocGFyZW50Vmlldykge1xuICAgICAgICAvLyByZWdpc3RlciBzZWxmIGFzIGEgY2hpbGQgb2YgdGhlIHBhcmVudCB2aWV3LFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGFjdGl2YXRpbmcgbm93LiBUaGlzIGlzIHNvIHRoYXQgdGhlXG4gICAgICAgIC8vIGNoaWxkJ3MgYWN0aXZhdGUgaG9vayBpcyBjYWxsZWQgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIHBhcmVudCdzIGhhcyByZXNvbHZlZC5cbiAgICAgICAgcGFyZW50Vmlldy5jaGlsZFZpZXcgPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgbGF0ZS1yZW5kZXJlZCB2aWV3XG4gICAgICAvLyB0d28gcG9zc2liaWxpdGllczpcbiAgICAgIC8vIDEuIHJvb3QgdmlldyByZW5kZXJlZCBhZnRlciB0cmFuc2l0aW9uIGhhcyBiZWVuXG4gICAgICAvLyAgICB2YWxpZGF0ZWQ7XG4gICAgICAvLyAyLiBjaGlsZCB2aWV3IHJlbmRlcmVkIGFmdGVyIHBhcmVudCB2aWV3IGhhcyBiZWVuXG4gICAgICAvLyAgICBhY3RpdmF0ZWQuXG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IHJvdXRlLnJvdXRlci5fY3VycmVudFRyYW5zaXRpb247XG4gICAgICBpZiAoIXBhcmVudFZpZXcgJiYgdHJhbnNpdGlvbi5kb25lIHx8IHBhcmVudFZpZXcgJiYgcGFyZW50Vmlldy5hY3RpdmF0ZWQpIHtcbiAgICAgICAgdmFyIGRlcHRoID0gcGFyZW50VmlldyA/IHBhcmVudFZpZXcuZGVwdGggKyAxIDogMDtcbiAgICAgICAgYWN0aXZhdGUodGhpcywgdHJhbnNpdGlvbiwgZGVwdGgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIHRoaXMucm91dGVyLl92aWV3cy4kcmVtb3ZlKHRoaXMpO1xuICAgICAgY29tcG9uZW50RGVmLnVuYmluZC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgVnVlLmVsZW1lbnREaXJlY3RpdmUoJ3JvdXRlci12aWV3Jywgdmlld0RlZik7XG59XG5cbnZhciB0cmFpbGluZ1NsYXNoUkUgPSAvXFwvJC87XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG52YXIgcXVlcnlTdHJpbmdSRSA9IC9cXD8uKiQvO1xuXG4vLyBpbnN0YWxsIHYtbGluaywgd2hpY2ggcHJvdmlkZXMgbmF2aWdhdGlvbiBzdXBwb3J0IGZvclxuLy8gSFRNTDUgaGlzdG9yeSBtb2RlXG5mdW5jdGlvbiBMaW5rIChWdWUpIHtcblxuICB2YXIgXyA9IFZ1ZS51dGlsO1xuXG4gIFZ1ZS5kaXJlY3RpdmUoJ2xpbmsnLCB7XG5cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHZtID0gdGhpcy52bTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCF2bS4kcm91dGUpIHtcbiAgICAgICAgd2Fybigndi1saW5rIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgJyArICdyb3V0ZXItZW5hYmxlZCBhcHAuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIG5vIG5lZWQgdG8gaGFuZGxlIGNsaWNrIGlmIGxpbmsgZXhwZWN0cyB0byBiZSBvcGVuZWRcbiAgICAgIC8vIGluIGEgbmV3IHdpbmRvdy90YWIuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLmVsLnRhZ05hbWUgPT09ICdBJyAmJiB0aGlzLmVsLmdldEF0dHJpYnV0ZSgndGFyZ2V0JykgPT09ICdfYmxhbmsnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGhhbmRsZSBjbGlja1xuICAgICAgdmFyIHJvdXRlciA9IHZtLiRyb3V0ZS5yb3V0ZXI7XG4gICAgICB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBkb24ndCByZWRpcmVjdCB3aXRoIGNvbnRyb2wga2V5c1xuICAgICAgICBpZiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSByZXR1cm47XG4gICAgICAgIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXG4gICAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgICAgLy8gZG9uJ3QgcmVkaXJlY3Qgb24gcmlnaHQgY2xpY2tcbiAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRhcmdldCA9IF90aGlzLnRhcmdldDtcbiAgICAgICAgdmFyIGdvID0gZnVuY3Rpb24gZ28odGFyZ2V0KSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcm91dGVyLmdvKHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChfdGhpcy5lbC50YWdOYW1lID09PSAnQScgfHwgZS50YXJnZXQgPT09IF90aGlzLmVsKSB7XG4gICAgICAgICAgLy8gdi1saW5rIG9uIDxhIHYtbGluaz1cIidwYXRoJ1wiPlxuICAgICAgICAgIGdvKHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1saW5rIGRlbGVnYXRlIG9uIDxkaXYgdi1saW5rPlxuICAgICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICAgIHdoaWxlIChlbCAmJiBlbC50YWdOYW1lICE9PSAnQScgJiYgZWwgIT09IF90aGlzLmVsKSB7XG4gICAgICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZWwpIHJldHVybjtcbiAgICAgICAgICBpZiAoZWwudGFnTmFtZSAhPT0gJ0EnIHx8ICFlbC5ocmVmKSB7XG4gICAgICAgICAgICAvLyBhbGxvdyBub3QgYW5jaG9yXG4gICAgICAgICAgICBnbyh0YXJnZXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2FtZU9yaWdpbihlbCkpIHtcbiAgICAgICAgICAgIGdvKHtcbiAgICAgICAgICAgICAgcGF0aDogZWwucGF0aG5hbWUsXG4gICAgICAgICAgICAgIHJlcGxhY2U6IHRhcmdldCAmJiB0YXJnZXQucmVwbGFjZSxcbiAgICAgICAgICAgICAgYXBwZW5kOiB0YXJnZXQgJiYgdGFyZ2V0LmFwcGVuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlcik7XG4gICAgICAvLyBtYW5hZ2UgYWN0aXZlIGxpbmsgY2xhc3NcbiAgICAgIHRoaXMudW53YXRjaCA9IHZtLiR3YXRjaCgnJHJvdXRlLnBhdGgnLCBfLmJpbmQodGhpcy51cGRhdGVDbGFzc2VzLCB0aGlzKSk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHBhdGgpIHtcbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnZtLiRyb3V0ZS5yb3V0ZXI7XG4gICAgICB2YXIgYXBwZW5kID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy50YXJnZXQgPSBwYXRoO1xuICAgICAgaWYgKF8uaXNPYmplY3QocGF0aCkpIHtcbiAgICAgICAgYXBwZW5kID0gcGF0aC5hcHBlbmQ7XG4gICAgICAgIHRoaXMuZXhhY3QgPSBwYXRoLmV4YWN0O1xuICAgICAgICB0aGlzLnByZXZBY3RpdmVDbGFzcyA9IHRoaXMuYWN0aXZlQ2xhc3M7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2xhc3MgPSBwYXRoLmFjdGl2ZUNsYXNzO1xuICAgICAgfVxuICAgICAgcGF0aCA9IHRoaXMucGF0aCA9IHJvdXRlci5fc3RyaW5naWZ5UGF0aChwYXRoKTtcbiAgICAgIHRoaXMuYWN0aXZlUkUgPSBwYXRoICYmICF0aGlzLmV4YWN0ID8gbmV3IFJlZ0V4cCgnXicgKyBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJykucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJykgKyAnKFxcXFwvfCQpJykgOiBudWxsO1xuICAgICAgdGhpcy51cGRhdGVDbGFzc2VzKHRoaXMudm0uJHJvdXRlLnBhdGgpO1xuICAgICAgdmFyIGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICAgICAgLy8gZG8gbm90IGZvcm1hdCBub24taGFzaCByZWxhdGl2ZSBwYXRoc1xuICAgICAgdmFyIGhyZWYgPSBwYXRoICYmIChyb3V0ZXIubW9kZSA9PT0gJ2hhc2gnIHx8IGlzQWJzb2x1dGUpID8gcm91dGVyLmhpc3RvcnkuZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpIDogcGF0aDtcbiAgICAgIGlmICh0aGlzLmVsLnRhZ05hbWUgPT09ICdBJykge1xuICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgIHRoaXMuZWwuaHJlZiA9IGhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVDbGFzc2VzOiBmdW5jdGlvbiB1cGRhdGVDbGFzc2VzKHBhdGgpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICB2YXIgcm91dGVyID0gdGhpcy52bS4kcm91dGUucm91dGVyO1xuICAgICAgdmFyIGFjdGl2ZUNsYXNzID0gdGhpcy5hY3RpdmVDbGFzcyB8fCByb3V0ZXIuX2xpbmtBY3RpdmVDbGFzcztcbiAgICAgIC8vIGNsZWFyIG9sZCBjbGFzc1xuICAgICAgaWYgKHRoaXMucHJldkFjdGl2ZUNsYXNzICE9PSBhY3RpdmVDbGFzcykge1xuICAgICAgICBfLnJlbW92ZUNsYXNzKGVsLCB0aGlzLnByZXZBY3RpdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgcXVlcnkgc3RyaW5nIGJlZm9yZSBtYXRjaGluZ1xuICAgICAgdmFyIGRlc3QgPSB0aGlzLnBhdGgucmVwbGFjZShxdWVyeVN0cmluZ1JFLCAnJyk7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKHF1ZXJ5U3RyaW5nUkUsICcnKTtcbiAgICAgIC8vIGFkZCBuZXcgY2xhc3NcbiAgICAgIGlmICh0aGlzLmV4YWN0KSB7XG4gICAgICAgIGlmIChkZXN0ID09PSBwYXRoIHx8XG4gICAgICAgIC8vIGFsc28gYWxsb3cgYWRkaXRpb25hbCB0cmFpbGluZyBzbGFzaFxuICAgICAgICBkZXN0LmNoYXJBdChkZXN0Lmxlbmd0aCAtIDEpICE9PSAnLycgJiYgZGVzdCA9PT0gcGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpKSB7XG4gICAgICAgICAgXy5hZGRDbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF8ucmVtb3ZlQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlUkUgJiYgdGhpcy5hY3RpdmVSRS50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgXy5hZGRDbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF8ucmVtb3ZlQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZXIpO1xuICAgICAgdGhpcy51bndhdGNoICYmIHRoaXMudW53YXRjaCgpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gc2FtZU9yaWdpbihsaW5rKSB7XG4gICAgcmV0dXJuIGxpbmsucHJvdG9jb2wgPT09IGxvY2F0aW9uLnByb3RvY29sICYmIGxpbmsuaG9zdG5hbWUgPT09IGxvY2F0aW9uLmhvc3RuYW1lICYmIGxpbmsucG9ydCA9PT0gbG9jYXRpb24ucG9ydDtcbiAgfVxufVxuXG52YXIgaGlzdG9yeUJhY2tlbmRzID0ge1xuICBhYnN0cmFjdDogQWJzdHJhY3RIaXN0b3J5LFxuICBoYXNoOiBIYXNoSGlzdG9yeSxcbiAgaHRtbDU6IEhUTUw1SGlzdG9yeVxufTtcblxuLy8gbGF0ZSBiaW5kIGR1cmluZyBpbnN0YWxsXG52YXIgVnVlID0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIFJvdXRlciBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqL1xuXG52YXIgUm91dGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUm91dGVyKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgX3JlZiRoYXNoYmFuZyA9IF9yZWYuaGFzaGJhbmc7XG4gICAgdmFyIGhhc2hiYW5nID0gX3JlZiRoYXNoYmFuZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkaGFzaGJhbmc7XG4gICAgdmFyIF9yZWYkYWJzdHJhY3QgPSBfcmVmLmFic3RyYWN0O1xuICAgIHZhciBhYnN0cmFjdCA9IF9yZWYkYWJzdHJhY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRhYnN0cmFjdDtcbiAgICB2YXIgX3JlZiRoaXN0b3J5ID0gX3JlZi5oaXN0b3J5O1xuICAgIHZhciBoaXN0b3J5ID0gX3JlZiRoaXN0b3J5ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkaGlzdG9yeTtcbiAgICB2YXIgX3JlZiRzYXZlU2Nyb2xsUG9zaXRpb24gPSBfcmVmLnNhdmVTY3JvbGxQb3NpdGlvbjtcbiAgICB2YXIgc2F2ZVNjcm9sbFBvc2l0aW9uID0gX3JlZiRzYXZlU2Nyb2xsUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRzYXZlU2Nyb2xsUG9zaXRpb247XG4gICAgdmFyIF9yZWYkdHJhbnNpdGlvbk9uTG9hZCA9IF9yZWYudHJhbnNpdGlvbk9uTG9hZDtcbiAgICB2YXIgdHJhbnNpdGlvbk9uTG9hZCA9IF9yZWYkdHJhbnNpdGlvbk9uTG9hZCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHRyYW5zaXRpb25PbkxvYWQ7XG4gICAgdmFyIF9yZWYkc3VwcHJlc3NUcmFuc2l0aW9uRXJyb3IgPSBfcmVmLnN1cHByZXNzVHJhbnNpdGlvbkVycm9yO1xuICAgIHZhciBzdXBwcmVzc1RyYW5zaXRpb25FcnJvciA9IF9yZWYkc3VwcHJlc3NUcmFuc2l0aW9uRXJyb3IgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRzdXBwcmVzc1RyYW5zaXRpb25FcnJvcjtcbiAgICB2YXIgX3JlZiRyb290ID0gX3JlZi5yb290O1xuICAgIHZhciByb290ID0gX3JlZiRyb290ID09PSB1bmRlZmluZWQgPyBudWxsIDogX3JlZiRyb290O1xuICAgIHZhciBfcmVmJGxpbmtBY3RpdmVDbGFzcyA9IF9yZWYubGlua0FjdGl2ZUNsYXNzO1xuICAgIHZhciBsaW5rQWN0aXZlQ2xhc3MgPSBfcmVmJGxpbmtBY3RpdmVDbGFzcyA9PT0gdW5kZWZpbmVkID8gJ3YtbGluay1hY3RpdmUnIDogX3JlZiRsaW5rQWN0aXZlQ2xhc3M7XG4gICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlcik7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIVJvdXRlci5pbnN0YWxsZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGluc3RhbGwgdGhlIFJvdXRlciB3aXRoIFZ1ZS51c2UoKSBiZWZvcmUgJyArICdjcmVhdGluZyBhbiBpbnN0YW5jZS4nKTtcbiAgICB9XG5cbiAgICAvLyBWdWUgaW5zdGFuY2VzXG4gICAgdGhpcy5hcHAgPSBudWxsO1xuICAgIHRoaXMuX3ZpZXdzID0gW107XG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcblxuICAgIC8vIHJvdXRlIHJlY29nbml6ZXJcbiAgICB0aGlzLl9yZWNvZ25pemVyID0gbmV3IFJvdXRlUmVjb2duaXplcigpO1xuICAgIHRoaXMuX2d1YXJkUmVjb2duaXplciA9IG5ldyBSb3V0ZVJlY29nbml6ZXIoKTtcblxuICAgIC8vIHN0YXRlXG4gICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXJ0Q2IgPSBudWxsO1xuICAgIHRoaXMuX2N1cnJlbnRSb3V0ZSA9IHt9O1xuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uID0gbnVsbDtcbiAgICB0aGlzLl9wcmV2aW91c1RyYW5zaXRpb24gPSBudWxsO1xuICAgIHRoaXMuX25vdEZvdW5kSGFuZGxlciA9IG51bGw7XG4gICAgdGhpcy5fbm90Rm91bmRSZWRpcmVjdCA9IG51bGw7XG4gICAgdGhpcy5fYmVmb3JlRWFjaEhvb2tzID0gW107XG4gICAgdGhpcy5fYWZ0ZXJFYWNoSG9va3MgPSBbXTtcblxuICAgIC8vIGZlYXR1cmUgZGV0ZWN0aW9uXG4gICAgdGhpcy5faGFzUHVzaFN0YXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmhpc3RvcnkgJiYgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlO1xuXG4gICAgLy8gdHJpZ2dlciB0cmFuc2l0aW9uIG9uIGluaXRpYWwgcmVuZGVyP1xuICAgIHRoaXMuX3JlbmRlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5fdHJhbnNpdGlvbk9uTG9hZCA9IHRyYW5zaXRpb25PbkxvYWQ7XG5cbiAgICAvLyBoaXN0b3J5IG1vZGVcbiAgICB0aGlzLl9hYnN0cmFjdCA9IGFic3RyYWN0O1xuICAgIHRoaXMuX2hhc2hiYW5nID0gaGFzaGJhbmc7XG4gICAgdGhpcy5faGlzdG9yeSA9IHRoaXMuX2hhc1B1c2hTdGF0ZSAmJiBoaXN0b3J5O1xuXG4gICAgLy8gb3RoZXIgb3B0aW9uc1xuICAgIHRoaXMuX3NhdmVTY3JvbGxQb3NpdGlvbiA9IHNhdmVTY3JvbGxQb3NpdGlvbjtcbiAgICB0aGlzLl9saW5rQWN0aXZlQ2xhc3MgPSBsaW5rQWN0aXZlQ2xhc3M7XG4gICAgdGhpcy5fc3VwcHJlc3MgPSBzdXBwcmVzc1RyYW5zaXRpb25FcnJvcjtcblxuICAgIC8vIGNyZWF0ZSBoaXN0b3J5IG9iamVjdFxuICAgIHZhciBpbkJyb3dzZXIgPSBWdWUudXRpbC5pbkJyb3dzZXI7XG4gICAgdGhpcy5tb2RlID0gIWluQnJvd3NlciB8fCB0aGlzLl9hYnN0cmFjdCA/ICdhYnN0cmFjdCcgOiB0aGlzLl9oaXN0b3J5ID8gJ2h0bWw1JyA6ICdoYXNoJztcblxuICAgIHZhciBIaXN0b3J5ID0gaGlzdG9yeUJhY2tlbmRzW3RoaXMubW9kZV07XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHtcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICBoYXNoYmFuZzogdGhpcy5faGFzaGJhbmcsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UocGF0aCwgc3RhdGUsIGFuY2hvcikge1xuICAgICAgICBzZWxmLl9tYXRjaChwYXRoLCBzdGF0ZSwgYW5jaG9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyBkaXJlY3RseSBwYXNzaW5nIGNvbXBvbmVudHMgdG8gYSByb3V0ZVxuICAgKiBkZWZpbml0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlclxuICAgKi9cblxuICAvLyBBUEkgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICogUmVnaXN0ZXIgYSBtYXAgb2YgdG9wLWxldmVsIHBhdGhzLlxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAqL1xuXG4gIFJvdXRlci5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwKF9tYXApIHtcbiAgICBmb3IgKHZhciByb3V0ZSBpbiBfbWFwKSB7XG4gICAgICB0aGlzLm9uKHJvdXRlLCBfbWFwW3JvdXRlXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHNpbmdsZSByb290LWxldmVsIHBhdGhcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJvb3RQYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGNvbXBvbmVudFxuICAgKiAgICAgICAgICAgICAgICAgLSB7T2JqZWN0fSBbc3ViUm91dGVzXVxuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gW2ZvcmNlUmVmcmVzaF1cbiAgICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbYmVmb3JlXVxuICAgKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFthZnRlcl1cbiAgICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKHJvb3RQYXRoLCBoYW5kbGVyKSB7XG4gICAgaWYgKHJvb3RQYXRoID09PSAnKicpIHtcbiAgICAgIHRoaXMuX25vdEZvdW5kKGhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRSb3V0ZShyb290UGF0aCwgaGFuZGxlciwgW10pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHJlZGlyZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAgKi9cblxuICBSb3V0ZXIucHJvdG90eXBlLnJlZGlyZWN0ID0gZnVuY3Rpb24gcmVkaXJlY3QobWFwKSB7XG4gICAgZm9yICh2YXIgcGF0aCBpbiBtYXApIHtcbiAgICAgIHRoaXMuX2FkZFJlZGlyZWN0KHBhdGgsIG1hcFtwYXRoXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYWxpYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAgKi9cblxuICBSb3V0ZXIucHJvdG90eXBlLmFsaWFzID0gZnVuY3Rpb24gYWxpYXMobWFwKSB7XG4gICAgZm9yICh2YXIgcGF0aCBpbiBtYXApIHtcbiAgICAgIHRoaXMuX2FkZEFsaWFzKHBhdGgsIG1hcFtwYXRoXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgZ2xvYmFsIGJlZm9yZSBob29rLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKi9cblxuICBSb3V0ZXIucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbiBiZWZvcmVFYWNoKGZuKSB7XG4gICAgdGhpcy5fYmVmb3JlRWFjaEhvb2tzLnB1c2goZm4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgZ2xvYmFsIGFmdGVyIGhvb2suXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFJvdXRlci5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24gYWZ0ZXJFYWNoKGZuKSB7XG4gICAgdGhpcy5fYWZ0ZXJFYWNoSG9va3MucHVzaChmbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIGEgZ2l2ZW4gcGF0aC5cbiAgICogVGhlIHBhdGggY2FuIGJlIGFuIG9iamVjdCBkZXNjcmliaW5nIGEgbmFtZWQgcGF0aCBpblxuICAgKiB0aGUgZm9ybWF0IG9mIHsgbmFtZTogJy4uLicsIHBhcmFtczoge30sIHF1ZXJ5OiB7fX1cbiAgICogVGhlIHBhdGggaXMgYXNzdW1lZCB0byBiZSBhbHJlYWR5IGRlY29kZWQsIGFuZCB3aWxsXG4gICAqIGJlIHJlc29sdmVkIGFnYWluc3Qgcm9vdCAoaWYgcHJvdmlkZWQpXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcGF0aFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZXBsYWNlXVxuICAgKi9cblxuICBSb3V0ZXIucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28ocGF0aCkge1xuICAgIHZhciByZXBsYWNlID0gZmFsc2U7XG4gICAgdmFyIGFwcGVuZCA9IGZhbHNlO1xuICAgIGlmIChWdWUudXRpbC5pc09iamVjdChwYXRoKSkge1xuICAgICAgcmVwbGFjZSA9IHBhdGgucmVwbGFjZTtcbiAgICAgIGFwcGVuZCA9IHBhdGguYXBwZW5kO1xuICAgIH1cbiAgICBwYXRoID0gdGhpcy5fc3RyaW5naWZ5UGF0aChwYXRoKTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgdGhpcy5oaXN0b3J5LmdvKHBhdGgsIHJlcGxhY2UsIGFwcGVuZCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTaG9ydCBoYW5kIGZvciByZXBsYWNpbmcgY3VycmVudCBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqL1xuXG4gIFJvdXRlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhdGggPSB7IHBhdGg6IHBhdGggfTtcbiAgICB9XG4gICAgcGF0aC5yZXBsYWNlID0gdHJ1ZTtcbiAgICB0aGlzLmdvKHBhdGgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgcm91dGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZUNvbnN0cnVjdG9yfSBBcHBcbiAgICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gY29udGFpbmVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KEFwcCwgY29udGFpbmVyLCBjYikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLl9zdGFydGVkKSB7XG4gICAgICB3YXJuKCdhbHJlYWR5IHN0YXJ0ZWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3N0YXJ0Q2IgPSBjYjtcbiAgICBpZiAoIXRoaXMuYXBwKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghQXBwIHx8ICFjb250YWluZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHN0YXJ0IHZ1ZS1yb3V0ZXIgd2l0aCBhIGNvbXBvbmVudCBhbmQgYSAnICsgJ3Jvb3QgY29udGFpbmVyLicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYXBwQ29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgdmFyIEN0b3IgPSB0aGlzLl9hcHBDb25zdHJ1Y3RvciA9IHR5cGVvZiBBcHAgPT09ICdmdW5jdGlvbicgPyBBcHAgOiBWdWUuZXh0ZW5kKEFwcCk7XG4gICAgICAvLyBnaXZlIGl0IGEgbmFtZSBmb3IgYmV0dGVyIGRlYnVnZ2luZ1xuICAgICAgQ3Rvci5vcHRpb25zLm5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCAnUm91dGVyQXBwJztcbiAgICB9XG4gICAgdGhpcy5oaXN0b3J5LnN0YXJ0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgbGlzdGVuaW5nIHRvIHJvdXRlIGNoYW5nZXMuXG4gICAqL1xuXG4gIFJvdXRlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgdGhpcy5oaXN0b3J5LnN0b3AoKTtcbiAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgbWV0aG9kcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAqIEFkZCBhIHJvdXRlIGNvbnRhaW5pbmcgYSBsaXN0IG9mIHNlZ21lbnRzIHRvIHRoZSBpbnRlcm5hbFxuICAqIHJvdXRlIHJlY29nbml6ZXIuIFdpbGwgYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5IHRvIGFkZCBhbGxcbiAgKiBwb3NzaWJsZSBzdWItcm91dGVzLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlclxuICAqIEBwYXJhbSB7QXJyYXl9IHNlZ21lbnRzXG4gICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5fYWRkUm91dGUgPSBmdW5jdGlvbiBfYWRkUm91dGUocGF0aCwgaGFuZGxlciwgc2VnbWVudHMpIHtcbiAgICBndWFyZENvbXBvbmVudChwYXRoLCBoYW5kbGVyKTtcbiAgICBoYW5kbGVyLnBhdGggPSBwYXRoO1xuICAgIGhhbmRsZXIuZnVsbFBhdGggPSAoc2VnbWVudHMucmVkdWNlKGZ1bmN0aW9uIChwYXRoLCBzZWdtZW50KSB7XG4gICAgICByZXR1cm4gcGF0aCArIHNlZ21lbnQucGF0aDtcbiAgICB9LCAnJykgKyBwYXRoKS5yZXBsYWNlKCcvLycsICcvJyk7XG4gICAgc2VnbWVudHMucHVzaCh7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgIH0pO1xuICAgIHRoaXMuX3JlY29nbml6ZXIuYWRkKHNlZ21lbnRzLCB7XG4gICAgICBhczogaGFuZGxlci5uYW1lXG4gICAgfSk7XG4gICAgLy8gYWRkIHN1YiByb3V0ZXNcbiAgICBpZiAoaGFuZGxlci5zdWJSb3V0ZXMpIHtcbiAgICAgIGZvciAodmFyIHN1YlBhdGggaW4gaGFuZGxlci5zdWJSb3V0ZXMpIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgd2FsayBhbGwgc3ViIHJvdXRlc1xuICAgICAgICB0aGlzLl9hZGRSb3V0ZShzdWJQYXRoLCBoYW5kbGVyLnN1YlJvdXRlc1tzdWJQYXRoXSxcbiAgICAgICAgLy8gcGFzcyBhIGNvcHkgaW4gcmVjdXJzaW9uIHRvIGF2b2lkIG11dGF0aW5nXG4gICAgICAgIC8vIGFjcm9zcyBicmFuY2hlc1xuICAgICAgICBzZWdtZW50cy5zbGljZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbm90Rm91bmQgcm91dGUgaGFuZGxlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5fbm90Rm91bmQgPSBmdW5jdGlvbiBfbm90Rm91bmQoaGFuZGxlcikge1xuICAgIGd1YXJkQ29tcG9uZW50KCcqJywgaGFuZGxlcik7XG4gICAgdGhpcy5fbm90Rm91bmRIYW5kbGVyID0gW3sgaGFuZGxlcjogaGFuZGxlciB9XTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgcmVkaXJlY3QgcmVjb3JkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVkaXJlY3RQYXRoXG4gICAqL1xuXG4gIFJvdXRlci5wcm90b3R5cGUuX2FkZFJlZGlyZWN0ID0gZnVuY3Rpb24gX2FkZFJlZGlyZWN0KHBhdGgsIHJlZGlyZWN0UGF0aCkge1xuICAgIGlmIChwYXRoID09PSAnKicpIHtcbiAgICAgIHRoaXMuX25vdEZvdW5kUmVkaXJlY3QgPSByZWRpcmVjdFBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZEd1YXJkKHBhdGgsIHJlZGlyZWN0UGF0aCwgdGhpcy5yZXBsYWNlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBhbGlhcyByZWNvcmQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhc1BhdGhcbiAgICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5fYWRkQWxpYXMgPSBmdW5jdGlvbiBfYWRkQWxpYXMocGF0aCwgYWxpYXNQYXRoKSB7XG4gICAgdGhpcy5fYWRkR3VhcmQocGF0aCwgYWxpYXNQYXRoLCB0aGlzLl9tYXRjaCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHBhdGggZ3VhcmQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtYXBwZWRQYXRoXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5fYWRkR3VhcmQgPSBmdW5jdGlvbiBfYWRkR3VhcmQocGF0aCwgbWFwcGVkUGF0aCwgX2hhbmRsZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fZ3VhcmRSZWNvZ25pemVyLmFkZChbe1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIobWF0Y2gsIHF1ZXJ5KSB7XG4gICAgICAgIHZhciByZWFsUGF0aCA9IG1hcFBhcmFtcyhtYXBwZWRQYXRoLCBtYXRjaC5wYXJhbXMsIHF1ZXJ5KTtcbiAgICAgICAgX2hhbmRsZXIuY2FsbChfdGhpcywgcmVhbFBhdGgpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBwYXRoIG1hdGNoZXMgYW55IHJlZGlyZWN0IHJlY29yZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gaWYgdHJ1ZSwgd2lsbCBza2lwIG5vcm1hbCBtYXRjaC5cbiAgICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5fY2hlY2tHdWFyZCA9IGZ1bmN0aW9uIF9jaGVja0d1YXJkKHBhdGgpIHtcbiAgICB2YXIgbWF0Y2hlZCA9IHRoaXMuX2d1YXJkUmVjb2duaXplci5yZWNvZ25pemUocGF0aCk7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIG1hdGNoZWRbMF0uaGFuZGxlcihtYXRjaGVkWzBdLCBtYXRjaGVkLnF1ZXJ5UGFyYW1zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fbm90Rm91bmRSZWRpcmVjdCkge1xuICAgICAgbWF0Y2hlZCA9IHRoaXMuX3JlY29nbml6ZXIucmVjb2duaXplKHBhdGgpO1xuICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgIHRoaXMucmVwbGFjZSh0aGlzLl9ub3RGb3VuZFJlZGlyZWN0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNYXRjaCBhIFVSTCBwYXRoIGFuZCBzZXQgdGhlIHJvdXRlIGNvbnRleHQgb24gdm0sXG4gICAqIHRyaWdnZXJpbmcgdmlldyB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YXRlXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2FuY2hvcl1cbiAgICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5fbWF0Y2ggPSBmdW5jdGlvbiBfbWF0Y2gocGF0aCwgc3RhdGUsIGFuY2hvcikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuX2NoZWNrR3VhcmQocGF0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFJvdXRlID0gdGhpcy5fY3VycmVudFJvdXRlO1xuICAgIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uO1xuXG4gICAgaWYgKGN1cnJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICBpZiAoY3VycmVudFRyYW5zaXRpb24udG8ucGF0aCA9PT0gcGF0aCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nIGlmIHdlIGhhdmUgYW4gYWN0aXZlIHRyYW5zaXRpb24gZ29pbmcgdG8gdGhlIHNhbWUgcGF0aFxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSb3V0ZS5wYXRoID09PSBwYXRoKSB7XG4gICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byB0aGUgc2FtZSBwYXRoLCBidXQgd2UgYWxzbyBoYXZlIGFuIG9uZ29pbmcgYnV0XG4gICAgICAgIC8vIG5vdC15ZXQtdmFsaWRhdGVkIHRyYW5zaXRpb24uIEFib3J0IHRoYXQgdHJhbnNpdGlvbiBhbmQgcmVzZXQgdG9cbiAgICAgICAgLy8gcHJldiB0cmFuc2l0aW9uLlxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRyYW5zaXRpb24gPSB0aGlzLl9wcmV2VHJhbnNpdGlvbjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ29pbmcgdG8gYSB0b3RhbGx5IGRpZmZlcmVudCBwYXRoLiBhYm9ydCBvbmdvaW5nIHRyYW5zaXRpb24uXG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnN0cnVjdCBuZXcgcm91dGUgYW5kIHRyYW5zaXRpb24gY29udGV4dFxuICAgIHZhciByb3V0ZSA9IG5ldyBSb3V0ZShwYXRoLCB0aGlzKTtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IG5ldyBSb3V0ZVRyYW5zaXRpb24odGhpcywgcm91dGUsIGN1cnJlbnRSb3V0ZSk7XG5cbiAgICAvLyBjdXJyZW50IHRyYW5zaXRpb24gaXMgdXBkYXRlZCByaWdodCBub3cuXG4gICAgLy8gaG93ZXZlciwgY3VycmVudCByb3V0ZSB3aWxsIG9ubHkgYmUgdXBkYXRlZCBhZnRlciB0aGUgdHJhbnNpdGlvbiBoYXNcbiAgICAvLyBiZWVuIHZhbGlkYXRlZC5cbiAgICB0aGlzLl9wcmV2VHJhbnNpdGlvbiA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblxuICAgIGlmICghdGhpcy5hcHApIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB0aGlzLmFwcCA9IG5ldyB0aGlzLl9hcHBDb25zdHJ1Y3Rvcih7XG4gICAgICAgIGVsOiB0aGlzLl9hcHBDb250YWluZXIsXG4gICAgICAgIF9tZXRhOiB7XG4gICAgICAgICAgJHJvdXRlOiByb3V0ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBnbG9iYWwgYmVmb3JlIGhvb2tcbiAgICB2YXIgYmVmb3JlSG9va3MgPSB0aGlzLl9iZWZvcmVFYWNoSG9va3M7XG4gICAgdmFyIHN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbigpIHtcbiAgICAgIHRyYW5zaXRpb24uc3RhcnQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuX3Bvc3RUcmFuc2l0aW9uKHJvdXRlLCBzdGF0ZSwgYW5jaG9yKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoYmVmb3JlSG9va3MubGVuZ3RoKSB7XG4gICAgICB0cmFuc2l0aW9uLnJ1blF1ZXVlKGJlZm9yZUhvb2tzLCBmdW5jdGlvbiAoaG9vaywgXywgbmV4dCkge1xuICAgICAgICBpZiAodHJhbnNpdGlvbiA9PT0gX3RoaXMyLl9jdXJyZW50VHJhbnNpdGlvbikge1xuICAgICAgICAgIHRyYW5zaXRpb24uY2FsbEhvb2soaG9vaywgbnVsbCwgbmV4dCwge1xuICAgICAgICAgICAgZXhwZWN0Qm9vbGVhbjogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCBzdGFydFRyYW5zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFRyYW5zaXRpb24oKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3JlbmRlcmVkICYmIHRoaXMuX3N0YXJ0Q2IpIHtcbiAgICAgIHRoaXMuX3N0YXJ0Q2IuY2FsbChudWxsKTtcbiAgICB9XG5cbiAgICAvLyBIQUNLOlxuICAgIC8vIHNldCByZW5kZXJlZCB0byB0cnVlIGFmdGVyIHRoZSB0cmFuc2l0aW9uIHN0YXJ0LCBzb1xuICAgIC8vIHRoYXQgY29tcG9uZW50cyB0aGF0IGFyZSBhY2l0dmF0ZWQgc3luY2hyb25vdXNseSBrbm93XG4gICAgLy8gd2hldGhlciBpdCBpcyB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgdGhpcy5fcmVuZGVyZWQgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgY3VycmVudCB0byB0aGUgbmV3IHRyYW5zaXRpb24uXG4gICAqIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSB0cmFuc2l0aW9uIG9iamVjdCB3aGVuIHRoZVxuICAgKiB2YWxpZGF0aW9uIG9mIGEgcm91dGUgaGFzIHN1Y2NlZWRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gICAqL1xuXG4gIFJvdXRlci5wcm90b3R5cGUuX29uVHJhbnNpdGlvblZhbGlkYXRlZCA9IGZ1bmN0aW9uIF9vblRyYW5zaXRpb25WYWxpZGF0ZWQodHJhbnNpdGlvbikge1xuICAgIC8vIHNldCBjdXJyZW50IHJvdXRlXG4gICAgdmFyIHJvdXRlID0gdGhpcy5fY3VycmVudFJvdXRlID0gdHJhbnNpdGlvbi50bztcbiAgICAvLyB1cGRhdGUgcm91dGUgY29udGV4dCBmb3IgYWxsIGNoaWxkcmVuXG4gICAgaWYgKHRoaXMuYXBwLiRyb3V0ZSAhPT0gcm91dGUpIHtcbiAgICAgIHRoaXMuYXBwLiRyb3V0ZSA9IHJvdXRlO1xuICAgICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuJHJvdXRlID0gcm91dGU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gY2FsbCBnbG9iYWwgYWZ0ZXIgaG9va1xuICAgIGlmICh0aGlzLl9hZnRlckVhY2hIb29rcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2FmdGVyRWFjaEhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgcmV0dXJuIGhvb2suY2FsbChudWxsLCB7XG4gICAgICAgICAgdG86IHRyYW5zaXRpb24udG8sXG4gICAgICAgICAgZnJvbTogdHJhbnNpdGlvbi5mcm9tXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uLmRvbmUgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgc3R1ZmYgYWZ0ZXIgdGhlIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Um91dGV9IHJvdXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhdGVdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYW5jaG9yXVxuICAgKi9cblxuICBSb3V0ZXIucHJvdG90eXBlLl9wb3N0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIF9wb3N0VHJhbnNpdGlvbihyb3V0ZSwgc3RhdGUsIGFuY2hvcikge1xuICAgIC8vIGhhbmRsZSBzY3JvbGwgcG9zaXRpb25zXG4gICAgLy8gc2F2ZWQgc2Nyb2xsIHBvc2l0aW9ucyB0YWtlIHByaW9yaXR5XG4gICAgLy8gdGhlbiB3ZSBjaGVjayBpZiB0aGUgcGF0aCBoYXMgYW4gYW5jaG9yXG4gICAgdmFyIHBvcyA9IHN0YXRlICYmIHN0YXRlLnBvcztcbiAgICBpZiAocG9zICYmIHRoaXMuX3NhdmVTY3JvbGxQb3NpdGlvbikge1xuICAgICAgVnVlLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHBvcy54LCBwb3MueSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGFuY2hvcikge1xuICAgICAgVnVlLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYW5jaG9yLnNsaWNlKDEpKTtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgd2luZG93LnNjcm9sbFRvKHdpbmRvdy5zY3JvbGxYLCBlbC5vZmZzZXRUb3ApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBuYW1lZCByb3V0ZSBvYmplY3QgLyBzdHJpbmcgcGF0aHMgaW50b1xuICAgKiBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfE51bWJlcn0gcGF0aFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIFJvdXRlci5wcm90b3R5cGUuX3N0cmluZ2lmeVBhdGggPSBmdW5jdGlvbiBfc3RyaW5naWZ5UGF0aChwYXRoKSB7XG4gICAgaWYgKHBhdGggJiYgdHlwZW9mIHBhdGggPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocGF0aC5uYW1lKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBwYXRoLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgaWYgKHBhdGgucXVlcnkpIHtcbiAgICAgICAgICBwYXJhbXMucXVlcnlQYXJhbXMgPSBwYXRoLnF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWNvZ25pemVyLmdlbmVyYXRlKHBhdGgubmFtZSwgcGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAocGF0aC5wYXRoKSB7XG4gICAgICAgIHZhciBmdWxsUGF0aCA9IHBhdGgucGF0aDtcbiAgICAgICAgaWYgKHBhdGgucXVlcnkpIHtcbiAgICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLl9yZWNvZ25pemVyLmdlbmVyYXRlUXVlcnlTdHJpbmcocGF0aC5xdWVyeSk7XG4gICAgICAgICAgaWYgKGZ1bGxQYXRoLmluZGV4T2YoJz8nKSA+IC0xKSB7XG4gICAgICAgICAgICBmdWxsUGF0aCArPSAnJicgKyBxdWVyeS5zbGljZSgxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVsbFBhdGggKz0gcXVlcnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdWxsUGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhdGggPyBwYXRoICsgJycgOiAnJztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJvdXRlcjtcbn0pKCk7XG5cbmZ1bmN0aW9uIGd1YXJkQ29tcG9uZW50KHBhdGgsIGhhbmRsZXIpIHtcbiAgdmFyIGNvbXAgPSBoYW5kbGVyLmNvbXBvbmVudDtcbiAgaWYgKFZ1ZS51dGlsLmlzUGxhaW5PYmplY3QoY29tcCkpIHtcbiAgICBjb21wID0gaGFuZGxlci5jb21wb25lbnQgPSBWdWUuZXh0ZW5kKGNvbXApO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGNvbXAgIT09ICdmdW5jdGlvbicpIHtcbiAgICBoYW5kbGVyLmNvbXBvbmVudCA9IG51bGw7XG4gICAgd2FybignaW52YWxpZCBjb21wb25lbnQgZm9yIHJvdXRlIFwiJyArIHBhdGggKyAnXCIuJyk7XG4gIH1cbn1cblxuLyogSW5zdGFsbGF0aW9uICovXG5cblJvdXRlci5pbnN0YWxsZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBJbnN0YWxsYXRpb24gaW50ZXJmYWNlLlxuICogSW5zdGFsbCB0aGUgbmVjZXNzYXJ5IGRpcmVjdGl2ZXMuXG4gKi9cblxuUm91dGVyLmluc3RhbGwgPSBmdW5jdGlvbiAoZXh0ZXJuYWxWdWUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChSb3V0ZXIuaW5zdGFsbGVkKSB7XG4gICAgd2FybignYWxyZWFkeSBpbnN0YWxsZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIFZ1ZSA9IGV4dGVybmFsVnVlO1xuICBhcHBseU92ZXJyaWRlKFZ1ZSk7XG4gIFZpZXcoVnVlKTtcbiAgTGluayhWdWUpO1xuICBleHBvcnRzJDEuVnVlID0gVnVlO1xuICBSb3V0ZXIuaW5zdGFsbGVkID0gdHJ1ZTtcbn07XG5cbi8vIGF1dG8gaW5zdGFsbFxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICB3aW5kb3cuVnVlLnVzZShSb3V0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdXRlcjsiLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIFdhdGNoZXIgPSByZXF1aXJlKCcuLi93YXRjaGVyJylcbnZhciBQYXRoID0gcmVxdWlyZSgnLi4vcGFyc2Vycy9wYXRoJylcbnZhciB0ZXh0UGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2Vycy90ZXh0JylcbnZhciBkaXJQYXJzZXIgPSByZXF1aXJlKCcuLi9wYXJzZXJzL2RpcmVjdGl2ZScpXG52YXIgZXhwUGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2Vycy9leHByZXNzaW9uJylcbnZhciBmaWx0ZXJSRSA9IC9bXnxdXFx8W158XS9cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZyb20gYW4gZXhwcmVzc2lvbiBvbiB0aGlzIHZtLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FzU3RhdGVtZW50XVxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5leHBvcnRzLiRnZXQgPSBmdW5jdGlvbiAoZXhwLCBhc1N0YXRlbWVudCkge1xuICB2YXIgcmVzID0gZXhwUGFyc2VyLnBhcnNlKGV4cClcbiAgaWYgKHJlcykge1xuICAgIGlmIChhc1N0YXRlbWVudCAmJiAhZXhwUGFyc2VyLmlzU2ltcGxlUGF0aChleHApKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgIHJldHVybiBmdW5jdGlvbiBzdGF0ZW1lbnRIYW5kbGVyICgpIHtcbiAgICAgICAgcmVzLmdldC5jYWxsKHNlbGYsIHNlbGYpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXMuZ2V0LmNhbGwodGhpcywgdGhpcylcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBmcm9tIGFuIGV4cHJlc3Npb24gb24gdGhpcyB2bS5cbiAqIFRoZSBleHByZXNzaW9uIG11c3QgYmUgYSB2YWxpZCBsZWZ0LWhhbmRcbiAqIGV4cHJlc3Npb24gaW4gYW4gYXNzaWdubWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmV4cG9ydHMuJHNldCA9IGZ1bmN0aW9uIChleHAsIHZhbCkge1xuICB2YXIgcmVzID0gZXhwUGFyc2VyLnBhcnNlKGV4cCwgdHJ1ZSlcbiAgaWYgKHJlcyAmJiByZXMuc2V0KSB7XG4gICAgcmVzLnNldC5jYWxsKHRoaXMsIHRoaXMsIHZhbClcbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IG9uIHRoZSBWTVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqL1xuXG5leHBvcnRzLiRkZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIF8uZGVsZXRlKHRoaXMuX2RhdGEsIGtleSlcbn1cblxuLyoqXG4gKiBXYXRjaCBhbiBleHByZXNzaW9uLCB0cmlnZ2VyIGNhbGxiYWNrIHdoZW4gaXRzXG4gKiB2YWx1ZSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBleHBPckZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGRlZXBcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBpbW1lZGlhdGVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIHVud2F0Y2hGblxuICovXG5cbmV4cG9ydHMuJHdhdGNoID0gZnVuY3Rpb24gKGV4cE9yRm4sIGNiLCBvcHRpb25zKSB7XG4gIHZhciB2bSA9IHRoaXNcbiAgdmFyIHBhcnNlZFxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcGFyc2VkID0gZGlyUGFyc2VyLnBhcnNlKGV4cE9yRm4pXG4gICAgZXhwT3JGbiA9IHBhcnNlZC5leHByZXNzaW9uXG4gIH1cbiAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIHtcbiAgICBkZWVwOiBvcHRpb25zICYmIG9wdGlvbnMuZGVlcCxcbiAgICBmaWx0ZXJzOiBwYXJzZWQgJiYgcGFyc2VkLmZpbHRlcnNcbiAgfSlcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgIHdhdGNoZXIudGVhcmRvd24oKVxuICB9XG59XG5cbi8qKlxuICogRXZhbHVhdGUgYSB0ZXh0IGRpcmVjdGl2ZSwgaW5jbHVkaW5nIGZpbHRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FzU3RhdGVtZW50XVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmV4cG9ydHMuJGV2YWwgPSBmdW5jdGlvbiAodGV4dCwgYXNTdGF0ZW1lbnQpIHtcbiAgLy8gY2hlY2sgZm9yIGZpbHRlcnMuXG4gIGlmIChmaWx0ZXJSRS50ZXN0KHRleHQpKSB7XG4gICAgdmFyIGRpciA9IGRpclBhcnNlci5wYXJzZSh0ZXh0KVxuICAgIC8vIHRoZSBmaWx0ZXIgcmVnZXggY2hlY2sgbWlnaHQgZ2l2ZSBmYWxzZSBwb3NpdGl2ZVxuICAgIC8vIGZvciBwaXBlcyBpbnNpZGUgc3RyaW5ncywgc28gaXQncyBwb3NzaWJsZSB0aGF0XG4gICAgLy8gd2UgZG9uJ3QgZ2V0IGFueSBmaWx0ZXJzIGhlcmVcbiAgICB2YXIgdmFsID0gdGhpcy4kZ2V0KGRpci5leHByZXNzaW9uLCBhc1N0YXRlbWVudClcbiAgICByZXR1cm4gZGlyLmZpbHRlcnNcbiAgICAgID8gdGhpcy5fYXBwbHlGaWx0ZXJzKHZhbCwgbnVsbCwgZGlyLmZpbHRlcnMpXG4gICAgICA6IHZhbFxuICB9IGVsc2Uge1xuICAgIC8vIG5vIGZpbHRlclxuICAgIHJldHVybiB0aGlzLiRnZXQodGV4dCwgYXNTdGF0ZW1lbnQpXG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcnBvbGF0ZSBhIHBpZWNlIG9mIHRlbXBsYXRlIHRleHQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5leHBvcnRzLiRpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIHZhciB0b2tlbnMgPSB0ZXh0UGFyc2VyLnBhcnNlKHRleHQpXG4gIHZhciB2bSA9IHRoaXNcbiAgaWYgKHRva2Vucykge1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdm0uJGV2YWwodG9rZW5zWzBdLnZhbHVlKSArICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4udGFnXG4gICAgICAgICAgPyB2bS4kZXZhbCh0b2tlbi52YWx1ZSlcbiAgICAgICAgICA6IHRva2VuLnZhbHVlXG4gICAgICB9KS5qb2luKCcnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGV4dFxuICB9XG59XG5cbi8qKlxuICogTG9nIGluc3RhbmNlIGRhdGEgYXMgYSBwbGFpbiBKUyBvYmplY3RcbiAqIHNvIHRoYXQgaXQgaXMgZWFzaWVyIHRvIGluc3BlY3QgaW4gY29uc29sZS5cbiAqIFRoaXMgbWV0aG9kIGFzc3VtZXMgY29uc29sZSBpcyBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICovXG5cbmV4cG9ydHMuJGxvZyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIHZhciBkYXRhID0gcGF0aFxuICAgID8gUGF0aC5nZXQodGhpcy5fZGF0YSwgcGF0aClcbiAgICA6IHRoaXMuX2RhdGFcbiAgaWYgKGRhdGEpIHtcbiAgICBkYXRhID0gY2xlYW4oZGF0YSlcbiAgfVxuICAvLyBpbmNsdWRlIGNvbXB1dGVkIGZpZWxkc1xuICBpZiAoIXBhdGgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy4kb3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgZGF0YVtrZXldID0gY2xlYW4odGhpc1trZXldKVxuICAgIH1cbiAgfVxuICBjb25zb2xlLmxvZyhkYXRhKVxufVxuXG4vKipcbiAqIFwiY2xlYW5cIiBhIGdldHRlci9zZXR0ZXIgY29udmVydGVkIG9iamVjdCBpbnRvIGEgcGxhaW5cbiAqIG9iamVjdCBjb3B5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAtIG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGNsZWFuIChvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSlcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgdHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4uL3RyYW5zaXRpb24nKVxuXG4vKipcbiAqIENvbnZlbmllbmNlIG9uLWluc3RhbmNlIG5leHRUaWNrLiBUaGUgY2FsbGJhY2sgaXNcbiAqIGF1dG8tYm91bmQgdG8gdGhlIGluc3RhbmNlLCBhbmQgdGhpcyBhdm9pZHMgY29tcG9uZW50XG4gKiBtb2R1bGVzIGhhdmluZyB0byByZWx5IG9uIHRoZSBnbG9iYWwgVnVlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuZXhwb3J0cy4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgXy5uZXh0VGljayhmbiwgdGhpcylcbn1cblxuLyoqXG4gKiBBcHBlbmQgaW5zdGFuY2UgdG8gdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAqL1xuXG5leHBvcnRzLiRhcHBlbmRUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICByZXR1cm4gaW5zZXJ0KFxuICAgIHRoaXMsIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLFxuICAgIGFwcGVuZCwgdHJhbnNpdGlvbi5hcHBlbmRcbiAgKVxufVxuXG4vKipcbiAqIFByZXBlbmQgaW5zdGFuY2UgdG8gdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAqL1xuXG5leHBvcnRzLiRwcmVwZW5kVG8gPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KVxuICBpZiAodGFyZ2V0Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIHRoaXMuJGJlZm9yZSh0YXJnZXQuZmlyc3RDaGlsZCwgY2IsIHdpdGhUcmFuc2l0aW9uKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuJGFwcGVuZFRvKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogSW5zZXJ0IGluc3RhbmNlIGJlZm9yZSB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICovXG5cbmV4cG9ydHMuJGJlZm9yZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICByZXR1cm4gaW5zZXJ0KFxuICAgIHRoaXMsIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLFxuICAgIGJlZm9yZSwgdHJhbnNpdGlvbi5iZWZvcmVcbiAgKVxufVxuXG4vKipcbiAqIEluc2VydCBpbnN0YW5jZSBhZnRlciB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICovXG5cbmV4cG9ydHMuJGFmdGVyID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gIHRhcmdldCA9IHF1ZXJ5KHRhcmdldClcbiAgaWYgKHRhcmdldC5uZXh0U2libGluZykge1xuICAgIHRoaXMuJGJlZm9yZSh0YXJnZXQubmV4dFNpYmxpbmcsIGNiLCB3aXRoVHJhbnNpdGlvbilcbiAgfSBlbHNlIHtcbiAgICB0aGlzLiRhcHBlbmRUbyh0YXJnZXQucGFyZW50Tm9kZSwgY2IsIHdpdGhUcmFuc2l0aW9uKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogUmVtb3ZlIGluc3RhbmNlIGZyb20gRE9NXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICovXG5cbmV4cG9ydHMuJHJlbW92ZSA9IGZ1bmN0aW9uIChjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgaWYgKCF0aGlzLiRlbC5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGNiICYmIGNiKClcbiAgfVxuICB2YXIgaW5Eb2MgPSB0aGlzLl9pc0F0dGFjaGVkICYmIF8uaW5Eb2ModGhpcy4kZWwpXG4gIC8vIGlmIHdlIGFyZSBub3QgaW4gZG9jdW1lbnQsIG5vIG5lZWQgdG8gY2hlY2tcbiAgLy8gZm9yIHRyYW5zaXRpb25zXG4gIGlmICghaW5Eb2MpIHdpdGhUcmFuc2l0aW9uID0gZmFsc2VcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciByZWFsQ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGluRG9jKSBzZWxmLl9jYWxsSG9vaygnZGV0YWNoZWQnKVxuICAgIGlmIChjYikgY2IoKVxuICB9XG4gIGlmICh0aGlzLl9pc0ZyYWdtZW50KSB7XG4gICAgXy5yZW1vdmVOb2RlUmFuZ2UoXG4gICAgICB0aGlzLl9mcmFnbWVudFN0YXJ0LFxuICAgICAgdGhpcy5fZnJhZ21lbnRFbmQsXG4gICAgICB0aGlzLCB0aGlzLl9mcmFnbWVudCwgcmVhbENiXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHZhciBvcCA9IHdpdGhUcmFuc2l0aW9uID09PSBmYWxzZVxuICAgICAgPyByZW1vdmVcbiAgICAgIDogdHJhbnNpdGlvbi5yZW1vdmVcbiAgICBvcCh0aGlzLiRlbCwgdGhpcywgcmVhbENiKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogU2hhcmVkIERPTSBpbnNlcnRpb24gZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcDEgLSBvcCBmb3Igbm9uLXRyYW5zaXRpb24gaW5zZXJ0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcDIgLSBvcCBmb3IgdHJhbnNpdGlvbiBpbnNlcnRcbiAqIEByZXR1cm4gdm1cbiAqL1xuXG5mdW5jdGlvbiBpbnNlcnQgKHZtLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgb3AxLCBvcDIpIHtcbiAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KVxuICB2YXIgdGFyZ2V0SXNEZXRhY2hlZCA9ICFfLmluRG9jKHRhcmdldClcbiAgdmFyIG9wID0gd2l0aFRyYW5zaXRpb24gPT09IGZhbHNlIHx8IHRhcmdldElzRGV0YWNoZWRcbiAgICAgID8gb3AxXG4gICAgICA6IG9wMlxuICB2YXIgc2hvdWxkQ2FsbEhvb2sgPVxuICAgICF0YXJnZXRJc0RldGFjaGVkICYmXG4gICAgIXZtLl9pc0F0dGFjaGVkICYmXG4gICAgIV8uaW5Eb2Modm0uJGVsKVxuICBpZiAodm0uX2lzRnJhZ21lbnQpIHtcbiAgICBfLm1hcE5vZGVSYW5nZSh2bS5fZnJhZ21lbnRTdGFydCwgdm0uX2ZyYWdtZW50RW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgb3Aobm9kZSwgdGFyZ2V0LCB2bSlcbiAgICB9KVxuICAgIGNiICYmIGNiKClcbiAgfSBlbHNlIHtcbiAgICBvcCh2bS4kZWwsIHRhcmdldCwgdm0sIGNiKVxuICB9XG4gIGlmIChzaG91bGRDYWxsSG9vaykge1xuICAgIHZtLl9jYWxsSG9vaygnYXR0YWNoZWQnKVxuICB9XG4gIHJldHVybiB2bVxufVxuXG4vKipcbiAqIENoZWNrIGZvciBzZWxlY3RvcnNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICovXG5cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICByZXR1cm4gdHlwZW9mIGVsID09PSAnc3RyaW5nJ1xuICAgID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbClcbiAgICA6IGVsXG59XG5cbi8qKlxuICogQXBwZW5kIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtOb2RlfSBlbFxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGFwcGVuZCAoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gIHRhcmdldC5hcHBlbmRDaGlsZChlbClcbiAgaWYgKGNiKSBjYigpXG59XG5cbi8qKlxuICogSW5zZXJ0QmVmb3JlIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtOb2RlfSBlbFxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGJlZm9yZSAoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gIF8uYmVmb3JlKGVsLCB0YXJnZXQpXG4gIGlmIChjYikgY2IoKVxufVxuXG4vKipcbiAqIFJlbW92ZSBvcGVyYXRpb24gdGhhdCB0YWtlcyBhIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZSAoZWwsIHZtLCBjYikge1xuICBfLnJlbW92ZShlbClcbiAgaWYgKGNiKSBjYigpXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cbmV4cG9ydHMuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAodGhpcy5fZXZlbnRzW2V2ZW50XSB8fCAodGhpcy5fZXZlbnRzW2V2ZW50XSA9IFtdKSlcbiAgICAucHVzaChmbilcbiAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgMSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cbmV4cG9ydHMuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgc2VsZi4kb2ZmKGV2ZW50LCBvbilcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbiAgb24uZm4gPSBmblxuICB0aGlzLiRvbihldmVudCwgb24pXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5leHBvcnRzLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gIHZhciBjYnNcbiAgLy8gYWxsXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGlmICh0aGlzLiRwYXJlbnQpIHtcbiAgICAgIGZvciAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgIGNicyA9IHRoaXMuX2V2ZW50c1tldmVudF1cbiAgICAgICAgaWYgKGNicykge1xuICAgICAgICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC1jYnMubGVuZ3RoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvLyBzcGVjaWZpYyBldmVudFxuICBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdXG4gIGlmICghY2JzKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC1jYnMubGVuZ3RoKVxuICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBudWxsXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYlxuICB2YXIgaSA9IGNicy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGNiID0gY2JzW2ldXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC0xKVxuICAgICAgY2JzLnNwbGljZShpLCAxKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGFuIGV2ZW50IG9uIHNlbGYuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKi9cblxuZXhwb3J0cy4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgY2JzID0gdGhpcy5fZXZlbnRzW2V2ZW50XVxuICB0aGlzLl9zaG91bGRQcm9wYWdhdGUgPSAhY2JzXG4gIGlmIChjYnMpIHtcbiAgICBjYnMgPSBjYnMubGVuZ3RoID4gMVxuICAgICAgPyBfLnRvQXJyYXkoY2JzKVxuICAgICAgOiBjYnNcbiAgICB2YXIgYXJncyA9IF8udG9BcnJheShhcmd1bWVudHMsIDEpXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgcmVzID0gY2JzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICBpZiAocmVzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBicm9hZGNhc3QgYW4gZXZlbnQgdG8gYWxsIGNoaWxkcmVuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7Li4uKn0gYWRkaXRpb25hbCBhcmd1bWVudHNcbiAqL1xuXG5leHBvcnRzLiRicm9hZGNhc3QgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gaWYgbm8gY2hpbGQgaGFzIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnQsXG4gIC8vIHRoZW4gdGhlcmUncyBubyBuZWVkIHRvIGJyb2FkY2FzdC5cbiAgaWYgKCF0aGlzLl9ldmVudHNDb3VudFtldmVudF0pIHJldHVyblxuICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRjaGlsZHJlblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG4gICAgY2hpbGQuJGVtaXQuYXBwbHkoY2hpbGQsIGFyZ3VtZW50cylcbiAgICBpZiAoY2hpbGQuX3Nob3VsZFByb3BhZ2F0ZSkge1xuICAgICAgY2hpbGQuJGJyb2FkY2FzdC5hcHBseShjaGlsZCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHByb3BhZ2F0ZSBhbiBldmVudCB1cCB0aGUgcGFyZW50IGNoYWluLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHsuLi4qfSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICovXG5cbmV4cG9ydHMuJGRpc3BhdGNoID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLiRlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudFxuICB3aGlsZSAocGFyZW50KSB7XG4gICAgcGFyZW50LiRlbWl0LmFwcGx5KHBhcmVudCwgYXJndW1lbnRzKVxuICAgIHBhcmVudCA9IHBhcmVudC5fc2hvdWxkUHJvcGFnYXRlXG4gICAgICA/IHBhcmVudC4kcGFyZW50XG4gICAgICA6IG51bGxcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIE1vZGlmeSB0aGUgbGlzdGVuZXIgY291bnRzIG9uIGFsbCBwYXJlbnRzLlxuICogVGhpcyBib29ra2VlcGluZyBhbGxvd3MgJGJyb2FkY2FzdCB0byByZXR1cm4gZWFybHkgd2hlblxuICogbm8gY2hpbGQgaGFzIGxpc3RlbmVkIHRvIGEgY2VydGFpbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG4gKi9cblxudmFyIGhvb2tSRSA9IC9eaG9vazovXG5mdW5jdGlvbiBtb2RpZnlMaXN0ZW5lckNvdW50ICh2bSwgZXZlbnQsIGNvdW50KSB7XG4gIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50XG4gIC8vIGhvb2tzIGRvIG5vdCBnZXQgYnJvYWRjYXN0ZWQgc28gbm8gbmVlZFxuICAvLyB0byBkbyBib29ra2VlcGluZyBmb3IgdGhlbVxuICBpZiAoIXBhcmVudCB8fCAhY291bnQgfHwgaG9va1JFLnRlc3QoZXZlbnQpKSByZXR1cm5cbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIHBhcmVudC5fZXZlbnRzQ291bnRbZXZlbnRdID1cbiAgICAgIChwYXJlbnQuX2V2ZW50c0NvdW50W2V2ZW50XSB8fCAwKSArIGNvdW50XG4gICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnRcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxuXG4vKipcbiAqIEV4cG9zZSB1c2VmdWwgaW50ZXJuYWxzXG4gKi9cblxuZXhwb3J0cy51dGlsID0gX1xuZXhwb3J0cy5jb25maWcgPSBjb25maWdcbmV4cG9ydHMuc2V0ID0gXy5zZXRcbmV4cG9ydHMuZGVsZXRlID0gXy5kZWxldGVcbmV4cG9ydHMubmV4dFRpY2sgPSBfLm5leHRUaWNrXG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBhcmUgZXhwb3NlZCBmb3IgYWR2YW5jZWQgdXNhZ2UgLyBwbHVnaW5zXG4gKi9cblxuZXhwb3J0cy5jb21waWxlciA9IHJlcXVpcmUoJy4uL2NvbXBpbGVyJylcbmV4cG9ydHMuRnJhZ21lbnRGYWN0b3J5ID0gcmVxdWlyZSgnLi4vZnJhZ21lbnQvZmFjdG9yeScpXG5leHBvcnRzLmludGVybmFsRGlyZWN0aXZlcyA9IHJlcXVpcmUoJy4uL2RpcmVjdGl2ZXMvaW50ZXJuYWwnKVxuZXhwb3J0cy5wYXJzZXJzID0ge1xuICBwYXRoOiByZXF1aXJlKCcuLi9wYXJzZXJzL3BhdGgnKSxcbiAgdGV4dDogcmVxdWlyZSgnLi4vcGFyc2Vycy90ZXh0JyksXG4gIHRlbXBsYXRlOiByZXF1aXJlKCcuLi9wYXJzZXJzL3RlbXBsYXRlJyksXG4gIGRpcmVjdGl2ZTogcmVxdWlyZSgnLi4vcGFyc2Vycy9kaXJlY3RpdmUnKSxcbiAgZXhwcmVzc2lvbjogcmVxdWlyZSgnLi4vcGFyc2Vycy9leHByZXNzaW9uJylcbn1cblxuLyoqXG4gKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICovXG5cbmV4cG9ydHMuY2lkID0gMFxudmFyIGNpZCA9IDFcblxuLyoqXG4gKiBDbGFzcyBpbmhlcml0YW5jZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbmRPcHRpb25zXG4gKi9cblxuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fVxuICB2YXIgU3VwZXIgPSB0aGlzXG4gIHZhciBpc0ZpcnN0RXh0ZW5kID0gU3VwZXIuY2lkID09PSAwXG4gIGlmIChpc0ZpcnN0RXh0ZW5kICYmIGV4dGVuZE9wdGlvbnMuX0N0b3IpIHtcbiAgICByZXR1cm4gZXh0ZW5kT3B0aW9ucy5fQ3RvclxuICB9XG4gIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZVxuICB2YXIgU3ViID0gY3JlYXRlQ2xhc3MobmFtZSB8fCAnVnVlQ29tcG9uZW50JylcbiAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKVxuICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViXG4gIFN1Yi5jaWQgPSBjaWQrK1xuICBTdWIub3B0aW9ucyA9IF8ubWVyZ2VPcHRpb25zKFxuICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgZXh0ZW5kT3B0aW9uc1xuICApXG4gIFN1Ylsnc3VwZXInXSA9IFN1cGVyXG4gIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uXG4gIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmRcbiAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV1cbiAgfSlcbiAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICBpZiAobmFtZSkge1xuICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWJcbiAgfVxuICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICBpZiAoaXNGaXJzdEV4dGVuZCkge1xuICAgIGV4dGVuZE9wdGlvbnMuX0N0b3IgPSBTdWJcbiAgfVxuICByZXR1cm4gU3ViXG59XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdWItY2xhc3MgY29uc3RydWN0b3Igd2l0aCB0aGVcbiAqIGdpdmVuIG5hbWUuIFRoaXMgZ2l2ZXMgdXMgbXVjaCBuaWNlciBvdXRwdXQgd2hlblxuICogbG9nZ2luZyBpbnN0YW5jZXMgaW4gdGhlIGNvbnNvbGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzIChuYW1lKSB7XG4gIHJldHVybiBuZXcgRnVuY3Rpb24oXG4gICAgJ3JldHVybiBmdW5jdGlvbiAnICsgXy5jbGFzc2lmeShuYW1lKSArXG4gICAgJyAob3B0aW9ucykgeyB0aGlzLl9pbml0KG9wdGlvbnMpIH0nXG4gICkoKVxufVxuXG4vKipcbiAqIFBsdWdpbiBzeXN0ZW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luXG4gKi9cblxuZXhwb3J0cy51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgIHJldHVyblxuICB9XG4gIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICB2YXIgYXJncyA9IF8udG9BcnJheShhcmd1bWVudHMsIDEpXG4gIGFyZ3MudW5zaGlmdCh0aGlzKVxuICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKVxuICB9IGVsc2Uge1xuICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKVxuICB9XG4gIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQXBwbHkgYSBnbG9iYWwgbWl4aW4gYnkgbWVyZ2luZyBpdCBpbnRvIHRoZSBkZWZhdWx0XG4gKiBvcHRpb25zLlxuICovXG5cbmV4cG9ydHMubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgdmFyIFZ1ZSA9IF8uVnVlXG4gIFZ1ZS5vcHRpb25zID0gXy5tZXJnZU9wdGlvbnMoVnVlLm9wdGlvbnMsIG1peGluKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcyB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHNpZ25hdHVyZTpcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7Kn0gZGVmaW5pdGlvblxuICovXG5cbmNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIGV4cG9ydHNbdHlwZV0gPSBmdW5jdGlvbiAoaWQsIGRlZmluaXRpb24pIHtcbiAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZSA9PT0gJ2NvbXBvbmVudCcgJiZcbiAgICAgICAgXy5pc1BsYWluT2JqZWN0KGRlZmluaXRpb24pXG4gICAgICApIHtcbiAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gaWRcbiAgICAgICAgZGVmaW5pdGlvbiA9IF8uVnVlLmV4dGVuZChkZWZpbml0aW9uKVxuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb25cbiAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgfVxuICB9XG59KVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBjb21waWxlciA9IHJlcXVpcmUoJy4uL2NvbXBpbGVyJylcblxuLyoqXG4gKiBTZXQgaW5zdGFuY2UgdGFyZ2V0IGVsZW1lbnQgYW5kIGtpY2sgb2ZmIHRoZSBjb21waWxhdGlvblxuICogcHJvY2Vzcy4gVGhlIHBhc3NlZCBpbiBgZWxgIGNhbiBiZSBhIHNlbGVjdG9yIHN0cmluZywgYW5cbiAqIGV4aXN0aW5nIEVsZW1lbnQsIG9yIGEgRG9jdW1lbnRGcmFnbWVudCAoZm9yIGJsb2NrXG4gKiBpbnN0YW5jZXMpLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fHN0cmluZ30gZWxcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLiRtb3VudCA9IGZ1bmN0aW9uIChlbCkge1xuICBpZiAodGhpcy5faXNDb21waWxlZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgJyRtb3VudCgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlLidcbiAgICApXG4gICAgcmV0dXJuXG4gIH1cbiAgZWwgPSBfLnF1ZXJ5KGVsKVxuICBpZiAoIWVsKSB7XG4gICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICB9XG4gIHRoaXMuX2NvbXBpbGUoZWwpXG4gIHRoaXMuX2luaXRET01Ib29rcygpXG4gIGlmIChfLmluRG9jKHRoaXMuJGVsKSkge1xuICAgIHRoaXMuX2NhbGxIb29rKCdhdHRhY2hlZCcpXG4gICAgcmVhZHkuY2FsbCh0aGlzKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuJG9uY2UoJ2hvb2s6YXR0YWNoZWQnLCByZWFkeSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIE1hcmsgYW4gaW5zdGFuY2UgYXMgcmVhZHkuXG4gKi9cblxuZnVuY3Rpb24gcmVhZHkgKCkge1xuICB0aGlzLl9pc0F0dGFjaGVkID0gdHJ1ZVxuICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZVxuICB0aGlzLl9jYWxsSG9vaygncmVhZHknKVxufVxuXG4vKipcbiAqIFRlYXJkb3duIHRoZSBpbnN0YW5jZSwgc2ltcGx5IGRlbGVnYXRlIHRvIHRoZSBpbnRlcm5hbFxuICogX2Rlc3Ryb3kuXG4gKi9cblxuZXhwb3J0cy4kZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmUsIGRlZmVyQ2xlYW51cCkge1xuICB0aGlzLl9kZXN0cm95KHJlbW92ZSwgZGVmZXJDbGVhbnVwKVxufVxuXG4vKipcbiAqIFBhcnRpYWxseSBjb21waWxlIGEgcGllY2Ugb2YgRE9NIGFuZCByZXR1cm4gYVxuICogZGVjb21waWxlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICogQHBhcmFtIHtWdWV9IFtob3N0XVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZXhwb3J0cy4kY29tcGlsZSA9IGZ1bmN0aW9uIChlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGUoZWwsIHRoaXMuJG9wdGlvbnMsIHRydWUpKFxuICAgIHRoaXMsIGVsLCBob3N0LCBzY29wZSwgZnJhZ1xuICApXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vdXRpbCcpXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKVxuXG4vLyB3ZSBoYXZlIHR3byBzZXBhcmF0ZSBxdWV1ZXM6IG9uZSBmb3IgZGlyZWN0aXZlIHVwZGF0ZXNcbi8vIGFuZCBvbmUgZm9yIHVzZXIgd2F0Y2hlciByZWdpc3RlcmVkIHZpYSAkd2F0Y2goKS5cbi8vIHdlIHdhbnQgdG8gZ3VhcmFudGVlIGRpcmVjdGl2ZSB1cGRhdGVzIHRvIGJlIGNhbGxlZFxuLy8gYmVmb3JlIHVzZXIgd2F0Y2hlcnMgc28gdGhhdCB3aGVuIHVzZXIgd2F0Y2hlcnMgYXJlXG4vLyB0cmlnZ2VyZWQsIHRoZSBET00gd291bGQgaGF2ZSBhbHJlYWR5IGJlZW4gaW4gdXBkYXRlZFxuLy8gc3RhdGUuXG52YXIgcXVldWUgPSBbXVxudmFyIHVzZXJRdWV1ZSA9IFtdXG52YXIgaGFzID0ge31cbnZhciBjaXJjdWxhciA9IHt9XG52YXIgd2FpdGluZyA9IGZhbHNlXG52YXIgaW50ZXJuYWxRdWV1ZURlcGxldGVkID0gZmFsc2VcblxuLyoqXG4gKiBSZXNldCB0aGUgYmF0Y2hlcidzIHN0YXRlLlxuICovXG5cbmZ1bmN0aW9uIHJlc2V0QmF0Y2hlclN0YXRlICgpIHtcbiAgcXVldWUgPSBbXVxuICB1c2VyUXVldWUgPSBbXVxuICBoYXMgPSB7fVxuICBjaXJjdWxhciA9IHt9XG4gIHdhaXRpbmcgPSBpbnRlcm5hbFF1ZXVlRGVwbGV0ZWQgPSBmYWxzZVxufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5cbmZ1bmN0aW9uIGZsdXNoQmF0Y2hlclF1ZXVlICgpIHtcbiAgcnVuQmF0Y2hlclF1ZXVlKHF1ZXVlKVxuICBpbnRlcm5hbFF1ZXVlRGVwbGV0ZWQgPSB0cnVlXG4gIHJ1bkJhdGNoZXJRdWV1ZSh1c2VyUXVldWUpXG4gIC8vIGRldiB0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKF8uaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fKSB7XG4gICAgICB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5lbWl0KCdmbHVzaCcpXG4gICAgfVxuICB9XG4gIHJlc2V0QmF0Y2hlclN0YXRlKClcbn1cblxuLyoqXG4gKiBSdW4gdGhlIHdhdGNoZXJzIGluIGEgc2luZ2xlIHF1ZXVlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHF1ZXVlXG4gKi9cblxuZnVuY3Rpb24gcnVuQmF0Y2hlclF1ZXVlIChxdWV1ZSkge1xuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldXG4gICAgdmFyIGlkID0gd2F0Y2hlci5pZFxuICAgIGhhc1tpZF0gPSBudWxsXG4gICAgd2F0Y2hlci5ydW4oKVxuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxXG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gY29uZmlnLl9tYXhVcGRhdGVDb3VudCkge1xuICAgICAgICBxdWV1ZS5zcGxpY2UoaGFzW2lkXSwgMSlcbiAgICAgICAgXy53YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgZm9yIHdhdGNoZXIgJyArXG4gICAgICAgICAgJ3dpdGggZXhwcmVzc2lvbjogJyArIHdhdGNoZXIuZXhwcmVzc2lvblxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKlxuICogQHBhcmFtIHtXYXRjaGVyfSB3YXRjaGVyXG4gKiAgIHByb3BlcnRpZXM6XG4gKiAgIC0ge051bWJlcn0gaWRcbiAqICAgLSB7RnVuY3Rpb259IHJ1blxuICovXG5cbmV4cG9ydHMucHVzaCA9IGZ1bmN0aW9uICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWRcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIC8vIGlmIGFuIGludGVybmFsIHdhdGNoZXIgaXMgcHVzaGVkLCBidXQgdGhlIGludGVybmFsXG4gICAgLy8gcXVldWUgaXMgYWxyZWFkeSBkZXBsZXRlZCwgd2UgcnVuIGl0IGltbWVkaWF0ZWx5LlxuICAgIGlmIChpbnRlcm5hbFF1ZXVlRGVwbGV0ZWQgJiYgIXdhdGNoZXIudXNlcikge1xuICAgICAgd2F0Y2hlci5ydW4oKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHB1c2ggd2F0Y2hlciBpbnRvIGFwcHJvcHJpYXRlIHF1ZXVlXG4gICAgdmFyIHEgPSB3YXRjaGVyLnVzZXIgPyB1c2VyUXVldWUgOiBxdWV1ZVxuICAgIGhhc1tpZF0gPSBxLmxlbmd0aFxuICAgIHEucHVzaCh3YXRjaGVyKVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWVcbiAgICAgIF8ubmV4dFRpY2soZmx1c2hCYXRjaGVyUXVldWUpXG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEEgZG91Ymx5IGxpbmtlZCBsaXN0LWJhc2VkIExlYXN0IFJlY2VudGx5IFVzZWQgKExSVSlcbiAqIGNhY2hlLiBXaWxsIGtlZXAgbW9zdCByZWNlbnRseSB1c2VkIGl0ZW1zIHdoaWxlXG4gKiBkaXNjYXJkaW5nIGxlYXN0IHJlY2VudGx5IHVzZWQgaXRlbXMgd2hlbiBpdHMgbGltaXQgaXNcbiAqIHJlYWNoZWQuIFRoaXMgaXMgYSBiYXJlLWJvbmUgdmVyc2lvbiBvZlxuICogUmFzbXVzIEFuZGVyc3NvbidzIGpzLWxydTpcbiAqXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9yc21zL2pzLWxydVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gQ2FjaGUgKGxpbWl0KSB7XG4gIHRoaXMuc2l6ZSA9IDBcbiAgdGhpcy5saW1pdCA9IGxpbWl0XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IHVuZGVmaW5lZFxuICB0aGlzLl9rZXltYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG59XG5cbnZhciBwID0gQ2FjaGUucHJvdG90eXBlXG5cbi8qKlxuICogUHV0IDx2YWx1ZT4gaW50byB0aGUgY2FjaGUgYXNzb2NpYXRlZCB3aXRoIDxrZXk+LlxuICogUmV0dXJucyB0aGUgZW50cnkgd2hpY2ggd2FzIHJlbW92ZWQgdG8gbWFrZSByb29tIGZvclxuICogdGhlIG5ldyBlbnRyeS4gT3RoZXJ3aXNlIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAqIChpLmUuIGlmIHRoZXJlIHdhcyBlbm91Z2ggcm9vbSBhbHJlYWR5KS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtFbnRyeXx1bmRlZmluZWR9XG4gKi9cblxucC5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgZW50cnkgPSB7XG4gICAga2V5OiBrZXksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH1cbiAgdGhpcy5fa2V5bWFwW2tleV0gPSBlbnRyeVxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnlcbiAgICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5XG4gIH1cbiAgdGhpcy50YWlsID0gZW50cnlcbiAgaWYgKHRoaXMuc2l6ZSA9PT0gdGhpcy5saW1pdCkge1xuICAgIHJldHVybiB0aGlzLnNoaWZ0KClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNpemUrK1xuICB9XG59XG5cbi8qKlxuICogUHVyZ2UgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgKG9sZGVzdCkgZW50cnkgZnJvbSB0aGVcbiAqIGNhY2hlLiBSZXR1cm5zIHRoZSByZW1vdmVkIGVudHJ5IG9yIHVuZGVmaW5lZCBpZiB0aGVcbiAqIGNhY2hlIHdhcyBlbXB0eS5cbiAqL1xuXG5wLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZW50cnkgPSB0aGlzLmhlYWRcbiAgaWYgKGVudHJ5KSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5ld2VyXG4gICAgdGhpcy5oZWFkLm9sZGVyID0gdW5kZWZpbmVkXG4gICAgZW50cnkubmV3ZXIgPSBlbnRyeS5vbGRlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2tleW1hcFtlbnRyeS5rZXldID0gdW5kZWZpbmVkXG4gIH1cbiAgcmV0dXJuIGVudHJ5XG59XG5cbi8qKlxuICogR2V0IGFuZCByZWdpc3RlciByZWNlbnQgdXNlIG9mIDxrZXk+LiBSZXR1cm5zIHRoZSB2YWx1ZVxuICogYXNzb2NpYXRlZCB3aXRoIDxrZXk+IG9yIHVuZGVmaW5lZCBpZiBub3QgaW4gY2FjaGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5FbnRyeVxuICogQHJldHVybiB7RW50cnl8Kn1cbiAqL1xuXG5wLmdldCA9IGZ1bmN0aW9uIChrZXksIHJldHVybkVudHJ5KSB7XG4gIHZhciBlbnRyeSA9IHRoaXMuX2tleW1hcFtrZXldXG4gIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgaWYgKGVudHJ5ID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gcmV0dXJuRW50cnlcbiAgICAgID8gZW50cnlcbiAgICAgIDogZW50cnkudmFsdWVcbiAgfVxuICAvLyBIRUFELS0tLS0tLS0tLS0tLS1UQUlMXG4gIC8vICAgPC5vbGRlciAgIC5uZXdlcj5cbiAgLy8gIDwtLS0gYWRkIGRpcmVjdGlvbiAtLVxuICAvLyAgIEEgIEIgIEMgIDxEPiAgRVxuICBpZiAoZW50cnkubmV3ZXIpIHtcbiAgICBpZiAoZW50cnkgPT09IHRoaXMuaGVhZCkge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnkubmV3ZXJcbiAgICB9XG4gICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlciAvLyBDIDwtLSBFLlxuICB9XG4gIGlmIChlbnRyeS5vbGRlcikge1xuICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXIgLy8gQy4gLS0+IEVcbiAgfVxuICBlbnRyeS5uZXdlciA9IHVuZGVmaW5lZCAvLyBEIC0teFxuICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbCAvLyBELiAtLT4gRVxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnkgLy8gRS4gPC0tIERcbiAgfVxuICB0aGlzLnRhaWwgPSBlbnRyeVxuICByZXR1cm4gcmV0dXJuRW50cnlcbiAgICA/IGVudHJ5XG4gICAgOiBlbnRyeS52YWx1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhY2hlXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIGRpclBhcnNlciA9IHJlcXVpcmUoJy4uL3BhcnNlcnMvZGlyZWN0aXZlJylcbnZhciBwcm9wRGVmID0gcmVxdWlyZSgnLi4vZGlyZWN0aXZlcy9pbnRlcm5hbC9wcm9wJylcbnZhciBwcm9wQmluZGluZ01vZGVzID0gcmVxdWlyZSgnLi4vY29uZmlnJykuX3Byb3BCaW5kaW5nTW9kZXNcbnZhciBlbXB0eSA9IHt9XG5cbi8vIHJlZ2V4ZXNcbnZhciBpZGVudFJFID0gcmVxdWlyZSgnLi4vcGFyc2Vycy9wYXRoJykuaWRlbnRSRVxudmFyIHNldHRhYmxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKihcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFtbXlxcW1xcXV0rXFxdKSokL1xuXG4vKipcbiAqIENvbXBpbGUgcHJvcHMgb24gYSByb290IGVsZW1lbnQgYW5kIHJldHVyblxuICogYSBwcm9wcyBsaW5rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICogQHBhcmFtIHtBcnJheX0gcHJvcE9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBwcm9wc0xpbmtGblxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tcGlsZVByb3BzIChlbCwgcHJvcE9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gW11cbiAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMocHJvcE9wdGlvbnMpXG4gIHZhciBpID0gbmFtZXMubGVuZ3RoXG4gIHZhciBvcHRpb25zLCBuYW1lLCBhdHRyLCB2YWx1ZSwgcGF0aCwgcGFyc2VkLCBwcm9wLCBpc1RpdGxlQmluZGluZ1xuICB3aGlsZSAoaS0tKSB7XG4gICAgbmFtZSA9IG5hbWVzW2ldXG4gICAgb3B0aW9ucyA9IHByb3BPcHRpb25zW25hbWVdIHx8IGVtcHR5XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnJGRhdGEnKSB7XG4gICAgICBfLndhcm4oJ0RvIG5vdCB1c2UgJGRhdGEgYXMgcHJvcC4nKVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvLyBwcm9wcyBjb3VsZCBjb250YWluIGRhc2hlcywgd2hpY2ggd2lsbCBiZVxuICAgIC8vIGludGVycHJldGVkIGFzIG1pbnVzIGNhbGN1bGF0aW9ucyBieSB0aGUgcGFyc2VyXG4gICAgLy8gc28gd2UgbmVlZCB0byBjYW1lbGl6ZSB0aGUgcGF0aCBoZXJlXG4gICAgcGF0aCA9IF8uY2FtZWxpemUobmFtZSlcbiAgICBpZiAoIWlkZW50UkUudGVzdChwYXRoKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3Aga2V5OiBcIicgKyBuYW1lICsgJ1wiLiBQcm9wIGtleXMgJyArXG4gICAgICAgICdtdXN0IGJlIHZhbGlkIGlkZW50aWZpZXJzLidcbiAgICAgIClcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgcHJvcCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIG1vZGU6IHByb3BCaW5kaW5nTW9kZXMuT05FX1dBWVxuICAgIH1cblxuICAgIC8vIElFIHRpdGxlIGlzc3Vlc1xuICAgIGlzVGl0bGVCaW5kaW5nID0gZmFsc2VcbiAgICBpZiAobmFtZSA9PT0gJ3RpdGxlJyAmJiAoZWwuZ2V0QXR0cmlidXRlKCc6dGl0bGUnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3YtYmluZDp0aXRsZScpKSkge1xuICAgICAgaXNUaXRsZUJpbmRpbmcgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gZmlyc3QgY2hlY2sgbGl0ZXJhbCB2ZXJzaW9uXG4gICAgYXR0ciA9IF8uaHlwaGVuYXRlKG5hbWUpXG4gICAgdmFsdWUgPSBwcm9wLnJhdyA9IF8uYXR0cihlbCwgYXR0cilcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgaXNUaXRsZUJpbmRpbmcpIHtcbiAgICAgIC8vIHRoZW4gY2hlY2sgZHluYW1pYyB2ZXJzaW9uXG4gICAgICBpZiAoKHZhbHVlID0gXy5nZXRCaW5kQXR0cihlbCwgYXR0cikpID09PSBudWxsKSB7XG4gICAgICAgIGlmICgodmFsdWUgPSBfLmdldEJpbmRBdHRyKGVsLCBhdHRyICsgJy5zeW5jJykpICE9PSBudWxsKSB7XG4gICAgICAgICAgcHJvcC5tb2RlID0gcHJvcEJpbmRpbmdNb2Rlcy5UV09fV0FZXG4gICAgICAgIH0gZWxzZSBpZiAoKHZhbHVlID0gXy5nZXRCaW5kQXR0cihlbCwgYXR0ciArICcub25jZScpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuT05FX1RJTUVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcC5yYXcgPSB2YWx1ZVxuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHBhcnNlZCA9IGRpclBhcnNlci5wYXJzZSh2YWx1ZSlcbiAgICAgICAgdmFsdWUgPSBwYXJzZWQuZXhwcmVzc2lvblxuICAgICAgICBwcm9wLmZpbHRlcnMgPSBwYXJzZWQuZmlsdGVyc1xuICAgICAgICAvLyBjaGVjayBiaW5kaW5nIHR5cGVcbiAgICAgICAgaWYgKF8uaXNMaXRlcmFsKHZhbHVlKSkge1xuICAgICAgICAgIC8vIGZvciBleHByZXNzaW9ucyBjb250YWluaW5nIGxpdGVyYWwgbnVtYmVycyBhbmRcbiAgICAgICAgICAvLyBib29sZWFucywgdGhlcmUncyBubyBuZWVkIHRvIHNldHVwIGEgcHJvcCBiaW5kaW5nLFxuICAgICAgICAgIC8vIHNvIHdlIGNhbiBvcHRpbWl6ZSB0aGVtIGFzIGEgb25lLXRpbWUgc2V0LlxuICAgICAgICAgIHByb3Aub3B0aW1pemVkTGl0ZXJhbCA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wLmR5bmFtaWMgPSB0cnVlXG4gICAgICAgICAgLy8gY2hlY2sgbm9uLXNldHRhYmxlIHBhdGggZm9yIHR3by13YXkgYmluZGluZ3NcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICBwcm9wLm1vZGUgPT09IHByb3BCaW5kaW5nTW9kZXMuVFdPX1dBWSAmJlxuICAgICAgICAgICAgICAhc2V0dGFibGVQYXRoUkUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuT05FX1dBWVxuICAgICAgICAgICAgXy53YXJuKFxuICAgICAgICAgICAgICAnQ2Fubm90IGJpbmQgdHdvLXdheSBwcm9wIHdpdGggbm9uLXNldHRhYmxlICcgK1xuICAgICAgICAgICAgICAncGFyZW50IHBhdGg6ICcgKyB2YWx1ZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9wLnBhcmVudFBhdGggPSB2YWx1ZVxuXG4gICAgICAgIC8vIHdhcm4gcmVxdWlyZWQgdHdvLXdheVxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIG9wdGlvbnMudHdvV2F5ICYmXG4gICAgICAgICAgcHJvcC5tb2RlICE9PSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVlcbiAgICAgICAgKSB7XG4gICAgICAgICAgXy53YXJuKFxuICAgICAgICAgICAgJ1Byb3AgXCInICsgbmFtZSArICdcIiBleHBlY3RzIGEgdHdvLXdheSBiaW5kaW5nIHR5cGUuJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVxdWlyZWQpIHtcbiAgICAgICAgLy8gd2FybiBtaXNzaW5nIHJlcXVpcmVkXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6ICcgKyBuYW1lXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwdXNoIHByb3BcbiAgICBwcm9wcy5wdXNoKHByb3ApXG4gIH1cbiAgcmV0dXJuIG1ha2VQcm9wc0xpbmtGbihwcm9wcylcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBwcm9wcyB0byBhIHZtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJvcHNMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlUHJvcHNMaW5rRm4gKHByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcm9wc0xpbmtGbiAodm0sIHNjb3BlKSB7XG4gICAgLy8gc3RvcmUgcmVzb2x2ZWQgcHJvcHMgaW5mb1xuICAgIHZtLl9wcm9wcyA9IHt9XG4gICAgdmFyIGkgPSBwcm9wcy5sZW5ndGhcbiAgICB2YXIgcHJvcCwgcGF0aCwgb3B0aW9ucywgdmFsdWUsIHJhd1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHByb3AgPSBwcm9wc1tpXVxuICAgICAgcmF3ID0gcHJvcC5yYXdcbiAgICAgIHBhdGggPSBwcm9wLnBhdGhcbiAgICAgIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnNcbiAgICAgIHZtLl9wcm9wc1twYXRoXSA9IHByb3BcbiAgICAgIGlmIChyYXcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBhYnNlbnQgcHJvcFxuICAgICAgICBfLmluaXRQcm9wKHZtLCBwcm9wLCBnZXREZWZhdWx0KHZtLCBvcHRpb25zKSlcbiAgICAgIH0gZWxzZSBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICAgIC8vIGR5bmFtaWMgcHJvcFxuICAgICAgICBpZiAodm0uX2NvbnRleHQpIHtcbiAgICAgICAgICBpZiAocHJvcC5tb2RlID09PSBwcm9wQmluZGluZ01vZGVzLk9ORV9USU1FKSB7XG4gICAgICAgICAgICAvLyBvbmUgdGltZSBiaW5kaW5nXG4gICAgICAgICAgICB2YWx1ZSA9IChzY29wZSB8fCB2bS5fY29udGV4dCkuJGdldChwcm9wLnBhcmVudFBhdGgpXG4gICAgICAgICAgICBfLmluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZHluYW1pYyBiaW5kaW5nXG4gICAgICAgICAgICB2bS5fYmluZERpcih7XG4gICAgICAgICAgICAgIG5hbWU6ICdwcm9wJyxcbiAgICAgICAgICAgICAgZGVmOiBwcm9wRGVmLFxuICAgICAgICAgICAgICBwcm9wOiBwcm9wXG4gICAgICAgICAgICB9LCBudWxsLCBudWxsLCBzY29wZSkgLy8gZWwsIGhvc3QsIHNjb3BlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAgICAgJ0Nhbm5vdCBiaW5kIGR5bmFtaWMgcHJvcCBvbiBhIHJvb3QgaW5zdGFuY2UnICtcbiAgICAgICAgICAgICcgd2l0aCBubyBwYXJlbnQ6ICcgKyBwcm9wLm5hbWUgKyAnPVwiJyArXG4gICAgICAgICAgICByYXcgKyAnXCInXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3Aub3B0aW1pemVkTGl0ZXJhbCkge1xuICAgICAgICAvLyBvcHRpbWl6ZWQgbGl0ZXJhbCwgY2FzdCBpdCBhbmQganVzdCBzZXQgb25jZVxuICAgICAgICByYXcgPSBfLnN0cmlwUXVvdGVzKHJhdylcbiAgICAgICAgdmFsdWUgPSBfLnRvQm9vbGVhbihfLnRvTnVtYmVyKHJhdykpXG4gICAgICAgIF8uaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RyaW5nIGxpdGVyYWwsIGJ1dCB3ZSBuZWVkIHRvIGNhdGVyIGZvclxuICAgICAgICAvLyBCb29sZWFuIHByb3BzIHdpdGggbm8gdmFsdWVcbiAgICAgICAgdmFsdWUgPSBvcHRpb25zLnR5cGUgPT09IEJvb2xlYW4gJiYgcmF3ID09PSAnJ1xuICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgIDogcmF3XG4gICAgICAgIF8uaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0ICh2bSwgb3B0aW9ucykge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpKSB7XG4gICAgLy8gYWJzZW50IGJvb2xlYW4gdmFsdWUgZGVmYXVsdHMgdG8gZmFsc2VcbiAgICByZXR1cm4gb3B0aW9ucy50eXBlID09PSBCb29sZWFuXG4gICAgICA/IGZhbHNlXG4gICAgICA6IHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBvcHRpb25zLmRlZmF1bHRcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAoXy5pc09iamVjdChkZWYpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnT2JqZWN0L0FycmF5IGFzIGRlZmF1bHQgcHJvcCB2YWx1ZXMgd2lsbCBiZSBzaGFyZWQgJyArXG4gICAgICAnYWNyb3NzIG11bHRpcGxlIGluc3RhbmNlcy4gVXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC4nXG4gICAgKVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMudHlwZSAhPT0gRnVuY3Rpb25cbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHB1YmxpY0RpcmVjdGl2ZXMgPSByZXF1aXJlKCcuLi9kaXJlY3RpdmVzL3B1YmxpYycpXG52YXIgaW50ZXJuYWxEaXJlY3RpdmVzID0gcmVxdWlyZSgnLi4vZGlyZWN0aXZlcy9pbnRlcm5hbCcpXG52YXIgY29tcGlsZVByb3BzID0gcmVxdWlyZSgnLi9jb21waWxlLXByb3BzJylcbnZhciB0ZXh0UGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2Vycy90ZXh0JylcbnZhciBkaXJQYXJzZXIgPSByZXF1aXJlKCcuLi9wYXJzZXJzL2RpcmVjdGl2ZScpXG52YXIgdGVtcGxhdGVQYXJzZXIgPSByZXF1aXJlKCcuLi9wYXJzZXJzL3RlbXBsYXRlJylcbnZhciByZXNvbHZlQXNzZXQgPSBfLnJlc29sdmVBc3NldFxuXG4vLyBzcGVjaWFsIGJpbmRpbmcgcHJlZml4ZXNcbnZhciBiaW5kUkUgPSAvXnYtYmluZDp8XjovXG52YXIgb25SRSA9IC9edi1vbjp8XkAvXG52YXIgYXJnUkUgPSAvOiguKikkL1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW15cXC5dKy9nXG52YXIgdHJhbnNpdGlvblJFID0gL14odi1iaW5kOnw6KT90cmFuc2l0aW9uJC9cblxuLy8gdGVybWluYWwgZGlyZWN0aXZlc1xudmFyIHRlcm1pbmFsRGlyZWN0aXZlcyA9IFtcbiAgJ2ZvcicsXG4gICdpZidcbl1cblxuLy8gZGVmYXVsdCBkaXJlY3RpdmUgcHJpb3JpdHlcbnZhciBERUZBVUxUX1BSSU9SSVRZID0gMTAwMFxuXG4vKipcbiAqIENvbXBpbGUgYSB0ZW1wbGF0ZSBhbmQgcmV0dXJuIGEgcmV1c2FibGUgY29tcG9zaXRlIGxpbmtcbiAqIGZ1bmN0aW9uLCB3aGljaCByZWN1cnNpdmVseSBjb250YWlucyBtb3JlIGxpbmsgZnVuY3Rpb25zXG4gKiBpbnNpZGUuIFRoaXMgdG9wIGxldmVsIGNvbXBpbGUgZnVuY3Rpb24gd291bGQgbm9ybWFsbHlcbiAqIGJlIGNhbGxlZCBvbiBpbnN0YW5jZSByb290IG5vZGVzLCBidXQgY2FuIGFsc28gYmUgdXNlZFxuICogZm9yIHBhcnRpYWwgY29tcGlsYXRpb24gaWYgdGhlIHBhcnRpYWwgYXJndW1lbnQgaXMgdHJ1ZS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgY29tcG9zaXRlIGxpbmsgZnVuY3Rpb24sIHdoZW4gY2FsbGVkLCB3aWxsXG4gKiByZXR1cm4gYW4gdW5saW5rIGZ1bmN0aW9uIHRoYXQgdGVhcnNkb3duIGFsbCBkaXJlY3RpdmVzXG4gKiBjcmVhdGVkIGR1cmluZyB0aGUgbGlua2luZyBwaGFzZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcnRpYWxcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydHMuY29tcGlsZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucywgcGFydGlhbCkge1xuICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgbm9kZSBpdHNlbGYuXG4gIHZhciBub2RlTGlua0ZuID0gcGFydGlhbCB8fCAhb3B0aW9ucy5fYXNDb21wb25lbnRcbiAgICA/IGNvbXBpbGVOb2RlKGVsLCBvcHRpb25zKVxuICAgIDogbnVsbFxuICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgY2hpbGROb2Rlc1xuICB2YXIgY2hpbGRMaW5rRm4gPVxuICAgICEobm9kZUxpbmtGbiAmJiBub2RlTGlua0ZuLnRlcm1pbmFsKSAmJlxuICAgIGVsLnRhZ05hbWUgIT09ICdTQ1JJUFQnICYmXG4gICAgZWwuaGFzQ2hpbGROb2RlcygpXG4gICAgICA/IGNvbXBpbGVOb2RlTGlzdChlbC5jaGlsZE5vZGVzLCBvcHRpb25zKVxuICAgICAgOiBudWxsXG5cbiAgLyoqXG4gICAqIEEgY29tcG9zaXRlIGxpbmtlciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYSBhbHJlYWR5XG4gICAqIGNvbXBpbGVkIHBpZWNlIG9mIERPTSwgd2hpY2ggaW5zdGFudGlhdGVzIGFsbCBkaXJlY3RpdmVcbiAgICogaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gICAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSBob3N0IHZtIG9mIHRyYW5zY2x1ZGVkIGNvbnRlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSB2LWZvciBzY29wZVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ10gLSBsaW5rIGNvbnRleHQgZnJhZ21lbnRcbiAgICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICAgKi9cblxuICByZXR1cm4gZnVuY3Rpb24gY29tcG9zaXRlTGlua0ZuICh2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgLy8gY2FjaGUgY2hpbGROb2RlcyBiZWZvcmUgbGlua2luZyBwYXJlbnQsIGZpeCAjNjU3XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBfLnRvQXJyYXkoZWwuY2hpbGROb2RlcylcbiAgICAvLyBsaW5rXG4gICAgdmFyIGRpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiBjb21wb3NpdGVMaW5rQ2FwdHVyZXIgKCkge1xuICAgICAgaWYgKG5vZGVMaW5rRm4pIG5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZylcbiAgICAgIGlmIChjaGlsZExpbmtGbikgY2hpbGRMaW5rRm4odm0sIGNoaWxkTm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKVxuICAgIH0sIHZtKVxuICAgIHJldHVybiBtYWtlVW5saW5rRm4odm0sIGRpcnMpXG4gIH1cbn1cblxuLyoqXG4gKiBBcHBseSBhIGxpbmtlciB0byBhIHZtL2VsZW1lbnQgcGFpciBhbmQgY2FwdHVyZSB0aGVcbiAqIGRpcmVjdGl2ZXMgY3JlYXRlZCBkdXJpbmcgdGhlIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlua2VyXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiBsaW5rQW5kQ2FwdHVyZSAobGlua2VyLCB2bSkge1xuICB2YXIgb3JpZ2luYWxEaXJDb3VudCA9IHZtLl9kaXJlY3RpdmVzLmxlbmd0aFxuICBsaW5rZXIoKVxuICB2YXIgZGlycyA9IHZtLl9kaXJlY3RpdmVzLnNsaWNlKG9yaWdpbmFsRGlyQ291bnQpXG4gIGRpcnMuc29ydChkaXJlY3RpdmVDb21wYXJhdG9yKVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyc1tpXS5fYmluZCgpXG4gIH1cbiAgcmV0dXJuIGRpcnNcbn1cblxuLyoqXG4gKiBEaXJlY3RpdmUgcHJpb3JpdHkgc29ydCBjb21wYXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKi9cblxuZnVuY3Rpb24gZGlyZWN0aXZlQ29tcGFyYXRvciAoYSwgYikge1xuICBhID0gYS5kZXNjcmlwdG9yLmRlZi5wcmlvcml0eSB8fCBERUZBVUxUX1BSSU9SSVRZXG4gIGIgPSBiLmRlc2NyaXB0b3IuZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfUFJJT1JJVFlcbiAgcmV0dXJuIGEgPiBiID8gLTEgOiBhID09PSBiID8gMCA6IDFcbn1cblxuLyoqXG4gKiBMaW5rZXIgZnVuY3Rpb25zIHJldHVybiBhbiB1bmxpbmsgZnVuY3Rpb24gdGhhdFxuICogdGVhcnNkb3duIGFsbCBkaXJlY3RpdmVzIGluc3RhbmNlcyBnZW5lcmF0ZWQgZHVyaW5nXG4gKiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiBXZSBjcmVhdGUgdW5saW5rIGZ1bmN0aW9ucyB3aXRoIG9ubHkgdGhlIG5lY2Vzc2FyeVxuICogaW5mb3JtYXRpb24gdG8gYXZvaWQgcmV0YWluaW5nIGFkZGl0aW9uYWwgY2xvc3VyZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJzXG4gKiBAcGFyYW0ge1Z1ZX0gW2NvbnRleHRdXG4gKiBAcGFyYW0ge0FycmF5fSBbY29udGV4dERpcnNdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlVW5saW5rRm4gKHZtLCBkaXJzLCBjb250ZXh0LCBjb250ZXh0RGlycykge1xuICByZXR1cm4gZnVuY3Rpb24gdW5saW5rIChkZXN0cm95aW5nKSB7XG4gICAgdGVhcmRvd25EaXJzKHZtLCBkaXJzLCBkZXN0cm95aW5nKVxuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHREaXJzKSB7XG4gICAgICB0ZWFyZG93bkRpcnMoY29udGV4dCwgY29udGV4dERpcnMpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGVhcmRvd24gcGFydGlhbCBsaW5rZWQgZGlyZWN0aXZlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7QXJyYXl9IGRpcnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVzdHJveWluZ1xuICovXG5cbmZ1bmN0aW9uIHRlYXJkb3duRGlycyAodm0sIGRpcnMsIGRlc3Ryb3lpbmcpIHtcbiAgdmFyIGkgPSBkaXJzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgZGlyc1tpXS5fdGVhcmRvd24oKVxuICAgIGlmICghZGVzdHJveWluZykge1xuICAgICAgdm0uX2RpcmVjdGl2ZXMuJHJlbW92ZShkaXJzW2ldKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgbGluayBwcm9wcyBvbiBhbiBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydHMuY29tcGlsZUFuZExpbmtQcm9wcyA9IGZ1bmN0aW9uICh2bSwgZWwsIHByb3BzLCBzY29wZSkge1xuICB2YXIgcHJvcHNMaW5rRm4gPSBjb21waWxlUHJvcHMoZWwsIHByb3BzKVxuICB2YXIgcHJvcERpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiAoKSB7XG4gICAgcHJvcHNMaW5rRm4odm0sIHNjb3BlKVxuICB9LCB2bSlcbiAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgcHJvcERpcnMpXG59XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgcm9vdCBlbGVtZW50IG9mIGFuIGluc3RhbmNlLlxuICpcbiAqIDEuIGF0dHJzIG9uIGNvbnRleHQgY29udGFpbmVyIChjb250ZXh0IHNjb3BlKVxuICogMi4gYXR0cnMgb24gdGhlIGNvbXBvbmVudCB0ZW1wbGF0ZSByb290IG5vZGUsIGlmXG4gKiAgICByZXBsYWNlOnRydWUgKGNoaWxkIHNjb3BlKVxuICpcbiAqIElmIHRoaXMgaXMgYSBmcmFnbWVudCBpbnN0YW5jZSwgd2Ugb25seSBuZWVkIHRvIGNvbXBpbGUgMS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dE9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydHMuY29tcGlsZVJvb3QgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMsIGNvbnRleHRPcHRpb25zKSB7XG4gIHZhciBjb250YWluZXJBdHRycyA9IG9wdGlvbnMuX2NvbnRhaW5lckF0dHJzXG4gIHZhciByZXBsYWNlckF0dHJzID0gb3B0aW9ucy5fcmVwbGFjZXJBdHRyc1xuICB2YXIgY29udGV4dExpbmtGbiwgcmVwbGFjZXJMaW5rRm5cblxuICAvLyBvbmx5IG5lZWQgdG8gY29tcGlsZSBvdGhlciBhdHRyaWJ1dGVzIGZvclxuICAvLyBub24tZnJhZ21lbnQgaW5zdGFuY2VzXG4gIGlmIChlbC5ub2RlVHlwZSAhPT0gMTEpIHtcbiAgICAvLyBmb3IgY29tcG9uZW50cywgY29udGFpbmVyIGFuZCByZXBsYWNlciBuZWVkIHRvIGJlXG4gICAgLy8gY29tcGlsZWQgc2VwYXJhdGVseSBhbmQgbGlua2VkIGluIGRpZmZlcmVudCBzY29wZXMuXG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgICAvLyAyLiBjb250YWluZXIgYXR0cmlidXRlc1xuICAgICAgaWYgKGNvbnRhaW5lckF0dHJzICYmIGNvbnRleHRPcHRpb25zKSB7XG4gICAgICAgIGNvbnRleHRMaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhjb250YWluZXJBdHRycywgY29udGV4dE9wdGlvbnMpXG4gICAgICB9XG4gICAgICBpZiAocmVwbGFjZXJBdHRycykge1xuICAgICAgICAvLyAzLiByZXBsYWNlciBhdHRyaWJ1dGVzXG4gICAgICAgIHJlcGxhY2VyTGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMocmVwbGFjZXJBdHRycywgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9uLWNvbXBvbmVudCwganVzdCBjb21waWxlIGFzIGEgbm9ybWFsIGVsZW1lbnQuXG4gICAgICByZXBsYWNlckxpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKGVsLmF0dHJpYnV0ZXMsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29udGFpbmVyQXR0cnMpIHtcbiAgICAvLyB3YXJuIGNvbnRhaW5lciBkaXJlY3RpdmVzIGZvciBmcmFnbWVudCBpbnN0YW5jZXNcbiAgICB2YXIgbmFtZXMgPSBjb250YWluZXJBdHRycy5tYXAoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIHJldHVybiAnXCInICsgYXR0ci5uYW1lICsgJ1wiJ1xuICAgIH0pLmpvaW4oJywgJylcbiAgICB2YXIgcGx1cmFsID0gY29udGFpbmVyQXR0cnMubGVuZ3RoID4gMVxuICAgIF8ud2FybihcbiAgICAgICdBdHRyaWJ1dGUnICsgKHBsdXJhbCA/ICdzICcgOiAnICcpICsgbmFtZXMgK1xuICAgICAgKHBsdXJhbCA/ICcgYXJlJyA6ICcgaXMnKSArICcgaWdub3JlZCBvbiBjb21wb25lbnQgJyArXG4gICAgICAnPCcgKyBvcHRpb25zLmVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICc+IGJlY2F1c2UgJyArXG4gICAgICAndGhlIGNvbXBvbmVudCBpcyBhIGZyYWdtZW50IGluc3RhbmNlOiAnICtcbiAgICAgICdodHRwOi8vdnVlanMub3JnL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNGcmFnbWVudF9JbnN0YW5jZSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcm9vdExpbmtGbiAodm0sIGVsLCBzY29wZSkge1xuICAgIC8vIGxpbmsgY29udGV4dCBzY29wZSBkaXJzXG4gICAgdmFyIGNvbnRleHQgPSB2bS5fY29udGV4dFxuICAgIHZhciBjb250ZXh0RGlyc1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHRMaW5rRm4pIHtcbiAgICAgIGNvbnRleHREaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZXh0TGlua0ZuKGNvbnRleHQsIGVsLCBudWxsLCBzY29wZSlcbiAgICAgIH0sIGNvbnRleHQpXG4gICAgfVxuXG4gICAgLy8gbGluayBzZWxmXG4gICAgdmFyIHNlbGZEaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJlcGxhY2VyTGlua0ZuKSByZXBsYWNlckxpbmtGbih2bSwgZWwpXG4gICAgfSwgdm0pXG5cbiAgICAvLyByZXR1cm4gdGhlIHVubGluayBmdW5jdGlvbiB0aGF0IHRlYXJzZG93biBjb250ZXh0XG4gICAgLy8gY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gICAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgc2VsZkRpcnMsIGNvbnRleHQsIGNvbnRleHREaXJzKVxuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIG5vZGUgYW5kIHJldHVybiBhIG5vZGVMaW5rRm4gYmFzZWQgb24gdGhlXG4gKiBub2RlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlTm9kZSAobm9kZSwgb3B0aW9ucykge1xuICB2YXIgdHlwZSA9IG5vZGUubm9kZVR5cGVcbiAgaWYgKHR5cGUgPT09IDEgJiYgbm9kZS50YWdOYW1lICE9PSAnU0NSSVBUJykge1xuICAgIHJldHVybiBjb21waWxlRWxlbWVudChub2RlLCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IDMgJiYgbm9kZS5kYXRhLnRyaW0oKSkge1xuICAgIHJldHVybiBjb21waWxlVGV4dE5vZGUobm9kZSwgb3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBhbiBlbGVtZW50IGFuZCByZXR1cm4gYSBub2RlTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVFbGVtZW50IChlbCwgb3B0aW9ucykge1xuICAvLyBwcmVwcm9jZXNzIHRleHRhcmVhcy5cbiAgLy8gdGV4dGFyZWEgdHJlYXRzIGl0cyB0ZXh0IGNvbnRlbnQgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gIC8vIGp1c3QgYmluZCBpdCBhcyBhbiBhdHRyIGRpcmVjdGl2ZSBmb3IgdmFsdWUuXG4gIGlmIChlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgdmFyIHRva2VucyA9IHRleHRQYXJzZXIucGFyc2UoZWwudmFsdWUpXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCc6dmFsdWUnLCB0ZXh0UGFyc2VyLnRva2Vuc1RvRXhwKHRva2VucykpXG4gICAgICBlbC52YWx1ZSA9ICcnXG4gICAgfVxuICB9XG4gIHZhciBsaW5rRm5cbiAgdmFyIGhhc0F0dHJzID0gZWwuaGFzQXR0cmlidXRlcygpXG4gIC8vIGNoZWNrIHRlcm1pbmFsIGRpcmVjdGl2ZXMgKGZvciAmIGlmKVxuICBpZiAoaGFzQXR0cnMpIHtcbiAgICBsaW5rRm4gPSBjaGVja1Rlcm1pbmFsRGlyZWN0aXZlcyhlbCwgb3B0aW9ucylcbiAgfVxuICAvLyBjaGVjayBlbGVtZW50IGRpcmVjdGl2ZXNcbiAgaWYgKCFsaW5rRm4pIHtcbiAgICBsaW5rRm4gPSBjaGVja0VsZW1lbnREaXJlY3RpdmVzKGVsLCBvcHRpb25zKVxuICB9XG4gIC8vIGNoZWNrIGNvbXBvbmVudFxuICBpZiAoIWxpbmtGbikge1xuICAgIGxpbmtGbiA9IGNoZWNrQ29tcG9uZW50KGVsLCBvcHRpb25zKVxuICB9XG4gIC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gIGlmICghbGlua0ZuICYmIGhhc0F0dHJzKSB7XG4gICAgbGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMoZWwuYXR0cmlidXRlcywgb3B0aW9ucylcbiAgfVxuICByZXR1cm4gbGlua0ZuXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHRleHROb2RlIGFuZCByZXR1cm4gYSBub2RlTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7VGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfSB0ZXh0Tm9kZUxpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVUZXh0Tm9kZSAobm9kZSwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gdGV4dFBhcnNlci5wYXJzZShub2RlLmRhdGEpXG4gIGlmICghdG9rZW5zKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICB2YXIgZWwsIHRva2VuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRva2VuID0gdG9rZW5zW2ldXG4gICAgZWwgPSB0b2tlbi50YWdcbiAgICAgID8gcHJvY2Vzc1RleHRUb2tlbih0b2tlbiwgb3B0aW9ucylcbiAgICAgIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodG9rZW4udmFsdWUpXG4gICAgZnJhZy5hcHBlbmRDaGlsZChlbClcbiAgfVxuICByZXR1cm4gbWFrZVRleHROb2RlTGlua0ZuKHRva2VucywgZnJhZywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgc2luZ2xlIHRleHQgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzVGV4dFRva2VuICh0b2tlbiwgb3B0aW9ucykge1xuICB2YXIgZWxcbiAgaWYgKHRva2VuLm9uZVRpbWUpIHtcbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKVxuICB9IGVsc2Uge1xuICAgIGlmICh0b2tlbi5odG1sKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ3YtaHRtbCcpXG4gICAgICBzZXRUb2tlblR5cGUoJ2h0bWwnKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSB3aWxsIGNsZWFuIHVwIGVtcHR5IHRleHROb2RlcyBkdXJpbmdcbiAgICAgIC8vIGZyYWcuY2xvbmVOb2RlKHRydWUpLCBzbyB3ZSBoYXZlIHRvIGdpdmUgaXRcbiAgICAgIC8vIHNvbWV0aGluZyBoZXJlLi4uXG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJylcbiAgICAgIHNldFRva2VuVHlwZSgndGV4dCcpXG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldFRva2VuVHlwZSAodHlwZSkge1xuICAgIGlmICh0b2tlbi5kZXNjcmlwdG9yKSByZXR1cm5cbiAgICB2YXIgcGFyc2VkID0gZGlyUGFyc2VyLnBhcnNlKHRva2VuLnZhbHVlKVxuICAgIHRva2VuLmRlc2NyaXB0b3IgPSB7XG4gICAgICBuYW1lOiB0eXBlLFxuICAgICAgZGVmOiBwdWJsaWNEaXJlY3RpdmVzW3R5cGVdLFxuICAgICAgZXhwcmVzc2lvbjogcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgICBmaWx0ZXJzOiBwYXJzZWQuZmlsdGVyc1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIGEgdGV4dE5vZGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSB0b2tlbnNcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ1xuICovXG5cbmZ1bmN0aW9uIG1ha2VUZXh0Tm9kZUxpbmtGbiAodG9rZW5zLCBmcmFnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0ZXh0Tm9kZUxpbmtGbiAodm0sIGVsLCBob3N0LCBzY29wZSkge1xuICAgIHZhciBmcmFnQ2xvbmUgPSBmcmFnLmNsb25lTm9kZSh0cnVlKVxuICAgIHZhciBjaGlsZE5vZGVzID0gXy50b0FycmF5KGZyYWdDbG9uZS5jaGlsZE5vZGVzKVxuICAgIHZhciB0b2tlbiwgdmFsdWUsIG5vZGVcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldXG4gICAgICB2YWx1ZSA9IHRva2VuLnZhbHVlXG4gICAgICBpZiAodG9rZW4udGFnKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZE5vZGVzW2ldXG4gICAgICAgIGlmICh0b2tlbi5vbmVUaW1lKSB7XG4gICAgICAgICAgdmFsdWUgPSAoc2NvcGUgfHwgdm0pLiRldmFsKHZhbHVlKVxuICAgICAgICAgIGlmICh0b2tlbi5odG1sKSB7XG4gICAgICAgICAgICBfLnJlcGxhY2Uobm9kZSwgdGVtcGxhdGVQYXJzZXIucGFyc2UodmFsdWUsIHRydWUpKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bS5fYmluZERpcih0b2tlbi5kZXNjcmlwdG9yLCBub2RlLCBob3N0LCBzY29wZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfLnJlcGxhY2UoZWwsIGZyYWdDbG9uZSlcbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgYSBub2RlIGxpc3QgYW5kIHJldHVybiBhIGNoaWxkTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVMaXN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVOb2RlTGlzdCAobm9kZUxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGxpbmtGbnMgPSBbXVxuICB2YXIgbm9kZUxpbmtGbiwgY2hpbGRMaW5rRm4sIG5vZGVcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBub2RlID0gbm9kZUxpc3RbaV1cbiAgICBub2RlTGlua0ZuID0gY29tcGlsZU5vZGUobm9kZSwgb3B0aW9ucylcbiAgICBjaGlsZExpbmtGbiA9XG4gICAgICAhKG5vZGVMaW5rRm4gJiYgbm9kZUxpbmtGbi50ZXJtaW5hbCkgJiZcbiAgICAgIG5vZGUudGFnTmFtZSAhPT0gJ1NDUklQVCcgJiZcbiAgICAgIG5vZGUuaGFzQ2hpbGROb2RlcygpXG4gICAgICAgID8gY29tcGlsZU5vZGVMaXN0KG5vZGUuY2hpbGROb2Rlcywgb3B0aW9ucylcbiAgICAgICAgOiBudWxsXG4gICAgbGlua0Zucy5wdXNoKG5vZGVMaW5rRm4sIGNoaWxkTGlua0ZuKVxuICB9XG4gIHJldHVybiBsaW5rRm5zLmxlbmd0aFxuICAgID8gbWFrZUNoaWxkTGlua0ZuKGxpbmtGbnMpXG4gICAgOiBudWxsXG59XG5cbi8qKlxuICogTWFrZSBhIGNoaWxkIGxpbmsgZnVuY3Rpb24gZm9yIGEgbm9kZSdzIGNoaWxkTm9kZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxGdW5jdGlvbj59IGxpbmtGbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBjaGlsZExpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VDaGlsZExpbmtGbiAobGlua0Zucykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hpbGRMaW5rRm4gKHZtLCBub2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICB2YXIgbm9kZSwgbm9kZUxpbmtGbiwgY2hpbGRyZW5MaW5rRm5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IDAsIGwgPSBsaW5rRm5zLmxlbmd0aDsgaSA8IGw7IG4rKykge1xuICAgICAgbm9kZSA9IG5vZGVzW25dXG4gICAgICBub2RlTGlua0ZuID0gbGlua0Zuc1tpKytdXG4gICAgICBjaGlsZHJlbkxpbmtGbiA9IGxpbmtGbnNbaSsrXVxuICAgICAgLy8gY2FjaGUgY2hpbGROb2RlcyBiZWZvcmUgbGlua2luZyBwYXJlbnQsIGZpeCAjNjU3XG4gICAgICB2YXIgY2hpbGROb2RlcyA9IF8udG9BcnJheShub2RlLmNoaWxkTm9kZXMpXG4gICAgICBpZiAobm9kZUxpbmtGbikge1xuICAgICAgICBub2RlTGlua0ZuKHZtLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZylcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZHJlbkxpbmtGbikge1xuICAgICAgICBjaGlsZHJlbkxpbmtGbih2bSwgY2hpbGROb2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIGVsZW1lbnQgZGlyZWN0aXZlcyAoY3VzdG9tIGVsZW1lbnRzIHRoYXQgc2hvdWxkXG4gKiBiZSByZXNvdmxlZCBhcyB0ZXJtaW5hbCBkaXJlY3RpdmVzKS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGNoZWNrRWxlbWVudERpcmVjdGl2ZXMgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgaWYgKF8uY29tbW9uVGFnUkUudGVzdCh0YWcpKSByZXR1cm5cbiAgdmFyIGRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZWxlbWVudERpcmVjdGl2ZXMnLCB0YWcpXG4gIGlmIChkZWYpIHtcbiAgICByZXR1cm4gbWFrZVRlcm1pbmFsTm9kZUxpbmtGbihlbCwgdGFnLCAnJywgb3B0aW9ucywgZGVmKVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIGNvbXBvbmVudC4gSWYgeWVzLCByZXR1cm5cbiAqIGEgY29tcG9uZW50IGxpbmsgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudCAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbXBvbmVudCA9IF8uY2hlY2tDb21wb25lbnQoZWwsIG9wdGlvbnMpXG4gIGlmIChjb21wb25lbnQpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgIG5hbWU6ICdjb21wb25lbnQnLFxuICAgICAgZXhwcmVzc2lvbjogY29tcG9uZW50LmlkLFxuICAgICAgZGVmOiBpbnRlcm5hbERpcmVjdGl2ZXMuY29tcG9uZW50LFxuICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgIGxpdGVyYWw6ICFjb21wb25lbnQuZHluYW1pY1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY29tcG9uZW50TGlua0ZuID0gZnVuY3Rpb24gKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAgIHZtLl9iaW5kRGlyKGRlc2NyaXB0b3IsIGVsLCBob3N0LCBzY29wZSwgZnJhZylcbiAgICB9XG4gICAgY29tcG9uZW50TGlua0ZuLnRlcm1pbmFsID0gdHJ1ZVxuICAgIHJldHVybiBjb21wb25lbnRMaW5rRm5cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGFuIGVsZW1lbnQgZm9yIHRlcm1pbmFsIGRpcmVjdGl2ZXMgaW4gZml4ZWQgb3JkZXIuXG4gKiBJZiBpdCBmaW5kcyBvbmUsIHJldHVybiBhIHRlcm1pbmFsIGxpbmsgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0ZXJtaW5hbExpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNoZWNrVGVybWluYWxEaXJlY3RpdmVzIChlbCwgb3B0aW9ucykge1xuICAvLyBza2lwIHYtcHJlXG4gIGlmIChfLmF0dHIoZWwsICd2LXByZScpICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNraXBcbiAgfVxuICAvLyBza2lwIHYtZWxzZSBibG9jaywgYnV0IG9ubHkgaWYgZm9sbG93aW5nIHYtaWZcbiAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgndi1lbHNlJykpIHtcbiAgICB2YXIgcHJldiA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmdcbiAgICBpZiAocHJldiAmJiBwcmV2Lmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgICByZXR1cm4gc2tpcFxuICAgIH1cbiAgfVxuICB2YXIgdmFsdWUsIGRpck5hbWVcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0ZXJtaW5hbERpcmVjdGl2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyTmFtZSA9IHRlcm1pbmFsRGlyZWN0aXZlc1tpXVxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaWYgKHZhbHVlID0gZWwuZ2V0QXR0cmlidXRlKCd2LScgKyBkaXJOYW1lKSkge1xuICAgICAgcmV0dXJuIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4oZWwsIGRpck5hbWUsIHZhbHVlLCBvcHRpb25zKVxuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gIH1cbn1cblxuZnVuY3Rpb24gc2tpcCAoKSB7fVxuc2tpcC50ZXJtaW5hbCA9IHRydWVcblxuLyoqXG4gKiBCdWlsZCBhIG5vZGUgbGluayBmdW5jdGlvbiBmb3IgYSB0ZXJtaW5hbCBkaXJlY3RpdmUuXG4gKiBBIHRlcm1pbmFsIGxpbmsgZnVuY3Rpb24gdGVybWluYXRlcyB0aGUgY3VycmVudFxuICogY29tcGlsYXRpb24gcmVjdXJzaW9uIGFuZCBoYW5kbGVzIGNvbXBpbGF0aW9uIG9mIHRoZVxuICogc3VidHJlZSBpbiB0aGUgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBkaXJOYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW2RlZl1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0ZXJtaW5hbExpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4gKGVsLCBkaXJOYW1lLCB2YWx1ZSwgb3B0aW9ucywgZGVmKSB7XG4gIHZhciBwYXJzZWQgPSBkaXJQYXJzZXIucGFyc2UodmFsdWUpXG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgIG5hbWU6IGRpck5hbWUsXG4gICAgZXhwcmVzc2lvbjogcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgZmlsdGVyczogcGFyc2VkLmZpbHRlcnMsXG4gICAgcmF3OiB2YWx1ZSxcbiAgICAvLyBlaXRoZXIgYW4gZWxlbWVudCBkaXJlY3RpdmUsIG9yIGlmL2ZvclxuICAgIGRlZjogZGVmIHx8IHB1YmxpY0RpcmVjdGl2ZXNbZGlyTmFtZV1cbiAgfVxuICB2YXIgZm4gPSBmdW5jdGlvbiB0ZXJtaW5hbE5vZGVMaW5rRm4gKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICB2bS5fYmluZERpcihkZXNjcmlwdG9yLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpXG4gIH1cbiAgZm4udGVybWluYWwgPSB0cnVlXG4gIHJldHVybiBmblxufVxuXG4vKipcbiAqIENvbXBpbGUgdGhlIGRpcmVjdGl2ZXMgb24gYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbGlua2VyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8TmFtZWROb2RlTWFwfSBhdHRyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVEaXJlY3RpdmVzIChhdHRycywgb3B0aW9ucykge1xuICB2YXIgaSA9IGF0dHJzLmxlbmd0aFxuICB2YXIgZGlycyA9IFtdXG4gIHZhciBhdHRyLCBuYW1lLCB2YWx1ZSwgcmF3TmFtZSwgcmF3VmFsdWUsIGRpck5hbWUsIGFyZywgbW9kaWZpZXJzLCBkaXJEZWYsIHRva2Vuc1xuICB3aGlsZSAoaS0tKSB7XG4gICAgYXR0ciA9IGF0dHJzW2ldXG4gICAgbmFtZSA9IHJhd05hbWUgPSBhdHRyLm5hbWVcbiAgICB2YWx1ZSA9IHJhd1ZhbHVlID0gYXR0ci52YWx1ZVxuICAgIHRva2VucyA9IHRleHRQYXJzZXIucGFyc2UodmFsdWUpXG4gICAgLy8gcmVzZXQgYXJnXG4gICAgYXJnID0gbnVsbFxuICAgIC8vIGNoZWNrIG1vZGlmaWVyc1xuICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJylcblxuICAgIC8vIGF0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uc1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIHZhbHVlID0gdGV4dFBhcnNlci50b2tlbnNUb0V4cCh0b2tlbnMpXG4gICAgICBhcmcgPSBuYW1lXG4gICAgICBwdXNoRGlyKCdiaW5kJywgcHVibGljRGlyZWN0aXZlcy5iaW5kLCB0cnVlKVxuICAgIH0gZWxzZVxuXG4gICAgLy8gc3BlY2lhbCBhdHRyaWJ1dGU6IHRyYW5zaXRpb25cbiAgICBpZiAodHJhbnNpdGlvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgIG1vZGlmaWVycy5saXRlcmFsID0gIWJpbmRSRS50ZXN0KG5hbWUpXG4gICAgICBwdXNoRGlyKCd0cmFuc2l0aW9uJywgaW50ZXJuYWxEaXJlY3RpdmVzLnRyYW5zaXRpb24pXG4gICAgfSBlbHNlXG5cbiAgICAvLyBldmVudCBoYW5kbGVyc1xuICAgIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgIGFyZyA9IG5hbWUucmVwbGFjZShvblJFLCAnJylcbiAgICAgIHB1c2hEaXIoJ29uJywgcHVibGljRGlyZWN0aXZlcy5vbilcbiAgICB9IGVsc2VcblxuICAgIC8vIGF0dHJpYnV0ZSBiaW5kaW5nc1xuICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkge1xuICAgICAgZGlyTmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKVxuICAgICAgaWYgKGRpck5hbWUgPT09ICdzdHlsZScgfHwgZGlyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICBwdXNoRGlyKGRpck5hbWUsIGludGVybmFsRGlyZWN0aXZlc1tkaXJOYW1lXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZyA9IGRpck5hbWVcbiAgICAgICAgcHVzaERpcignYmluZCcsIHB1YmxpY0RpcmVjdGl2ZXMuYmluZClcbiAgICAgIH1cbiAgICB9IGVsc2VcblxuICAgIC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgaWYgKG5hbWUuaW5kZXhPZigndi0nKSA9PT0gMCkge1xuICAgICAgLy8gY2hlY2sgYXJnXG4gICAgICBhcmcgPSAoYXJnID0gbmFtZS5tYXRjaChhcmdSRSkpICYmIGFyZ1sxXVxuICAgICAgaWYgKGFyZykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGFyZ1JFLCAnJylcbiAgICAgIH1cbiAgICAgIC8vIGV4dHJhY3QgZGlyZWN0aXZlIG5hbWVcbiAgICAgIGRpck5hbWUgPSBuYW1lLnNsaWNlKDIpXG5cbiAgICAgIC8vIHNraXAgdi1lbHNlICh3aGVuIHVzZWQgd2l0aCB2LXNob3cpXG4gICAgICBpZiAoZGlyTmFtZSA9PT0gJ2Vsc2UnKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGRpckRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpck5hbWUpXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIF8uYXNzZXJ0QXNzZXQoZGlyRGVmLCAnZGlyZWN0aXZlJywgZGlyTmFtZSlcbiAgICAgIH1cblxuICAgICAgaWYgKGRpckRlZikge1xuICAgICAgICBpZiAoXy5pc0xpdGVyYWwodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSBfLnN0cmlwUXVvdGVzKHZhbHVlKVxuICAgICAgICAgIG1vZGlmaWVycy5saXRlcmFsID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHB1c2hEaXIoZGlyTmFtZSwgZGlyRGVmKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIGEgZGlyZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyTmFtZVxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gZGVmXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVycF1cbiAgICovXG5cbiAgZnVuY3Rpb24gcHVzaERpciAoZGlyTmFtZSwgZGVmLCBpbnRlcnApIHtcbiAgICB2YXIgcGFyc2VkID0gZGlyUGFyc2VyLnBhcnNlKHZhbHVlKVxuICAgIGRpcnMucHVzaCh7XG4gICAgICBuYW1lOiBkaXJOYW1lLFxuICAgICAgYXR0cjogcmF3TmFtZSxcbiAgICAgIHJhdzogcmF3VmFsdWUsXG4gICAgICBkZWY6IGRlZixcbiAgICAgIGFyZzogYXJnLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICBleHByZXNzaW9uOiBwYXJzZWQuZXhwcmVzc2lvbixcbiAgICAgIGZpbHRlcnM6IHBhcnNlZC5maWx0ZXJzLFxuICAgICAgaW50ZXJwOiBpbnRlcnBcbiAgICB9KVxuICB9XG5cbiAgaWYgKGRpcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG1ha2VOb2RlTGlua0ZuKGRpcnMpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBtb2RpZmllcnMgZnJvbSBkaXJlY3RpdmUgYXR0cmlidXRlIG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpXG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBpID0gbWF0Y2gubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcmVzW21hdGNoW2ldLnNsaWNlKDEpXSA9IHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgbGluayBmdW5jdGlvbiBmb3IgYWxsIGRpcmVjdGl2ZXMgb24gYSBzaW5nbGUgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJlY3RpdmVzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gZGlyZWN0aXZlc0xpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VOb2RlTGlua0ZuIChkaXJlY3RpdmVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBub2RlTGlua0ZuICh2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgLy8gcmV2ZXJzZSBhcHBseSBiZWNhdXNlIGl0J3Mgc29ydGVkIGxvdyB0byBoaWdoXG4gICAgdmFyIGkgPSBkaXJlY3RpdmVzLmxlbmd0aFxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl9iaW5kRGlyKGRpcmVjdGl2ZXNbaV0sIGVsLCBob3N0LCBzY29wZSwgZnJhZylcbiAgICB9XG4gIH1cbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG5cbl8uZXh0ZW5kKGV4cG9ydHMsIHJlcXVpcmUoJy4vY29tcGlsZScpKVxuXy5leHRlbmQoZXhwb3J0cywgcmVxdWlyZSgnLi90cmFuc2NsdWRlJykpXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHRlbXBsYXRlUGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2Vycy90ZW1wbGF0ZScpXG52YXIgc3BlY2lhbENoYXJSRSA9IC9bXlxcd1xcLTpcXC5dL1xuXG4vKipcbiAqIFByb2Nlc3MgYW4gZWxlbWVudCBvciBhIERvY3VtZW50RnJhZ21lbnQgYmFzZWQgb24gYVxuICogaW5zdGFuY2Ugb3B0aW9uIG9iamVjdC4gVGhpcyBhbGxvd3MgdXMgdG8gdHJhbnNjbHVkZVxuICogYSB0ZW1wbGF0ZSBub2RlL2ZyYWdtZW50IGJlZm9yZSB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCxcbiAqIHNvIHRoZSBwcm9jZXNzZWQgZnJhZ21lbnQgY2FuIHRoZW4gYmUgY2xvbmVkIGFuZCByZXVzZWRcbiAqIGluIHYtZm9yLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZXhwb3J0cy50cmFuc2NsdWRlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIC8vIGV4dHJhY3QgY29udGFpbmVyIGF0dHJpYnV0ZXMgdG8gcGFzcyB0aGVtIGRvd25cbiAgLy8gdG8gY29tcGlsZXIsIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIGNvbXBpbGVkIGluXG4gIC8vIHBhcmVudCBzY29wZS4gd2UgYXJlIG11dGF0aW5nIHRoZSBvcHRpb25zIG9iamVjdCBoZXJlXG4gIC8vIGFzc3VtaW5nIHRoZSBzYW1lIG9iamVjdCB3aWxsIGJlIHVzZWQgZm9yIGNvbXBpbGVcbiAgLy8gcmlnaHQgYWZ0ZXIgdGhpcy5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLl9jb250YWluZXJBdHRycyA9IGV4dHJhY3RBdHRycyhlbClcbiAgfVxuICAvLyBmb3IgdGVtcGxhdGUgdGFncywgd2hhdCB3ZSB3YW50IGlzIGl0cyBjb250ZW50IGFzXG4gIC8vIGEgZG9jdW1lbnRGcmFnbWVudCAoZm9yIGZyYWdtZW50IGluc3RhbmNlcylcbiAgaWYgKF8uaXNUZW1wbGF0ZShlbCkpIHtcbiAgICBlbCA9IHRlbXBsYXRlUGFyc2VyLnBhcnNlKGVsKVxuICB9XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50ICYmICFvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICBvcHRpb25zLnRlbXBsYXRlID0gJzxzbG90Pjwvc2xvdD4nXG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICBvcHRpb25zLl9jb250ZW50ID0gXy5leHRyYWN0Q29udGVudChlbClcbiAgICAgIGVsID0gdHJhbnNjbHVkZVRlbXBsYXRlKGVsLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuICBpZiAoZWwgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgLy8gYW5jaG9ycyBmb3IgZnJhZ21lbnQgaW5zdGFuY2VcbiAgICAvLyBwYXNzaW5nIGluIGBwZXJzaXN0OiB0cnVlYCB0byBhdm9pZCB0aGVtIGJlaW5nXG4gICAgLy8gZGlzY2FyZGVkIGJ5IElFIGR1cmluZyB0ZW1wbGF0ZSBjbG9uaW5nXG4gICAgXy5wcmVwZW5kKF8uY3JlYXRlQW5jaG9yKCd2LXN0YXJ0JywgdHJ1ZSksIGVsKVxuICAgIGVsLmFwcGVuZENoaWxkKF8uY3JlYXRlQW5jaG9yKCd2LWVuZCcsIHRydWUpKVxuICB9XG4gIHJldHVybiBlbFxufVxuXG4vKipcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlIG9wdGlvbi5cbiAqIElmIHRoZSByZXBsYWNlIG9wdGlvbiBpcyB0cnVlIHRoaXMgd2lsbCBzd2FwIHRoZSAkZWwuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2NsdWRlVGVtcGxhdGUgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGVcbiAgdmFyIGZyYWcgPSB0ZW1wbGF0ZVBhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgdHJ1ZSlcbiAgaWYgKGZyYWcpIHtcbiAgICB2YXIgcmVwbGFjZXIgPSBmcmFnLmZpcnN0Q2hpbGRcbiAgICB2YXIgdGFnID0gcmVwbGFjZXIudGFnTmFtZSAmJiByZXBsYWNlci50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICBpZiAob3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgICAnWW91IGFyZSBtb3VudGluZyBhbiBpbnN0YW5jZSB3aXRoIGEgdGVtcGxhdGUgdG8gJyArXG4gICAgICAgICAgJzxib2R5Pi4gVGhpcyB3aWxsIHJlcGxhY2UgPGJvZHk+IGVudGlyZWx5LiBZb3UgJyArXG4gICAgICAgICAgJ3Nob3VsZCBwcm9iYWJseSB1c2UgYHJlcGxhY2U6IGZhbHNlYCBoZXJlLidcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgLy8gdGhlcmUgYXJlIG1hbnkgY2FzZXMgd2hlcmUgdGhlIGluc3RhbmNlIG11c3RcbiAgICAgIC8vIGJlY29tZSBhIGZyYWdtZW50IGluc3RhbmNlOiBiYXNpY2FsbHkgYW55dGhpbmcgdGhhdFxuICAgICAgLy8gY2FuIGNyZWF0ZSBtb3JlIHRoYW4gMSByb290IG5vZGVzLlxuICAgICAgaWYgKFxuICAgICAgICAvLyBtdWx0aS1jaGlsZHJlbiB0ZW1wbGF0ZVxuICAgICAgICBmcmFnLmNoaWxkTm9kZXMubGVuZ3RoID4gMSB8fFxuICAgICAgICAvLyBub24tZWxlbWVudCB0ZW1wbGF0ZVxuICAgICAgICByZXBsYWNlci5ub2RlVHlwZSAhPT0gMSB8fFxuICAgICAgICAvLyBzaW5nbGUgbmVzdGVkIGNvbXBvbmVudFxuICAgICAgICB0YWcgPT09ICdjb21wb25lbnQnIHx8XG4gICAgICAgIF8ucmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSB8fFxuICAgICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ2lzJykgfHxcbiAgICAgICAgcmVwbGFjZXIuaGFzQXR0cmlidXRlKCc6aXMnKSB8fFxuICAgICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtYmluZDppcycpIHx8XG4gICAgICAgIC8vIGVsZW1lbnQgZGlyZWN0aXZlXG4gICAgICAgIF8ucmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdlbGVtZW50RGlyZWN0aXZlcycsIHRhZykgfHxcbiAgICAgICAgLy8gZm9yIGJsb2NrXG4gICAgICAgIHJlcGxhY2VyLmhhc0F0dHJpYnV0ZSgndi1mb3InKSB8fFxuICAgICAgICAvLyBpZiBibG9ja1xuICAgICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtaWYnKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmcmFnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLl9yZXBsYWNlckF0dHJzID0gZXh0cmFjdEF0dHJzKHJlcGxhY2VyKVxuICAgICAgICBtZXJnZUF0dHJzKGVsLCByZXBsYWNlcilcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWcpXG4gICAgICByZXR1cm4gZWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnSW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246ICcgKyB0ZW1wbGF0ZVxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB0byBleHRyYWN0IGEgY29tcG9uZW50IGNvbnRhaW5lcidzIGF0dHJpYnV0ZXNcbiAqIGludG8gYSBwbGFpbiBvYmplY3QgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdEF0dHJzIChlbCkge1xuICBpZiAoZWwubm9kZVR5cGUgPT09IDEgJiYgZWwuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgcmV0dXJuIF8udG9BcnJheShlbC5hdHRyaWJ1dGVzKVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdGhlIGF0dHJpYnV0ZXMgb2YgdHdvIGVsZW1lbnRzLCBhbmQgbWFrZSBzdXJlXG4gKiB0aGUgY2xhc3MgbmFtZXMgYXJlIG1lcmdlZCBwcm9wZXJseS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGZyb21cbiAqIEBwYXJhbSB7RWxlbWVudH0gdG9cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZUF0dHJzIChmcm9tLCB0bykge1xuICB2YXIgYXR0cnMgPSBmcm9tLmF0dHJpYnV0ZXNcbiAgdmFyIGkgPSBhdHRycy5sZW5ndGhcbiAgdmFyIG5hbWUsIHZhbHVlXG4gIHdoaWxlIChpLS0pIHtcbiAgICBuYW1lID0gYXR0cnNbaV0ubmFtZVxuICAgIHZhbHVlID0gYXR0cnNbaV0udmFsdWVcbiAgICBpZiAoIXRvLmhhc0F0dHJpYnV0ZShuYW1lKSAmJiAhc3BlY2lhbENoYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICB0by5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICB2YWx1ZSA9IHRvLmdldEF0dHJpYnV0ZShuYW1lKSArICcgJyArIHZhbHVlXG4gICAgICB0by5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKipcbiAgICogV2hldGhlciB0byBwcmludCBkZWJ1ZyBtZXNzYWdlcy5cbiAgICogQWxzbyBlbmFibGVzIHN0YWNrIHRyYWNlIGZvciB3YXJuaW5ncy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIGRlYnVnOiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gdXNlIGFzeW5jIHJlbmRlcmluZy5cbiAgICovXG5cbiAgYXN5bmM6IHRydWUsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gd2FybiBhZ2FpbnN0IGVycm9ycyBjYXVnaHQgd2hlbiBldmFsdWF0aW5nXG4gICAqIGV4cHJlc3Npb25zLlxuICAgKi9cblxuICB3YXJuRXhwcmVzc2lvbkVycm9yczogdHJ1ZSxcblxuICAvKipcbiAgICogSW50ZXJuYWwgZmxhZyB0byBpbmRpY2F0ZSB0aGUgZGVsaW1pdGVycyBoYXZlIGJlZW5cbiAgICogY2hhbmdlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIF9kZWxpbWl0ZXJzQ2hhbmdlZDogdHJ1ZSxcblxuICAvKipcbiAgICogTGlzdCBvZiBhc3NldCB0eXBlcyB0aGF0IGEgY29tcG9uZW50IGNhbiBvd24uXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG5cbiAgX2Fzc2V0VHlwZXM6IFtcbiAgICAnY29tcG9uZW50JyxcbiAgICAnZGlyZWN0aXZlJyxcbiAgICAnZWxlbWVudERpcmVjdGl2ZScsXG4gICAgJ2ZpbHRlcicsXG4gICAgJ3RyYW5zaXRpb24nLFxuICAgICdwYXJ0aWFsJ1xuICBdLFxuXG4gIC8qKlxuICAgKiBwcm9wIGJpbmRpbmcgbW9kZXNcbiAgICovXG5cbiAgX3Byb3BCaW5kaW5nTW9kZXM6IHtcbiAgICBPTkVfV0FZOiAwLFxuICAgIFRXT19XQVk6IDEsXG4gICAgT05FX1RJTUU6IDJcbiAgfSxcblxuICAvKipcbiAgICogTWF4IGNpcmN1bGFyIHVwZGF0ZXMgYWxsb3dlZCBpbiBhIGJhdGNoZXIgZmx1c2ggY3ljbGUuXG4gICAqL1xuXG4gIF9tYXhVcGRhdGVDb3VudDogMTAwXG5cbn1cblxuLyoqXG4gKiBJbnRlcnBvbGF0aW9uIGRlbGltaXRlcnMuIENoYW5naW5nIHRoZXNlIHdvdWxkIHRyaWdnZXJcbiAqIHRoZSB0ZXh0IHBhcnNlciB0byByZS1jb21waWxlIHRoZSByZWd1bGFyIGV4cHJlc3Npb25zLlxuICpcbiAqIEB0eXBlIHtBcnJheTxTdHJpbmc+fVxuICovXG5cbnZhciBkZWxpbWl0ZXJzID0gWyd7eycsICd9fSddXG52YXIgdW5zYWZlRGVsaW1pdGVycyA9IFsne3t7JywgJ319fSddXG52YXIgdGV4dFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2Vycy90ZXh0JylcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnZGVsaW1pdGVycycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRlbGltaXRlcnNcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgZGVsaW1pdGVycyA9IHZhbFxuICAgIHRleHRQYXJzZXIuY29tcGlsZVJlZ2V4KClcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAndW5zYWZlRGVsaW1pdGVycycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVuc2FmZURlbGltaXRlcnNcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdW5zYWZlRGVsaW1pdGVycyA9IHZhbFxuICAgIHRleHRQYXJzZXIuY29tcGlsZVJlZ2V4KClcbiAgfVxufSlcbiIsInZhciBfID0gcmVxdWlyZSgnLi91dGlsJylcbnZhciBXYXRjaGVyID0gcmVxdWlyZSgnLi93YXRjaGVyJylcbnZhciBleHBQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcnMvZXhwcmVzc2lvbicpXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgbGlua3MgYSBET00gZWxlbWVudCB3aXRoIGEgcGllY2Ugb2YgZGF0YSxcbiAqIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyBhbiBleHByZXNzaW9uLlxuICogSXQgcmVnaXN0ZXJzIGEgd2F0Y2hlciB3aXRoIHRoZSBleHByZXNzaW9uIGFuZCBjYWxsc1xuICogdGhlIERPTSB1cGRhdGUgZnVuY3Rpb24gd2hlbiBhIGNoYW5nZSBpcyB0cmlnZ2VyZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3JcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICAgICAgICAtIHtPYmplY3R9IGRlZlxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gZXhwcmVzc2lvblxuICogICAgICAgICAgICAgICAgIC0ge0FycmF5PE9iamVjdD59IFtmaWx0ZXJzXVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGxpdGVyYWxcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGF0dHJcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IHJhd1xuICogQHBhcmFtIHtPYmplY3R9IGRlZiAtIGRpcmVjdGl2ZSBkZWZpbml0aW9uIG9iamVjdFxuICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIHRyYW5zY2x1c2lvbiBob3N0IGNvbXBvbmVudFxuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSB2LWZvciBzY29wZVxuICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddIC0gb3duZXIgZnJhZ21lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIERpcmVjdGl2ZSAoZGVzY3JpcHRvciwgdm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICB0aGlzLnZtID0gdm1cbiAgdGhpcy5lbCA9IGVsXG4gIC8vIGNvcHkgZGVzY3JpcHRvciBwcm9wZXJ0aWVzXG4gIHRoaXMuZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JcbiAgdGhpcy5uYW1lID0gZGVzY3JpcHRvci5uYW1lXG4gIHRoaXMuZXhwcmVzc2lvbiA9IGRlc2NyaXB0b3IuZXhwcmVzc2lvblxuICB0aGlzLmFyZyA9IGRlc2NyaXB0b3IuYXJnXG4gIHRoaXMubW9kaWZpZXJzID0gZGVzY3JpcHRvci5tb2RpZmllcnNcbiAgdGhpcy5maWx0ZXJzID0gZGVzY3JpcHRvci5maWx0ZXJzXG4gIHRoaXMubGl0ZXJhbCA9IHRoaXMubW9kaWZpZXJzICYmIHRoaXMubW9kaWZpZXJzLmxpdGVyYWxcbiAgLy8gcHJpdmF0ZVxuICB0aGlzLl9sb2NrZWQgPSBmYWxzZVxuICB0aGlzLl9ib3VuZCA9IGZhbHNlXG4gIHRoaXMuX2xpc3RlbmVycyA9IG51bGxcbiAgLy8gbGluayBjb250ZXh0XG4gIHRoaXMuX2hvc3QgPSBob3N0XG4gIHRoaXMuX3Njb3BlID0gc2NvcGVcbiAgdGhpcy5fZnJhZyA9IGZyYWdcbiAgLy8gc3RvcmUgZGlyZWN0aXZlcyBvbiBub2RlIGluIGRldiBtb2RlXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuZWwpIHtcbiAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcyA9IHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzIHx8IFtdXG4gICAgdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMucHVzaCh0aGlzKVxuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZGlyZWN0aXZlLCBtaXhpbiBkZWZpbml0aW9uIHByb3BlcnRpZXMsXG4gKiBzZXR1cCB0aGUgd2F0Y2hlciwgY2FsbCBkZWZpbml0aW9uIGJpbmQoKSBhbmQgdXBkYXRlKClcbiAqIGlmIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZlxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX2JpbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lXG4gIHZhciBkZXNjcmlwdG9yID0gdGhpcy5kZXNjcmlwdG9yXG5cbiAgLy8gcmVtb3ZlIGF0dHJpYnV0ZVxuICBpZiAoXG4gICAgKG5hbWUgIT09ICdjbG9haycgfHwgdGhpcy52bS5faXNDb21waWxlZCkgJiZcbiAgICB0aGlzLmVsICYmIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlXG4gICkge1xuICAgIHZhciBhdHRyID0gZGVzY3JpcHRvci5hdHRyIHx8ICgndi0nICsgbmFtZSlcbiAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKVxuICB9XG5cbiAgLy8gY29weSBkZWYgcHJvcGVydGllc1xuICB2YXIgZGVmID0gZGVzY3JpcHRvci5kZWZcbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLnVwZGF0ZSA9IGRlZlxuICB9IGVsc2Uge1xuICAgIF8uZXh0ZW5kKHRoaXMsIGRlZilcbiAgfVxuXG4gIC8vIHNldHVwIGRpcmVjdGl2ZSBwYXJhbXNcbiAgdGhpcy5fc2V0dXBQYXJhbXMoKVxuXG4gIC8vIGluaXRpYWwgYmluZFxuICBpZiAodGhpcy5iaW5kKSB7XG4gICAgdGhpcy5iaW5kKClcbiAgfVxuXG4gIGlmICh0aGlzLmxpdGVyYWwpIHtcbiAgICB0aGlzLnVwZGF0ZSAmJiB0aGlzLnVwZGF0ZShkZXNjcmlwdG9yLnJhdylcbiAgfSBlbHNlIGlmIChcbiAgICAodGhpcy5leHByZXNzaW9uIHx8IHRoaXMubW9kaWZpZXJzKSAmJlxuICAgICh0aGlzLnVwZGF0ZSB8fCB0aGlzLnR3b1dheSkgJiZcbiAgICAhdGhpcy5fY2hlY2tTdGF0ZW1lbnQoKVxuICApIHtcbiAgICAvLyB3cmFwcGVkIHVwZGF0ZXIgZm9yIGNvbnRleHRcbiAgICB2YXIgZGlyID0gdGhpc1xuICAgIGlmICh0aGlzLnVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZhbCwgb2xkVmFsKSB7XG4gICAgICAgIGlmICghZGlyLl9sb2NrZWQpIHtcbiAgICAgICAgICBkaXIudXBkYXRlKHZhbCwgb2xkVmFsKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSA9IG5vb3BcbiAgICB9XG4gICAgdmFyIHByZVByb2Nlc3MgPSB0aGlzLl9wcmVQcm9jZXNzXG4gICAgICA/IF8uYmluZCh0aGlzLl9wcmVQcm9jZXNzLCB0aGlzKVxuICAgICAgOiBudWxsXG4gICAgdmFyIHBvc3RQcm9jZXNzID0gdGhpcy5fcG9zdFByb2Nlc3NcbiAgICAgID8gXy5iaW5kKHRoaXMuX3Bvc3RQcm9jZXNzLCB0aGlzKVxuICAgICAgOiBudWxsXG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyID0gbmV3IFdhdGNoZXIoXG4gICAgICB0aGlzLnZtLFxuICAgICAgdGhpcy5leHByZXNzaW9uLFxuICAgICAgdGhpcy5fdXBkYXRlLCAvLyBjYWxsYmFja1xuICAgICAge1xuICAgICAgICBmaWx0ZXJzOiB0aGlzLmZpbHRlcnMsXG4gICAgICAgIHR3b1dheTogdGhpcy50d29XYXksXG4gICAgICAgIGRlZXA6IHRoaXMuZGVlcCxcbiAgICAgICAgcHJlUHJvY2VzczogcHJlUHJvY2VzcyxcbiAgICAgICAgcG9zdFByb2Nlc3M6IHBvc3RQcm9jZXNzLFxuICAgICAgICBzY29wZTogdGhpcy5fc2NvcGVcbiAgICAgIH1cbiAgICApXG4gICAgLy8gdi1tb2RlbCB3aXRoIGluaXRhbCBpbmxpbmUgdmFsdWUgbmVlZCB0byBzeW5jIGJhY2sgdG9cbiAgICAvLyBtb2RlbCBpbnN0ZWFkIG9mIHVwZGF0ZSB0byBET00gb24gaW5pdC4gVGhleSB3b3VsZFxuICAgIC8vIHNldCB0aGUgYWZ0ZXJCaW5kIGhvb2sgdG8gaW5kaWNhdGUgdGhhdC5cbiAgICBpZiAodGhpcy5hZnRlckJpbmQpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kKClcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZSh3YXRjaGVyLnZhbHVlKVxuICAgIH1cbiAgfVxuICB0aGlzLl9ib3VuZCA9IHRydWVcbn1cblxuLyoqXG4gKiBTZXR1cCBhbGwgcGFyYW0gYXR0cmlidXRlcywgZS5nLiB0cmFjay1ieSxcbiAqIHRyYW5zaXRpb24tbW9kZSwgZXRjLi4uXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fc2V0dXBQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5wYXJhbXMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXNcbiAgLy8gc3dhcCB0aGUgcGFyYW1zIGFycmF5IHdpdGggYSBmcmVzaCBvYmplY3QuXG4gIHRoaXMucGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB2YXIgaSA9IHBhcmFtcy5sZW5ndGhcbiAgdmFyIGtleSwgdmFsLCBtYXBwZWRLZXlcbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IHBhcmFtc1tpXVxuICAgIG1hcHBlZEtleSA9IF8uY2FtZWxpemUoa2V5KVxuICAgIHZhbCA9IF8uZ2V0QmluZEF0dHIodGhpcy5lbCwga2V5KVxuICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgLy8gZHluYW1pY1xuICAgICAgdGhpcy5fc2V0dXBQYXJhbVdhdGNoZXIobWFwcGVkS2V5LCB2YWwpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN0YXRpY1xuICAgICAgdmFsID0gXy5hdHRyKHRoaXMuZWwsIGtleSlcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBhcmFtc1ttYXBwZWRLZXldID0gdmFsID09PSAnJyA/IHRydWUgOiB2YWxcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZXR1cCBhIHdhdGNoZXIgZm9yIGEgZHluYW1pYyBwYXJhbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvblxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3NldHVwUGFyYW1XYXRjaGVyID0gZnVuY3Rpb24gKGtleSwgZXhwcmVzc2lvbikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gIHZhciB1bndhdGNoID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiR3YXRjaChleHByZXNzaW9uLCBmdW5jdGlvbiAodmFsLCBvbGRWYWwpIHtcbiAgICBzZWxmLnBhcmFtc1trZXldID0gdmFsXG4gICAgLy8gc2luY2Ugd2UgYXJlIGluIGltbWVkaWF0ZSBtb2RlLFxuICAgIC8vIG9ubHkgY2FsbCB0aGUgcGFyYW0gY2hhbmdlIGNhbGxiYWNrcyBpZiB0aGlzIGlzIG5vdCB0aGUgZmlyc3QgdXBkYXRlLlxuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHZhciBjYiA9IHNlbGYucGFyYW1XYXRjaGVycyAmJiBzZWxmLnBhcmFtV2F0Y2hlcnNba2V5XVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiLmNhbGwoc2VsZiwgdmFsLCBvbGRWYWwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxlZCA9IHRydWVcbiAgICB9XG4gIH0sIHtcbiAgICBpbW1lZGlhdGU6IHRydWVcbiAgfSlcbiAgOyh0aGlzLl9wYXJhbVVud2F0Y2hGbnMgfHwgKHRoaXMuX3BhcmFtVW53YXRjaEZucyA9IFtdKSkucHVzaCh1bndhdGNoKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBkaXJlY3RpdmUgaXMgYSBmdW5jdGlvbiBjYWxsZXJcbiAqIGFuZCBpZiB0aGUgZXhwcmVzc2lvbiBpcyBhIGNhbGxhYmxlIG9uZS4gSWYgYm90aCB0cnVlLFxuICogd2Ugd3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBhbmQgdXNlIGl0IGFzIHRoZSBldmVudFxuICogaGFuZGxlci5cbiAqXG4gKiBlLmcuIG9uLWNsaWNrPVwiYSsrXCJcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX2NoZWNrU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvblxuICBpZiAoXG4gICAgZXhwcmVzc2lvbiAmJiB0aGlzLmFjY2VwdFN0YXRlbWVudCAmJlxuICAgICFleHBQYXJzZXIuaXNTaW1wbGVQYXRoKGV4cHJlc3Npb24pXG4gICkge1xuICAgIHZhciBmbiA9IGV4cFBhcnNlci5wYXJzZShleHByZXNzaW9uKS5nZXRcbiAgICB2YXIgc2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmbi5jYWxsKHNjb3BlLCBzY29wZSlcbiAgICB9XG4gICAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgICAgaGFuZGxlciA9IHNjb3BlLl9hcHBseUZpbHRlcnMoaGFuZGxlciwgbnVsbCwgdGhpcy5maWx0ZXJzKVxuICAgIH1cbiAgICB0aGlzLnVwZGF0ZShoYW5kbGVyKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgd2l0aCB0aGUgc2V0dGVyLlxuICogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGluIHR3by13YXkgZGlyZWN0aXZlc1xuICogZS5nLiB2LW1vZGVsLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwdWJsaWNcbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy50d29XYXkpIHtcbiAgICB0aGlzLl93aXRoTG9jayhmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl93YXRjaGVyLnNldCh2YWx1ZSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBfLndhcm4oXG4gICAgICAnRGlyZWN0aXZlLnNldCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHR3b1dheScgK1xuICAgICAgJ2RpcmVjdGl2ZXMuJ1xuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIEV4ZWN1dGUgYSBmdW5jdGlvbiB3aGlsZSBwcmV2ZW50aW5nIHRoYXQgZnVuY3Rpb24gZnJvbVxuICogdHJpZ2dlcmluZyB1cGRhdGVzIG9uIHRoaXMgZGlyZWN0aXZlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fd2l0aExvY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2xvY2tlZCA9IHRydWVcbiAgZm4uY2FsbChzZWxmKVxuICBfLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9sb2NrZWQgPSBmYWxzZVxuICB9KVxufVxuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF0dGFjaGVzIGEgRE9NIGV2ZW50IGxpc3RlbmVyXG4gKiB0byB0aGUgZGlyZWN0aXZlIGVsZW1lbnQgYW5kIGF1dG9tZXRpY2FsbHkgdGVhcnMgaXQgZG93blxuICogZHVyaW5nIHVuYmluZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyKSB7XG4gIF8ub24odGhpcy5lbCwgZXZlbnQsIGhhbmRsZXIpXG4gIDsodGhpcy5fbGlzdGVuZXJzIHx8ICh0aGlzLl9saXN0ZW5lcnMgPSBbXSkpXG4gICAgLnB1c2goW2V2ZW50LCBoYW5kbGVyXSlcbn1cblxuLyoqXG4gKiBUZWFyZG93biB0aGUgd2F0Y2hlciBhbmQgY2FsbCB1bmJpbmQuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fdGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9ib3VuZCkge1xuICAgIHRoaXMuX2JvdW5kID0gZmFsc2VcbiAgICBpZiAodGhpcy51bmJpbmQpIHtcbiAgICAgIHRoaXMudW5iaW5kKClcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dhdGNoZXIpIHtcbiAgICAgIHRoaXMuX3dhdGNoZXIudGVhcmRvd24oKVxuICAgIH1cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzXG4gICAgdmFyIGlcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICBpID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBfLm9mZih0aGlzLmVsLCBsaXN0ZW5lcnNbaV1bMF0sIGxpc3RlbmVyc1tpXVsxXSlcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVud2F0Y2hGbnMgPSB0aGlzLl9wYXJhbVVud2F0Y2hGbnNcbiAgICBpZiAodW53YXRjaEZucykge1xuICAgICAgaSA9IHVud2F0Y2hGbnMubGVuZ3RoXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHVud2F0Y2hGbnNbaV0oKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsKSB7XG4gICAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcy4kcmVtb3ZlKHRoaXMpXG4gICAgfVxuICAgIHRoaXMudm0gPSB0aGlzLmVsID0gdGhpcy5fd2F0Y2hlciA9IHRoaXMuX2xpc3RlbmVycyA9IG51bGxcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpcmVjdGl2ZVxuIiwiZXhwb3J0cy5zbG90ID0gcmVxdWlyZSgnLi9zbG90JylcbmV4cG9ydHMucGFydGlhbCA9IHJlcXVpcmUoJy4vcGFydGlhbCcpXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIHZJZiA9IHJlcXVpcmUoJy4uL3B1YmxpYy9pZicpXG52YXIgRnJhZ21lbnRGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vZnJhZ21lbnQvZmFjdG9yeScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIHByaW9yaXR5OiAxNzUwLFxuXG4gIHBhcmFtczogWyduYW1lJ10sXG5cbiAgLy8gd2F0Y2ggY2hhbmdlcyB0byBuYW1lIGZvciBkeW5hbWljIHBhcnRpYWxzXG4gIHBhcmFtV2F0Y2hlcnM6IHtcbiAgICBuYW1lOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZJZi5yZW1vdmUuY2FsbCh0aGlzKVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0KHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hbmNob3IgPSBfLmNyZWF0ZUFuY2hvcigndi1wYXJ0aWFsJylcbiAgICBfLnJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpXG4gICAgdGhpcy5pbnNlcnQodGhpcy5wYXJhbXMubmFtZSlcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBwYXJ0aWFsID0gXy5yZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ3BhcnRpYWxzJywgaWQpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIF8uYXNzZXJ0QXNzZXQocGFydGlhbCwgJ3BhcnRpYWwnLCBpZClcbiAgICB9XG4gICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy52bSwgcGFydGlhbClcbiAgICAgIHZJZi5pbnNlcnQuY2FsbCh0aGlzKVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5mcmFnKSB7XG4gICAgICB0aGlzLmZyYWcuZGVzdHJveSgpXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIHRlbXBsYXRlUGFyc2VyID0gcmVxdWlyZSgnLi4vLi4vcGFyc2Vycy90ZW1wbGF0ZScpXG5cbi8vIFRoaXMgaXMgdGhlIGVsZW1lbnREaXJlY3RpdmUgdGhhdCBoYW5kbGVzIDxjb250ZW50PlxuLy8gdHJhbnNjbHVzaW9ucy4gSXQgcmVsaWVzIG9uIHRoZSByYXcgY29udGVudCBvZiBhblxuLy8gaW5zdGFuY2UgYmVpbmcgc3RvcmVkIGFzIGAkb3B0aW9ucy5fY29udGVudGAgZHVyaW5nXG4vLyB0aGUgdHJhbnNjbHVkZSBwaGFzZS5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDE3NTAsXG5cbiAgcGFyYW1zOiBbJ25hbWUnXSxcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvc3QgPSB0aGlzLnZtXG4gICAgdmFyIHJhdyA9IGhvc3QuJG9wdGlvbnMuX2NvbnRlbnRcbiAgICB2YXIgY29udGVudFxuICAgIGlmICghcmF3KSB7XG4gICAgICB0aGlzLmZhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgY29udGV4dCA9IGhvc3QuX2NvbnRleHRcbiAgICB2YXIgc2xvdE5hbWUgPSB0aGlzLnBhcmFtcy5uYW1lXG4gICAgaWYgKCFzbG90TmFtZSkge1xuICAgICAgLy8gRGVmYXVsdCBjb250ZW50XG4gICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgIHZhciBjb21waWxlRGVmYXVsdENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY29tcGlsZShcbiAgICAgICAgICBleHRyYWN0RnJhZ21lbnQocmF3LmNoaWxkTm9kZXMsIHJhdywgdHJ1ZSksXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBob3N0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICghaG9zdC5faXNDb21waWxlZCkge1xuICAgICAgICAvLyBkZWZlciB1bnRpbCB0aGUgZW5kIG9mIGluc3RhbmNlIGNvbXBpbGF0aW9uLFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBkZWZhdWx0IG91dGxldCBtdXN0IHdhaXQgdW50aWwgYWxsXG4gICAgICAgIC8vIG90aGVyIHBvc3NpYmxlIG91dGxldHMgd2l0aCBzZWxlY3RvcnMgaGF2ZSBwaWNrZWRcbiAgICAgICAgLy8gb3V0IHRoZWlyIGNvbnRlbnRzLlxuICAgICAgICBob3N0LiRvbmNlKCdob29rOmNvbXBpbGVkJywgY29tcGlsZURlZmF1bHRDb250ZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGlsZURlZmF1bHRDb250ZW50KClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlbGVjdG9yID0gJ1tzbG90PVwiJyArIHNsb3ROYW1lICsgJ1wiXSdcbiAgICAgIHZhciBub2RlcyA9IHJhdy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKVxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICBjb250ZW50ID0gZXh0cmFjdEZyYWdtZW50KG5vZGVzLCByYXcpXG4gICAgICAgIGlmIChjb250ZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIHRoaXMuY29tcGlsZShjb250ZW50LCBjb250ZXh0LCBob3N0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZmFsbGJhY2soKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZhbGxiYWNrKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZmFsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbXBpbGUoXy5leHRyYWN0Q29udGVudCh0aGlzLmVsLCB0cnVlKSwgdGhpcy52bSlcbiAgfSxcblxuICBjb21waWxlOiBmdW5jdGlvbiAoY29udGVudCwgY29udGV4dCwgaG9zdCkge1xuICAgIGlmIChjb250ZW50ICYmIGNvbnRleHQpIHtcbiAgICAgIHZhciBzY29wZSA9IGhvc3RcbiAgICAgICAgPyBob3N0Ll9zY29wZVxuICAgICAgICA6IHRoaXMuX3Njb3BlXG4gICAgICB0aGlzLnVubGluayA9IGNvbnRleHQuJGNvbXBpbGUoXG4gICAgICAgIGNvbnRlbnQsIGhvc3QsIHNjb3BlLCB0aGlzLl9mcmFnXG4gICAgICApXG4gICAgfVxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBfLnJlcGxhY2UodGhpcy5lbCwgY29udGVudClcbiAgICB9IGVsc2Uge1xuICAgICAgXy5yZW1vdmUodGhpcy5lbClcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudW5saW5rKSB7XG4gICAgICB0aGlzLnVubGluaygpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBxdWFsaWZpZWQgY29udGVudCBub2RlcyBmcm9tIGEgbm9kZSBsaXN0LlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxuICogQHBhcmFtIHtCb29sZWFufSBtYWluXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RGcmFnbWVudCAobm9kZXMsIHBhcmVudCwgbWFpbikge1xuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV1cbiAgICAvLyBpZiB0aGlzIGlzIHRoZSBtYWluIG91dGxldCwgd2Ugd2FudCB0byBza2lwIGFsbFxuICAgIC8vIHByZXZpb3VzbHkgc2VsZWN0ZWQgbm9kZXM7XG4gICAgLy8gb3RoZXJ3aXNlLCB3ZSB3YW50IHRvIG1hcmsgdGhlIG5vZGUgYXMgc2VsZWN0ZWQuXG4gICAgLy8gY2xvbmUgdGhlIG5vZGUgc28gdGhlIG9yaWdpbmFsIHJhdyBjb250ZW50IHJlbWFpbnNcbiAgICAvLyBpbnRhY3QuIHRoaXMgZW5zdXJlcyBwcm9wZXIgcmUtY29tcGlsYXRpb24gaW4gY2FzZXNcbiAgICAvLyB3aGVyZSB0aGUgb3V0bGV0IGlzIGluc2lkZSBhIGNvbmRpdGlvbmFsIGJsb2NrXG4gICAgaWYgKG1haW4gJiYgIW5vZGUuX192X3NlbGVjdGVkKSB7XG4gICAgICBhcHBlbmQobm9kZSlcbiAgICB9IGVsc2UgaWYgKCFtYWluICYmIG5vZGUucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICBub2RlLl9fdl9zZWxlY3RlZCA9IHRydWVcbiAgICAgIGFwcGVuZChub2RlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZnJhZ1xuXG4gIGZ1bmN0aW9uIGFwcGVuZCAobm9kZSkge1xuICAgIGlmIChfLmlzVGVtcGxhdGUobm9kZSkgJiZcbiAgICAgICAgIW5vZGUuaGFzQXR0cmlidXRlKCd2LWlmJykgJiZcbiAgICAgICAgIW5vZGUuaGFzQXR0cmlidXRlKCd2LWZvcicpKSB7XG4gICAgICBub2RlID0gdGVtcGxhdGVQYXJzZXIucGFyc2Uobm9kZSlcbiAgICB9XG4gICAgbm9kZSA9IHRlbXBsYXRlUGFyc2VyLmNsb25lKG5vZGUpXG4gICAgZnJhZy5hcHBlbmRDaGlsZChub2RlKVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIGFkZENsYXNzID0gXy5hZGRDbGFzc1xudmFyIHJlbW92ZUNsYXNzID0gXy5yZW1vdmVDbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBkZWVwOiB0cnVlLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHN0cmluZ1RvT2JqZWN0KHZhbHVlKSlcbiAgICB9IGVsc2UgaWYgKF8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlKVxuICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhpcy5oYW5kbGVBcnJheSh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhbnVwKClcbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlT2JqZWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNsZWFudXAodmFsdWUpXG4gICAgdmFyIGtleXMgPSB0aGlzLnByZXZLZXlzID0gT2JqZWN0LmtleXModmFsdWUpXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuZWwsIGtleSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIGtleSlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlQXJyYXk6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuY2xlYW51cCh2YWx1ZSlcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHZhbHVlW2ldKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuZWwsIHZhbHVlW2ldKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByZXZLZXlzID0gdmFsdWUuc2xpY2UoKVxuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnByZXZLZXlzKSB7XG4gICAgICB2YXIgaSA9IHRoaXMucHJldktleXMubGVuZ3RoXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnByZXZLZXlzW2ldXG4gICAgICAgIGlmIChrZXkgJiYgKCF2YWx1ZSB8fCAhY29udGFpbnModmFsdWUsIGtleSkpKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwga2V5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvT2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0ge31cbiAgdmFyIGtleXMgPSB2YWx1ZS50cmltKCkuc3BsaXQoL1xccysvKVxuICB2YXIgaSA9IGtleXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXNba2V5c1tpXV0gPSB0cnVlXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjb250YWlucyAodmFsdWUsIGtleSkge1xuICByZXR1cm4gXy5pc0FycmF5KHZhbHVlKVxuICAgID8gdmFsdWUuaW5kZXhPZihrZXkpID4gLTFcbiAgICA6IHZhbHVlLmhhc093blByb3BlcnR5KGtleSlcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG52YXIgdGVtcGxhdGVQYXJzZXIgPSByZXF1aXJlKCcuLi8uLi9wYXJzZXJzL3RlbXBsYXRlJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDE1MDAsXG5cbiAgcGFyYW1zOiBbXG4gICAgJ2tlZXAtYWxpdmUnLFxuICAgICd0cmFuc2l0aW9uLW1vZGUnLFxuICAgICdpbmxpbmUtdGVtcGxhdGUnXG4gIF0sXG5cbiAgLyoqXG4gICAqIFNldHVwLiBUd28gcG9zc2libGUgdXNhZ2VzOlxuICAgKlxuICAgKiAtIHN0YXRpYzpcbiAgICogICA8Y29tcD4gb3IgPGRpdiB2LWNvbXBvbmVudD1cImNvbXBcIj5cbiAgICpcbiAgICogLSBkeW5hbWljOlxuICAgKiAgIDxjb21wb25lbnQgOmlzPVwidmlld1wiPlxuICAgKi9cblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmVsLl9fdnVlX18pIHtcbiAgICAgIC8vIGNoZWNrIHJlZlxuICAgICAgdGhpcy5yZWYgPSBfLmZpbmRSZWYodGhpcy5lbClcbiAgICAgIHZhciByZWZzID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRyZWZzXG4gICAgICBpZiAodGhpcy5yZWYgJiYgIXJlZnMuaGFzT3duUHJvcGVydHkodGhpcy5yZWYpKSB7XG4gICAgICAgIF8uZGVmaW5lUmVhY3RpdmUocmVmcywgdGhpcy5yZWYsIG51bGwpXG4gICAgICB9XG4gICAgICAvLyBrZWVwLWFsaXZlIGNhY2hlXG4gICAgICB0aGlzLmtlZXBBbGl2ZSA9IHRoaXMucGFyYW1zLmtlZXBBbGl2ZVxuICAgICAgaWYgKHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fVxuICAgICAgfVxuICAgICAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlXG4gICAgICBpZiAodGhpcy5wYXJhbXMuaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgICAgLy8gZXh0cmFjdCBpbmxpbmUgdGVtcGxhdGUgYXMgYSBEb2N1bWVudEZyYWdtZW50XG4gICAgICAgIHRoaXMuaW5saW5lVGVtcGxhdGUgPSBfLmV4dHJhY3RDb250ZW50KHRoaXMuZWwsIHRydWUpXG4gICAgICB9XG4gICAgICAvLyBjb21wb25lbnQgcmVzb2x1dGlvbiByZWxhdGVkIHN0YXRlXG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiA9XG4gICAgICB0aGlzLkNvbXBvbmVudCA9IG51bGxcbiAgICAgIC8vIHRyYW5zaXRpb24gcmVsYXRlZCBzdGF0ZVxuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHMgPSAwXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsQ2IgPSBudWxsXG4gICAgICAvLyBjaGVjayBkeW5hbWljIGNvbXBvbmVudCBwYXJhbXNcbiAgICAgICAgLy8gY3JlYXRlIGEgcmVmIGFuY2hvclxuICAgICAgdGhpcy5hbmNob3IgPSBfLmNyZWF0ZUFuY2hvcigndi1jb21wb25lbnQnKVxuICAgICAgXy5yZXBsYWNlKHRoaXMuZWwsIHRoaXMuYW5jaG9yKVxuICAgICAgLy8gaWYgc3RhdGljLCBidWlsZCByaWdodCBub3cuXG4gICAgICBpZiAodGhpcy5saXRlcmFsKSB7XG4gICAgICAgIHRoaXMuc2V0Q29tcG9uZW50KHRoaXMuZXhwcmVzc2lvbilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICdjYW5ub3QgbW91bnQgY29tcG9uZW50IFwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiAnICtcbiAgICAgICAgJ29uIGFscmVhZHkgbW91bnRlZCBlbGVtZW50OiAnICsgdGhpcy5lbFxuICAgICAgKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHVibGljIHVwZGF0ZSwgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyIGluIHRoZSBkeW5hbWljXG4gICAqIGxpdGVyYWwgc2NlbmFyaW8sIGUuZy4gPGNvbXBvbmVudCA6aXM9XCJ2aWV3XCI+XG4gICAqL1xuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmxpdGVyYWwpIHtcbiAgICAgIHRoaXMuc2V0Q29tcG9uZW50KHZhbHVlKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3dpdGNoIGR5bmFtaWMgY29tcG9uZW50cy4gTWF5IHJlc29sdmUgdGhlIGNvbXBvbmVudFxuICAgKiBhc3luY2hyb25vdXNseSwgYW5kIHBlcmZvcm0gdHJhbnNpdGlvbiBiYXNlZCBvblxuICAgKiBzcGVjaWZpZWQgdHJhbnNpdGlvbiBtb2RlLiBBY2NlcHRzIGEgZmV3IGFkZGl0aW9uYWxcbiAgICogYXJndW1lbnRzIHNwZWNpZmljYWxseSBmb3IgdnVlLXJvdXRlci5cbiAgICpcbiAgICogVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBmdWxsIHRyYW5zaXRpb24gaXNcbiAgICogZmluaXNoZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIHNldENvbXBvbmVudDogZnVuY3Rpb24gKHZhbHVlLCBjYikge1xuICAgIHRoaXMuaW52YWxpZGF0ZVBlbmRpbmcoKVxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIC8vIGp1c3QgcmVtb3ZlIGN1cnJlbnRcbiAgICAgIHRoaXMudW5idWlsZCh0cnVlKVxuICAgICAgdGhpcy5yZW1vdmUodGhpcy5jaGlsZFZNLCBjYilcbiAgICAgIHRoaXMuY2hpbGRWTSA9IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICB0aGlzLnJlc29sdmVDb21wb25lbnQodmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5tb3VudENvbXBvbmVudChjYilcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3IgdG8gdXNlIHdoZW4gY3JlYXRpbmdcbiAgICogdGhlIGNoaWxkIHZtLlxuICAgKi9cblxuICByZXNvbHZlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSBfLmNhbmNlbGxhYmxlKGZ1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgICAgIHNlbGYuQ29tcG9uZW50TmFtZSA9IENvbXBvbmVudC5vcHRpb25zLm5hbWUgfHwgaWRcbiAgICAgIHNlbGYuQ29tcG9uZW50ID0gQ29tcG9uZW50XG4gICAgICBjYigpXG4gICAgfSlcbiAgICB0aGlzLnZtLl9yZXNvbHZlQ29tcG9uZW50KGlkLCB0aGlzLnBlbmRpbmdDb21wb25lbnRDYilcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIHVzaW5nIHRoZSBjdXJyZW50IGNvbnN0cnVjdG9yIGFuZFxuICAgKiByZXBsYWNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS4gVGhpcyBtZXRob2QgZG9lc24ndCBjYXJlXG4gICAqIHdoZXRoZXIgdGhlIG5ldyBjb21wb25lbnQgYW5kIHRoZSBvbGQgb25lIGFyZSBhY3R1YWxseVxuICAgKiB0aGUgc2FtZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGNiKSB7XG4gICAgLy8gYWN0dWFsIG1vdW50XG4gICAgdGhpcy51bmJ1aWxkKHRydWUpXG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdmFyIGFjdGl2YXRlSG9vayA9IHRoaXMuQ29tcG9uZW50Lm9wdGlvbnMuYWN0aXZhdGVcbiAgICB2YXIgY2FjaGVkID0gdGhpcy5nZXRDYWNoZWQoKVxuICAgIHZhciBuZXdDb21wb25lbnQgPSB0aGlzLmJ1aWxkKClcbiAgICBpZiAoYWN0aXZhdGVIb29rICYmICFjYWNoZWQpIHtcbiAgICAgIHRoaXMud2FpdGluZ0ZvciA9IG5ld0NvbXBvbmVudFxuICAgICAgYWN0aXZhdGVIb29rLmNhbGwobmV3Q29tcG9uZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYud2FpdGluZ0ZvciA9IG51bGxcbiAgICAgICAgc2VsZi50cmFuc2l0aW9uKG5ld0NvbXBvbmVudCwgY2IpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24obmV3Q29tcG9uZW50LCBjYilcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbXBvbmVudCBjaGFuZ2VzIG9yIHVuYmluZHMgYmVmb3JlIGFuIGFzeW5jXG4gICAqIGNvbnN0cnVjdG9yIGlzIHJlc29sdmVkLCB3ZSBuZWVkIHRvIGludmFsaWRhdGUgaXRzXG4gICAqIHBlbmRpbmcgY2FsbGJhY2suXG4gICAqL1xuXG4gIGludmFsaWRhdGVQZW5kaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NvbXBvbmVudENiKSB7XG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYi5jYW5jZWwoKVxuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSBudWxsXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZS9pbnNlcnQgYSBuZXcgY2hpbGQgdm0uXG4gICAqIElmIGtlZXAgYWxpdmUgYW5kIGhhcyBjYWNoZWQgaW5zdGFuY2UsIGluc2VydCB0aGF0XG4gICAqIGluc3RhbmNlOyBvdGhlcndpc2UgYnVpbGQgYSBuZXcgb25lIGFuZCBjYWNoZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRyYU9wdGlvbnNdXG4gICAqIEByZXR1cm4ge1Z1ZX0gLSB0aGUgY3JlYXRlZCBpbnN0YW5jZVxuICAgKi9cblxuICBidWlsZDogZnVuY3Rpb24gKGV4dHJhT3B0aW9ucykge1xuICAgIHZhciBjYWNoZWQgPSB0aGlzLmdldENhY2hlZCgpXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFxuICAgIH1cbiAgICBpZiAodGhpcy5Db21wb25lbnQpIHtcbiAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIG5hbWU6IHRoaXMuQ29tcG9uZW50TmFtZSxcbiAgICAgICAgZWw6IHRlbXBsYXRlUGFyc2VyLmNsb25lKHRoaXMuZWwpLFxuICAgICAgICB0ZW1wbGF0ZTogdGhpcy5pbmxpbmVUZW1wbGF0ZSxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGFkZCB0aGUgY2hpbGQgd2l0aCBjb3JyZWN0IHBhcmVudFxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBpdHMgcGFyZW50XG4gICAgICAgIC8vIHNob3VsZCBiZSB0aGUgdHJhbnNjbHVzaW9uIGhvc3QuXG4gICAgICAgIHBhcmVudDogdGhpcy5faG9zdCB8fCB0aGlzLnZtLFxuICAgICAgICAvLyBpZiBubyBpbmxpbmUtdGVtcGxhdGUsIHRoZW4gdGhlIGNvbXBpbGVkXG4gICAgICAgIC8vIGxpbmtlciBjYW4gYmUgY2FjaGVkIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgICAgIF9saW5rZXJDYWNoYWJsZTogIXRoaXMuaW5saW5lVGVtcGxhdGUsXG4gICAgICAgIF9yZWY6IHRoaXMucmVmLFxuICAgICAgICBfYXNDb21wb25lbnQ6IHRydWUsXG4gICAgICAgIF9pc1JvdXRlclZpZXc6IHRoaXMuX2lzUm91dGVyVmlldyxcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHRyYW5zY2x1ZGVkIGNvbXBvbmVudCwgY29udGV4dFxuICAgICAgICAvLyB3aWxsIGJlIHRoZSBjb21tb24gcGFyZW50IHZtIG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgLy8gYW5kIGl0cyBob3N0LlxuICAgICAgICBfY29udGV4dDogdGhpcy52bSxcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBpbnNpZGUgYW4gaW5saW5lIHYtZm9yLCB0aGUgc2NvcGVcbiAgICAgICAgLy8gd2lsbCBiZSB0aGUgaW50ZXJtZWRpYXRlIHNjb3BlIGNyZWF0ZWQgZm9yIHRoaXNcbiAgICAgICAgLy8gcmVwZWF0IGZyYWdtZW50LiB0aGlzIGlzIHVzZWQgZm9yIGxpbmtpbmcgcHJvcHNcbiAgICAgICAgLy8gYW5kIGNvbnRhaW5lciBkaXJlY3RpdmVzLlxuICAgICAgICBfc2NvcGU6IHRoaXMuX3Njb3BlLFxuICAgICAgICAvLyBwYXNzIGluIHRoZSBvd25lciBmcmFnbWVudCBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3Nhcnkgc28gdGhhdCB0aGUgZnJhZ21lbnQgY2FuIGtlZXBcbiAgICAgICAgLy8gdHJhY2sgb2YgaXRzIGNvbnRhaW5lZCBjb21wb25lbnRzIGluIG9yZGVyIHRvXG4gICAgICAgIC8vIGNhbGwgYXR0YWNoL2RldGFjaCBob29rcyBmb3IgdGhlbS5cbiAgICAgICAgX2ZyYWc6IHRoaXMuX2ZyYWdcbiAgICAgIH1cbiAgICAgIC8vIGV4dHJhIG9wdGlvbnNcbiAgICAgIC8vIGluIDEuMC4wIHRoaXMgaXMgdXNlZCBieSB2dWUtcm91dGVyIG9ubHlcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGV4dHJhT3B0aW9ucykge1xuICAgICAgICBfLmV4dGVuZChvcHRpb25zLCBleHRyYU9wdGlvbnMpXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5Db21wb25lbnQob3B0aW9ucylcbiAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgICB0aGlzLmNhY2hlW3RoaXMuQ29tcG9uZW50LmNpZF0gPSBjaGlsZFxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIHRoaXMuZWwuaGFzQXR0cmlidXRlKCd0cmFuc2l0aW9uJykgJiZcbiAgICAgICAgICBjaGlsZC5faXNGcmFnbWVudCkge1xuICAgICAgICBfLndhcm4oXG4gICAgICAgICAgJ1RyYW5zaXRpb25zIHdpbGwgbm90IHdvcmsgb24gYSBmcmFnbWVudCBpbnN0YW5jZS4gJyArXG4gICAgICAgICAgJ1RlbXBsYXRlOiAnICsgY2hpbGQuJG9wdGlvbnMudGVtcGxhdGVcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUcnkgdG8gZ2V0IGEgY2FjaGVkIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHJldHVybiB7VnVlfHVuZGVmaW5lZH1cbiAgICovXG5cbiAgZ2V0Q2FjaGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMua2VlcEFsaXZlICYmIHRoaXMuY2FjaGVbdGhpcy5Db21wb25lbnQuY2lkXVxuICB9LFxuXG4gIC8qKlxuICAgKiBUZWFyZG93biB0aGUgY3VycmVudCBjaGlsZCwgYnV0IGRlZmVycyBjbGVhbnVwIHNvXG4gICAqIHRoYXQgd2UgY2FuIHNlcGFyYXRlIHRoZSBkZXN0cm95IGFuZCByZW1vdmFsIHN0ZXBzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZmVyXG4gICAqL1xuXG4gIHVuYnVpbGQ6IGZ1bmN0aW9uIChkZWZlcikge1xuICAgIGlmICh0aGlzLndhaXRpbmdGb3IpIHtcbiAgICAgIHRoaXMud2FpdGluZ0Zvci4kZGVzdHJveSgpXG4gICAgICB0aGlzLndhaXRpbmdGb3IgPSBudWxsXG4gICAgfVxuICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRWTVxuICAgIGlmICghY2hpbGQgfHwgdGhpcy5rZWVwQWxpdmUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyB0aGUgc29sZSBwdXJwb3NlIG9mIGBkZWZlckNsZWFudXBgIGlzIHNvIHRoYXQgd2UgY2FuXG4gICAgLy8gXCJkZWFjdGl2YXRlXCIgdGhlIHZtIHJpZ2h0IG5vdyBhbmQgcGVyZm9ybSBET00gcmVtb3ZhbFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLiRkZXN0cm95KGZhbHNlLCBkZWZlcilcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGN1cnJlbnQgZGVzdHJveWVkIGNoaWxkIGFuZCBtYW51YWxseSBkb1xuICAgKiB0aGUgY2xlYW51cCBhZnRlciByZW1vdmFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZCwgY2IpIHtcbiAgICB2YXIga2VlcEFsaXZlID0gdGhpcy5rZWVwQWxpdmVcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIC8vIHdlIG1heSBoYXZlIGEgY29tcG9uZW50IHN3aXRjaCB3aGVuIGEgcHJldmlvdXNcbiAgICAgIC8vIGNvbXBvbmVudCBpcyBzdGlsbCBiZWluZyB0cmFuc2l0aW9uZWQgb3V0LlxuICAgICAgLy8gd2Ugd2FudCB0byB0cmlnZ2VyIG9ubHkgb25lIGxhc3Rlc3QgaW5zZXJ0aW9uIGNiXG4gICAgICAvLyB3aGVuIHRoZSBleGlzdGluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLiAoIzExMTkpXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFscysrXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsQ2IgPSBjYlxuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICBjaGlsZC4kcmVtb3ZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbHMtLVxuICAgICAgICBpZiAoIWtlZXBBbGl2ZSkgY2hpbGQuX2NsZWFudXAoKVxuICAgICAgICBpZiAoIXNlbGYucGVuZGluZ1JlbW92YWxzICYmIHNlbGYucGVuZGluZ1JlbW92YWxDYikge1xuICAgICAgICAgIHNlbGYucGVuZGluZ1JlbW92YWxDYigpXG4gICAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbENiID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKClcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFjdHVhbGx5IHN3YXAgdGhlIGNvbXBvbmVudHMsIGRlcGVuZGluZyBvbiB0aGVcbiAgICogdHJhbnNpdGlvbiBtb2RlLiBEZWZhdWx0cyB0byBzaW11bHRhbmVvdXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICB0cmFuc2l0aW9uOiBmdW5jdGlvbiAodGFyZ2V0LCBjYikge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jaGlsZFZNXG4gICAgLy8gZm9yIGRldnRvb2wgaW5zcGVjdGlvblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY3VycmVudCkgY3VycmVudC5faW5hY3RpdmUgPSB0cnVlXG4gICAgICB0YXJnZXQuX2luYWN0aXZlID0gZmFsc2VcbiAgICB9XG4gICAgdGhpcy5jaGlsZFZNID0gdGFyZ2V0XG4gICAgc3dpdGNoIChzZWxmLnBhcmFtcy50cmFuc2l0aW9uTW9kZSkge1xuICAgICAgY2FzZSAnaW4tb3V0JzpcbiAgICAgICAgdGFyZ2V0LiRiZWZvcmUoc2VsZi5hbmNob3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50LCBjYilcbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ291dC1pbic6XG4gICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgY2IpXG4gICAgICAgIH0pXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50KVxuICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgY2IpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbmJpbmQuXG4gICAqL1xuXG4gIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaW52YWxpZGF0ZVBlbmRpbmcoKVxuICAgIC8vIERvIG5vdCBkZWZlciBjbGVhbnVwIHdoZW4gdW5iaW5kaW5nXG4gICAgdGhpcy51bmJ1aWxkKClcbiAgICAvLyBkZXN0cm95IGFsbCBrZWVwLWFsaXZlIGNhY2hlZCBpbnN0YW5jZXNcbiAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldLiRkZXN0cm95KClcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUgPSBudWxsXG4gICAgfVxuICB9XG59XG4iLCJleHBvcnRzLnN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpXG5leHBvcnRzWydjbGFzcyddID0gcmVxdWlyZSgnLi9jbGFzcycpXG5leHBvcnRzLmNvbXBvbmVudCA9IHJlcXVpcmUoJy4vY29tcG9uZW50JylcbmV4cG9ydHMucHJvcCA9IHJlcXVpcmUoJy4vcHJvcCcpXG5leHBvcnRzLnRyYW5zaXRpb24gPSByZXF1aXJlKCcuL3RyYW5zaXRpb24nKVxuIiwiLy8gTk9URTogdGhlIHByb3AgaW50ZXJuYWwgZGlyZWN0aXZlIGlzIGNvbXBpbGVkIGFuZCBsaW5rZWRcbi8vIGR1cmluZyBfaW5pdFNjb3BlKCksIGJlZm9yZSB0aGUgY3JlYXRlZCBob29rIGlzIGNhbGxlZC5cbi8vIFRoZSBwdXJwb3NlIGlzIHRvIG1ha2UgdGhlIGluaXRpYWwgcHJvcCB2YWx1ZXMgYXZhaWxhYmxlXG4vLyBpbnNpZGUgYGNyZWF0ZWRgIGhvb2tzIGFuZCBgZGF0YWAgZnVuY3Rpb25zLlxuXG52YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIFdhdGNoZXIgPSByZXF1aXJlKCcuLi8uLi93YXRjaGVyJylcbnZhciBiaW5kaW5nTW9kZXMgPSByZXF1aXJlKCcuLi8uLi9jb25maWcnKS5fcHJvcEJpbmRpbmdNb2Rlc1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgY2hpbGQgPSB0aGlzLnZtXG4gICAgdmFyIHBhcmVudCA9IGNoaWxkLl9jb250ZXh0XG4gICAgLy8gcGFzc2VkIGluIGZyb20gY29tcGlsZXIgZGlyZWN0bHlcbiAgICB2YXIgcHJvcCA9IHRoaXMuZGVzY3JpcHRvci5wcm9wXG4gICAgdmFyIGNoaWxkS2V5ID0gcHJvcC5wYXRoXG4gICAgdmFyIHBhcmVudEtleSA9IHByb3AucGFyZW50UGF0aFxuICAgIHZhciB0d29XYXkgPSBwcm9wLm1vZGUgPT09IGJpbmRpbmdNb2Rlcy5UV09fV0FZXG5cbiAgICB2YXIgcGFyZW50V2F0Y2hlciA9IHRoaXMucGFyZW50V2F0Y2hlciA9IG5ldyBXYXRjaGVyKFxuICAgICAgcGFyZW50LFxuICAgICAgcGFyZW50S2V5LFxuICAgICAgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBpZiAoXy5hc3NlcnRQcm9wKHByb3AsIHZhbCkpIHtcbiAgICAgICAgICBjaGlsZFtjaGlsZEtleV0gPSB2YWxcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0d29XYXk6IHR3b1dheSxcbiAgICAgICAgZmlsdGVyczogcHJvcC5maWx0ZXJzLFxuICAgICAgICAvLyBpbXBvcnRhbnQ6IHByb3BzIG5lZWQgdG8gYmUgb2JzZXJ2ZWQgb24gdGhlXG4gICAgICAgIC8vIHYtZm9yIHNjb3BlIGlmIHByZXNlbnRcbiAgICAgICAgc2NvcGU6IHRoaXMuX3Njb3BlXG4gICAgICB9XG4gICAgKVxuXG4gICAgLy8gc2V0IHRoZSBjaGlsZCBpbml0aWFsIHZhbHVlLlxuICAgIF8uaW5pdFByb3AoY2hpbGQsIHByb3AsIHBhcmVudFdhdGNoZXIudmFsdWUpXG5cbiAgICAvLyBzZXR1cCB0d28td2F5IGJpbmRpbmdcbiAgICBpZiAodHdvV2F5KSB7XG4gICAgICAvLyBpbXBvcnRhbnQ6IGRlZmVyIHRoZSBjaGlsZCB3YXRjaGVyIGNyZWF0aW9uIHVudGlsXG4gICAgICAvLyB0aGUgY3JlYXRlZCBob29rIChhZnRlciBkYXRhIG9ic2VydmF0aW9uKVxuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICBjaGlsZC4kb25jZSgnaG9vazpjcmVhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmNoaWxkV2F0Y2hlciA9IG5ldyBXYXRjaGVyKFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIGNoaWxkS2V5LFxuICAgICAgICAgIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHBhcmVudFdhdGNoZXIuc2V0KHZhbClcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGFyZW50V2F0Y2hlci50ZWFyZG93bigpXG4gICAgaWYgKHRoaXMuY2hpbGRXYXRjaGVyKSB7XG4gICAgICB0aGlzLmNoaWxkV2F0Y2hlci50ZWFyZG93bigpXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIHByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctbXMtJ11cbnZhciBjYW1lbFByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ11cbnZhciBpbXBvcnRhbnRSRSA9IC8haW1wb3J0YW50Oz8kL1xudmFyIHRlc3RFbCA9IG51bGxcbnZhciBwcm9wQ2FjaGUgPSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBkZWVwOiB0cnVlLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuZWwuc3R5bGUuY3NzVGV4dCA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZS5yZWR1Y2UoXy5leHRlbmQsIHt9KSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUgfHwge30pXG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZU9iamVjdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gY2FjaGUgb2JqZWN0IHN0eWxlcyBzbyB0aGF0IG9ubHkgY2hhbmdlZCBwcm9wc1xuICAgIC8vIGFyZSBhY3R1YWxseSB1cGRhdGVkLlxuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUgfHwgKHRoaXMuY2FjaGUgPSB7fSlcbiAgICB2YXIgbmFtZSwgdmFsXG4gICAgZm9yIChuYW1lIGluIGNhY2hlKSB7XG4gICAgICBpZiAoIShuYW1lIGluIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZShuYW1lLCBudWxsKVxuICAgICAgICBkZWxldGUgY2FjaGVbbmFtZV1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChuYW1lIGluIHZhbHVlKSB7XG4gICAgICB2YWwgPSB2YWx1ZVtuYW1lXVxuICAgICAgaWYgKHZhbCAhPT0gY2FjaGVbbmFtZV0pIHtcbiAgICAgICAgY2FjaGVbbmFtZV0gPSB2YWxcbiAgICAgICAgdGhpcy5oYW5kbGVTaW5nbGUobmFtZSwgdmFsKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBoYW5kbGVTaW5nbGU6IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgIHByb3AgPSBub3JtYWxpemUocHJvcClcbiAgICBpZiAoIXByb3ApIHJldHVybiAvLyB1bnN1cHBvcnRlZCBwcm9wXG4gICAgLy8gY2FzdCBwb3NzaWJsZSBudW1iZXJzL2Jvb2xlYW5zIGludG8gc3RyaW5nc1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZSArPSAnJ1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdmFyIGlzSW1wb3J0YW50ID0gaW1wb3J0YW50UkUudGVzdCh2YWx1ZSlcbiAgICAgICAgPyAnaW1wb3J0YW50J1xuICAgICAgICA6ICcnXG4gICAgICBpZiAoaXNJbXBvcnRhbnQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGltcG9ydGFudFJFLCAnJykudHJpbSgpXG4gICAgICB9XG4gICAgICB0aGlzLmVsLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIHZhbHVlLCBpc0ltcG9ydGFudClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKVxuICAgIH1cbiAgfVxuXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgQ1NTIHByb3BlcnR5IG5hbWUuXG4gKiAtIGNhY2hlIHJlc3VsdFxuICogLSBhdXRvIHByZWZpeFxuICogLSBjYW1lbENhc2UgLT4gZGFzaC1jYXNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemUgKHByb3ApIHtcbiAgaWYgKHByb3BDYWNoZVtwcm9wXSkge1xuICAgIHJldHVybiBwcm9wQ2FjaGVbcHJvcF1cbiAgfVxuICB2YXIgcmVzID0gcHJlZml4KHByb3ApXG4gIHByb3BDYWNoZVtwcm9wXSA9IHByb3BDYWNoZVtyZXNdID0gcmVzXG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBBdXRvIGRldGVjdCB0aGUgYXBwcm9wcmlhdGUgcHJlZml4IGZvciBhIENTUyBwcm9wZXJ0eS5cbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81MjM2OTJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHByZWZpeCAocHJvcCkge1xuICBwcm9wID0gXy5oeXBoZW5hdGUocHJvcClcbiAgdmFyIGNhbWVsID0gXy5jYW1lbGl6ZShwcm9wKVxuICB2YXIgdXBwZXIgPSBjYW1lbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsLnNsaWNlKDEpXG4gIGlmICghdGVzdEVsKSB7XG4gICAgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgfVxuICBpZiAoY2FtZWwgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgaSA9IHByZWZpeGVzLmxlbmd0aFxuICB2YXIgcHJlZml4ZWRcbiAgd2hpbGUgKGktLSkge1xuICAgIHByZWZpeGVkID0gY2FtZWxQcmVmaXhlc1tpXSArIHVwcGVyXG4gICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVzW2ldICsgcHJvcFxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbnZhciBUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDEwMDAsXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoaWQsIG9sZElkKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbFxuICAgIC8vIHJlc29sdmUgb24gb3duZXIgdm1cbiAgICB2YXIgaG9va3MgPSBfLnJlc29sdmVBc3NldCh0aGlzLnZtLiRvcHRpb25zLCAndHJhbnNpdGlvbnMnLCBpZClcbiAgICBpZCA9IGlkIHx8ICd2J1xuICAgIC8vIGFwcGx5IG9uIGNsb3Nlc3Qgdm1cbiAgICBlbC5fX3ZfdHJhbnMgPSBuZXcgVHJhbnNpdGlvbihlbCwgaWQsIGhvb2tzLCB0aGlzLmVsLl9fdnVlX18gfHwgdGhpcy52bSlcbiAgICBpZiAob2xkSWQpIHtcbiAgICAgIF8ucmVtb3ZlQ2xhc3MoZWwsIG9sZElkICsgJy10cmFuc2l0aW9uJylcbiAgICB9XG4gICAgXy5hZGRDbGFzcyhlbCwgaWQgKyAnLXRyYW5zaXRpb24nKVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuXG4vLyB4bGlua1xudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcbnZhciB4bGlua1JFID0gL154bGluazovXG5cbi8vIHRoZXNlIGlucHV0IGVsZW1lbnQgYXR0cmlidXRlcyBzaG91bGQgYWxzbyBzZXQgdGhlaXJcbi8vIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllc1xudmFyIGlucHV0UHJvcHMgPSB7XG4gIHZhbHVlOiAxLFxuICBjaGVja2VkOiAxLFxuICBzZWxlY3RlZDogMVxufVxuXG4vLyB0aGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBzZXQgYSBoaWRkZW4gcHJvcGVydHkgZm9yXG4vLyBiaW5kaW5nIHYtbW9kZWwgdG8gb2JqZWN0IHZhbHVlc1xudmFyIG1vZGVsUHJvcHMgPSB7XG4gIHZhbHVlOiAnX3ZhbHVlJyxcbiAgJ3RydWUtdmFsdWUnOiAnX3RydWVWYWx1ZScsXG4gICdmYWxzZS12YWx1ZSc6ICdfZmFsc2VWYWx1ZSdcbn1cblxuLy8gY2hlY2sgZm9yIGF0dHJpYnV0ZXMgdGhhdCBwcm9oaWJpdCBpbnRlcnBvbGF0aW9uc1xudmFyIGRpc2FsbG93ZWRJbnRlcnBBdHRyUkUgPSAvXnYtfF46fF5AfF4oaXN8dHJhbnNpdGlvbnx0cmFuc2l0aW9uLW1vZGV8ZGVib3VuY2V8dHJhY2stYnl8c3RhZ2dlcnxlbnRlci1zdGFnZ2VyfGxlYXZlLXN0YWdnZXIpJC9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDg1MCxcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF0dHIgPSB0aGlzLmFyZ1xuICAgIHZhciB0YWcgPSB0aGlzLmVsLnRhZ05hbWVcbiAgICAvLyBzaG91bGQgYmUgZGVlcCB3YXRjaCBvbiBvYmplY3QgbW9kZVxuICAgIGlmICghYXR0cikge1xuICAgICAgdGhpcy5kZWVwID0gdHJ1ZVxuICAgIH1cbiAgICAvLyBoYW5kbGUgaW50ZXJwb2xhdGlvbiBiaW5kaW5nc1xuICAgIGlmICh0aGlzLmRlc2NyaXB0b3IuaW50ZXJwKSB7XG4gICAgICAvLyBvbmx5IGFsbG93IGJpbmRpbmcgb24gbmF0aXZlIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChcbiAgICAgICAgZGlzYWxsb3dlZEludGVycEF0dHJSRS50ZXN0KGF0dHIpIHx8XG4gICAgICAgIChhdHRyID09PSAnbmFtZScgJiYgKHRhZyA9PT0gJ1BBUlRJQUwnIHx8IHRhZyA9PT0gJ1NMT1QnKSlcbiAgICAgICkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgICBhdHRyICsgJz1cIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICtcbiAgICAgICAgICAnYXR0cmlidXRlIGludGVycG9sYXRpb24gaXMgbm90IGFsbG93ZWQgaW4gVnVlLmpzICcgK1xuICAgICAgICAgICdkaXJlY3RpdmVzIGFuZCBzcGVjaWFsIGF0dHJpYnV0ZXMuJ1xuICAgICAgICApXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpXG4gICAgICAgIHRoaXMuaW52YWxpZCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgcmF3ID0gYXR0ciArICc9XCInICsgdGhpcy5kZXNjcmlwdG9yLnJhdyArICdcIjogJ1xuICAgICAgICAvLyB3YXJuIHNyY1xuICAgICAgICBpZiAoYXR0ciA9PT0gJ3NyYycpIHtcbiAgICAgICAgICBfLndhcm4oXG4gICAgICAgICAgICByYXcgKyAnaW50ZXJwb2xhdGlvbiBpbiBcInNyY1wiIGF0dHJpYnV0ZSB3aWxsIGNhdXNlICcgK1xuICAgICAgICAgICAgJ2EgNDA0IHJlcXVlc3QuIFVzZSB2LWJpbmQ6c3JjIGluc3RlYWQuJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdhcm4gc3R5bGVcbiAgICAgICAgaWYgKGF0dHIgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBfLndhcm4oXG4gICAgICAgICAgICByYXcgKyAnaW50ZXJwb2xhdGlvbiBpbiBcInN0eWxlXCIgYXR0cmlidXRlIHdpbGwgY2F1c2UgJyArXG4gICAgICAgICAgICAndGhlIGF0dHJpYnV0ZSB0byBiZSBkaXNjYXJkZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQ6c3R5bGUgaW5zdGVhZC4nXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBhdHRyID0gdGhpcy5hcmdcbiAgICBpZiAodGhpcy5hcmcpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2luZ2xlKGF0dHIsIHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZSB8fCB7fSlcbiAgICB9XG4gIH0sXG5cbiAgLy8gc2hhcmUgb2JqZWN0IGhhbmRsZXIgd2l0aCB2LWJpbmQ6Y2xhc3NcbiAgaGFuZGxlT2JqZWN0OiByZXF1aXJlKCcuLi9pbnRlcm5hbC9zdHlsZScpLmhhbmRsZU9iamVjdCxcblxuICBoYW5kbGVTaW5nbGU6IGZ1bmN0aW9uIChhdHRyLCB2YWx1ZSkge1xuICAgIGlmIChpbnB1dFByb3BzW2F0dHJdICYmIGF0dHIgaW4gdGhpcy5lbCkge1xuICAgICAgdGhpcy5lbFthdHRyXSA9IGF0dHIgPT09ICd2YWx1ZSdcbiAgICAgICAgPyAodmFsdWUgfHwgJycpIC8vIElFOSB3aWxsIHNldCBpbnB1dC52YWx1ZSB0byBcIm51bGxcIiBmb3IgbnVsbC4uLlxuICAgICAgICA6IHZhbHVlXG4gICAgfVxuICAgIC8vIHNldCBtb2RlbCBwcm9wc1xuICAgIHZhciBtb2RlbFByb3AgPSBtb2RlbFByb3BzW2F0dHJdXG4gICAgaWYgKG1vZGVsUHJvcCkge1xuICAgICAgdGhpcy5lbFttb2RlbFByb3BdID0gdmFsdWVcbiAgICAgIC8vIHVwZGF0ZSB2LW1vZGVsIGlmIHByZXNlbnRcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuZWwuX192X21vZGVsXG4gICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWwubGlzdGVuZXIoKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBkbyBub3Qgc2V0IHZhbHVlIGF0dHJpYnV0ZSBmb3IgdGV4dGFyZWFcbiAgICBpZiAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiB0aGlzLmVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gdXBkYXRlIGF0dHJpYnV0ZVxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgaWYgKHhsaW5rUkUudGVzdChhdHRyKSkge1xuICAgICAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGF0dHIsIHZhbHVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWxcbiAgICB0aGlzLnZtLiRvbmNlKCdob29rOmNvbXBpbGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd2LWNsb2FrJylcbiAgICB9KVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBwcmlvcml0eTogMTUwMCxcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0aGlzLmFyZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpZCA9IHRoaXMuaWQgPSBfLmNhbWVsaXplKHRoaXMuYXJnKVxuICAgIHZhciByZWZzID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRlbHNcbiAgICBpZiAocmVmcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHJlZnNbaWRdID0gdGhpcy5lbFxuICAgIH0gZWxzZSB7XG4gICAgICBfLmRlZmluZVJlYWN0aXZlKHJlZnMsIGlkLCB0aGlzLmVsKVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kZWxzXG4gICAgaWYgKHJlZnNbdGhpcy5pZF0gPT09IHRoaXMuZWwpIHtcbiAgICAgIHJlZnNbdGhpcy5pZF0gPSBudWxsXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIEZyYWdtZW50RmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uL2ZyYWdtZW50L2ZhY3RvcnknKVxudmFyIGlzT2JqZWN0ID0gXy5pc09iamVjdFxudmFyIHVpZCA9IDBcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDIwMDAsXG5cbiAgcGFyYW1zOiBbXG4gICAgJ3RyYWNrLWJ5JyxcbiAgICAnc3RhZ2dlcicsXG4gICAgJ2VudGVyLXN0YWdnZXInLFxuICAgICdsZWF2ZS1zdGFnZ2VyJ1xuICBdLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzdXBwb3J0IFwiaXRlbSBpbiBpdGVtc1wiIHN5bnRheFxuICAgIHZhciBpbk1hdGNoID0gdGhpcy5leHByZXNzaW9uLm1hdGNoKC8oLiopIGluICguKikvKVxuICAgIGlmIChpbk1hdGNoKSB7XG4gICAgICB2YXIgaXRNYXRjaCA9IGluTWF0Y2hbMV0ubWF0Y2goL1xcKCguKiksKC4qKVxcKS8pXG4gICAgICBpZiAoaXRNYXRjaCkge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRNYXRjaFsxXS50cmltKClcbiAgICAgICAgdGhpcy5hbGlhcyA9IGl0TWF0Y2hbMl0udHJpbSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFsaWFzID0gaW5NYXRjaFsxXS50cmltKClcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGluTWF0Y2hbMl1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYWxpYXMpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAnQWxpYXMgaXMgcmVxdWlyZWQgaW4gdi1mb3IuJ1xuICAgICAgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gdWlkIGFzIGEgY2FjaGUgaWRlbnRpZmllclxuICAgIHRoaXMuaWQgPSAnX192LWZvcl9fJyArICgrK3VpZClcblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgYW4gb3B0aW9uIGxpc3QsXG4gICAgLy8gc28gdGhhdCB3ZSBrbm93IGlmIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSA8c2VsZWN0PidzXG4gICAgLy8gdi1tb2RlbCB3aGVuIHRoZSBvcHRpb24gbGlzdCBoYXMgY2hhbmdlZC5cbiAgICAvLyBiZWNhdXNlIHYtbW9kZWwgaGFzIGEgbG93ZXIgcHJpb3JpdHkgdGhhbiB2LWZvcixcbiAgICAvLyB0aGUgdi1tb2RlbCBpcyBub3QgYm91bmQgaGVyZSB5ZXQsIHNvIHdlIGhhdmUgdG9cbiAgICAvLyByZXRyaXZlIGl0IGluIHRoZSBhY3R1YWwgdXBkYXRlTW9kZWwoKSBmdW5jdGlvbi5cbiAgICB2YXIgdGFnID0gdGhpcy5lbC50YWdOYW1lXG4gICAgdGhpcy5pc09wdGlvbiA9XG4gICAgICAodGFnID09PSAnT1BUSU9OJyB8fCB0YWcgPT09ICdPUFRHUk9VUCcpICYmXG4gICAgICB0aGlzLmVsLnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ1NFTEVDVCdcblxuICAgIC8vIHNldHVwIGFuY2hvciBub2Rlc1xuICAgIHRoaXMuc3RhcnQgPSBfLmNyZWF0ZUFuY2hvcigndi1mb3Itc3RhcnQnKVxuICAgIHRoaXMuZW5kID0gXy5jcmVhdGVBbmNob3IoJ3YtZm9yLWVuZCcpXG4gICAgXy5yZXBsYWNlKHRoaXMuZWwsIHRoaXMuZW5kKVxuICAgIF8uYmVmb3JlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKVxuXG4gICAgLy8gY2hlY2sgcmVmXG4gICAgdGhpcy5yZWYgPSBfLmZpbmRSZWYodGhpcy5lbClcblxuICAgIC8vIGNhY2hlXG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAgIC8vIGZyYWdtZW50IGZhY3RvcnlcbiAgICB0aGlzLmZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMudm0sIHRoaXMuZWwpXG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuZGlmZihkYXRhKVxuICAgIHRoaXMudXBkYXRlUmVmKClcbiAgICB0aGlzLnVwZGF0ZU1vZGVsKClcbiAgfSxcblxuICAvKipcbiAgICogRGlmZiwgYmFzZWQgb24gbmV3IGRhdGEgYW5kIG9sZCBkYXRhLCBkZXRlcm1pbmUgdGhlXG4gICAqIG1pbmltdW0gYW1vdW50IG9mIERPTSBtYW5pcHVsYXRpb25zIG5lZWRlZCB0byBtYWtlIHRoZVxuICAgKiBET00gcmVmbGVjdCB0aGUgbmV3IGRhdGEgQXJyYXkuXG4gICAqXG4gICAqIFRoZSBhbGdvcml0aG0gZGlmZnMgdGhlIG5ldyBkYXRhIEFycmF5IGJ5IHN0b3JpbmcgYVxuICAgKiBoaWRkZW4gcmVmZXJlbmNlIHRvIGFuIG93bmVyIHZtIGluc3RhbmNlIG9uIHByZXZpb3VzbHlcbiAgICogc2VlbiBkYXRhLiBUaGlzIGFsbG93cyB1cyB0byBhY2hpZXZlIE8obikgd2hpY2ggaXNcbiAgICogYmV0dGVyIHRoYW4gYSBsZXZlbnNodGVpbiBkaXN0YW5jZSBiYXNlZCBhbGdvcml0aG0sXG4gICAqIHdoaWNoIGlzIE8obSAqIG4pLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gICAqL1xuXG4gIGRpZmY6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIEFycmF5IHdhcyBjb252ZXJ0ZWQgZnJvbSBhbiBPYmplY3RcbiAgICB2YXIgaXRlbSA9IGRhdGFbMF1cbiAgICB2YXIgY29udmVydGVkRnJvbU9iamVjdCA9IHRoaXMuZnJvbU9iamVjdCA9XG4gICAgICBpc09iamVjdChpdGVtKSAmJlxuICAgICAgaXRlbS5oYXNPd25Qcm9wZXJ0eSgnJGtleScpICYmXG4gICAgICBpdGVtLmhhc093blByb3BlcnR5KCckdmFsdWUnKVxuXG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5XG4gICAgdmFyIG9sZEZyYWdzID0gdGhpcy5mcmFnc1xuICAgIHZhciBmcmFncyA9IHRoaXMuZnJhZ3MgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpXG4gICAgdmFyIGFsaWFzID0gdGhpcy5hbGlhc1xuICAgIHZhciBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3JcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0XG4gICAgdmFyIGVuZCA9IHRoaXMuZW5kXG4gICAgdmFyIGluRG9jID0gXy5pbkRvYyhzdGFydClcbiAgICB2YXIgaW5pdCA9ICFvbGRGcmFnc1xuICAgIHZhciBpLCBsLCBmcmFnLCBrZXksIHZhbHVlLCBwcmltaXRpdmVcblxuICAgIC8vIEZpcnN0IHBhc3MsIGdvIHRocm91Z2ggdGhlIG5ldyBBcnJheSBhbmQgZmlsbCB1cFxuICAgIC8vIHRoZSBuZXcgZnJhZ3MgYXJyYXkuIElmIGEgcGllY2Ugb2YgZGF0YSBoYXMgYSBjYWNoZWRcbiAgICAvLyBpbnN0YW5jZSBmb3IgaXQsIHdlIHJldXNlIGl0LiBPdGhlcndpc2UgYnVpbGQgYSBuZXdcbiAgICAvLyBpbnN0YW5jZS5cbiAgICBmb3IgKGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBkYXRhW2ldXG4gICAgICBrZXkgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4ka2V5IDogbnVsbFxuICAgICAgdmFsdWUgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4kdmFsdWUgOiBpdGVtXG4gICAgICBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpXG4gICAgICBmcmFnID0gIWluaXQgJiYgdGhpcy5nZXRDYWNoZWRGcmFnKHZhbHVlLCBpLCBrZXkpXG4gICAgICBpZiAoZnJhZykgeyAvLyByZXVzYWJsZSBmcmFnbWVudFxuICAgICAgICBmcmFnLnJldXNlZCA9IHRydWVcbiAgICAgICAgLy8gdXBkYXRlICRpbmRleFxuICAgICAgICBmcmFnLnNjb3BlLiRpbmRleCA9IGlcbiAgICAgICAgLy8gdXBkYXRlICRrZXlcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGZyYWcuc2NvcGUuJGtleSA9IGtleVxuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBpdGVyYXRvclxuICAgICAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICBmcmFnLnNjb3BlW2l0ZXJhdG9yXSA9IGtleSAhPT0gbnVsbCA/IGtleSA6IGlcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgZGF0YSBmb3IgdHJhY2stYnksIG9iamVjdCByZXBlYXQgJlxuICAgICAgICAvLyBwcmltaXRpdmUgdmFsdWVzLlxuICAgICAgICBpZiAodHJhY2tCeUtleSB8fCBjb252ZXJ0ZWRGcm9tT2JqZWN0IHx8IHByaW1pdGl2ZSkge1xuICAgICAgICAgIGZyYWcuc2NvcGVbYWxpYXNdID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgLy8gbmV3IGlzbnRhbmNlXG4gICAgICAgIGZyYWcgPSB0aGlzLmNyZWF0ZSh2YWx1ZSwgYWxpYXMsIGksIGtleSlcbiAgICAgICAgZnJhZy5mcmVzaCA9ICFpbml0XG4gICAgICB9XG4gICAgICBmcmFnc1tpXSA9IGZyYWdcbiAgICAgIGlmIChpbml0KSB7XG4gICAgICAgIGZyYWcuYmVmb3JlKGVuZClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSdyZSBkb25lIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgaWYgKGluaXQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFNlY29uZCBwYXNzLCBnbyB0aHJvdWdoIHRoZSBvbGQgZnJhZ21lbnRzIGFuZFxuICAgIC8vIGRlc3Ryb3kgdGhvc2Ugd2hvIGFyZSBub3QgcmV1c2VkIChhbmQgcmVtb3ZlIHRoZW1cbiAgICAvLyBmcm9tIGNhY2hlKVxuICAgIHZhciByZW1vdmFsSW5kZXggPSAwXG4gICAgdmFyIHRvdGFsUmVtb3ZlZCA9IG9sZEZyYWdzLmxlbmd0aCAtIGZyYWdzLmxlbmd0aFxuICAgIGZvciAoaSA9IDAsIGwgPSBvbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZyYWcgPSBvbGRGcmFnc1tpXVxuICAgICAgaWYgKCFmcmFnLnJldXNlZCkge1xuICAgICAgICB0aGlzLmRlbGV0ZUNhY2hlZEZyYWcoZnJhZylcbiAgICAgICAgdGhpcy5yZW1vdmUoZnJhZywgcmVtb3ZhbEluZGV4KyssIHRvdGFsUmVtb3ZlZCwgaW5Eb2MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmluYWwgcGFzcywgbW92ZS9pbnNlcnQgbmV3IGZyYWdtZW50cyBpbnRvIHRoZVxuICAgIC8vIHJpZ2h0IHBsYWNlLlxuICAgIHZhciB0YXJnZXRQcmV2LCBwcmV2RWwsIGN1cnJlbnRQcmV2XG4gICAgdmFyIGluc2VydGlvbkluZGV4ID0gMFxuICAgIGZvciAoaSA9IDAsIGwgPSBmcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZyYWcgPSBmcmFnc1tpXVxuICAgICAgLy8gdGhpcyBpcyB0aGUgZnJhZyB0aGF0IHdlIHNob3VsZCBiZSBhZnRlclxuICAgICAgdGFyZ2V0UHJldiA9IGZyYWdzW2kgLSAxXVxuICAgICAgcHJldkVsID0gdGFyZ2V0UHJldlxuICAgICAgICA/IHRhcmdldFByZXYuc3RhZ2dlckNiXG4gICAgICAgICAgPyB0YXJnZXRQcmV2LnN0YWdnZXJBbmNob3JcbiAgICAgICAgICA6IHRhcmdldFByZXYuZW5kIHx8IHRhcmdldFByZXYubm9kZVxuICAgICAgICA6IHN0YXJ0XG4gICAgICBpZiAoZnJhZy5yZXVzZWQgJiYgIWZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICAgIGN1cnJlbnRQcmV2ID0gZmluZFByZXZGcmFnKGZyYWcsIHN0YXJ0LCB0aGlzLmlkKVxuICAgICAgICBpZiAoY3VycmVudFByZXYgIT09IHRhcmdldFByZXYpIHtcbiAgICAgICAgICB0aGlzLm1vdmUoZnJhZywgcHJldkVsKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgaW5zdGFuY2UsIG9yIHN0aWxsIGluIHN0YWdnZXIuXG4gICAgICAgIC8vIGluc2VydCB3aXRoIHVwZGF0ZWQgc3RhZ2dlciBpbmRleC5cbiAgICAgICAgdGhpcy5pbnNlcnQoZnJhZywgaW5zZXJ0aW9uSW5kZXgrKywgcHJldkVsLCBpbkRvYylcbiAgICAgIH1cbiAgICAgIGZyYWcucmV1c2VkID0gZnJhZy5mcmVzaCA9IGZhbHNlXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFsaWFzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAgICogQHJldHVybiB7RnJhZ21lbnR9XG4gICAqL1xuXG4gIGNyZWF0ZTogZnVuY3Rpb24gKHZhbHVlLCBhbGlhcywgaW5kZXgsIGtleSkge1xuICAgIHZhciBob3N0ID0gdGhpcy5faG9zdFxuICAgIC8vIGNyZWF0ZSBpdGVyYXRpb24gc2NvcGVcbiAgICB2YXIgcGFyZW50U2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtXG4gICAgdmFyIHNjb3BlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZSlcbiAgICAvLyByZWYgaG9sZGVyIGZvciB0aGUgc2NvcGVcbiAgICBzY29wZS4kcmVmcyA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUuJHJlZnMpXG4gICAgc2NvcGUuJGVscyA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUuJGVscylcbiAgICAvLyBtYWtlIHN1cmUgcG9pbnQgJHBhcmVudCB0byBwYXJlbnQgc2NvcGVcbiAgICBzY29wZS4kcGFyZW50ID0gcGFyZW50U2NvcGVcbiAgICAvLyBmb3IgdHdvLXdheSBiaW5kaW5nIG9uIGFsaWFzXG4gICAgc2NvcGUuJGZvckNvbnRleHQgPSB0aGlzXG4gICAgLy8gZGVmaW5lIHNjb3BlIHByb3BlcnRpZXNcbiAgICBfLmRlZmluZVJlYWN0aXZlKHNjb3BlLCBhbGlhcywgdmFsdWUpXG4gICAgXy5kZWZpbmVSZWFjdGl2ZShzY29wZSwgJyRpbmRleCcsIGluZGV4KVxuICAgIGlmIChrZXkpIHtcbiAgICAgIF8uZGVmaW5lUmVhY3RpdmUoc2NvcGUsICcka2V5Jywga2V5KVxuICAgIH0gZWxzZSBpZiAoc2NvcGUuJGtleSkge1xuICAgICAgLy8gYXZvaWQgYWNjaWRlbnRhbCBmYWxsYmFja1xuICAgICAgXy5kZWZpbmUoc2NvcGUsICcka2V5JywgbnVsbClcbiAgICB9XG4gICAgaWYgKHRoaXMuaXRlcmF0b3IpIHtcbiAgICAgIF8uZGVmaW5lUmVhY3RpdmUoc2NvcGUsIHRoaXMuaXRlcmF0b3IsIGtleSAhPT0gbnVsbCA/IGtleSA6IGluZGV4KVxuICAgIH1cbiAgICB2YXIgZnJhZyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUoaG9zdCwgc2NvcGUsIHRoaXMuX2ZyYWcpXG4gICAgZnJhZy5mb3JJZCA9IHRoaXMuaWRcbiAgICB0aGlzLmNhY2hlRnJhZyh2YWx1ZSwgZnJhZywgaW5kZXgsIGtleSlcbiAgICByZXR1cm4gZnJhZ1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHYtcmVmIG9uIG93bmVyIHZtLlxuICAgKi9cblxuICB1cGRhdGVSZWY6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5yZWZcbiAgICBpZiAoIXJlZikgcmV0dXJuXG4gICAgdmFyIGhhc2ggPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHJlZnNcbiAgICB2YXIgcmVmc1xuICAgIGlmICghdGhpcy5mcm9tT2JqZWN0KSB7XG4gICAgICByZWZzID0gdGhpcy5mcmFncy5tYXAoZmluZFZtRnJvbUZyYWcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnMgPSB7fVxuICAgICAgdGhpcy5mcmFncy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgIHJlZnNbZnJhZy5zY29wZS4ka2V5XSA9IGZpbmRWbUZyb21GcmFnKGZyYWcpXG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAoIWhhc2guaGFzT3duUHJvcGVydHkocmVmKSkge1xuICAgICAgXy5kZWZpbmVSZWFjdGl2ZShoYXNoLCByZWYsIHJlZnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc2hbcmVmXSA9IHJlZnNcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBvcHRpb24gbGlzdHMsIHVwZGF0ZSB0aGUgY29udGFpbmluZyB2LW1vZGVsIG9uXG4gICAqIHBhcmVudCA8c2VsZWN0Pi5cbiAgICovXG5cbiAgdXBkYXRlTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc09wdGlvbikge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuc3RhcnQucGFyZW50Tm9kZVxuICAgICAgdmFyIG1vZGVsID0gcGFyZW50ICYmIHBhcmVudC5fX3ZfbW9kZWxcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICBtb2RlbC5mb3JjZVVwZGF0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSBmcmFnbWVudC4gSGFuZGxlcyBzdGFnZ2VyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge05vZGV9IHByZXZFbFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluRG9jXG4gICAqL1xuXG4gIGluc2VydDogZnVuY3Rpb24gKGZyYWcsIGluZGV4LCBwcmV2RWwsIGluRG9jKSB7XG4gICAgaWYgKGZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICBmcmFnLnN0YWdnZXJDYi5jYW5jZWwoKVxuICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsXG4gICAgfVxuICAgIHZhciBzdGFnZ2VyQW1vdW50ID0gdGhpcy5nZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCBudWxsLCAnZW50ZXInKVxuICAgIGlmIChpbkRvYyAmJiBzdGFnZ2VyQW1vdW50KSB7XG4gICAgICAvLyBjcmVhdGUgYW4gYW5jaG9yIGFuZCBpbnNlcnQgaXQgc3luY2hyb25vdXNseSxcbiAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIHJlc29sdmUgdGhlIGNvcnJlY3Qgb3JkZXIgd2l0aG91dFxuICAgICAgLy8gd29ycnlpbmcgYWJvdXQgc29tZSBlbGVtZW50cyBub3QgaW5zZXJ0ZWQgeWV0XG4gICAgICB2YXIgYW5jaG9yID0gZnJhZy5zdGFnZ2VyQW5jaG9yXG4gICAgICBpZiAoIWFuY2hvcikge1xuICAgICAgICBhbmNob3IgPSBmcmFnLnN0YWdnZXJBbmNob3IgPSBfLmNyZWF0ZUFuY2hvcignc3RhZ2dlci1hbmNob3InKVxuICAgICAgICBhbmNob3IuX192ZnJhZ19fID0gZnJhZ1xuICAgICAgfVxuICAgICAgXy5hZnRlcihhbmNob3IsIHByZXZFbClcbiAgICAgIHZhciBvcCA9IGZyYWcuc3RhZ2dlckNiID0gXy5jYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbFxuICAgICAgICBmcmFnLmJlZm9yZShhbmNob3IpXG4gICAgICAgIF8ucmVtb3ZlKGFuY2hvcilcbiAgICAgIH0pXG4gICAgICBzZXRUaW1lb3V0KG9wLCBzdGFnZ2VyQW1vdW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnLmJlZm9yZShwcmV2RWwubmV4dFNpYmxpbmcpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmcmFnbWVudC4gSGFuZGxlcyBzdGFnZ2VyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gdG90YWxcbiAgICogQHBhcmFtIHtCb29sZWFufSBpbkRvY1xuICAgKi9cblxuICByZW1vdmU6IGZ1bmN0aW9uIChmcmFnLCBpbmRleCwgdG90YWwsIGluRG9jKSB7XG4gICAgaWYgKGZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICBmcmFnLnN0YWdnZXJDYi5jYW5jZWwoKVxuICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsXG4gICAgICAvLyBpdCdzIG5vdCBwb3NzaWJsZSBmb3IgdGhlIHNhbWUgZnJhZyB0byBiZSByZW1vdmVkXG4gICAgICAvLyB0d2ljZSwgc28gaWYgd2UgaGF2ZSBhIHBlbmRpbmcgc3RhZ2dlciBjYWxsYmFjayxcbiAgICAgIC8vIGl0IG1lYW5zIHRoaXMgZnJhZyBpcyBxdWV1ZWQgZm9yIGVudGVyIGJ1dCByZW1vdmVkXG4gICAgICAvLyBiZWZvcmUgaXRzIHRyYW5zaXRpb24gc3RhcnRlZC4gU2luY2UgaXQgaXMgYWxyZWFkeVxuICAgICAgLy8gZGVzdHJveWVkLCB3ZSBjYW4ganVzdCBsZWF2ZSBpdCBpbiBkZXRhY2hlZCBzdGF0ZS5cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgc3RhZ2dlckFtb3VudCA9IHRoaXMuZ2V0U3RhZ2dlcihmcmFnLCBpbmRleCwgdG90YWwsICdsZWF2ZScpXG4gICAgaWYgKGluRG9jICYmIHN0YWdnZXJBbW91bnQpIHtcbiAgICAgIHZhciBvcCA9IGZyYWcuc3RhZ2dlckNiID0gXy5jYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbFxuICAgICAgICBmcmFnLnJlbW92ZSh0cnVlKVxuICAgICAgfSlcbiAgICAgIHNldFRpbWVvdXQob3AsIHN0YWdnZXJBbW91bnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcucmVtb3ZlKHRydWUpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlIGEgZnJhZ21lbnQgdG8gYSBuZXcgcG9zaXRpb24uXG4gICAqIEZvcmNlIG5vIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOb2RlfSBwcmV2RWxcbiAgICovXG5cbiAgbW92ZTogZnVuY3Rpb24gKGZyYWcsIHByZXZFbCkge1xuICAgIGZyYWcuYmVmb3JlKHByZXZFbC5uZXh0U2libGluZywgZmFsc2UpXG4gIH0sXG5cbiAgLyoqXG4gICAqIENhY2hlIGEgZnJhZ21lbnQgdXNpbmcgdHJhY2stYnkgb3IgdGhlIG9iamVjdCBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gICAqL1xuXG4gIGNhY2hlRnJhZzogZnVuY3Rpb24gKHZhbHVlLCBmcmFnLCBpbmRleCwga2V5KSB7XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZVxuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpXG4gICAgdmFyIGlkXG4gICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgaWQgPSB0cmFja0J5S2V5XG4gICAgICAgID8gdHJhY2tCeUtleSA9PT0gJyRpbmRleCdcbiAgICAgICAgICA/IGluZGV4XG4gICAgICAgICAgOiB2YWx1ZVt0cmFja0J5S2V5XVxuICAgICAgICA6IChrZXkgfHwgdmFsdWUpXG4gICAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgICBjYWNoZVtpZF0gPSBmcmFnXG4gICAgICB9IGVsc2UgaWYgKHRyYWNrQnlLZXkgIT09ICckaW5kZXgnKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IHRoaXMuaWRcbiAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgaWYgKHZhbHVlW2lkXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlW2lkXSA9IGZyYWdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfLmRlZmluZSh2YWx1ZSwgaWQsIGZyYWcpXG4gICAgICB9XG4gICAgfVxuICAgIGZyYWcucmF3ID0gdmFsdWVcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgY2FjaGVkIGZyYWdtZW50IGZyb20gdGhlIHZhbHVlL2luZGV4L2tleVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge0ZyYWdtZW50fVxuICAgKi9cblxuICBnZXRDYWNoZWRGcmFnOiBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnlcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKVxuICAgIHZhciBmcmFnXG4gICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgdmFyIGlkID0gdHJhY2tCeUtleVxuICAgICAgICA/IHRyYWNrQnlLZXkgPT09ICckaW5kZXgnXG4gICAgICAgICAgPyBpbmRleFxuICAgICAgICAgIDogdmFsdWVbdHJhY2tCeUtleV1cbiAgICAgICAgOiAoa2V5IHx8IHZhbHVlKVxuICAgICAgZnJhZyA9IHRoaXMuY2FjaGVbaWRdXG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcgPSB2YWx1ZVt0aGlzLmlkXVxuICAgIH1cbiAgICBpZiAoZnJhZyAmJiAoZnJhZy5yZXVzZWQgfHwgZnJhZy5mcmVzaCkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHRoaXMud2FybkR1cGxpY2F0ZSh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlIGEgZnJhZ21lbnQgZnJvbSBjYWNoZS5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKi9cblxuICBkZWxldGVDYWNoZWRGcmFnOiBmdW5jdGlvbiAoZnJhZykge1xuICAgIHZhciB2YWx1ZSA9IGZyYWcucmF3XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5XG4gICAgdmFyIHNjb3BlID0gZnJhZy5zY29wZVxuICAgIHZhciBpbmRleCA9IHNjb3BlLiRpbmRleFxuICAgIC8vIGZpeCAjOTQ4OiBhdm9pZCBhY2NpZGVudGFsbHkgZmFsbCB0aHJvdWdoIHRvXG4gICAgLy8gYSBwYXJlbnQgcmVwZWF0ZXIgd2hpY2ggaGFwcGVucyB0byBoYXZlICRrZXkuXG4gICAgdmFyIGtleSA9IHNjb3BlLmhhc093blByb3BlcnR5KCcka2V5JykgJiYgc2NvcGUuJGtleVxuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpXG4gICAgaWYgKHRyYWNrQnlLZXkgfHwga2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgdmFyIGlkID0gdHJhY2tCeUtleVxuICAgICAgICA/IHRyYWNrQnlLZXkgPT09ICckaW5kZXgnXG4gICAgICAgICAgPyBpbmRleFxuICAgICAgICAgIDogdmFsdWVbdHJhY2tCeUtleV1cbiAgICAgICAgOiAoa2V5IHx8IHZhbHVlKVxuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlW3RoaXMuaWRdID0gbnVsbFxuICAgICAgZnJhZy5yYXcgPSBudWxsXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YWdnZXIgYW1vdW50IGZvciBhbiBpbnNlcnRpb24vcmVtb3ZhbC5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqL1xuXG4gIGdldFN0YWdnZXI6IGZ1bmN0aW9uIChmcmFnLCBpbmRleCwgdG90YWwsIHR5cGUpIHtcbiAgICB0eXBlID0gdHlwZSArICdTdGFnZ2VyJ1xuICAgIHZhciB0cmFucyA9IGZyYWcubm9kZS5fX3ZfdHJhbnNcbiAgICB2YXIgaG9va3MgPSB0cmFucyAmJiB0cmFucy5ob29rc1xuICAgIHZhciBob29rID0gaG9va3MgJiYgKGhvb2tzW3R5cGVdIHx8IGhvb2tzLnN0YWdnZXIpXG4gICAgcmV0dXJuIGhvb2tcbiAgICAgID8gaG9vay5jYWxsKGZyYWcsIGluZGV4LCB0b3RhbClcbiAgICAgIDogaW5kZXggKiBwYXJzZUludCh0aGlzLnBhcmFtc1t0eXBlXSB8fCB0aGlzLnBhcmFtcy5zdGFnZ2VyLCAxMClcbiAgfSxcblxuICAvKipcbiAgICogUHJlLXByb2Nlc3MgdGhlIHZhbHVlIGJlZm9yZSBwaXBpbmcgaXQgdGhyb3VnaCB0aGVcbiAgICogZmlsdGVycy4gVGhpcyBpcyBwYXNzZWQgdG8gYW5kIGNhbGxlZCBieSB0aGUgd2F0Y2hlci5cbiAgICovXG5cbiAgX3ByZVByb2Nlc3M6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHJlZ2FyZGxlc3Mgb2YgdHlwZSwgc3RvcmUgdGhlIHVuLWZpbHRlcmVkIHJhdyB2YWx1ZS5cbiAgICB0aGlzLnJhd1ZhbHVlID0gdmFsdWVcbiAgICByZXR1cm4gdmFsdWVcbiAgfSxcblxuICAvKipcbiAgICogUG9zdC1wcm9jZXNzIHRoZSB2YWx1ZSBhZnRlciBpdCBoYXMgYmVlbiBwaXBlZCB0aHJvdWdoXG4gICAqIHRoZSBmaWx0ZXJzLiBUaGlzIGlzIHBhc3NlZCB0byBhbmQgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyLlxuICAgKlxuICAgKiBJdCBpcyBuZWNlc3NhcnkgZm9yIHRoaXMgdG8gYmUgY2FsbGVkIGR1cmluZyB0aGVcbiAgICogd2F0aGNlcidzIGRlcGVuZGVuY3kgY29sbGVjdGlvbiBwaGFzZSBiZWNhdXNlIHdlIHdhbnRcbiAgICogdGhlIHYtZm9yIHRvIHVwZGF0ZSB3aGVuIHRoZSBzb3VyY2UgT2JqZWN0IGlzIG11dGF0ZWQuXG4gICAqL1xuXG4gIF9wb3N0UHJvY2VzczogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgLy8gY29udmVydCBwbGFpbiBvYmplY3QgdG8gYXJyYXkuXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKVxuICAgICAgdmFyIGkgPSBrZXlzLmxlbmd0aFxuICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShpKVxuICAgICAgdmFyIGtleVxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2ldXG4gICAgICAgIHJlc1tpXSA9IHtcbiAgICAgICAgICAka2V5OiBrZXksXG4gICAgICAgICAgJHZhbHVlOiB2YWx1ZVtrZXldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWVcbiAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YWx1ZSA9IHJhbmdlKHZhbHVlKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWx1ZSA9IF8udG9BcnJheSh2YWx1ZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSB8fCBbXVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kcmVmc1t0aGlzLnJlZl0gPSBudWxsXG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdzKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuZnJhZ3MubGVuZ3RoXG4gICAgICB2YXIgZnJhZ1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBmcmFnID0gdGhpcy5mcmFnc1tpXVxuICAgICAgICB0aGlzLmRlbGV0ZUNhY2hlZEZyYWcoZnJhZylcbiAgICAgICAgZnJhZy5kZXN0cm95KClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZmluZCB0aGUgcHJldmlvdXMgZWxlbWVudCB0aGF0IGlzIGEgZnJhZ21lbnRcbiAqIGFuY2hvci4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBhIGRlc3Ryb3llZCBmcmFnJ3NcbiAqIGVsZW1lbnQgY291bGQgc3RpbGwgYmUgbGluZ2VyaW5nIGluIHRoZSBET00gYmVmb3JlIGl0c1xuICogbGVhdmluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLCBidXQgaXRzIGluc2VydGVkIGZsYWdcbiAqIHNob3VsZCBoYXZlIGJlZW4gc2V0IHRvIGZhbHNlIHNvIHdlIGNhbiBza2lwIHRoZW0uXG4gKlxuICogSWYgdGhpcyBpcyBhIGJsb2NrIHJlcGVhdCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2Ugb25seVxuICogcmV0dXJuIGZyYWcgdGhhdCBpcyBib3VuZCB0byB0aGlzIHYtZm9yLiAoc2VlICM5MjkpXG4gKlxuICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICogQHBhcmFtIHtDb21tZW50fFRleHR9IGFuY2hvclxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBmaW5kUHJldkZyYWcgKGZyYWcsIGFuY2hvciwgaWQpIHtcbiAgdmFyIGVsID0gZnJhZy5ub2RlLnByZXZpb3VzU2libGluZ1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFlbCkgcmV0dXJuXG4gIGZyYWcgPSBlbC5fX3ZmcmFnX19cbiAgd2hpbGUgKFxuICAgICghZnJhZyB8fCBmcmFnLmZvcklkICE9PSBpZCB8fCAhZnJhZy5pbnNlcnRlZCkgJiZcbiAgICBlbCAhPT0gYW5jaG9yXG4gICkge1xuICAgIGVsID0gZWwucHJldmlvdXNTaWJsaW5nXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFlbCkgcmV0dXJuXG4gICAgZnJhZyA9IGVsLl9fdmZyYWdfX1xuICB9XG4gIHJldHVybiBmcmFnXG59XG5cbi8qKlxuICogRmluZCBhIHZtIGZyb20gYSBmcmFnbWVudC5cbiAqXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gKiBAcmV0dXJuIHtWdWV8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGZpbmRWbUZyb21GcmFnIChmcmFnKSB7XG4gIHJldHVybiBmcmFnLm5vZGUuX192dWVfXyB8fCBmcmFnLm5vZGUubmV4dFNpYmxpbmcuX192dWVfX1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJhbmdlIGFycmF5IGZyb20gZ2l2ZW4gbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiByYW5nZSAobikge1xuICB2YXIgaSA9IC0xXG4gIHZhciByZXQgPSBuZXcgQXJyYXkobilcbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICByZXRbaV0gPSBpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cy53YXJuRHVwbGljYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgXy53YXJuKFxuICAgICAgJ0R1cGxpY2F0ZSB2YWx1ZSBmb3VuZCBpbiB2LWZvcj1cIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcuIFVzZSB0cmFjay1ieT1cIiRpbmRleFwiIGlmICcgK1xuICAgICAgJ3lvdSBhcmUgZXhwZWN0aW5nIGR1cGxpY2F0ZSB2YWx1ZXMuJ1xuICAgIClcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbnZhciB0ZW1wbGF0ZVBhcnNlciA9IHJlcXVpcmUoJy4uLy4uL3BhcnNlcnMvdGVtcGxhdGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gYSBjb21tZW50IG5vZGUgbWVhbnMgdGhpcyBpcyBhIGJpbmRpbmcgZm9yXG4gICAgLy8ge3t7IGlubGluZSB1bmVzY2FwZWQgaHRtbCB9fX1cbiAgICBpZiAodGhpcy5lbC5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgLy8gaG9sZCBub2Rlc1xuICAgICAgdGhpcy5ub2RlcyA9IFtdXG4gICAgICAvLyByZXBsYWNlIHRoZSBwbGFjZWhvbGRlciB3aXRoIHByb3BlciBhbmNob3JcbiAgICAgIHRoaXMuYW5jaG9yID0gXy5jcmVhdGVBbmNob3IoJ3YtaHRtbCcpXG4gICAgICBfLnJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpXG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBfLnRvU3RyaW5nKHZhbHVlKVxuICAgIGlmICh0aGlzLm5vZGVzKSB7XG4gICAgICB0aGlzLnN3YXAodmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gdmFsdWVcbiAgICB9XG4gIH0sXG5cbiAgc3dhcDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gcmVtb3ZlIG9sZCBub2Rlc1xuICAgIHZhciBpID0gdGhpcy5ub2Rlcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBfLnJlbW92ZSh0aGlzLm5vZGVzW2ldKVxuICAgIH1cbiAgICAvLyBjb252ZXJ0IG5ldyB2YWx1ZSB0byBhIGZyYWdtZW50XG4gICAgLy8gZG8gbm90IGF0dGVtcHQgdG8gcmV0cmlldmUgZnJvbSBpZCBzZWxlY3RvclxuICAgIHZhciBmcmFnID0gdGVtcGxhdGVQYXJzZXIucGFyc2UodmFsdWUsIHRydWUsIHRydWUpXG4gICAgLy8gc2F2ZSBhIHJlZmVyZW5jZSB0byB0aGVzZSBub2RlcyBzbyB3ZSBjYW4gcmVtb3ZlIGxhdGVyXG4gICAgdGhpcy5ub2RlcyA9IF8udG9BcnJheShmcmFnLmNoaWxkTm9kZXMpXG4gICAgXy5iZWZvcmUoZnJhZywgdGhpcy5hbmNob3IpXG4gIH1cbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG52YXIgRnJhZ21lbnRGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vZnJhZ21lbnQvZmFjdG9yeScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIHByaW9yaXR5OiAyMDAwLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsXG4gICAgaWYgKCFlbC5fX3Z1ZV9fKSB7XG4gICAgICAvLyBjaGVjayBlbHNlIGJsb2NrXG4gICAgICB2YXIgbmV4dCA9IGVsLm5leHRFbGVtZW50U2libGluZ1xuICAgICAgaWYgKG5leHQgJiYgXy5hdHRyKG5leHQsICd2LWVsc2UnKSAhPT0gbnVsbCkge1xuICAgICAgICBfLnJlbW92ZShuZXh0KVxuICAgICAgICB0aGlzLmVsc2VGYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCBuZXh0KVxuICAgICAgfVxuICAgICAgLy8gY2hlY2sgbWFpbiBibG9ja1xuICAgICAgdGhpcy5hbmNob3IgPSBfLmNyZWF0ZUFuY2hvcigndi1pZicpXG4gICAgICBfLnJlcGxhY2UoZWwsIHRoaXMuYW5jaG9yKVxuICAgICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCBlbClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICd2LWlmPVwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiBjYW5ub3QgYmUgJyArXG4gICAgICAgICd1c2VkIG9uIGFuIGluc3RhbmNlIHJvb3QgZWxlbWVudC4nXG4gICAgICApXG4gICAgICB0aGlzLmludmFsaWQgPSB0cnVlXG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkgcmV0dXJuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuZnJhZykge1xuICAgICAgICB0aGlzLmluc2VydCgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlKClcbiAgICB9XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZWxzZUZyYWcpIHtcbiAgICAgIHRoaXMuZWxzZUZyYWcucmVtb3ZlKHRydWUpXG4gICAgICB0aGlzLmVsc2VGcmFnID0gbnVsbFxuICAgIH1cbiAgICB0aGlzLmZyYWcgPSB0aGlzLmZhY3RvcnkuY3JlYXRlKHRoaXMuX2hvc3QsIHRoaXMuX3Njb3BlLCB0aGlzLl9mcmFnKVxuICAgIHRoaXMuZnJhZy5iZWZvcmUodGhpcy5hbmNob3IpXG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZnJhZykge1xuICAgICAgdGhpcy5mcmFnLnJlbW92ZSh0cnVlKVxuICAgICAgdGhpcy5mcmFnID0gbnVsbFxuICAgIH1cbiAgICBpZiAodGhpcy5lbHNlRmFjdG9yeSkge1xuICAgICAgdGhpcy5lbHNlRnJhZyA9IHRoaXMuZWxzZUZhY3RvcnkuY3JlYXRlKHRoaXMuX2hvc3QsIHRoaXMuX3Njb3BlLCB0aGlzLl9mcmFnKVxuICAgICAgdGhpcy5lbHNlRnJhZy5iZWZvcmUodGhpcy5hbmNob3IpXG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5kZXN0cm95KClcbiAgICB9XG4gIH1cbn1cbiIsIi8vIHRleHQgJiBodG1sXG5leHBvcnRzLnRleHQgPSByZXF1aXJlKCcuL3RleHQnKVxuZXhwb3J0cy5odG1sID0gcmVxdWlyZSgnLi9odG1sJylcblxuLy8gbG9naWMgY29udHJvbFxuZXhwb3J0c1snZm9yJ10gPSByZXF1aXJlKCcuL2ZvcicpXG5leHBvcnRzWydpZiddID0gcmVxdWlyZSgnLi9pZicpXG5leHBvcnRzLnNob3cgPSByZXF1aXJlKCcuL3Nob3cnKVxuXG4vLyB0d28td2F5IGJpbmRpbmdcbmV4cG9ydHMubW9kZWwgPSByZXF1aXJlKCcuL21vZGVsJylcblxuLy8gZXZlbnQgaGFuZGxpbmdcbmV4cG9ydHMub24gPSByZXF1aXJlKCcuL29uJylcblxuLy8gYXR0cmlidXRlc1xuZXhwb3J0cy5iaW5kID0gcmVxdWlyZSgnLi9iaW5kJylcblxuLy8gcmVmICYgZWxcbmV4cG9ydHMuZWwgPSByZXF1aXJlKCcuL2VsJylcbmV4cG9ydHMucmVmID0gcmVxdWlyZSgnLi9yZWYnKVxuXG4vLyBjbG9ha1xuZXhwb3J0cy5jbG9hayA9IHJlcXVpcmUoJy4vY2xvYWsnKVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBlbCA9IHRoaXMuZWxcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZWwuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpXG4gICAgICAgID8gZWwuX3ZhbHVlXG4gICAgICAgIDogc2VsZi5wYXJhbXMubnVtYmVyXG4gICAgICAgICAgPyBfLnRvTnVtYmVyKGVsLnZhbHVlKVxuICAgICAgICAgIDogZWwudmFsdWVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb29sZWFuVmFsdWUgKCkge1xuICAgICAgdmFyIHZhbCA9IGVsLmNoZWNrZWRcbiAgICAgIGlmICh2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX3RydWVWYWx1ZVxuICAgICAgfVxuICAgICAgaWYgKCF2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ19mYWxzZVZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGVsLl9mYWxzZVZhbHVlXG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtb2RlbCA9IHNlbGYuX3dhdGNoZXIudmFsdWVcbiAgICAgIGlmIChfLmlzQXJyYXkobW9kZWwpKSB7XG4gICAgICAgIHZhciB2YWwgPSBzZWxmLmdldFZhbHVlKClcbiAgICAgICAgaWYgKGVsLmNoZWNrZWQpIHtcbiAgICAgICAgICBpZiAoXy5pbmRleE9mKG1vZGVsLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgbW9kZWwucHVzaCh2YWwpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVsLiRyZW1vdmUodmFsKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNldChnZXRCb29sZWFuVmFsdWUoKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKVxuICAgIGlmIChlbC5jaGVja2VkKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXJcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsXG4gICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBfLmluZGV4T2YodmFsdWUsIHRoaXMuZ2V0VmFsdWUoKSkgPiAtMVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICBlbC5jaGVja2VkID0gXy5sb29zZUVxdWFsKHZhbHVlLCBlbC5fdHJ1ZVZhbHVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9ICEhdmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG5cbnZhciBoYW5kbGVycyA9IHtcbiAgdGV4dDogcmVxdWlyZSgnLi90ZXh0JyksXG4gIHJhZGlvOiByZXF1aXJlKCcuL3JhZGlvJyksXG4gIHNlbGVjdDogcmVxdWlyZSgnLi9zZWxlY3QnKSxcbiAgY2hlY2tib3g6IHJlcXVpcmUoJy4vY2hlY2tib3gnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBwcmlvcml0eTogODAwLFxuICB0d29XYXk6IHRydWUsXG4gIGhhbmRsZXJzOiBoYW5kbGVycyxcbiAgcGFyYW1zOiBbJ2xhenknLCAnbnVtYmVyJywgJ2RlYm91bmNlJ10sXG5cbiAgLyoqXG4gICAqIFBvc3NpYmxlIGVsZW1lbnRzOlxuICAgKiAgIDxzZWxlY3Q+XG4gICAqICAgPHRleHRhcmVhPlxuICAgKiAgIDxpbnB1dCB0eXBlPVwiKlwiPlxuICAgKiAgICAgLSB0ZXh0XG4gICAqICAgICAtIGNoZWNrYm94XG4gICAqICAgICAtIHJhZGlvXG4gICAqICAgICAtIG51bWJlclxuICAgKi9cblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZnJpZW5kbHkgd2FybmluZy4uLlxuICAgIHRoaXMuY2hlY2tGaWx0ZXJzKClcbiAgICBpZiAodGhpcy5oYXNSZWFkICYmICF0aGlzLmhhc1dyaXRlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgYSByZWFkLW9ubHkgZmlsdGVyIHdpdGggJyArXG4gICAgICAgICd2LW1vZGVsLiBZb3UgbWlnaHQgd2FudCB0byB1c2UgYSB0d28td2F5IGZpbHRlciAnICtcbiAgICAgICAgJ3RvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yLidcbiAgICAgIClcbiAgICB9XG4gICAgdmFyIGVsID0gdGhpcy5lbFxuICAgIHZhciB0YWcgPSBlbC50YWdOYW1lXG4gICAgdmFyIGhhbmRsZXJcbiAgICBpZiAodGFnID09PSAnSU5QVVQnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnNbZWwudHlwZV0gfHwgaGFuZGxlcnMudGV4dFxuICAgIH0gZWxzZSBpZiAodGFnID09PSAnU0VMRUNUJykge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXJzLnNlbGVjdFxuICAgIH0gZWxzZSBpZiAodGFnID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnMudGV4dFxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgJ3YtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBlbGVtZW50IHR5cGU6ICcgKyB0YWdcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbC5fX3ZfbW9kZWwgPSB0aGlzXG4gICAgaGFuZGxlci5iaW5kLmNhbGwodGhpcylcbiAgICB0aGlzLnVwZGF0ZSA9IGhhbmRsZXIudXBkYXRlXG4gICAgdGhpcy5fdW5iaW5kID0gaGFuZGxlci51bmJpbmRcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgcmVhZC93cml0ZSBmaWx0ZXIgc3RhdHMuXG4gICAqL1xuXG4gIGNoZWNrRmlsdGVyczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzXG4gICAgaWYgKCFmaWx0ZXJzKSByZXR1cm5cbiAgICB2YXIgaSA9IGZpbHRlcnMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGZpbHRlciA9IF8ucmVzb2x2ZUFzc2V0KHRoaXMudm0uJG9wdGlvbnMsICdmaWx0ZXJzJywgZmlsdGVyc1tpXS5uYW1lKVxuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgZmlsdGVyLnJlYWQpIHtcbiAgICAgICAgdGhpcy5oYXNSZWFkID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKGZpbHRlci53cml0ZSkge1xuICAgICAgICB0aGlzLmhhc1dyaXRlID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsLl9fdl9tb2RlbCA9IG51bGxcbiAgICB0aGlzLl91bmJpbmQgJiYgdGhpcy5fdW5iaW5kKClcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBlbCA9IHRoaXMuZWxcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB2YWx1ZSBvdmVyd3JpdGUgdmlhIHYtYmluZDp2YWx1ZVxuICAgICAgaWYgKGVsLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX3ZhbHVlXG4gICAgICB9XG4gICAgICB2YXIgdmFsID0gZWwudmFsdWVcbiAgICAgIGlmIChzZWxmLnBhcmFtcy5udW1iZXIpIHtcbiAgICAgICAgdmFsID0gXy50b051bWJlcih2YWwpXG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuc2V0KHNlbGYuZ2V0VmFsdWUoKSlcbiAgICB9XG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcilcblxuICAgIGlmIChlbC5jaGVja2VkKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXJcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmVsLmNoZWNrZWQgPSBfLmxvb3NlRXF1YWwodmFsdWUsIHRoaXMuZ2V0VmFsdWUoKSlcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBlbCA9IHRoaXMuZWxcblxuICAgIC8vIG1ldGhvZCB0byBmb3JjZSB1cGRhdGUgRE9NIHVzaW5nIGxhdGVzdCB2YWx1ZS5cbiAgICB0aGlzLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuX3dhdGNoZXIpIHtcbiAgICAgICAgc2VsZi51cGRhdGUoc2VsZi5fd2F0Y2hlci5nZXQoKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGEgbXVsdGlwbGUgc2VsZWN0XG4gICAgdmFyIG11bHRpcGxlID0gdGhpcy5tdWx0aXBsZSA9IGVsLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKVxuXG4gICAgLy8gYXR0YWNoIGxpc3RlbmVyXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKGVsLCBtdWx0aXBsZSlcbiAgICAgIHZhbHVlID0gc2VsZi5wYXJhbXMubnVtYmVyXG4gICAgICAgID8gXy5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgID8gdmFsdWUubWFwKF8udG9OdW1iZXIpXG4gICAgICAgICAgOiBfLnRvTnVtYmVyKHZhbHVlKVxuICAgICAgICA6IHZhbHVlXG4gICAgICBzZWxmLnNldCh2YWx1ZSlcbiAgICB9XG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcilcblxuICAgIC8vIGlmIGhhcyBpbml0aWFsIHZhbHVlLCBzZXQgYWZ0ZXJCaW5kXG4gICAgdmFyIGluaXRWYWx1ZSA9IGdldFZhbHVlKGVsLCBtdWx0aXBsZSwgdHJ1ZSlcbiAgICBpZiAoKG11bHRpcGxlICYmIGluaXRWYWx1ZS5sZW5ndGgpIHx8XG4gICAgICAgICghbXVsdGlwbGUgJiYgaW5pdFZhbHVlICE9PSBudWxsKSkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyXG4gICAgfVxuXG4gICAgLy8gQWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBGaXJlZm94IHJlc2V0c1xuICAgIC8vIHNlbGVjdGVkSW5kZXggd2l0aCB2YWx1ZSAtMSB0byAwIHdoZW4gdGhlIGVsZW1lbnRcbiAgICAvLyBpcyBhcHBlbmRlZCB0byBhIG5ldyBwYXJlbnQsIHRoZXJlZm9yZSB3ZSBoYXZlIHRvXG4gICAgLy8gZm9yY2UgYSBET00gdXBkYXRlIHdoZW5ldmVyIHRoYXQgaGFwcGVucy4uLlxuICAgIHRoaXMudm0uJG9uKCdob29rOmF0dGFjaGVkJywgdGhpcy5mb3JjZVVwZGF0ZSlcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWxcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTFcbiAgICB2YXIgbXVsdGkgPSB0aGlzLm11bHRpcGxlICYmIF8uaXNBcnJheSh2YWx1ZSlcbiAgICB2YXIgb3B0aW9ucyA9IGVsLm9wdGlvbnNcbiAgICB2YXIgaSA9IG9wdGlvbnMubGVuZ3RoXG4gICAgdmFyIG9wLCB2YWxcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBvcCA9IG9wdGlvbnNbaV1cbiAgICAgIHZhbCA9IG9wLmhhc093blByb3BlcnR5KCdfdmFsdWUnKVxuICAgICAgICA/IG9wLl92YWx1ZVxuICAgICAgICA6IG9wLnZhbHVlXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgICAgIG9wLnNlbGVjdGVkID0gbXVsdGlcbiAgICAgICAgPyBpbmRleE9mKHZhbHVlLCB2YWwpID4gLTFcbiAgICAgICAgOiBfLmxvb3NlRXF1YWwodmFsdWUsIHZhbClcbiAgICAgIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhpcy52bS4kb2ZmKCdob29rOmF0dGFjaGVkJywgdGhpcy5mb3JjZVVwZGF0ZSlcbiAgfVxufVxuXG4vKipcbiAqIEdldCBzZWxlY3QgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge1NlbGVjdEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG11bHRpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEByZXR1cm4ge0FycmF5fCp9XG4gKi9cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKGVsLCBtdWx0aSwgaW5pdCkge1xuICB2YXIgcmVzID0gbXVsdGkgPyBbXSA6IG51bGxcbiAgdmFyIG9wLCB2YWwsIHNlbGVjdGVkXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcCA9IGVsLm9wdGlvbnNbaV1cbiAgICBzZWxlY3RlZCA9IGluaXRcbiAgICAgID8gb3AuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpXG4gICAgICA6IG9wLnNlbGVjdGVkXG4gICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICB2YWwgPSBvcC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJylcbiAgICAgICAgPyBvcC5fdmFsdWVcbiAgICAgICAgOiBvcC52YWx1ZVxuICAgICAgaWYgKG11bHRpKSB7XG4gICAgICAgIHJlcy5wdXNoKHZhbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIE5hdGl2ZSBBcnJheS5pbmRleE9mIHVzZXMgc3RyaWN0IGVxdWFsLCBidXQgaW4gdGhpc1xuICogY2FzZSB3ZSBuZWVkIHRvIG1hdGNoIHN0cmluZy9udW1iZXJzIHdpdGggY3VzdG9tIGVxdWFsLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBpbmRleE9mIChhcnIsIHZhbCkge1xuICB2YXIgaSA9IGFyci5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChfLmxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICB2YXIgZWwgPSB0aGlzLmVsXG4gICAgdmFyIGlzUmFuZ2UgPSBlbC50eXBlID09PSAncmFuZ2UnXG4gICAgdmFyIGxhenkgPSB0aGlzLnBhcmFtcy5sYXp5XG4gICAgdmFyIG51bWJlciA9IHRoaXMucGFyYW1zLm51bWJlclxuICAgIHZhciBkZWJvdW5jZSA9IHRoaXMucGFyYW1zLmRlYm91bmNlXG5cbiAgICAvLyBoYW5kbGUgY29tcG9zaXRpb24gZXZlbnRzLlxuICAgIC8vICAgaHR0cDovL2Jsb2cuZXZhbnlvdS5tZS8yMDE0LzAxLzAzL2NvbXBvc2l0aW9uLWV2ZW50L1xuICAgIC8vIHNraXAgdGhpcyBmb3IgQW5kcm9pZCBiZWNhdXNlIGl0IGhhbmRsZXMgY29tcG9zaXRpb25cbiAgICAvLyBldmVudHMgcXVpdGUgZGlmZmVyZW50bHkuIEFuZHJvaWQgZG9lc24ndCB0cmlnZ2VyXG4gICAgLy8gY29tcG9zaXRpb24gZXZlbnRzIGZvciBsYW5ndWFnZSBpbnB1dCBtZXRob2RzIGUuZy5cbiAgICAvLyBDaGluZXNlLCBidXQgaW5zdGVhZCB0cmlnZ2VycyB0aGVtIGZvciBzcGVsbGluZ1xuICAgIC8vIHN1Z2dlc3Rpb25zLi4uIChzZWUgRGlzY3Vzc2lvbi8jMTYyKVxuICAgIHZhciBjb21wb3NpbmcgPSBmYWxzZVxuICAgIGlmICghXy5pc0FuZHJvaWQgJiYgIWlzUmFuZ2UpIHtcbiAgICAgIHRoaXMub24oJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXBvc2luZyA9IHRydWVcbiAgICAgIH0pXG4gICAgICB0aGlzLm9uKCdjb21wb3NpdGlvbmVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tcG9zaW5nID0gZmFsc2VcbiAgICAgICAgLy8gaW4gSUUxMSB0aGUgXCJjb21wb3NpdGlvbmVuZFwiIGV2ZW50IGZpcmVzIEFGVEVSXG4gICAgICAgIC8vIHRoZSBcImlucHV0XCIgZXZlbnQsIHNvIHRoZSBpbnB1dCBoYW5kbGVyIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gYXQgdGhlIGVuZC4uLiBoYXZlIHRvIGNhbGwgaXQgaGVyZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gIzEzMjc6IGluIGxhenkgbW9kZSB0aGlzIGlzIHVuZWNlc3NhcnkuXG4gICAgICAgIGlmICghbGF6eSkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXIoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIHByZXZlbnQgbWVzc2luZyB3aXRoIHRoZSBpbnB1dCB3aGVuIHVzZXIgaXMgdHlwaW5nLFxuICAgIC8vIGFuZCBmb3JjZSB1cGRhdGUgb24gYmx1ci5cbiAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZVxuICAgIGlmICghaXNSYW5nZSkge1xuICAgICAgdGhpcy5vbignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZm9jdXNlZCA9IHRydWVcbiAgICAgIH0pXG4gICAgICB0aGlzLm9uKCdibHVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmZvY3VzZWQgPSBmYWxzZVxuICAgICAgICBzZWxmLmxpc3RlbmVyKClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gTm93IGF0dGFjaCB0aGUgbWFpbiBsaXN0ZW5lclxuICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29tcG9zaW5nKSByZXR1cm5cbiAgICAgIHZhciB2YWwgPSBudW1iZXIgfHwgaXNSYW5nZVxuICAgICAgICA/IF8udG9OdW1iZXIoZWwudmFsdWUpXG4gICAgICAgIDogZWwudmFsdWVcbiAgICAgIHNlbGYuc2V0KHZhbClcbiAgICAgIC8vIGZvcmNlIHVwZGF0ZSBvbiBuZXh0IHRpY2sgdG8gYXZvaWQgbG9jayAmIHNhbWUgdmFsdWVcbiAgICAgIC8vIGFsc28gb25seSB1cGRhdGUgd2hlbiB1c2VyIGlzIG5vdCB0eXBpbmdcbiAgICAgIF8ubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5fYm91bmQgJiYgIXNlbGYuZm9jdXNlZCkge1xuICAgICAgICAgIHNlbGYudXBkYXRlKHNlbGYuX3dhdGNoZXIudmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgZGVib3VuY2VcbiAgICBpZiAoZGVib3VuY2UpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIgPSBfLmRlYm91bmNlKHRoaXMubGlzdGVuZXIsIGRlYm91bmNlKVxuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgalF1ZXJ5IGV2ZW50cywgc2luY2UgalF1ZXJ5LnRyaWdnZXIoKSBkb2Vzbid0XG4gICAgLy8gdHJpZ2dlciBuYXRpdmUgZXZlbnRzIGluIHNvbWUgY2FzZXMgYW5kIHNvbWUgcGx1Z2luc1xuICAgIC8vIHJlbHkgb24gJC50cmlnZ2VyKClcbiAgICAvL1xuICAgIC8vIFdlIHdhbnQgdG8gbWFrZSBzdXJlIGlmIGEgbGlzdGVuZXIgaXMgYXR0YWNoZWQgdXNpbmdcbiAgICAvLyBqUXVlcnksIGl0IGlzIGFsc28gcmVtb3ZlZCB3aXRoIGpRdWVyeSwgdGhhdCdzIHdoeVxuICAgIC8vIHdlIGRvIHRoZSBjaGVjayBmb3IgZWFjaCBkaXJlY3RpdmUgaW5zdGFuY2UgYW5kXG4gICAgLy8gc3RvcmUgdGhhdCBjaGVjayByZXN1bHQgb24gaXRzZWxmLiBUaGlzIGFsc28gYWxsb3dzXG4gICAgLy8gZWFzaWVyIHRlc3QgY292ZXJhZ2UgY29udHJvbCBieSB1bnNldHRpbmcgdGhlIGdsb2JhbFxuICAgIC8vIGpRdWVyeSB2YXJpYWJsZSBpbiB0ZXN0cy5cbiAgICB0aGlzLmhhc2pRdWVyeSA9IHR5cGVvZiBqUXVlcnkgPT09ICdmdW5jdGlvbidcbiAgICBpZiAodGhpcy5oYXNqUXVlcnkpIHtcbiAgICAgIGpRdWVyeShlbCkub24oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpXG4gICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgalF1ZXJ5KGVsKS5vbignaW5wdXQnLCB0aGlzLmxpc3RlbmVyKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKVxuICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgIHRoaXMub24oJ2lucHV0JywgdGhpcy5saXN0ZW5lcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTkgZG9lc24ndCBmaXJlIGlucHV0IGV2ZW50IG9uIGJhY2tzcGFjZS9kZWwvY3V0XG4gICAgaWYgKCFsYXp5ICYmIF8uaXNJRTkpIHtcbiAgICAgIHRoaXMub24oJ2N1dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgXy5uZXh0VGljayhzZWxmLmxpc3RlbmVyKVxuICAgICAgfSlcbiAgICAgIHRoaXMub24oJ2tleXVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gNDYgfHwgZS5rZXlDb2RlID09PSA4KSB7XG4gICAgICAgICAgc2VsZi5saXN0ZW5lcigpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gc2V0IGluaXRpYWwgdmFsdWUgaWYgcHJlc2VudFxuICAgIGlmIChcbiAgICAgIGVsLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSB8fFxuICAgICAgKGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiYgZWwudmFsdWUudHJpbSgpKVxuICAgICkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyXG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5lbC52YWx1ZSA9IF8udG9TdHJpbmcodmFsdWUpXG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbFxuICAgIGlmICh0aGlzLmhhc2pRdWVyeSkge1xuICAgICAgalF1ZXJ5KGVsKS5vZmYoJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpXG4gICAgICBqUXVlcnkoZWwpLm9mZignaW5wdXQnLCB0aGlzLmxpc3RlbmVyKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsJylcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gICdkZWxldGUnOiA0NixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MFxufVxuXG5mdW5jdGlvbiBrZXlGaWx0ZXIgKGhhbmRsZXIsIGtleXMpIHtcbiAgdmFyIGNvZGVzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjb2RlID0ga2V5Q29kZXNba2V5XVxuICAgIGlmICghY29kZSkge1xuICAgICAgY29kZSA9IHBhcnNlSW50KGtleSwgMTApXG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH0pXG4gIHJldHVybiBmdW5jdGlvbiBrZXlIYW5kbGVyIChlKSB7XG4gICAgaWYgKGNvZGVzLmluZGV4T2YoZS5rZXlDb2RlKSA+IC0xKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BGaWx0ZXIgKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0b3BIYW5kbGVyIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmV2ZW50RmlsdGVyIChoYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50SGFuZGxlciAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBhY2NlcHRTdGF0ZW1lbnQ6IHRydWUsXG4gIHByaW9yaXR5OiA3MDAsXG5cbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIC8vIGRlYWwgd2l0aCBpZnJhbWVzXG4gICAgaWYgKFxuICAgICAgdGhpcy5lbC50YWdOYW1lID09PSAnSUZSQU1FJyAmJlxuICAgICAgdGhpcy5hcmcgIT09ICdsb2FkJ1xuICAgICkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICB0aGlzLmlmcmFtZUJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF8ub24oc2VsZi5lbC5jb250ZW50V2luZG93LCBzZWxmLmFyZywgc2VsZi5oYW5kbGVyKVxuICAgICAgfVxuICAgICAgdGhpcy5vbignbG9hZCcsIHRoaXMuaWZyYW1lQmluZClcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIC8vIHN0dWIgYSBub29wIGZvciB2LW9uIHdpdGggbm8gdmFsdWUsXG4gICAgLy8gZS5nLiBAbW91c2Vkb3duLnByZXZlbnRcbiAgICBpZiAoIXRoaXMuZGVzY3JpcHRvci5yYXcpIHtcbiAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7fVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICd2LW9uOicgKyB0aGlzLmFyZyArICc9XCInICtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uICsgJ1wiIGV4cGVjdHMgYSBmdW5jdGlvbiB2YWx1ZSwgJyArXG4gICAgICAgICdnb3QgJyArIGhhbmRsZXJcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGFwcGx5IG1vZGlmaWVyc1xuICAgIGlmICh0aGlzLm1vZGlmaWVycy5zdG9wKSB7XG4gICAgICBoYW5kbGVyID0gc3RvcEZpbHRlcihoYW5kbGVyKVxuICAgIH1cbiAgICBpZiAodGhpcy5tb2RpZmllcnMucHJldmVudCkge1xuICAgICAgaGFuZGxlciA9IHByZXZlbnRGaWx0ZXIoaGFuZGxlcilcbiAgICB9XG4gICAgLy8ga2V5IGZpbHRlclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5tb2RpZmllcnMpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSAhPT0gJ3N0b3AnICYmIGtleSAhPT0gJ3ByZXZlbnQnXG4gICAgICB9KVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgaGFuZGxlciA9IGtleUZpbHRlcihoYW5kbGVyLCBrZXlzKVxuICAgIH1cblxuICAgIHRoaXMucmVzZXQoKVxuICAgIHZhciBzY29wZSA9IHRoaXMuX3Njb3BlIHx8IHRoaXMudm1cbiAgICB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgc2NvcGUuJGV2ZW50ID0gZVxuICAgICAgdmFyIHJlcyA9IGhhbmRsZXIoZSlcbiAgICAgIHNjb3BlLiRldmVudCA9IG51bGxcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gICAgaWYgKHRoaXMuaWZyYW1lQmluZCkge1xuICAgICAgdGhpcy5pZnJhbWVCaW5kKClcbiAgICB9IGVsc2Uge1xuICAgICAgXy5vbih0aGlzLmVsLCB0aGlzLmFyZywgdGhpcy5oYW5kbGVyKVxuICAgIH1cbiAgfSxcblxuICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IHRoaXMuaWZyYW1lQmluZFxuICAgICAgPyB0aGlzLmVsLmNvbnRlbnRXaW5kb3dcbiAgICAgIDogdGhpcy5lbFxuICAgIGlmICh0aGlzLmhhbmRsZXIpIHtcbiAgICAgIF8ub2ZmKGVsLCB0aGlzLmFyZywgdGhpcy5oYW5kbGVyKVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2V0KClcbiAgfVxufVxuIiwiaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmVxdWlyZSgnLi4vLi4vdXRpbCcpLndhcm4oXG4gICAgICAgICd2LXJlZjonICsgdGhpcy5hcmcgKyAnIG11c3QgYmUgdXNlZCBvbiBhIGNoaWxkICcgK1xuICAgICAgICAnY29tcG9uZW50LiBGb3VuZCBvbiA8JyArIHRoaXMuZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgJz4uJ1xuICAgICAgKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbnZhciB0cmFuc2l0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHJhbnNpdGlvbicpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjaGVjayBlbHNlIGJsb2NrXG4gICAgdmFyIG5leHQgPSB0aGlzLmVsLm5leHRFbGVtZW50U2libGluZ1xuICAgIGlmIChuZXh0ICYmIF8uYXR0cihuZXh0LCAndi1lbHNlJykgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZWxzZUVsID0gbmV4dFxuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWxcbiAgICB0cmFuc2l0aW9uLmFwcGx5KGVsLCB2YWx1ZSA/IDEgOiAtMSwgZnVuY3Rpb24gKCkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gJycgOiAnbm9uZSdcbiAgICB9LCB0aGlzLnZtKVxuICAgIHZhciBlbHNlRWwgPSB0aGlzLmVsc2VFbFxuICAgIGlmIChlbHNlRWwpIHtcbiAgICAgIHRyYW5zaXRpb24uYXBwbHkoZWxzZUVsLCB2YWx1ZSA/IC0xIDogMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbHNlRWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gJ25vbmUnIDogJydcbiAgICAgIH0sIHRoaXMudm0pXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hdHRyID0gdGhpcy5lbC5ub2RlVHlwZSA9PT0gM1xuICAgICAgPyAnZGF0YSdcbiAgICAgIDogJ3RleHRDb250ZW50J1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5lbFt0aGlzLmF0dHJdID0gXy50b1N0cmluZyh2YWx1ZSlcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBQYXRoID0gcmVxdWlyZSgnLi4vcGFyc2Vycy9wYXRoJylcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgnLi4vZGlyZWN0aXZlcy9wdWJsaWMvZm9yJykuX3Bvc3RQcm9jZXNzXG5cbi8qKlxuICogTGltaXQgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICovXG5cbmV4cG9ydHMubGltaXRCeSA9IGZ1bmN0aW9uIChhcnIsIG4pIHtcbiAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJ1xuICAgID8gYXJyLnNsaWNlKDAsIG4pXG4gICAgOiBhcnJcbn1cblxuLyoqXG4gKiBGaWx0ZXIgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoS2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gW2RlbGltaXRlcl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhS2V5XG4gKi9cblxuZXhwb3J0cy5maWx0ZXJCeSA9IGZ1bmN0aW9uIChhcnIsIHNlYXJjaCwgZGVsaW1pdGVyIC8qIC4uLmRhdGFLZXlzICovKSB7XG4gIGFyciA9IHRvQXJyYXkoYXJyKVxuICBpZiAoc2VhcmNoID09IG51bGwpIHtcbiAgICByZXR1cm4gYXJyXG4gIH1cbiAgaWYgKHR5cGVvZiBzZWFyY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYXJyLmZpbHRlcihzZWFyY2gpXG4gIH1cbiAgLy8gY2FzdCB0byBsb3dlcmNhc2Ugc3RyaW5nXG4gIHNlYXJjaCA9ICgnJyArIHNlYXJjaCkudG9Mb3dlckNhc2UoKVxuICAvLyBhbGxvdyBvcHRpb25hbCBgaW5gIGRlbGltaXRlclxuICAvLyBiZWNhdXNlIHdoeSBub3RcbiAgdmFyIG4gPSBkZWxpbWl0ZXIgPT09ICdpbicgPyAzIDogMlxuICAvLyBleHRyYWN0IGFuZCBmbGF0dGVuIGtleXNcbiAgdmFyIGtleXMgPSBfLnRvQXJyYXkoYXJndW1lbnRzLCBuKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgIHJldHVybiBwcmV2LmNvbmNhdChjdXIpXG4gIH0sIFtdKVxuICB2YXIgcmVzID0gW11cbiAgdmFyIGl0ZW0sIGtleSwgdmFsLCBqXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBhcnJbaV1cbiAgICB2YWwgPSAoaXRlbSAmJiBpdGVtLiR2YWx1ZSkgfHwgaXRlbVxuICAgIGogPSBrZXlzLmxlbmd0aFxuICAgIGlmIChqKSB7XG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGtleSA9IGtleXNbal1cbiAgICAgICAgaWYgKChrZXkgPT09ICcka2V5JyAmJiBjb250YWlucyhpdGVtLiRrZXksIHNlYXJjaCkpIHx8XG4gICAgICAgICAgICBjb250YWlucyhQYXRoLmdldCh2YWwsIGtleSksIHNlYXJjaCkpIHtcbiAgICAgICAgICByZXMucHVzaChpdGVtKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zKGl0ZW0sIHNlYXJjaCkpIHtcbiAgICAgIHJlcy5wdXNoKGl0ZW0pXG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBGaWx0ZXIgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc29ydEtleVxuICogQHBhcmFtIHtTdHJpbmd9IHJldmVyc2VcbiAqL1xuXG5leHBvcnRzLm9yZGVyQnkgPSBmdW5jdGlvbiAoYXJyLCBzb3J0S2V5LCByZXZlcnNlKSB7XG4gIGFyciA9IHRvQXJyYXkoYXJyKVxuICBpZiAoIXNvcnRLZXkpIHtcbiAgICByZXR1cm4gYXJyXG4gIH1cbiAgdmFyIG9yZGVyID0gKHJldmVyc2UgJiYgcmV2ZXJzZSA8IDApID8gLTEgOiAxXG4gIC8vIHNvcnQgb24gYSBjb3B5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGFycmF5XG4gIHJldHVybiBhcnIuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKHNvcnRLZXkgIT09ICcka2V5Jykge1xuICAgICAgaWYgKF8uaXNPYmplY3QoYSkgJiYgJyR2YWx1ZScgaW4gYSkgYSA9IGEuJHZhbHVlXG4gICAgICBpZiAoXy5pc09iamVjdChiKSAmJiAnJHZhbHVlJyBpbiBiKSBiID0gYi4kdmFsdWVcbiAgICB9XG4gICAgYSA9IF8uaXNPYmplY3QoYSkgPyBQYXRoLmdldChhLCBzb3J0S2V5KSA6IGFcbiAgICBiID0gXy5pc09iamVjdChiKSA/IFBhdGguZ2V0KGIsIHNvcnRLZXkpIDogYlxuICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gb3JkZXIgOiAtb3JkZXJcbiAgfSlcbn1cblxuLyoqXG4gKiBTdHJpbmcgY29udGFpbiBoZWxwZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5zICh2YWwsIHNlYXJjaCkge1xuICB2YXIgaVxuICBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbClcbiAgICBpID0ga2V5cy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY29udGFpbnModmFsW2tleXNbaV1dLCBzZWFyY2gpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKF8uaXNBcnJheSh2YWwpKSB7XG4gICAgaSA9IHZhbC5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY29udGFpbnModmFsW2ldLCBzZWFyY2gpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gpID4gLTFcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcblxuLyoqXG4gKiBTdHJpbmdpZnkgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGVudFxuICovXG5cbmV4cG9ydHMuanNvbiA9IHtcbiAgcmVhZDogZnVuY3Rpb24gKHZhbHVlLCBpbmRlbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgPyB2YWx1ZVxuICAgICAgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgTnVtYmVyKGluZGVudCkgfHwgMilcbiAgfSxcbiAgd3JpdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiAnYWJjJyA9PiAnQWJjJ1xuICovXG5cbmV4cG9ydHMuY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSByZXR1cm4gJydcbiAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpXG4gIHJldHVybiB2YWx1ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbHVlLnNsaWNlKDEpXG59XG5cbi8qKlxuICogJ2FiYycgPT4gJ0FCQydcbiAqL1xuXG5leHBvcnRzLnVwcGVyY2FzZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlIHx8IHZhbHVlID09PSAwKVxuICAgID8gdmFsdWUudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpXG4gICAgOiAnJ1xufVxuXG4vKipcbiAqICdBYkMnID0+ICdhYmMnXG4gKi9cblxuZXhwb3J0cy5sb3dlcmNhc2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMClcbiAgICA/IHZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKVxuICAgIDogJydcbn1cblxuLyoqXG4gKiAxMjM0NSA9PiAkMTIsMzQ1LjAwXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ25cbiAqL1xuXG52YXIgZGlnaXRzUkUgPSAvKFxcZHszfSkoPz1cXGQpL2dcbmV4cG9ydHMuY3VycmVuY3kgPSBmdW5jdGlvbiAodmFsdWUsIGN1cnJlbmN5KSB7XG4gIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSlcbiAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkgfHwgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkpIHJldHVybiAnJ1xuICBjdXJyZW5jeSA9IGN1cnJlbmN5ICE9IG51bGwgPyBjdXJyZW5jeSA6ICckJ1xuICB2YXIgc3RyaW5naWZpZWQgPSBNYXRoLmFicyh2YWx1ZSkudG9GaXhlZCgyKVxuICB2YXIgX2ludCA9IHN0cmluZ2lmaWVkLnNsaWNlKDAsIC0zKVxuICB2YXIgaSA9IF9pbnQubGVuZ3RoICUgM1xuICB2YXIgaGVhZCA9IGkgPiAwXG4gICAgPyAoX2ludC5zbGljZSgwLCBpKSArIChfaW50Lmxlbmd0aCA+IDMgPyAnLCcgOiAnJykpXG4gICAgOiAnJ1xuICB2YXIgX2Zsb2F0ID0gc3RyaW5naWZpZWQuc2xpY2UoLTMpXG4gIHZhciBzaWduID0gdmFsdWUgPCAwID8gJy0nIDogJydcbiAgcmV0dXJuIGN1cnJlbmN5ICsgc2lnbiArIGhlYWQgK1xuICAgIF9pbnQuc2xpY2UoaSkucmVwbGFjZShkaWdpdHNSRSwgJyQxLCcpICtcbiAgICBfZmxvYXRcbn1cblxuLyoqXG4gKiAnaXRlbScgPT4gJ2l0ZW1zJ1xuICpcbiAqIEBwYXJhbXNcbiAqICBhbiBhcnJheSBvZiBzdHJpbmdzIGNvcnJlc3BvbmRpbmcgdG9cbiAqICB0aGUgc2luZ2xlLCBkb3VibGUsIHRyaXBsZSAuLi4gZm9ybXMgb2YgdGhlIHdvcmQgdG9cbiAqICBiZSBwbHVyYWxpemVkLiBXaGVuIHRoZSBudW1iZXIgdG8gYmUgcGx1cmFsaXplZFxuICogIGV4Y2VlZHMgdGhlIGxlbmd0aCBvZiB0aGUgYXJncywgaXQgd2lsbCB1c2UgdGhlIGxhc3RcbiAqICBlbnRyeSBpbiB0aGUgYXJyYXkuXG4gKlxuICogIGUuZy4gWydzaW5nbGUnLCAnZG91YmxlJywgJ3RyaXBsZScsICdtdWx0aXBsZSddXG4gKi9cblxuZXhwb3J0cy5wbHVyYWxpemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIGFyZ3MgPSBfLnRvQXJyYXkoYXJndW1lbnRzLCAxKVxuICByZXR1cm4gYXJncy5sZW5ndGggPiAxXG4gICAgPyAoYXJnc1t2YWx1ZSAlIDEwIC0gMV0gfHwgYXJnc1thcmdzLmxlbmd0aCAtIDFdKVxuICAgIDogKGFyZ3NbMF0gKyAodmFsdWUgPT09IDEgPyAnJyA6ICdzJykpXG59XG5cbi8qKlxuICogRGVib3VuY2UgYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSA9IDMwMFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZXhwb3J0cy5kZWJvdW5jZSA9IGZ1bmN0aW9uIChoYW5kbGVyLCBkZWxheSkge1xuICBpZiAoIWhhbmRsZXIpIHJldHVyblxuICBpZiAoIWRlbGF5KSB7XG4gICAgZGVsYXkgPSAzMDBcbiAgfVxuICByZXR1cm4gXy5kZWJvdW5jZShoYW5kbGVyLCBkZWxheSlcbn1cblxuLyoqXG4gKiBJbnN0YWxsIHNwZWNpYWwgYXJyYXkgZmlsdGVyc1xuICovXG5cbl8uZXh0ZW5kKGV4cG9ydHMsIHJlcXVpcmUoJy4vYXJyYXktZmlsdGVycycpKVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBjb21waWxlciA9IHJlcXVpcmUoJy4uL2NvbXBpbGVyJylcbnZhciB0ZW1wbGF0ZVBhcnNlciA9IHJlcXVpcmUoJy4uL3BhcnNlcnMvdGVtcGxhdGUnKVxudmFyIEZyYWdtZW50ID0gcmVxdWlyZSgnLi9mcmFnbWVudCcpXG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZScpXG52YXIgbGlua2VyQ2FjaGUgPSBuZXcgQ2FjaGUoNTAwMClcblxuLyoqXG4gKiBBIGZhY3RvcnkgdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIGFcbiAqIGZyYWdtZW50LiBDYWNoZXMgdGhlIGNvbXBpbGVkIGxpbmtlciBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsXG4gKi9cblxuZnVuY3Rpb24gRnJhZ21lbnRGYWN0b3J5ICh2bSwgZWwpIHtcbiAgdGhpcy52bSA9IHZtXG4gIHZhciB0ZW1wbGF0ZVxuICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgZWwgPT09ICdzdHJpbmcnXG4gIGlmIChpc1N0cmluZyB8fCBfLmlzVGVtcGxhdGUoZWwpKSB7XG4gICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZVBhcnNlci5wYXJzZShlbCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKGVsKVxuICB9XG4gIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZVxuICAvLyBsaW5rZXIgY2FuIGJlIGNhY2hlZCwgYnV0IG9ubHkgZm9yIGNvbXBvbmVudHNcbiAgdmFyIGxpbmtlclxuICB2YXIgY2lkID0gdm0uY29uc3RydWN0b3IuY2lkXG4gIGlmIChjaWQgPiAwKSB7XG4gICAgdmFyIGNhY2hlSWQgPSBjaWQgKyAoaXNTdHJpbmcgPyBlbCA6IGVsLm91dGVySFRNTClcbiAgICBsaW5rZXIgPSBsaW5rZXJDYWNoZS5nZXQoY2FjaGVJZClcbiAgICBpZiAoIWxpbmtlcikge1xuICAgICAgbGlua2VyID0gY29tcGlsZXIuY29tcGlsZSh0ZW1wbGF0ZSwgdm0uJG9wdGlvbnMsIHRydWUpXG4gICAgICBsaW5rZXJDYWNoZS5wdXQoY2FjaGVJZCwgbGlua2VyKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsaW5rZXIgPSBjb21waWxlci5jb21waWxlKHRlbXBsYXRlLCB2bS4kb3B0aW9ucywgdHJ1ZSlcbiAgfVxuICB0aGlzLmxpbmtlciA9IGxpbmtlclxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGZyYWdtZW50IGluc3RhbmNlIHdpdGggZ2l2ZW4gaG9zdCBhbmQgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtWdWV9IGhvc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQHBhcmFtIHtGcmFnbWVudH0gcGFyZW50RnJhZ1xuICovXG5cbkZyYWdtZW50RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gIHZhciBmcmFnID0gdGVtcGxhdGVQYXJzZXIuY2xvbmUodGhpcy50ZW1wbGF0ZSlcbiAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmxpbmtlciwgdGhpcy52bSwgZnJhZywgaG9zdCwgc2NvcGUsIHBhcmVudEZyYWcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhZ21lbnRGYWN0b3J5XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHRyYW5zaXRpb24gPSByZXF1aXJlKCcuLi90cmFuc2l0aW9uJylcblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBmb3IgYSBwYXJ0aWFsbHktY29tcGlsZWQgZnJhZ21lbnQuXG4gKiBDYW4gb3B0aW9uYWxseSBjb21waWxlIGNvbnRlbnQgd2l0aCBhIGNoaWxkIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpbmtlclxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7VnVlfSBbaG9zdF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gKi9cblxuZnVuY3Rpb24gRnJhZ21lbnQgKGxpbmtlciwgdm0sIGZyYWcsIGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXVxuICB0aGlzLmNoaWxkRnJhZ3MgPSBbXVxuICB0aGlzLnZtID0gdm1cbiAgdGhpcy5zY29wZSA9IHNjb3BlXG4gIHRoaXMuaW5zZXJ0ZWQgPSBmYWxzZVxuICB0aGlzLnBhcmVudEZyYWcgPSBwYXJlbnRGcmFnXG4gIGlmIChwYXJlbnRGcmFnKSB7XG4gICAgcGFyZW50RnJhZy5jaGlsZEZyYWdzLnB1c2godGhpcylcbiAgfVxuICB0aGlzLnVubGluayA9IGxpbmtlcih2bSwgZnJhZywgaG9zdCwgc2NvcGUsIHRoaXMpXG4gIHZhciBzaW5nbGUgPSB0aGlzLnNpbmdsZSA9IGZyYWcuY2hpbGROb2Rlcy5sZW5ndGggPT09IDFcbiAgaWYgKHNpbmdsZSkge1xuICAgIHRoaXMubm9kZSA9IGZyYWcuY2hpbGROb2Rlc1swXVxuICAgIHRoaXMuYmVmb3JlID0gc2luZ2xlQmVmb3JlXG4gICAgdGhpcy5yZW1vdmUgPSBzaW5nbGVSZW1vdmVcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5vZGUgPSBfLmNyZWF0ZUFuY2hvcignZnJhZ21lbnQtc3RhcnQnKVxuICAgIHRoaXMuZW5kID0gXy5jcmVhdGVBbmNob3IoJ2ZyYWdtZW50LWVuZCcpXG4gICAgdGhpcy5mcmFnID0gZnJhZ1xuICAgIF8ucHJlcGVuZCh0aGlzLm5vZGUsIGZyYWcpXG4gICAgZnJhZy5hcHBlbmRDaGlsZCh0aGlzLmVuZClcbiAgICB0aGlzLmJlZm9yZSA9IG11bHRpQmVmb3JlXG4gICAgdGhpcy5yZW1vdmUgPSBtdWx0aVJlbW92ZVxuICB9XG4gIHRoaXMubm9kZS5fX3ZmcmFnX18gPSB0aGlzXG59XG5cbi8qKlxuICogQ2FsbCBhdHRhY2gvZGV0YWNoIGZvciBhbGwgY29tcG9uZW50cyBjb250YWluZWQgd2l0aGluXG4gKiB0aGlzIGZyYWdtZW50LiBBbHNvIGRvIHNvIHJlY3Vyc2l2ZWx5IGZvciBhbGwgY2hpbGRcbiAqIGZyYWdtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmNhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgdmFyIGksIGxcbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaG9vayh0aGlzLmNoaWxkcmVuW2ldKVxuICB9XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5jaGlsZEZyYWdzW2ldLmNhbGxIb29rKGhvb2spXG4gIH1cbn1cblxuLyoqXG4gKiBEZXN0cm95IHRoZSBmcmFnbWVudC5cbiAqL1xuXG5GcmFnbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGFyZW50RnJhZykge1xuICAgIHRoaXMucGFyZW50RnJhZy5jaGlsZEZyYWdzLiRyZW1vdmUodGhpcylcbiAgfVxuICB0aGlzLnVubGluaygpXG59XG5cbi8qKlxuICogSW5zZXJ0IGZyYWdtZW50IGJlZm9yZSB0YXJnZXQsIHNpbmdsZSBub2RlIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIHNpbmdsZUJlZm9yZSAodGFyZ2V0LCB3aXRoVHJhbnNpdGlvbikge1xuICB0aGlzLmluc2VydGVkID0gdHJ1ZVxuICB2YXIgbWV0aG9kID0gd2l0aFRyYW5zaXRpb24gIT09IGZhbHNlXG4gICAgPyB0cmFuc2l0aW9uLmJlZm9yZVxuICAgIDogXy5iZWZvcmVcbiAgbWV0aG9kKHRoaXMubm9kZSwgdGFyZ2V0LCB0aGlzLnZtKVxuICBpZiAoXy5pbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgdGhpcy5jYWxsSG9vayhhdHRhY2gpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZnJhZ21lbnQsIHNpbmdsZSBub2RlIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtkZXN0cm95XVxuICovXG5cbmZ1bmN0aW9uIHNpbmdsZVJlbW92ZSAoZGVzdHJveSkge1xuICB0aGlzLmluc2VydGVkID0gZmFsc2VcbiAgdmFyIHNob3VsZENhbGxSZW1vdmUgPSBfLmluRG9jKHRoaXMubm9kZSlcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRyYW5zaXRpb24ucmVtb3ZlKHRoaXMubm9kZSwgdGhpcy52bSwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzaG91bGRDYWxsUmVtb3ZlKSB7XG4gICAgICBzZWxmLmNhbGxIb29rKGRldGFjaClcbiAgICB9XG4gICAgaWYgKGRlc3Ryb3kpIHtcbiAgICAgIHNlbGYuZGVzdHJveSgpXG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIEluc2VydCBmcmFnbWVudCBiZWZvcmUgdGFyZ2V0LCBtdWx0aS1ub2RlcyB2ZXJzaW9uXG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFRyYW5zaXRpb25cbiAqL1xuXG5mdW5jdGlvbiBtdWx0aUJlZm9yZSAodGFyZ2V0LCB3aXRoVHJhbnNpdGlvbikge1xuICB0aGlzLmluc2VydGVkID0gdHJ1ZVxuICB2YXIgdm0gPSB0aGlzLnZtXG4gIHZhciBtZXRob2QgPSB3aXRoVHJhbnNpdGlvbiAhPT0gZmFsc2VcbiAgICA/IHRyYW5zaXRpb24uYmVmb3JlXG4gICAgOiBfLmJlZm9yZVxuICBfLm1hcE5vZGVSYW5nZSh0aGlzLm5vZGUsIHRoaXMuZW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIG1ldGhvZChub2RlLCB0YXJnZXQsIHZtKVxuICB9KVxuICBpZiAoXy5pbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgdGhpcy5jYWxsSG9vayhhdHRhY2gpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZnJhZ21lbnQsIG11bHRpLW5vZGVzIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtkZXN0cm95XVxuICovXG5cbmZ1bmN0aW9uIG11bHRpUmVtb3ZlIChkZXN0cm95KSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSBmYWxzZVxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHNob3VsZENhbGxSZW1vdmUgPSBfLmluRG9jKHRoaXMubm9kZSlcbiAgXy5yZW1vdmVOb2RlUmFuZ2UodGhpcy5ub2RlLCB0aGlzLmVuZCwgdGhpcy52bSwgdGhpcy5mcmFnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNob3VsZENhbGxSZW1vdmUpIHtcbiAgICAgIHNlbGYuY2FsbEhvb2soZGV0YWNoKVxuICAgIH1cbiAgICBpZiAoZGVzdHJveSkge1xuICAgICAgc2VsZi5kZXN0cm95KClcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogQ2FsbCBhdHRhY2ggaG9vayBmb3IgYSBWdWUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gKi9cblxuZnVuY3Rpb24gYXR0YWNoIChjaGlsZCkge1xuICBpZiAoIWNoaWxkLl9pc0F0dGFjaGVkKSB7XG4gICAgY2hpbGQuX2NhbGxIb29rKCdhdHRhY2hlZCcpXG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsIGRldGFjaCBob29rIGZvciBhIFZ1ZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAqL1xuXG5mdW5jdGlvbiBkZXRhY2ggKGNoaWxkKSB7XG4gIGlmIChjaGlsZC5faXNBdHRhY2hlZCkge1xuICAgIGNoaWxkLl9jYWxsSG9vaygnZGV0YWNoZWQnKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhZ21lbnRcbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgaW5Eb2MgPSBfLmluRG9jXG52YXIgZXZlbnRSRSA9IC9edi1vbjp8XkAvXG5cbi8qKlxuICogU2V0dXAgdGhlIGluc3RhbmNlJ3Mgb3B0aW9uIGV2ZW50cyAmIHdhdGNoZXJzLlxuICogSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCB3ZSBwdWxsIGl0IGZyb20gdGhlXG4gKiBpbnN0YW5jZSdzIG1ldGhvZHMgYnkgbmFtZS5cbiAqL1xuXG5leHBvcnRzLl9pbml0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgcmVnaXN0ZXJDb21wb25lbnRFdmVudHModGhpcywgb3B0aW9ucy5lbClcbiAgfVxuICByZWdpc3RlckNhbGxiYWNrcyh0aGlzLCAnJG9uJywgb3B0aW9ucy5ldmVudHMpXG4gIHJlZ2lzdGVyQ2FsbGJhY2tzKHRoaXMsICckd2F0Y2gnLCBvcHRpb25zLndhdGNoKVxufVxuXG4vKipcbiAqIFJlZ2lzdGVyIHYtb24gZXZlbnRzIG9uIGEgY2hpbGQgY29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnRFdmVudHMgKHZtLCBlbCkge1xuICB2YXIgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzXG4gIHZhciBuYW1lLCBoYW5kbGVyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IGF0dHJzW2ldLm5hbWVcbiAgICBpZiAoZXZlbnRSRS50ZXN0KG5hbWUpKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGV2ZW50UkUsICcnKVxuICAgICAgaGFuZGxlciA9ICh2bS5fc2NvcGUgfHwgdm0uX2NvbnRleHQpLiRldmFsKGF0dHJzW2ldLnZhbHVlLCB0cnVlKVxuICAgICAgdm0uJG9uKG5hbWUucmVwbGFjZShldmVudFJFKSwgaGFuZGxlcilcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlciBjYWxsYmFja3MgZm9yIG9wdGlvbiBldmVudHMgYW5kIHdhdGNoZXJzLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGhhc2hcbiAqL1xuXG5mdW5jdGlvbiByZWdpc3RlckNhbGxiYWNrcyAodm0sIGFjdGlvbiwgaGFzaCkge1xuICBpZiAoIWhhc2gpIHJldHVyblxuICB2YXIgaGFuZGxlcnMsIGtleSwgaSwgalxuICBmb3IgKGtleSBpbiBoYXNoKSB7XG4gICAgaGFuZGxlcnMgPSBoYXNoW2tleV1cbiAgICBpZiAoXy5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgZm9yIChpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXJzW2ldKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXJzKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB0byByZWdpc3RlciBhbiBldmVudC93YXRjaCBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfE9iamVjdH0gaGFuZGxlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICovXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyICh2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgaGFuZGxlclxuICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZtW2FjdGlvbl0oa2V5LCBoYW5kbGVyLCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzXG4gICAgdmFyIG1ldGhvZCA9IG1ldGhvZHMgJiYgbWV0aG9kc1toYW5kbGVyXVxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHZtW2FjdGlvbl0oa2V5LCBtZXRob2QsIG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAnVW5rbm93biBtZXRob2Q6IFwiJyArIGhhbmRsZXIgKyAnXCIgd2hlbiAnICtcbiAgICAgICAgJ3JlZ2lzdGVyaW5nIGNhbGxiYWNrIGZvciAnICsgYWN0aW9uICtcbiAgICAgICAgJzogXCInICsga2V5ICsgJ1wiLidcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAoaGFuZGxlciAmJiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlci5oYW5kbGVyLCBoYW5kbGVyKVxuICB9XG59XG5cbi8qKlxuICogU2V0dXAgcmVjdXJzaXZlIGF0dGFjaGVkL2RldGFjaGVkIGNhbGxzXG4gKi9cblxuZXhwb3J0cy5faW5pdERPTUhvb2tzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLiRvbignaG9vazphdHRhY2hlZCcsIG9uQXR0YWNoZWQpXG4gIHRoaXMuJG9uKCdob29rOmRldGFjaGVkJywgb25EZXRhY2hlZClcbn1cblxuLyoqXG4gKiBDYWxsYmFjayB0byByZWN1cnNpdmVseSBjYWxsIGF0dGFjaGVkIGhvb2sgb24gY2hpbGRyZW5cbiAqL1xuXG5mdW5jdGlvbiBvbkF0dGFjaGVkICgpIHtcbiAgaWYgKCF0aGlzLl9pc0F0dGFjaGVkKSB7XG4gICAgdGhpcy5faXNBdHRhY2hlZCA9IHRydWVcbiAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNhbGxBdHRhY2gpXG4gIH1cbn1cblxuLyoqXG4gKiBJdGVyYXRvciB0byBjYWxsIGF0dGFjaGVkIGhvb2tcbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAqL1xuXG5mdW5jdGlvbiBjYWxsQXR0YWNoIChjaGlsZCkge1xuICBpZiAoIWNoaWxkLl9pc0F0dGFjaGVkICYmIGluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICBjaGlsZC5fY2FsbEhvb2soJ2F0dGFjaGVkJylcbiAgfVxufVxuXG4vKipcbiAqIENhbGxiYWNrIHRvIHJlY3Vyc2l2ZWx5IGNhbGwgZGV0YWNoZWQgaG9vayBvbiBjaGlsZHJlblxuICovXG5cbmZ1bmN0aW9uIG9uRGV0YWNoZWQgKCkge1xuICBpZiAodGhpcy5faXNBdHRhY2hlZCkge1xuICAgIHRoaXMuX2lzQXR0YWNoZWQgPSBmYWxzZVxuICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goY2FsbERldGFjaClcbiAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdG9yIHRvIGNhbGwgZGV0YWNoZWQgaG9va1xuICpcbiAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICovXG5cbmZ1bmN0aW9uIGNhbGxEZXRhY2ggKGNoaWxkKSB7XG4gIGlmIChjaGlsZC5faXNBdHRhY2hlZCAmJiAhaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgIGNoaWxkLl9jYWxsSG9vaygnZGV0YWNoZWQnKVxuICB9XG59XG5cbi8qKlxuICogVHJpZ2dlciBhbGwgaGFuZGxlcnMgZm9yIGEgaG9va1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBob29rXG4gKi9cblxuZXhwb3J0cy5fY2FsbEhvb2sgPSBmdW5jdGlvbiAoaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB0aGlzLiRvcHRpb25zW2hvb2tdXG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBoYW5kbGVyc1tpXS5jYWxsKHRoaXMpXG4gICAgfVxuICB9XG4gIHRoaXMuJGVtaXQoJ2hvb2s6JyArIGhvb2spXG59XG4iLCJ2YXIgbWVyZ2VPcHRpb25zID0gcmVxdWlyZSgnLi4vdXRpbCcpLm1lcmdlT3B0aW9uc1xudmFyIHVpZCA9IDBcblxuLyoqXG4gKiBUaGUgbWFpbiBpbml0IHNlcXVlbmNlLiBUaGlzIGlzIGNhbGxlZCBmb3IgZXZlcnlcbiAqIGluc3RhbmNlLCBpbmNsdWRpbmcgb25lcyB0aGF0IGFyZSBjcmVhdGVkIGZyb20gZXh0ZW5kZWRcbiAqIGNvbnN0cnVjdG9ycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoaXMgb3B0aW9ucyBvYmplY3Qgc2hvdWxkIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSByZXN1bHQgb2YgbWVyZ2luZyBjbGFzc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zIGFuZCB0aGUgb3B0aW9ucyBwYXNzZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdG8gdGhlIGNvbnN0cnVjdG9yLlxuICovXG5cbmV4cG9ydHMuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgdGhpcy4kZWwgPSBudWxsXG4gIHRoaXMuJHBhcmVudCA9IG9wdGlvbnMucGFyZW50XG4gIHRoaXMuJHJvb3QgPSB0aGlzLiRwYXJlbnRcbiAgICA/IHRoaXMuJHBhcmVudC4kcm9vdFxuICAgIDogdGhpc1xuICB0aGlzLiRjaGlsZHJlbiA9IFtdXG4gIHRoaXMuJHJlZnMgPSB7fSAgICAgICAvLyBjaGlsZCB2bSByZWZlcmVuY2VzXG4gIHRoaXMuJGVscyA9IHt9ICAgICAgICAvLyBlbGVtZW50IHJlZmVyZW5jZXNcbiAgdGhpcy5fd2F0Y2hlcnMgPSBbXSAgIC8vIGFsbCB3YXRjaGVycyBhcyBhbiBhcnJheVxuICB0aGlzLl9kaXJlY3RpdmVzID0gW10gLy8gYWxsIGRpcmVjdGl2ZXNcblxuICAvLyBhIHVpZFxuICB0aGlzLl91aWQgPSB1aWQrK1xuXG4gIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gIHRoaXMuX2lzVnVlID0gdHJ1ZVxuXG4gIC8vIGV2ZW50cyBib29ra2VlcGluZ1xuICB0aGlzLl9ldmVudHMgPSB7fSAgICAgICAgICAgIC8vIHJlZ2lzdGVyZWQgY2FsbGJhY2tzXG4gIHRoaXMuX2V2ZW50c0NvdW50ID0ge30gICAgICAgLy8gZm9yICRicm9hZGNhc3Qgb3B0aW1pemF0aW9uXG4gIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSA9IGZhbHNlIC8vIGZvciBldmVudCBwcm9wYWdhdGlvblxuXG4gIC8vIGZyYWdtZW50IGluc3RhbmNlIHByb3BlcnRpZXNcbiAgdGhpcy5faXNGcmFnbWVudCA9IGZhbHNlXG4gIHRoaXMuX2ZyYWdtZW50ID0gICAgICAgICAvLyBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH1cbiAgdGhpcy5fZnJhZ21lbnRTdGFydCA9ICAgIC8vIEB0eXBlIHtUZXh0fENvbW1lbnR9XG4gIHRoaXMuX2ZyYWdtZW50RW5kID0gbnVsbCAvLyBAdHlwZSB7VGV4dHxDb21tZW50fVxuXG4gIC8vIGxpZmVjeWNsZSBzdGF0ZVxuICB0aGlzLl9pc0NvbXBpbGVkID1cbiAgdGhpcy5faXNEZXN0cm95ZWQgPVxuICB0aGlzLl9pc1JlYWR5ID1cbiAgdGhpcy5faXNBdHRhY2hlZCA9XG4gIHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZVxuICB0aGlzLl91bmxpbmtGbiA9IG51bGxcblxuICAvLyBjb250ZXh0OlxuICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBjb250ZXh0XG4gIC8vIHdpbGwgYmUgdGhlIGNvbW1vbiBwYXJlbnQgdm0gb2YgdGhpcyBpbnN0YW5jZVxuICAvLyBhbmQgaXRzIGhvc3QuXG4gIHRoaXMuX2NvbnRleHQgPSBvcHRpb25zLl9jb250ZXh0IHx8IHRoaXMuJHBhcmVudFxuXG4gIC8vIHNjb3BlOlxuICAvLyBpZiB0aGlzIGlzIGluc2lkZSBhbiBpbmxpbmUgdi1mb3IsIHRoZSBzY29wZVxuICAvLyB3aWxsIGJlIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgY3JlYXRlZCBmb3IgdGhpc1xuICAvLyByZXBlYXQgZnJhZ21lbnQuIHRoaXMgaXMgdXNlZCBmb3IgbGlua2luZyBwcm9wc1xuICAvLyBhbmQgY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gIHRoaXMuX3Njb3BlID0gb3B0aW9ucy5fc2NvcGVcblxuICAvLyBmcmFnbWVudDpcbiAgLy8gaWYgdGhpcyBpbnN0YW5jZSBpcyBjb21waWxlZCBpbnNpZGUgYSBGcmFnbWVudCwgaXRcbiAgLy8gbmVlZHMgdG8gcmVpZ3N0ZXIgaXRzZWxmIGFzIGEgY2hpbGQgb2YgdGhhdCBmcmFnbWVudFxuICAvLyBmb3IgYXR0YWNoL2RldGFjaCB0byB3b3JrIHByb3Blcmx5LlxuICB0aGlzLl9mcmFnID0gb3B0aW9ucy5fZnJhZ1xuICBpZiAodGhpcy5fZnJhZykge1xuICAgIHRoaXMuX2ZyYWcuY2hpbGRyZW4ucHVzaCh0aGlzKVxuICB9XG5cbiAgLy8gcHVzaCBzZWxmIGludG8gcGFyZW50IC8gdHJhbnNjbHVzaW9uIGhvc3RcbiAgaWYgKHRoaXMuJHBhcmVudCkge1xuICAgIHRoaXMuJHBhcmVudC4kY2hpbGRyZW4ucHVzaCh0aGlzKVxuICB9XG5cbiAgLy8gc2V0IHJlZlxuICBpZiAob3B0aW9ucy5fcmVmKSB7XG4gICAgKHRoaXMuX3Njb3BlIHx8IHRoaXMuX2NvbnRleHQpLiRyZWZzW29wdGlvbnMuX3JlZl0gPSB0aGlzXG4gIH1cblxuICAvLyBtZXJnZSBvcHRpb25zLlxuICBvcHRpb25zID0gdGhpcy4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICB0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnMsXG4gICAgb3B0aW9ucyxcbiAgICB0aGlzXG4gIClcblxuICAvLyBpbml0aWFsaXplIGRhdGEgYXMgZW1wdHkgb2JqZWN0LlxuICAvLyBpdCB3aWxsIGJlIGZpbGxlZCB1cCBpbiBfaW5pdFNjb3BlKCkuXG4gIHRoaXMuX2RhdGEgPSB7fVxuXG4gIC8vIGNhbGwgaW5pdCBob29rXG4gIHRoaXMuX2NhbGxIb29rKCdpbml0JylcblxuICAvLyBpbml0aWFsaXplIGRhdGEgb2JzZXJ2YXRpb24gYW5kIHNjb3BlIGluaGVyaXRhbmNlLlxuICB0aGlzLl9pbml0U3RhdGUoKVxuXG4gIC8vIHNldHVwIGV2ZW50IHN5c3RlbSBhbmQgb3B0aW9uIGV2ZW50cy5cbiAgdGhpcy5faW5pdEV2ZW50cygpXG5cbiAgLy8gY2FsbCBjcmVhdGVkIGhvb2tcbiAgdGhpcy5fY2FsbEhvb2soJ2NyZWF0ZWQnKVxuXG4gIC8vIGlmIGBlbGAgb3B0aW9uIGlzIHBhc3NlZCwgc3RhcnQgY29tcGlsYXRpb24uXG4gIGlmIChvcHRpb25zLmVsKSB7XG4gICAgdGhpcy4kbW91bnQob3B0aW9ucy5lbClcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBEaXJlY3RpdmUgPSByZXF1aXJlKCcuLi9kaXJlY3RpdmUnKVxudmFyIGNvbXBpbGVyID0gcmVxdWlyZSgnLi4vY29tcGlsZXInKVxuXG4vKipcbiAqIFRyYW5zY2x1ZGUsIGNvbXBpbGUgYW5kIGxpbmsgZWxlbWVudC5cbiAqXG4gKiBJZiBhIHByZS1jb21waWxlZCBsaW5rZXIgaXMgYXZhaWxhYmxlLCB0aGF0IG1lYW5zIHRoZVxuICogcGFzc2VkIGluIGVsZW1lbnQgd2lsbCBiZSBwcmUtdHJhbnNjbHVkZWQgYW5kIGNvbXBpbGVkXG4gKiBhcyB3ZWxsIC0gYWxsIHdlIG5lZWQgdG8gZG8gaXMgdG8gY2FsbCB0aGUgbGlua2VyLlxuICpcbiAqIE90aGVyd2lzZSB3ZSBuZWVkIHRvIGNhbGwgdHJhbnNjbHVkZS9jb21waWxlL2xpbmsgaGVyZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5cbmV4cG9ydHMuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zXG5cbiAgLy8gdHJhbnNjbHVkZSBhbmQgaW5pdCBlbGVtZW50XG4gIC8vIHRyYW5zY2x1ZGUgY2FuIHBvdGVudGlhbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgLy8gc28gd2UgbmVlZCB0byBrZWVwIHJlZmVyZW5jZTsgdGhpcyBzdGVwIGFsc28gaW5qZWN0c1xuICAvLyB0aGUgdGVtcGxhdGUgYW5kIGNhY2hlcyB0aGUgb3JpZ2luYWwgYXR0cmlidXRlc1xuICAvLyBvbiB0aGUgY29udGFpbmVyIG5vZGUgYW5kIHJlcGxhY2VyIG5vZGUuXG4gIHZhciBvcmlnaW5hbCA9IGVsXG4gIGVsID0gY29tcGlsZXIudHJhbnNjbHVkZShlbCwgb3B0aW9ucylcbiAgdGhpcy5faW5pdEVsZW1lbnQoZWwpXG5cbiAgLy8gcm9vdCBpcyBhbHdheXMgY29tcGlsZWQgcGVyLWluc3RhbmNlLCBiZWNhdXNlXG4gIC8vIGNvbnRhaW5lciBhdHRycyBhbmQgcHJvcHMgY2FuIGJlIGRpZmZlcmVudCBldmVyeSB0aW1lLlxuICB2YXIgY29udGV4dE9wdGlvbnMgPSB0aGlzLl9jb250ZXh0ICYmIHRoaXMuX2NvbnRleHQuJG9wdGlvbnNcbiAgdmFyIHJvb3RMaW5rZXIgPSBjb21waWxlci5jb21waWxlUm9vdChlbCwgb3B0aW9ucywgY29udGV4dE9wdGlvbnMpXG5cbiAgLy8gY29tcGlsZSBhbmQgbGluayB0aGUgcmVzdFxuICB2YXIgY29udGVudExpbmtGblxuICB2YXIgY3RvciA9IHRoaXMuY29uc3RydWN0b3JcbiAgLy8gY29tcG9uZW50IGNvbXBpbGF0aW9uIGNhbiBiZSBjYWNoZWRcbiAgLy8gYXMgbG9uZyBhcyBpdCdzIG5vdCB1c2luZyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKG9wdGlvbnMuX2xpbmtlckNhY2hhYmxlKSB7XG4gICAgY29udGVudExpbmtGbiA9IGN0b3IubGlua2VyXG4gICAgaWYgKCFjb250ZW50TGlua0ZuKSB7XG4gICAgICBjb250ZW50TGlua0ZuID0gY3Rvci5saW5rZXIgPSBjb21waWxlci5jb21waWxlKGVsLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIC8vIGxpbmsgcGhhc2VcbiAgLy8gbWFrZSBzdXJlIHRvIGxpbmsgcm9vdCB3aXRoIHByb3Agc2NvcGUhXG4gIHZhciByb290VW5saW5rRm4gPSByb290TGlua2VyKHRoaXMsIGVsLCB0aGlzLl9zY29wZSlcbiAgdmFyIGNvbnRlbnRVbmxpbmtGbiA9IGNvbnRlbnRMaW5rRm5cbiAgICA/IGNvbnRlbnRMaW5rRm4odGhpcywgZWwpXG4gICAgOiBjb21waWxlci5jb21waWxlKGVsLCBvcHRpb25zKSh0aGlzLCBlbClcblxuICAvLyByZWdpc3RlciBjb21wb3NpdGUgdW5saW5rIGZ1bmN0aW9uXG4gIC8vIHRvIGJlIGNhbGxlZCBkdXJpbmcgaW5zdGFuY2UgZGVzdHJ1Y3Rpb25cbiAgdGhpcy5fdW5saW5rRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcm9vdFVubGlua0ZuKClcbiAgICAvLyBwYXNzaW5nIGRlc3Ryb3lpbmc6IHRydWUgdG8gYXZvaWQgc2VhcmNoaW5nIGFuZFxuICAgIC8vIHNwbGljaW5nIHRoZSBkaXJlY3RpdmVzXG4gICAgY29udGVudFVubGlua0ZuKHRydWUpXG4gIH1cblxuICAvLyBmaW5hbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgaWYgKG9wdGlvbnMucmVwbGFjZSkge1xuICAgIF8ucmVwbGFjZShvcmlnaW5hbCwgZWwpXG4gIH1cblxuICB0aGlzLl9pc0NvbXBpbGVkID0gdHJ1ZVxuICB0aGlzLl9jYWxsSG9vaygnY29tcGlsZWQnKVxuICByZXR1cm4gZWxcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGluc3RhbmNlIGVsZW1lbnQuIENhbGxlZCBpbiB0aGUgcHVibGljXG4gKiAkbW91bnQoKSBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmV4cG9ydHMuX2luaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gIGlmIChlbCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICB0aGlzLl9pc0ZyYWdtZW50ID0gdHJ1ZVxuICAgIHRoaXMuJGVsID0gdGhpcy5fZnJhZ21lbnRTdGFydCA9IGVsLmZpcnN0Q2hpbGRcbiAgICB0aGlzLl9mcmFnbWVudEVuZCA9IGVsLmxhc3RDaGlsZFxuICAgIC8vIHNldCBwZXJzaXN0ZWQgdGV4dCBhbmNob3JzIHRvIGVtcHR5XG4gICAgaWYgKHRoaXMuX2ZyYWdtZW50U3RhcnQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIHRoaXMuX2ZyYWdtZW50U3RhcnQuZGF0YSA9IHRoaXMuX2ZyYWdtZW50RW5kLmRhdGEgPSAnJ1xuICAgIH1cbiAgICB0aGlzLl9mcmFnbWVudCA9IGVsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy4kZWwgPSBlbFxuICB9XG4gIHRoaXMuJGVsLl9fdnVlX18gPSB0aGlzXG4gIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVDb21waWxlJylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW5kIGJpbmQgYSBkaXJlY3RpdmUgdG8gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIGRpcmVjdGl2ZSBuYW1lXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgICAtIHRhcmdldCBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzYyAtIHBhcnNlZCBkaXJlY3RpdmUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtPYmplY3R9IGRlZiAgLSBkaXJlY3RpdmUgZGVmaW5pdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSB0cmFuc2NsdXNpb24gaG9zdCBjb21wb25lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gdi1mb3Igc2NvcGVcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIG93bmVyIGZyYWdtZW50XG4gKi9cblxuZXhwb3J0cy5fYmluZERpciA9IGZ1bmN0aW9uIChkZXNjcmlwdG9yLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZykge1xuICB0aGlzLl9kaXJlY3RpdmVzLnB1c2goXG4gICAgbmV3IERpcmVjdGl2ZShkZXNjcmlwdG9yLCB0aGlzLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZylcbiAgKVxufVxuXG4vKipcbiAqIFRlYXJkb3duIGFuIGluc3RhbmNlLCB1bm9ic2VydmVzIHRoZSBkYXRhLCB1bmJpbmQgYWxsIHRoZVxuICogZGlyZWN0aXZlcywgdHVybiBvZmYgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMsIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZSAtIHdoZXRoZXIgdG8gcmVtb3ZlIHRoZSBET00gbm9kZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVmZXJDbGVhbnVwIC0gaWYgdHJ1ZSwgZGVmZXIgY2xlYW51cCB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBjYWxsZWQgbGF0ZXJcbiAqL1xuXG5leHBvcnRzLl9kZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZSwgZGVmZXJDbGVhbnVwKSB7XG4gIGlmICh0aGlzLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5fY2FsbEhvb2soJ2JlZm9yZURlc3Ryb3knKVxuICB0aGlzLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZVxuICB2YXIgaVxuICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudC4gb25seSBuZWNlc3NhcnlcbiAgLy8gaWYgcGFyZW50IGlzIG5vdCBiZWluZyBkZXN0cm95ZWQgYXMgd2VsbC5cbiAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudFxuICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICBwYXJlbnQuJGNoaWxkcmVuLiRyZW1vdmUodGhpcylcbiAgICAvLyB1bnJlZ2lzdGVyIHJlZlxuICAgIHZhciByZWYgPSB0aGlzLiRvcHRpb25zLl9yZWZcbiAgICBpZiAocmVmKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLl9jb250ZXh0XG4gICAgICBpZiAoc2NvcGUuJHJlZnNbcmVmXSA9PT0gdGhpcykge1xuICAgICAgICBzY29wZS4kcmVmc1tyZWZdID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyByZW1vdmUgc2VsZiBmcm9tIG93bmVyIGZyYWdtZW50XG4gIGlmICh0aGlzLl9mcmFnKSB7XG4gICAgdGhpcy5fZnJhZy5jaGlsZHJlbi4kcmVtb3ZlKHRoaXMpXG4gIH1cbiAgLy8gZGVzdHJveSBhbGwgY2hpbGRyZW4uXG4gIGkgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuJGNoaWxkcmVuW2ldLiRkZXN0cm95KClcbiAgfVxuICAvLyB0ZWFyZG93biBwcm9wc1xuICBpZiAodGhpcy5fcHJvcHNVbmxpbmtGbikge1xuICAgIHRoaXMuX3Byb3BzVW5saW5rRm4oKVxuICB9XG4gIC8vIHRlYXJkb3duIGFsbCBkaXJlY3RpdmVzLiB0aGlzIGFsc28gdGVhcnNkb3duIGFsbFxuICAvLyBkaXJlY3RpdmUtb3duZWQgd2F0Y2hlcnMuXG4gIGlmICh0aGlzLl91bmxpbmtGbikge1xuICAgIHRoaXMuX3VubGlua0ZuKClcbiAgfVxuICBpID0gdGhpcy5fd2F0Y2hlcnMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzLl93YXRjaGVyc1tpXS50ZWFyZG93bigpXG4gIH1cbiAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBzZWxmIG9uICRlbFxuICBpZiAodGhpcy4kZWwpIHtcbiAgICB0aGlzLiRlbC5fX3Z1ZV9fID0gbnVsbFxuICB9XG4gIC8vIHJlbW92ZSBET00gZWxlbWVudFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHJlbW92ZSAmJiB0aGlzLiRlbCkge1xuICAgIHRoaXMuJHJlbW92ZShmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9jbGVhbnVwKClcbiAgICB9KVxuICB9IGVsc2UgaWYgKCFkZWZlckNsZWFudXApIHtcbiAgICB0aGlzLl9jbGVhbnVwKClcbiAgfVxufVxuXG4vKipcbiAqIENsZWFuIHVwIHRvIGVuc3VyZSBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gKiBUaGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgbGVhdmUgdHJhbnNpdGlvbiBpZiB0aGVyZVxuICogaXMgYW55LlxuICovXG5cbmV4cG9ydHMuX2NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICBpZiAodGhpcy5fZGF0YS5fX29iX18pIHtcbiAgICB0aGlzLl9kYXRhLl9fb2JfXy5yZW1vdmVWbSh0aGlzKVxuICB9XG4gIC8vIENsZWFuIHVwIHJlZmVyZW5jZXMgdG8gcHJpdmF0ZSBwcm9wZXJ0aWVzIGFuZCBvdGhlclxuICAvLyBpbnN0YW5jZXMuIHByZXNlcnZlIHJlZmVyZW5jZSB0byBfZGF0YSBzbyB0aGF0IHByb3h5XG4gIC8vIGFjY2Vzc29ycyBzdGlsbCB3b3JrLiBUaGUgb25seSBwb3RlbnRpYWwgc2lkZSBlZmZlY3RcbiAgLy8gaGVyZSBpcyB0aGF0IG11dGF0aW5nIHRoZSBpbnN0YW5jZSBhZnRlciBpdCdzIGRlc3Ryb3llZFxuICAvLyBtYXkgYWZmZWN0IHRoZSBzdGF0ZSBvZiBvdGhlciBjb21wb25lbnRzIHRoYXQgYXJlIHN0aWxsXG4gIC8vIG9ic2VydmluZyB0aGUgc2FtZSBvYmplY3QsIGJ1dCB0aGF0IHNlZW1zIHRvIGJlIGFcbiAgLy8gcmVhc29uYWJsZSByZXNwb25zaWJpbGl0eSBmb3IgdGhlIHVzZXIgcmF0aGVyIHRoYW5cbiAgLy8gYWx3YXlzIHRocm93aW5nIGFuIGVycm9yIG9uIHRoZW0uXG4gIHRoaXMuJGVsID1cbiAgdGhpcy4kcGFyZW50ID1cbiAgdGhpcy4kcm9vdCA9XG4gIHRoaXMuJGNoaWxkcmVuID1cbiAgdGhpcy5fd2F0Y2hlcnMgPVxuICB0aGlzLl9jb250ZXh0ID1cbiAgdGhpcy5fc2NvcGUgPVxuICB0aGlzLl9kaXJlY3RpdmVzID0gbnVsbFxuICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgdGhpcy5faXNEZXN0cm95ZWQgPSB0cnVlXG4gIHRoaXMuX2NhbGxIb29rKCdkZXN0cm95ZWQnKVxuICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICB0aGlzLiRvZmYoKVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcblxuLyoqXG4gKiBBcHBseSBhIGxpc3Qgb2YgZmlsdGVyIChkZXNjcmlwdG9ycykgdG8gYSB2YWx1ZS5cbiAqIFVzaW5nIHBsYWluIGZvciBsb29wcyBoZXJlIGJlY2F1c2UgdGhpcyB3aWxsIGJlIGNhbGxlZCBpblxuICogdGhlIGdldHRlciBvZiBhbnkgd2F0Y2hlciB3aXRoIGZpbHRlcnMgc28gaXQgaXMgdmVyeVxuICogcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7Kn0gW29sZFZhbHVlXVxuICogQHBhcmFtIHtBcnJheX0gZmlsdGVyc1xuICogQHBhcmFtIHtCb29sZWFufSB3cml0ZVxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5leHBvcnRzLl9hcHBseUZpbHRlcnMgPSBmdW5jdGlvbiAodmFsdWUsIG9sZFZhbHVlLCBmaWx0ZXJzLCB3cml0ZSkge1xuICB2YXIgZmlsdGVyLCBmbiwgYXJncywgYXJnLCBvZmZzZXQsIGksIGwsIGosIGtcbiAgZm9yIChpID0gMCwgbCA9IGZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZmlsdGVyID0gZmlsdGVyc1tpXVxuICAgIGZuID0gXy5yZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBmaWx0ZXIubmFtZSlcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgXy5hc3NlcnRBc3NldChmbiwgJ2ZpbHRlcicsIGZpbHRlci5uYW1lKVxuICAgIH1cbiAgICBpZiAoIWZuKSBjb250aW51ZVxuICAgIGZuID0gd3JpdGUgPyBmbi53cml0ZSA6IChmbi5yZWFkIHx8IGZuKVxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIGNvbnRpbnVlXG4gICAgYXJncyA9IHdyaXRlID8gW3ZhbHVlLCBvbGRWYWx1ZV0gOiBbdmFsdWVdXG4gICAgb2Zmc2V0ID0gd3JpdGUgPyAyIDogMVxuICAgIGlmIChmaWx0ZXIuYXJncykge1xuICAgICAgZm9yIChqID0gMCwgayA9IGZpbHRlci5hcmdzLmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICBhcmcgPSBmaWx0ZXIuYXJnc1tqXVxuICAgICAgICBhcmdzW2ogKyBvZmZzZXRdID0gYXJnLmR5bmFtaWNcbiAgICAgICAgICA/IHRoaXMuJGdldChhcmcudmFsdWUpXG4gICAgICAgICAgOiBhcmcudmFsdWVcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIFJlc29sdmUgYSBjb21wb25lbnQsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBjb21wb25lbnRcbiAqIGlzIGRlZmluZWQgbm9ybWFsbHkgb3IgdXNpbmcgYW4gYXN5bmMgZmFjdG9yeSBmdW5jdGlvbi5cbiAqIFJlc29sdmVzIHN5bmNocm9ub3VzbHkgaWYgYWxyZWFkeSByZXNvbHZlZCwgb3RoZXJ3aXNlXG4gKiByZXNvbHZlcyBhc3luY2hyb25vdXNseSBhbmQgY2FjaGVzIHRoZSByZXNvbHZlZFxuICogY29uc3RydWN0b3Igb24gdGhlIGZhY3RvcnkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmV4cG9ydHMuX3Jlc29sdmVDb21wb25lbnQgPSBmdW5jdGlvbiAoaWQsIGNiKSB7XG4gIHZhciBmYWN0b3J5ID0gXy5yZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCBpZClcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBfLmFzc2VydEFzc2V0KGZhY3RvcnksICdjb21wb25lbnQnLCBpZClcbiAgfVxuICBpZiAoIWZhY3RvcnkpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvLyBhc3luYyBjb21wb25lbnQgZmFjdG9yeVxuICBpZiAoIWZhY3Rvcnkub3B0aW9ucykge1xuICAgIGlmIChmYWN0b3J5LnJlc29sdmVkKSB7XG4gICAgICAvLyBjYWNoZWRcbiAgICAgIGNiKGZhY3RvcnkucmVzb2x2ZWQpXG4gICAgfSBlbHNlIGlmIChmYWN0b3J5LnJlcXVlc3RlZCkge1xuICAgICAgLy8gcG9vbCBjYWxsYmFja3NcbiAgICAgIGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICBmYWN0b3J5LnJlcXVlc3RlZCA9IHRydWVcbiAgICAgIHZhciBjYnMgPSBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MgPSBbY2JdXG4gICAgICBmYWN0b3J5KGZ1bmN0aW9uIHJlc29sdmUgKHJlcykge1xuICAgICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHJlcykpIHtcbiAgICAgICAgICByZXMgPSBfLlZ1ZS5leHRlbmQocmVzKVxuICAgICAgICB9XG4gICAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSByZXNcbiAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrc1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjYnNbaV0ocmVzKVxuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiByZWplY3QgKHJlYXNvbikge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiAnICsgaWQgKyAnLiAnICtcbiAgICAgICAgICAocmVhc29uID8gJ1xcblJlYXNvbjogJyArIHJlYXNvbiA6ICcnKVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBub3JtYWwgY29tcG9uZW50XG4gICAgY2IoZmFjdG9yeSlcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBjb21waWxlciA9IHJlcXVpcmUoJy4uL2NvbXBpbGVyJylcbnZhciBPYnNlcnZlciA9IHJlcXVpcmUoJy4uL29ic2VydmVyJylcbnZhciBEZXAgPSByZXF1aXJlKCcuLi9vYnNlcnZlci9kZXAnKVxudmFyIFdhdGNoZXIgPSByZXF1aXJlKCcuLi93YXRjaGVyJylcblxuLyoqXG4gKiBTZXR1cCB0aGUgc2NvcGUgb2YgYW4gaW5zdGFuY2UsIHdoaWNoIGNvbnRhaW5zOlxuICogLSBvYnNlcnZlZCBkYXRhXG4gKiAtIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAqIC0gdXNlciBtZXRob2RzXG4gKiAtIG1ldGEgcHJvcGVydGllc1xuICovXG5cbmV4cG9ydHMuX2luaXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5faW5pdFByb3BzKClcbiAgdGhpcy5faW5pdE1ldGEoKVxuICB0aGlzLl9pbml0TWV0aG9kcygpXG4gIHRoaXMuX2luaXREYXRhKClcbiAgdGhpcy5faW5pdENvbXB1dGVkKClcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHByb3BzLlxuICovXG5cbmV4cG9ydHMuX2luaXRQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zXG4gIHZhciBlbCA9IG9wdGlvbnMuZWxcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wc1xuICBpZiAocHJvcHMgJiYgIWVsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnUHJvcHMgd2lsbCBub3QgYmUgY29tcGlsZWQgaWYgbm8gYGVsYCBvcHRpb24gaXMgJyArXG4gICAgICAncHJvdmlkZWQgYXQgaW5zdGFudGlhdGlvbi4nXG4gICAgKVxuICB9XG4gIC8vIG1ha2Ugc3VyZSB0byBjb252ZXJ0IHN0cmluZyBzZWxlY3RvcnMgaW50byBlbGVtZW50IG5vd1xuICBlbCA9IG9wdGlvbnMuZWwgPSBfLnF1ZXJ5KGVsKVxuICB0aGlzLl9wcm9wc1VubGlua0ZuID0gZWwgJiYgZWwubm9kZVR5cGUgPT09IDEgJiYgcHJvcHNcbiAgICAvLyBwcm9wcyBtdXN0IGJlIGxpbmtlZCBpbiBwcm9wZXIgc2NvcGUgaWYgaW5zaWRlIHYtZm9yXG4gICAgPyBjb21waWxlci5jb21waWxlQW5kTGlua1Byb3BzKHRoaXMsIGVsLCBwcm9wcywgdGhpcy5fc2NvcGUpXG4gICAgOiBudWxsXG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZGF0YS5cbiAqL1xuXG5leHBvcnRzLl9pbml0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHRoaXMuX2RhdGFcbiAgdmFyIG9wdGlvbnNEYXRhRm4gPSB0aGlzLiRvcHRpb25zLmRhdGFcbiAgdmFyIG9wdGlvbnNEYXRhID0gb3B0aW9uc0RhdGFGbiAmJiBvcHRpb25zRGF0YUZuKClcbiAgaWYgKG9wdGlvbnNEYXRhKSB7XG4gICAgdGhpcy5fZGF0YSA9IG9wdGlvbnNEYXRhXG4gICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wc0RhdGEpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgb3B0aW9uc0RhdGEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgXy53YXJuKFxuICAgICAgICAgICdEYXRhIGZpZWxkIFwiJyArIHByb3AgKyAnXCIgaXMgYWxyZWFkeSBkZWZpbmVkICcgK1xuICAgICAgICAgICdhcyBhIHByb3AuIFVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC4nXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wcm9wc1twcm9wXS5yYXcgIT09IG51bGwgfHxcbiAgICAgICAgICAhb3B0aW9uc0RhdGEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgXy5zZXQob3B0aW9uc0RhdGEsIHByb3AsIHByb3BzRGF0YVtwcm9wXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhXG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKVxuICB2YXIgaSwga2V5XG4gIGkgPSBrZXlzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAga2V5ID0ga2V5c1tpXVxuICAgIHRoaXMuX3Byb3h5KGtleSlcbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgT2JzZXJ2ZXIuY3JlYXRlKGRhdGEsIHRoaXMpXG59XG5cbi8qKlxuICogU3dhcCB0aGUgaXNudGFuY2UncyAkZGF0YS4gQ2FsbGVkIGluICRkYXRhJ3Mgc2V0dGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdEYXRhXG4gKi9cblxuZXhwb3J0cy5fc2V0RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gIG5ld0RhdGEgPSBuZXdEYXRhIHx8IHt9XG4gIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YVxuICB0aGlzLl9kYXRhID0gbmV3RGF0YVxuICB2YXIga2V5cywga2V5LCBpXG4gIC8vIHVucHJveHkga2V5cyBub3QgcHJlc2VudCBpbiBuZXcgZGF0YVxuICBrZXlzID0gT2JqZWN0LmtleXMob2xkRGF0YSlcbiAgaSA9IGtleXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICBrZXkgPSBrZXlzW2ldXG4gICAgaWYgKCEoa2V5IGluIG5ld0RhdGEpKSB7XG4gICAgICB0aGlzLl91bnByb3h5KGtleSlcbiAgICB9XG4gIH1cbiAgLy8gcHJveHkga2V5cyBub3QgYWxyZWFkeSBwcm94aWVkLFxuICAvLyBhbmQgdHJpZ2dlciBjaGFuZ2UgZm9yIGNoYW5nZWQgdmFsdWVzXG4gIGtleXMgPSBPYmplY3Qua2V5cyhuZXdEYXRhKVxuICBpID0ga2V5cy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV1cbiAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gbmV3IHByb3BlcnR5XG4gICAgICB0aGlzLl9wcm94eShrZXkpXG4gICAgfVxuICB9XG4gIG9sZERhdGEuX19vYl9fLnJlbW92ZVZtKHRoaXMpXG4gIE9ic2VydmVyLmNyZWF0ZShuZXdEYXRhLCB0aGlzKVxuICB0aGlzLl9kaWdlc3QoKVxufVxuXG4vKipcbiAqIFByb3h5IGEgcHJvcGVydHksIHNvIHRoYXRcbiAqIHZtLnByb3AgPT09IHZtLl9kYXRhLnByb3BcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKi9cblxuZXhwb3J0cy5fcHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICghXy5pc1Jlc2VydmVkKGtleSkpIHtcbiAgICAvLyBuZWVkIHRvIHN0b3JlIHJlZiB0byBzZWxmIGhlcmVcbiAgICAvLyBiZWNhdXNlIHRoZXNlIGdldHRlci9zZXR0ZXJzIG1pZ2h0XG4gICAgLy8gYmUgY2FsbGVkIGJ5IGNoaWxkIHNjb3BlcyB2aWFcbiAgICAvLyBwcm90b3R5cGUgaW5oZXJpdGFuY2UuXG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5fZGF0YVtrZXldXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgICAgIHNlbGYuX2RhdGFba2V5XSA9IHZhbFxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBVbnByb3h5IGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICovXG5cbmV4cG9ydHMuX3VucHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICghXy5pc1Jlc2VydmVkKGtleSkpIHtcbiAgICBkZWxldGUgdGhpc1trZXldXG4gIH1cbn1cblxuLyoqXG4gKiBGb3JjZSB1cGRhdGUgb24gZXZlcnkgd2F0Y2hlciBpbiBzY29wZS5cbiAqL1xuXG5leHBvcnRzLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fd2F0Y2hlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5fd2F0Y2hlcnNbaV0udXBkYXRlKHRydWUpIC8vIHNoYWxsb3cgdXBkYXRlc1xuICB9XG59XG5cbi8qKlxuICogU2V0dXAgY29tcHV0ZWQgcHJvcGVydGllcy4gVGhleSBhcmUgZXNzZW50aWFsbHlcbiAqIHNwZWNpYWwgZ2V0dGVyL3NldHRlcnNcbiAqL1xuXG5mdW5jdGlvbiBub29wICgpIHt9XG5leHBvcnRzLl9pbml0Q29tcHV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb21wdXRlZCA9IHRoaXMuJG9wdGlvbnMuY29tcHV0ZWRcbiAgaWYgKGNvbXB1dGVkKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV1cbiAgICAgIHZhciBkZWYgPSB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRlZi5nZXQgPSBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZiwgdGhpcylcbiAgICAgICAgZGVmLnNldCA9IG5vb3BcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgICAgID8gbWFrZUNvbXB1dGVkR2V0dGVyKHVzZXJEZWYuZ2V0LCB0aGlzKVxuICAgICAgICAgICAgOiBfLmJpbmQodXNlckRlZi5nZXQsIHRoaXMpXG4gICAgICAgICAgOiBub29wXG4gICAgICAgIGRlZi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgICAgID8gXy5iaW5kKHVzZXJEZWYuc2V0LCB0aGlzKVxuICAgICAgICAgIDogbm9vcFxuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVmKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQ29tcHV0ZWRHZXR0ZXIgKGdldHRlciwgb3duZXIpIHtcbiAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihvd25lciwgZ2V0dGVyLCBudWxsLCB7XG4gICAgbGF6eTogdHJ1ZVxuICB9KVxuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICB3YXRjaGVyLmV2YWx1YXRlKClcbiAgICB9XG4gICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgIHdhdGNoZXIuZGVwZW5kKClcbiAgICB9XG4gICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgfVxufVxuXG4vKipcbiAqIFNldHVwIGluc3RhbmNlIG1ldGhvZHMuIE1ldGhvZHMgbXVzdCBiZSBib3VuZCB0byB0aGVcbiAqIGluc3RhbmNlIHNpbmNlIHRoZXkgbWlnaHQgYmUgcGFzc2VkIGRvd24gYXMgYSBwcm9wIHRvXG4gKiBjaGlsZCBjb21wb25lbnRzLlxuICovXG5cbmV4cG9ydHMuX2luaXRNZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWV0aG9kcyA9IHRoaXMuJG9wdGlvbnMubWV0aG9kc1xuICBpZiAobWV0aG9kcykge1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgICB0aGlzW2tleV0gPSBfLmJpbmQobWV0aG9kc1trZXldLCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgbWV0YSBpbmZvcm1hdGlvbiBsaWtlICRpbmRleCwgJGtleSAmICR2YWx1ZS5cbiAqL1xuXG5leHBvcnRzLl9pbml0TWV0YSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1ldGFzID0gdGhpcy4kb3B0aW9ucy5fbWV0YVxuICBpZiAobWV0YXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWV0YXMpIHtcbiAgICAgIF8uZGVmaW5lUmVhY3RpdmUodGhpcywga2V5LCBtZXRhc1trZXldKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlXG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKVxuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5cbjtbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dXG4uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF1cbiAgXy5kZWZpbmUoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpKVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgdmFyIG9iID0gdGhpcy5fX29iX19cbiAgICB2YXIgaW5zZXJ0ZWRcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGluc2VydGVkID0gYXJnc1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJnc1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pXG59KVxuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGggYSBuZXcgdmFsdWVcbiAqIGFuZCBlbWl0cyBjb3JyZXNwb25kaW5nIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4geyp9IC0gcmVwbGFjZWQgZWxlbWVudFxuICovXG5cbl8uZGVmaW5lKFxuICBhcnJheVByb3RvLFxuICAnJHNldCcsXG4gIGZ1bmN0aW9uICRzZXQgKGluZGV4LCB2YWwpIHtcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gaW5kZXggKyAxXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMSwgdmFsKVswXVxuICB9XG4pXG5cbi8qKlxuICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSB0aGUgZWxlbWVudCBhdCBnaXZlbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuXy5kZWZpbmUoXG4gIGFycmF5UHJvdG8sXG4gICckcmVtb3ZlJyxcbiAgZnVuY3Rpb24gJHJlbW92ZSAoaXRlbSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdGhpcy5sZW5ndGgpIHJldHVyblxuICAgIHZhciBpbmRleCA9IF8uaW5kZXhPZih0aGlzLCBpdGVtKVxuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG4pXG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNZXRob2RzXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHVpZCA9IDBcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrXG4gIHRoaXMuc3VicyA9IFtdXG59XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGxcblxuLyoqXG4gKiBBZGQgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yilcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHRoaXMuc3Vicy4kcmVtb3ZlKHN1Yilcbn1cblxuLyoqXG4gKiBBZGQgc2VsZiBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRhcmdldCB3YXRjaGVyLlxuICovXG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKVxufVxuXG4vKipcbiAqIE5vdGlmeSBhbGwgc3Vic2NyaWJlcnMgb2YgYSBuZXcgdmFsdWUuXG4gKi9cblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHN0YWJsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSBfLnRvQXJyYXkodGhpcy5zdWJzKVxuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGVwXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIERlcCA9IHJlcXVpcmUoJy4vZGVwJylcbnZhciBhcnJheU1ldGhvZHMgPSByZXF1aXJlKCcuL2FycmF5JylcbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpXG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKClcbiAgXy5kZWZpbmUodmFsdWUsICdfX29iX18nLCB0aGlzKVxuICBpZiAoXy5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gXy5oYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnRcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cylcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpXG4gIH1cbn1cblxuLy8gU3RhdGljIG1ldGhvZHNcblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHJldHVybiB7T2JzZXJ2ZXJ8dW5kZWZpbmVkfVxuICogQHN0YXRpY1xuICovXG5cbk9ic2VydmVyLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdm0pIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iXG4gIGlmIChcbiAgICB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnX19vYl9fJykgJiZcbiAgICB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlclxuICApIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfX1xuICB9IGVsc2UgaWYgKFxuICAgIChfLmlzQXJyYXkodmFsdWUpIHx8IF8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgIU9iamVjdC5pc0Zyb3plbih2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKVxuICB9XG4gIGlmIChvYiAmJiB2bSkge1xuICAgIG9iLmFkZFZtKHZtKVxuICB9XG4gIHJldHVybiBvYlxufVxuXG4vLyBJbnN0YW5jZSBtZXRob2RzXG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gIHZhciBpID0ga2V5cy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuY29udmVydChrZXlzW2ldLCBvYmpba2V5c1tpXV0pXG4gIH1cbn1cblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgdmFyIGkgPSBpdGVtcy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIE9ic2VydmVyLmNyZWF0ZShpdGVtc1tpXSlcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBwcm9wZXJ0eSBpbnRvIGdldHRlci9zZXR0ZXIgc28gd2UgY2FuIGVtaXRcbiAqIHRoZSBldmVudHMgd2hlbiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQvY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gIGRlZmluZVJlYWN0aXZlKHRoaXMudmFsdWUsIGtleSwgdmFsKVxufVxuXG4vKipcbiAqIEFkZCBhbiBvd25lciB2bSwgc28gdGhhdCB3aGVuICRzZXQvJGRlbGV0ZSBtdXRhdGlvbnNcbiAqIGhhcHBlbiB3ZSBjYW4gbm90aWZ5IG93bmVyIHZtcyB0byBwcm94eSB0aGUga2V5cyBhbmRcbiAqIGRpZ2VzdCB0aGUgd2F0Y2hlcnMuIFRoaXMgaXMgb25seSBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0XG4gKiBpcyBvYnNlcnZlZCBhcyBhbiBpbnN0YW5jZSdzIHJvb3QgJGRhdGEuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLmFkZFZtID0gZnVuY3Rpb24gKHZtKSB7XG4gICh0aGlzLnZtcyB8fCAodGhpcy52bXMgPSBbXSkpLnB1c2godm0pXG59XG5cbi8qKlxuICogUmVtb3ZlIGFuIG93bmVyIHZtLiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBvYmplY3QgaXNcbiAqIHN3YXBwZWQgb3V0IGFzIGFuIGluc3RhbmNlJ3MgJGRhdGEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5yZW1vdmVWbSA9IGZ1bmN0aW9uICh2bSkge1xuICB0aGlzLnZtcy4kcmVtb3ZlKHZtKVxufVxuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG9cbiAqL1xuXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmNcbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1xuICovXG5cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICB2YXIgaSA9IGtleXMubGVuZ3RoXG4gIHZhciBrZXlcbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV1cbiAgICBfLmRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pXG4gIH1cbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSAob2JqLCBrZXksIHZhbCkge1xuICB2YXIgZGVwID0gbmV3IERlcCgpXG4gIHZhciBjaGlsZE9iID0gT2JzZXJ2ZXIuY3JlYXRlKHZhbClcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBtZXRhR2V0dGVyICgpIHtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKVxuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8uaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgZm9yICh2YXIgZSwgaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBlID0gdmFsW2ldXG4gICAgICAgICAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbFxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBtZXRhU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbCkgcmV0dXJuXG4gICAgICB2YWwgPSBuZXdWYWxcbiAgICAgIGNoaWxkT2IgPSBPYnNlcnZlci5jcmVhdGUobmV3VmFsKVxuICAgICAgZGVwLm5vdGlmeSgpXG4gICAgfVxuICB9KVxufVxuXG4vLyBBdHRhY2ggdG8gdGhlIHV0aWwgb2JqZWN0IHNvIGl0IGNhbiBiZSB1c2VkIGVsc2V3aGVyZS5cbl8uZGVmaW5lUmVhY3RpdmUgPSBkZWZpbmVSZWFjdGl2ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9ic2VydmVyXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIENhY2hlID0gcmVxdWlyZSgnLi4vY2FjaGUnKVxudmFyIGNhY2hlID0gbmV3IENhY2hlKDEwMDApXG52YXIgZmlsdGVyVG9rZW5SRSA9IC9bXlxccydcIl0rfCdbXiddKid8XCJbXlwiXSpcIi9nXG52YXIgcmVzZXJ2ZWRBcmdSRSA9IC9eaW4kfF4tP1xcZCsvXG5cbi8qKlxuICogUGFyc2VyIHN0YXRlXG4gKi9cblxudmFyIHN0ciwgZGlyXG52YXIgYywgaSwgbCwgbGFzdEZpbHRlckluZGV4XG52YXIgaW5TaW5nbGUsIGluRG91YmxlLCBjdXJseSwgc3F1YXJlLCBwYXJlblxuXG4vKipcbiAqIFB1c2ggYSBmaWx0ZXIgdG8gdGhlIGN1cnJlbnQgZGlyZWN0aXZlIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICB2YXIgZXhwID0gc3RyLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpXG4gIHZhciBmaWx0ZXJcbiAgaWYgKGV4cCkge1xuICAgIGZpbHRlciA9IHt9XG4gICAgdmFyIHRva2VucyA9IGV4cC5tYXRjaChmaWx0ZXJUb2tlblJFKVxuICAgIGZpbHRlci5uYW1lID0gdG9rZW5zWzBdXG4gICAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgICBmaWx0ZXIuYXJncyA9IHRva2Vucy5zbGljZSgxKS5tYXAocHJvY2Vzc0ZpbHRlckFyZylcbiAgICB9XG4gIH1cbiAgaWYgKGZpbHRlcikge1xuICAgIChkaXIuZmlsdGVycyA9IGRpci5maWx0ZXJzIHx8IFtdKS5wdXNoKGZpbHRlcilcbiAgfVxuICBsYXN0RmlsdGVySW5kZXggPSBpICsgMVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGFyZ3VtZW50IGlzIGR5bmFtaWMgYW5kIHN0cmlwIHF1b3Rlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYXJnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gcHJvY2Vzc0ZpbHRlckFyZyAoYXJnKSB7XG4gIGlmIChyZXNlcnZlZEFyZ1JFLnRlc3QoYXJnKSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogXy50b051bWJlcihhcmcpLFxuICAgICAgZHluYW1pYzogZmFsc2VcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0cmlwcGVkID0gXy5zdHJpcFF1b3RlcyhhcmcpXG4gICAgdmFyIGR5bmFtaWMgPSBzdHJpcHBlZCA9PT0gYXJnXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBkeW5hbWljID8gYXJnIDogc3RyaXBwZWQsXG4gICAgICBkeW5hbWljOiBkeW5hbWljXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYSBkaXJlY3RpdmUgdmFsdWUgYW5kIGV4dHJhY3QgdGhlIGV4cHJlc3Npb25cbiAqIGFuZCBpdHMgZmlsdGVycyBpbnRvIGEgZGVzY3JpcHRvci5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIFwiYSArIDEgfCB1cHBlcmNhc2VcIiB3aWxsIHlpZWxkOlxuICoge1xuICogICBleHByZXNzaW9uOiAnYSArIDEnLFxuICogICBmaWx0ZXJzOiBbXG4gKiAgICAgeyBuYW1lOiAndXBwZXJjYXNlJywgYXJnczogbnVsbCB9XG4gKiAgIF1cbiAqIH1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzKSB7XG5cbiAgdmFyIGhpdCA9IGNhY2hlLmdldChzKVxuICBpZiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdFxuICB9XG5cbiAgLy8gcmVzZXQgcGFyc2VyIHN0YXRlXG4gIHN0ciA9IHNcbiAgaW5TaW5nbGUgPSBpbkRvdWJsZSA9IGZhbHNlXG4gIGN1cmx5ID0gc3F1YXJlID0gcGFyZW4gPSAwXG4gIGxhc3RGaWx0ZXJJbmRleCA9IDBcbiAgZGlyID0ge31cblxuICBmb3IgKGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgLy8gY2hlY2sgc2luZ2xlIHF1b3RlXG4gICAgICBpZiAoYyA9PT0gMHgyNykgaW5TaW5nbGUgPSAhaW5TaW5nbGVcbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICAvLyBjaGVjayBkb3VibGUgcXVvdGVcbiAgICAgIGlmIChjID09PSAweDIyKSBpbkRvdWJsZSA9ICFpbkRvdWJsZVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgc3RyLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDXG4gICAgKSB7XG4gICAgICBpZiAoZGlyLmV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxXG4gICAgICAgIGRpci5leHByZXNzaW9uID0gc3RyLnNsaWNlKDAsIGkpLnRyaW0oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWxyZWFkeSBoYXMgZmlsdGVyXG4gICAgICAgIHB1c2hGaWx0ZXIoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAvLyAnXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpci5leHByZXNzaW9uID09IG51bGwpIHtcbiAgICBkaXIuZXhwcmVzc2lvbiA9IHN0ci5zbGljZSgwLCBpKS50cmltKClcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKClcbiAgfVxuXG4gIGNhY2hlLnB1dChzLCBkaXIpXG4gIHJldHVybiBkaXJcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgUGF0aCA9IHJlcXVpcmUoJy4vcGF0aCcpXG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZScpXG52YXIgZXhwcmVzc2lvbkNhY2hlID0gbmV3IENhY2hlKDEwMDApXG5cbnZhciBhbGxvd2VkS2V5d29yZHMgPVxuICAnTWF0aCxEYXRlLHRoaXMsdHJ1ZSxmYWxzZSxudWxsLHVuZGVmaW5lZCxJbmZpbml0eSxOYU4sJyArXG4gICdpc05hTixpc0Zpbml0ZSxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSwnICtcbiAgJ2VuY29kZVVSSUNvbXBvbmVudCxwYXJzZUludCxwYXJzZUZsb2F0J1xudmFyIGFsbG93ZWRLZXl3b3Jkc1JFID1cbiAgbmV3IFJlZ0V4cCgnXignICsgYWxsb3dlZEtleXdvcmRzLnJlcGxhY2UoLywvZywgJ1xcXFxifCcpICsgJ1xcXFxiKScpXG5cbi8vIGtleXdvcmRzIHRoYXQgZG9uJ3QgbWFrZSBzZW5zZSBpbnNpZGUgZXhwcmVzc2lvbnNcbnZhciBpbXByb3BlcktleXdvcmRzID1cbiAgJ2JyZWFrLGNhc2UsY2xhc3MsY2F0Y2gsY29uc3QsY29udGludWUsZGVidWdnZXIsZGVmYXVsdCwnICtcbiAgJ2RlbGV0ZSxkbyxlbHNlLGV4cG9ydCxleHRlbmRzLGZpbmFsbHksZm9yLGZ1bmN0aW9uLGlmLCcgK1xuICAnaW1wb3J0LGluLGluc3RhbmNlb2YsbGV0LHJldHVybixzdXBlcixzd2l0Y2gsdGhyb3csdHJ5LCcgK1xuICAndmFyLHdoaWxlLHdpdGgseWllbGQsZW51bSxhd2FpdCxpbXBsZW1lbnRzLHBhY2thZ2UsJyArXG4gICdwcm9jdGVjdGVkLHN0YXRpYyxpbnRlcmZhY2UscHJpdmF0ZSxwdWJsaWMnXG52YXIgaW1wcm9wZXJLZXl3b3Jkc1JFID1cbiAgbmV3IFJlZ0V4cCgnXignICsgaW1wcm9wZXJLZXl3b3Jkcy5yZXBsYWNlKC8sL2csICdcXFxcYnwnKSArICdcXFxcYiknKVxuXG52YXIgd3NSRSA9IC9cXHMvZ1xudmFyIG5ld2xpbmVSRSA9IC9cXG4vZ1xudmFyIHNhdmVSRSA9IC9bXFx7LF1cXHMqW1xcd1xcJF9dK1xccyo6fCgnW14nXSonfFwiW15cIl0qXCIpfG5ldyB8dHlwZW9mIHx2b2lkIC9nXG52YXIgcmVzdG9yZVJFID0gL1wiKFxcZCspXCIvZ1xudmFyIHBhdGhUZXN0UkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKFxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXFxdfFxcW1wiLio/XCJcXF18XFxbXFxkK1xcXXxcXFtbQS1aYS16XyRdW1xcdyRdKlxcXSkqJC9cbnZhciBwYXRoUmVwbGFjZVJFID0gL1teXFx3JFxcLl0oW0EtWmEtel8kXVtcXHckXSooXFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPydcXF18XFxbXCIuKj9cIlxcXSkqKS9nXG52YXIgYm9vbGVhbkxpdGVyYWxSRSA9IC9eKHRydWV8ZmFsc2UpJC9cblxuLyoqXG4gKiBTYXZlIC8gUmV3cml0ZSAvIFJlc3RvcmVcbiAqXG4gKiBXaGVuIHJld3JpdGluZyBwYXRocyBmb3VuZCBpbiBhbiBleHByZXNzaW9uLCBpdCBpc1xuICogcG9zc2libGUgZm9yIHRoZSBzYW1lIGxldHRlciBzZXF1ZW5jZXMgdG8gYmUgZm91bmQgaW5cbiAqIHN0cmluZ3MgYW5kIE9iamVjdCBsaXRlcmFsIHByb3BlcnR5IGtleXMuIFRoZXJlZm9yZSB3ZVxuICogcmVtb3ZlIGFuZCBzdG9yZSB0aGVzZSBwYXJ0cyBpbiBhIHRlbXBvcmFyeSBhcnJheSwgYW5kXG4gKiByZXN0b3JlIHRoZW0gYWZ0ZXIgdGhlIHBhdGggcmV3cml0ZS5cbiAqL1xuXG52YXIgc2F2ZWQgPSBbXVxuXG4vKipcbiAqIFNhdmUgcmVwbGFjZXJcbiAqXG4gKiBUaGUgc2F2ZSByZWdleCBjYW4gbWF0Y2ggdHdvIHBvc3NpYmxlIGNhc2VzOlxuICogMS4gQW4gb3BlbmluZyBvYmplY3QgbGl0ZXJhbFxuICogMi4gQSBzdHJpbmdcbiAqIElmIG1hdGNoZWQgYXMgYSBwbGFpbiBzdHJpbmcsIHdlIG5lZWQgdG8gZXNjYXBlIGl0c1xuICogbmV3bGluZXMsIHNpbmNlIHRoZSBzdHJpbmcgbmVlZHMgdG8gYmUgcHJlc2VydmVkIHdoZW5cbiAqIGdlbmVyYXRpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGlzU3RyaW5nIC0gc3RyIGlmIG1hdGNoZWQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gLSBwbGFjZWhvbGRlciB3aXRoIGluZGV4XG4gKi9cblxuZnVuY3Rpb24gc2F2ZSAoc3RyLCBpc1N0cmluZykge1xuICB2YXIgaSA9IHNhdmVkLmxlbmd0aFxuICBzYXZlZFtpXSA9IGlzU3RyaW5nXG4gICAgPyBzdHIucmVwbGFjZShuZXdsaW5lUkUsICdcXFxcbicpXG4gICAgOiBzdHJcbiAgcmV0dXJuICdcIicgKyBpICsgJ1wiJ1xufVxuXG4vKipcbiAqIFBhdGggcmV3cml0ZSByZXBsYWNlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiByZXdyaXRlIChyYXcpIHtcbiAgdmFyIGMgPSByYXcuY2hhckF0KDApXG4gIHZhciBwYXRoID0gcmF3LnNsaWNlKDEpXG4gIGlmIChhbGxvd2VkS2V5d29yZHNSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuIHJhd1xuICB9IGVsc2Uge1xuICAgIHBhdGggPSBwYXRoLmluZGV4T2YoJ1wiJykgPiAtMVxuICAgICAgPyBwYXRoLnJlcGxhY2UocmVzdG9yZVJFLCByZXN0b3JlKVxuICAgICAgOiBwYXRoXG4gICAgcmV0dXJuIGMgKyAnc2NvcGUuJyArIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIFJlc3RvcmUgcmVwbGFjZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gaSAtIG1hdGNoZWQgc2F2ZSBpbmRleFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHJlc3RvcmUgKHN0ciwgaSkge1xuICByZXR1cm4gc2F2ZWRbaV1cbn1cblxuLyoqXG4gKiBSZXdyaXRlIGFuIGV4cHJlc3Npb24sIHByZWZpeGluZyBhbGwgcGF0aCBhY2Nlc3NvcnMgd2l0aFxuICogYHNjb3BlLmAgYW5kIGdlbmVyYXRlIGdldHRlci9zZXR0ZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVlZFNldFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZUV4cEZucyAoZXhwLCBuZWVkU2V0KSB7XG4gIGlmIChpbXByb3BlcktleXdvcmRzUkUudGVzdChleHApKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnQXZvaWQgdXNpbmcgcmVzZXJ2ZWQga2V5d29yZHMgaW4gZXhwcmVzc2lvbjogJyArIGV4cFxuICAgIClcbiAgfVxuICAvLyByZXNldCBzdGF0ZVxuICBzYXZlZC5sZW5ndGggPSAwXG4gIC8vIHNhdmUgc3RyaW5ncyBhbmQgb2JqZWN0IGxpdGVyYWwga2V5c1xuICB2YXIgYm9keSA9IGV4cFxuICAgIC5yZXBsYWNlKHNhdmVSRSwgc2F2ZSlcbiAgICAucmVwbGFjZSh3c1JFLCAnJylcbiAgLy8gcmV3cml0ZSBhbGwgcGF0aHNcbiAgLy8gcGFkIDEgc3BhY2UgaGVyZSBiZWNhdWUgdGhlIHJlZ2V4IG1hdGNoZXMgMSBleHRyYSBjaGFyXG4gIGJvZHkgPSAoJyAnICsgYm9keSlcbiAgICAucmVwbGFjZShwYXRoUmVwbGFjZVJFLCByZXdyaXRlKVxuICAgIC5yZXBsYWNlKHJlc3RvcmVSRSwgcmVzdG9yZSlcbiAgdmFyIGdldHRlciA9IG1ha2VHZXR0ZXIoYm9keSlcbiAgaWYgKGdldHRlcikge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQ6IGdldHRlcixcbiAgICAgIGJvZHk6IGJvZHksXG4gICAgICBzZXQ6IG5lZWRTZXRcbiAgICAgICAgPyBtYWtlU2V0dGVyKGJvZHkpXG4gICAgICAgIDogbnVsbFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgZ2V0dGVyIHNldHRlcnMgZm9yIGEgc2ltcGxlIHBhdGguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVBhdGhGbnMgKGV4cCkge1xuICB2YXIgZ2V0dGVyLCBwYXRoXG4gIGlmIChleHAuaW5kZXhPZignWycpIDwgMCkge1xuICAgIC8vIHJlYWxseSBzaW1wbGUgcGF0aFxuICAgIHBhdGggPSBleHAuc3BsaXQoJy4nKVxuICAgIHBhdGgucmF3ID0gZXhwXG4gICAgZ2V0dGVyID0gUGF0aC5jb21waWxlR2V0dGVyKHBhdGgpXG4gIH0gZWxzZSB7XG4gICAgLy8gZG8gdGhlIHJlYWwgcGFyc2luZ1xuICAgIHBhdGggPSBQYXRoLnBhcnNlKGV4cClcbiAgICBnZXR0ZXIgPSBwYXRoLmdldFxuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0OiBnZXR0ZXIsXG4gICAgLy8gYWx3YXlzIGdlbmVyYXRlIHNldHRlciBmb3Igc2ltcGxlIHBhdGhzXG4gICAgc2V0OiBmdW5jdGlvbiAob2JqLCB2YWwpIHtcbiAgICAgIFBhdGguc2V0KG9iaiwgcGF0aCwgdmFsKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkIGEgZ2V0dGVyIGZ1bmN0aW9uLiBSZXF1aXJlcyBldmFsLlxuICpcbiAqIFdlIGlzb2xhdGUgdGhlIHRyeS9jYXRjaCBzbyBpdCBkb2Vzbid0IGFmZmVjdCB0aGVcbiAqIG9wdGltaXphdGlvbiBvZiB0aGUgcGFyc2UgZnVuY3Rpb24gd2hlbiBpdCBpcyBub3QgY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBib2R5XG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gbWFrZUdldHRlciAoYm9keSkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3Njb3BlJywgJ3JldHVybiAnICsgYm9keSArICc7JylcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgJ0ludmFsaWQgZXhwcmVzc2lvbi4gJyArXG4gICAgICAnR2VuZXJhdGVkIGZ1bmN0aW9uIGJvZHk6ICcgKyBib2R5XG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQnVpbGQgYSBzZXR0ZXIgZnVuY3Rpb24uXG4gKlxuICogVGhpcyBpcyBvbmx5IG5lZWRlZCBpbiByYXJlIHNpdHVhdGlvbnMgbGlrZSBcImFbYl1cIiB3aGVyZVxuICogYSBzZXR0YWJsZSBwYXRoIHJlcXVpcmVzIGR5bmFtaWMgZXZhbHVhdGlvbi5cbiAqXG4gKiBUaGlzIHNldHRlciBmdW5jdGlvbiBtYXkgdGhyb3cgZXJyb3Igd2hlbiBjYWxsZWQgaWYgdGhlXG4gKiBleHByZXNzaW9uIGJvZHkgaXMgbm90IGEgdmFsaWQgbGVmdC1oYW5kIGV4cHJlc3Npb24gaW5cbiAqIGFzc2lnbm1lbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJvZHlcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlU2V0dGVyIChib2R5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbignc2NvcGUnLCAndmFsdWUnLCBib2R5ICsgJz12YWx1ZTsnKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnSW52YWxpZCBzZXR0ZXIgZnVuY3Rpb24gYm9keTogJyArIGJvZHlcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBmb3Igc2V0dGVyIGV4aXN0ZW5jZSBvbiBhIGNhY2hlIGhpdC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoaXRcbiAqL1xuXG5mdW5jdGlvbiBjaGVja1NldHRlciAoaGl0KSB7XG4gIGlmICghaGl0LnNldCkge1xuICAgIGhpdC5zZXQgPSBtYWtlU2V0dGVyKGhpdC5ib2R5KVxuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYW4gZXhwcmVzc2lvbiBpbnRvIHJlLXdyaXR0ZW4gZ2V0dGVyL3NldHRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHBhcmFtIHtCb29sZWFufSBuZWVkU2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKGV4cCwgbmVlZFNldCkge1xuICBleHAgPSBleHAudHJpbSgpXG4gIC8vIHRyeSBjYWNoZVxuICB2YXIgaGl0ID0gZXhwcmVzc2lvbkNhY2hlLmdldChleHApXG4gIGlmIChoaXQpIHtcbiAgICBpZiAobmVlZFNldCkge1xuICAgICAgY2hlY2tTZXR0ZXIoaGl0KVxuICAgIH1cbiAgICByZXR1cm4gaGl0XG4gIH1cbiAgLy8gd2UgZG8gYSBzaW1wbGUgcGF0aCBjaGVjayB0byBvcHRpbWl6ZSBmb3IgdGhlbS5cbiAgLy8gdGhlIGNoZWNrIGZhaWxzIHZhbGlkIHBhdGhzIHdpdGggdW51c2FsIHdoaXRlc3BhY2VzLFxuICAvLyBidXQgdGhhdCdzIHRvbyByYXJlIGFuZCB3ZSBkb24ndCBjYXJlLlxuICAvLyBhbHNvIHNraXAgYm9vbGVhbiBsaXRlcmFscyBhbmQgcGF0aHMgdGhhdCBzdGFydCB3aXRoXG4gIC8vIGdsb2JhbCBcIk1hdGhcIlxuICB2YXIgcmVzID0gZXhwb3J0cy5pc1NpbXBsZVBhdGgoZXhwKVxuICAgID8gY29tcGlsZVBhdGhGbnMoZXhwKVxuICAgIDogY29tcGlsZUV4cEZucyhleHAsIG5lZWRTZXQpXG4gIGV4cHJlc3Npb25DYWNoZS5wdXQoZXhwLCByZXMpXG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgc2ltcGxlIHBhdGguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzU2ltcGxlUGF0aCA9IGZ1bmN0aW9uIChleHApIHtcbiAgcmV0dXJuIHBhdGhUZXN0UkUudGVzdChleHApICYmXG4gICAgLy8gZG9uJ3QgdHJlYXQgdHJ1ZS9mYWxzZSBhcyBwYXRoc1xuICAgICFib29sZWFuTGl0ZXJhbFJFLnRlc3QoZXhwKSAmJlxuICAgIC8vIE1hdGggY29uc3RhbnRzIGUuZy4gTWF0aC5QSSwgTWF0aC5FIGV0Yy5cbiAgICBleHAuc2xpY2UoMCwgNSkgIT09ICdNYXRoLidcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZScpXG52YXIgcGF0aENhY2hlID0gbmV3IENhY2hlKDEwMDApXG52YXIgaWRlbnRSRSA9IGV4cG9ydHMuaWRlbnRSRSA9IC9eWyRfYS16QS1aXStbXFx3JF0qJC9cblxuLy8gYWN0aW9uc1xudmFyIEFQUEVORCA9IDBcbnZhciBQVVNIID0gMVxuXG4vLyBzdGF0ZXNcbnZhciBCRUZPUkVfUEFUSCA9IDBcbnZhciBJTl9QQVRIID0gMVxudmFyIEJFRk9SRV9JREVOVCA9IDJcbnZhciBJTl9JREVOVCA9IDNcbnZhciBCRUZPUkVfRUxFTUVOVCA9IDRcbnZhciBBRlRFUl9aRVJPID0gNVxudmFyIElOX0lOREVYID0gNlxudmFyIElOX1NJTkdMRV9RVU9URSA9IDdcbnZhciBJTl9ET1VCTEVfUVVPVEUgPSA4XG52YXIgSU5fU1VCX1BBVEggPSA5XG52YXIgQUZURVJfRUxFTUVOVCA9IDEwXG52YXIgQUZURVJfUEFUSCA9IDExXG52YXIgRVJST1IgPSAxMlxuXG52YXIgcGF0aFN0YXRlTWFjaGluZSA9IFtdXG5cbnBhdGhTdGF0ZU1hY2hpbmVbQkVGT1JFX1BBVEhdID0ge1xuICAnd3MnOiBbQkVGT1JFX1BBVEhdLFxuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICdbJzogW0JFRk9SRV9FTEVNRU5UXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRIXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1BBVEhdID0ge1xuICAnd3MnOiBbSU5fUEFUSF0sXG4gICcuJzogW0JFRk9SRV9JREVOVF0sXG4gICdbJzogW0JFRk9SRV9FTEVNRU5UXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRIXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0JFRk9SRV9JREVOVF0gPSB7XG4gICd3cyc6IFtCRUZPUkVfSURFTlRdLFxuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF1cbn1cblxucGF0aFN0YXRlTWFjaGluZVtJTl9JREVOVF0gPSB7XG4gICdpZGVudCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJzAnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICdudW1iZXInOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICd3cyc6IFtJTl9QQVRILCBQVVNIXSxcbiAgJy4nOiBbQkVGT1JFX0lERU5ULCBQVVNIXSxcbiAgJ1snOiBbQkVGT1JFX0VMRU1FTlQsIFBVU0hdLFxuICAnZW9mJzogW0FGVEVSX1BBVEgsIFBVU0hdXG59XG5cbnBhdGhTdGF0ZU1hY2hpbmVbQkVGT1JFX0VMRU1FTlRdID0ge1xuICAnd3MnOiBbQkVGT1JFX0VMRU1FTlRdLFxuICAnMCc6IFtBRlRFUl9aRVJPLCBBUFBFTkRdLFxuICAnbnVtYmVyJzogW0lOX0lOREVYLCBBUFBFTkRdLFxuICBcIidcIjogW0lOX1NJTkdMRV9RVU9URSwgQVBQRU5ELCAnJ10sXG4gICdcIic6IFtJTl9ET1VCTEVfUVVPVEUsIEFQUEVORCwgJyddLFxuICAnaWRlbnQnOiBbSU5fU1VCX1BBVEgsIEFQUEVORCwgJyonXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0FGVEVSX1pFUk9dID0ge1xuICAnd3MnOiBbQUZURVJfRUxFTUVOVCwgUFVTSF0sXG4gICddJzogW0lOX1BBVEgsIFBVU0hdXG59XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fSU5ERVhdID0ge1xuICAnMCc6IFtJTl9JTkRFWCwgQVBQRU5EXSxcbiAgJ251bWJlcic6IFtJTl9JTkRFWCwgQVBQRU5EXSxcbiAgJ3dzJzogW0FGVEVSX0VMRU1FTlRdLFxuICAnXSc6IFtJTl9QQVRILCBQVVNIXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1NJTkdMRV9RVU9URV0gPSB7XG4gIFwiJ1wiOiBbQUZURVJfRUxFTUVOVF0sXG4gICdlb2YnOiBFUlJPUixcbiAgJ2Vsc2UnOiBbSU5fU0lOR0xFX1FVT1RFLCBBUFBFTkRdXG59XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fRE9VQkxFX1FVT1RFXSA9IHtcbiAgJ1wiJzogW0FGVEVSX0VMRU1FTlRdLFxuICAnZW9mJzogRVJST1IsXG4gICdlbHNlJzogW0lOX0RPVUJMRV9RVU9URSwgQVBQRU5EXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1NVQl9QQVRIXSA9IHtcbiAgJ2lkZW50JzogW0lOX1NVQl9QQVRILCBBUFBFTkRdLFxuICAnMCc6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXSxcbiAgJ251bWJlcic6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXSxcbiAgJ3dzJzogW0FGVEVSX0VMRU1FTlRdLFxuICAnXSc6IFtJTl9QQVRILCBQVVNIXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0FGVEVSX0VMRU1FTlRdID0ge1xuICAnd3MnOiBbQUZURVJfRUxFTUVOVF0sXG4gICddJzogW0lOX1BBVEgsIFBVU0hdXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgY2hhcmFjdGVyIGluIGEga2V5cGF0aC5cbiAqXG4gKiBAcGFyYW0ge0NoYXJ9IGNoXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXRoQ2hhclR5cGUgKGNoKSB7XG4gIGlmIChjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICdlb2YnXG4gIH1cblxuICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMClcblxuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4NUI6IC8vIFtcbiAgICBjYXNlIDB4NUQ6IC8vIF1cbiAgICBjYXNlIDB4MkU6IC8vIC5cbiAgICBjYXNlIDB4MjI6IC8vIFwiXG4gICAgY2FzZSAweDI3OiAvLyAnXG4gICAgY2FzZSAweDMwOiAvLyAwXG4gICAgICByZXR1cm4gY2hcblxuICAgIGNhc2UgMHg1RjogLy8gX1xuICAgIGNhc2UgMHgyNDogLy8gJFxuICAgICAgcmV0dXJuICdpZGVudCdcblxuICAgIGNhc2UgMHgyMDogLy8gU3BhY2VcbiAgICBjYXNlIDB4MDk6IC8vIFRhYlxuICAgIGNhc2UgMHgwQTogLy8gTmV3bGluZVxuICAgIGNhc2UgMHgwRDogLy8gUmV0dXJuXG4gICAgY2FzZSAweEEwOiAgLy8gTm8tYnJlYWsgc3BhY2VcbiAgICBjYXNlIDB4RkVGRjogIC8vIEJ5dGUgT3JkZXIgTWFya1xuICAgIGNhc2UgMHgyMDI4OiAgLy8gTGluZSBTZXBhcmF0b3JcbiAgICBjYXNlIDB4MjAyOTogIC8vIFBhcmFncmFwaCBTZXBhcmF0b3JcbiAgICAgIHJldHVybiAnd3MnXG4gIH1cblxuICAvLyBhLXosIEEtWlxuICBpZiAoXG4gICAgKGNvZGUgPj0gMHg2MSAmJiBjb2RlIDw9IDB4N0EpIHx8XG4gICAgKGNvZGUgPj0gMHg0MSAmJiBjb2RlIDw9IDB4NUEpXG4gICkge1xuICAgIHJldHVybiAnaWRlbnQnXG4gIH1cblxuICAvLyAxLTlcbiAgaWYgKGNvZGUgPj0gMHgzMSAmJiBjb2RlIDw9IDB4MzkpIHtcbiAgICByZXR1cm4gJ251bWJlcidcbiAgfVxuXG4gIHJldHVybiAnZWxzZSdcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBwYXRoIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICB2YXIga2V5cyA9IFtdXG4gIHZhciBpbmRleCA9IC0xXG4gIHZhciBtb2RlID0gQkVGT1JFX1BBVEhcbiAgdmFyIGMsIG5ld0NoYXIsIGtleSwgdHlwZSwgdHJhbnNpdGlvbiwgYWN0aW9uLCB0eXBlTWFwXG5cbiAgdmFyIGFjdGlvbnMgPSBbXVxuICBhY3Rpb25zW1BVU0hdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGtleXMucHVzaChrZXkpXG4gICAga2V5ID0gdW5kZWZpbmVkXG4gIH1cbiAgYWN0aW9uc1tBUFBFTkRdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gbmV3Q2hhclxuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgKz0gbmV3Q2hhclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlVW5lc2NhcGVRdW90ZSAoKSB7XG4gICAgdmFyIG5leHRDaGFyID0gcGF0aFtpbmRleCArIDFdXG4gICAgaWYgKChtb2RlID09PSBJTl9TSU5HTEVfUVVPVEUgJiYgbmV4dENoYXIgPT09IFwiJ1wiKSB8fFxuICAgICAgICAobW9kZSA9PT0gSU5fRE9VQkxFX1FVT1RFICYmIG5leHRDaGFyID09PSAnXCInKSkge1xuICAgICAgaW5kZXgrK1xuICAgICAgbmV3Q2hhciA9IG5leHRDaGFyXG4gICAgICBhY3Rpb25zW0FQUEVORF0oKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICB3aGlsZSAobW9kZSAhPSBudWxsKSB7XG4gICAgaW5kZXgrK1xuICAgIGMgPSBwYXRoW2luZGV4XVxuXG4gICAgaWYgKGMgPT09ICdcXFxcJyAmJiBtYXliZVVuZXNjYXBlUXVvdGUoKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB0eXBlID0gZ2V0UGF0aENoYXJUeXBlKGMpXG4gICAgdHlwZU1hcCA9IHBhdGhTdGF0ZU1hY2hpbmVbbW9kZV1cbiAgICB0cmFuc2l0aW9uID0gdHlwZU1hcFt0eXBlXSB8fCB0eXBlTWFwWydlbHNlJ10gfHwgRVJST1JcblxuICAgIGlmICh0cmFuc2l0aW9uID09PSBFUlJPUikge1xuICAgICAgcmV0dXJuIC8vIHBhcnNlIGVycm9yXG4gICAgfVxuXG4gICAgbW9kZSA9IHRyYW5zaXRpb25bMF1cbiAgICBhY3Rpb24gPSBhY3Rpb25zW3RyYW5zaXRpb25bMV1dXG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgbmV3Q2hhciA9IHRyYW5zaXRpb25bMl1cbiAgICAgIG5ld0NoYXIgPSBuZXdDaGFyID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBjXG4gICAgICAgIDogbmV3Q2hhciA9PT0gJyonXG4gICAgICAgICAgPyBuZXdDaGFyICsgY1xuICAgICAgICAgIDogbmV3Q2hhclxuICAgICAgYWN0aW9uKClcbiAgICB9XG5cbiAgICBpZiAobW9kZSA9PT0gQUZURVJfUEFUSCkge1xuICAgICAga2V5cy5yYXcgPSBwYXRoXG4gICAgICByZXR1cm4ga2V5c1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEZvcm1hdCBhIGFjY2Vzc29yIHNlZ21lbnQgYmFzZWQgb24gaXRzIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBY2Nlc3NvciAoa2V5KSB7XG4gIGlmIChpZGVudFJFLnRlc3Qoa2V5KSkgeyAvLyBpZGVudGlmaWVyXG4gICAgcmV0dXJuICcuJyArIGtleVxuICB9IGVsc2UgaWYgKCtrZXkgPT09IGtleSA+Pj4gMCkgeyAvLyBicmFja2V0IGluZGV4XG4gICAgcmV0dXJuICdbJyArIGtleSArICddJ1xuICB9IGVsc2UgaWYgKGtleS5jaGFyQXQoMCkgPT09ICcqJykge1xuICAgIHJldHVybiAnW28nICsgZm9ybWF0QWNjZXNzb3Ioa2V5LnNsaWNlKDEpKSArICddJ1xuICB9IGVsc2UgeyAvLyBicmFja2V0IHN0cmluZ1xuICAgIHJldHVybiAnW1wiJyArIGtleS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyAnXCJdJ1xuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZXMgYSBnZXR0ZXIgZnVuY3Rpb24gd2l0aCBhIGZpeGVkIHBhdGguXG4gKiBUaGUgZml4ZWQgcGF0aCBnZXR0ZXIgc3VwcmVzc2VzIGVycm9ycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnRzLmNvbXBpbGVHZXR0ZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICB2YXIgYm9keSA9ICdyZXR1cm4gbycgKyBwYXRoLm1hcChmb3JtYXRBY2Nlc3Nvcikuam9pbignJylcbiAgcmV0dXJuIG5ldyBGdW5jdGlvbignbycsIGJvZHkpXG59XG5cbi8qKlxuICogRXh0ZXJuYWwgcGFyc2UgdGhhdCBjaGVjayBmb3IgYSBjYWNoZSBoaXQgZmlyc3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl8dW5kZWZpbmVkfVxuICovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAocGF0aCkge1xuICB2YXIgaGl0ID0gcGF0aENhY2hlLmdldChwYXRoKVxuICBpZiAoIWhpdCkge1xuICAgIGhpdCA9IHBhcnNlUGF0aChwYXRoKVxuICAgIGlmIChoaXQpIHtcbiAgICAgIGhpdC5nZXQgPSBleHBvcnRzLmNvbXBpbGVHZXR0ZXIoaGl0KVxuICAgICAgcGF0aENhY2hlLnB1dChwYXRoLCBoaXQpXG4gICAgfVxuICB9XG4gIHJldHVybiBoaXRcbn1cblxuLyoqXG4gKiBHZXQgZnJvbSBhbiBvYmplY3QgZnJvbSBhIHBhdGggc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqL1xuXG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uIChvYmosIHBhdGgpIHtcbiAgcGF0aCA9IGV4cG9ydHMucGFyc2UocGF0aClcbiAgaWYgKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5nZXQob2JqKVxuICB9XG59XG5cbi8qKlxuICogV2FybiBhZ2FpbnN0IHNldHRpbmcgbm9uLWV4aXN0ZW50IHJvb3QgcGF0aCBvbiBhIHZtLlxuICovXG5cbnZhciB3YXJuTm9uRXhpc3RlbnRcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5Ob25FeGlzdGVudCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgXy53YXJuKFxuICAgICAgJ1lvdSBhcmUgc2V0dGluZyBhIG5vbi1leGlzdGVudCBwYXRoIFwiJyArIHBhdGgucmF3ICsgJ1wiICcgK1xuICAgICAgJ29uIGEgdm0gaW5zdGFuY2UuIENvbnNpZGVyIHByZS1pbml0aWFsaXppbmcgdGhlIHByb3BlcnR5ICcgK1xuICAgICAgJ3dpdGggdGhlIFwiZGF0YVwiIG9wdGlvbiBmb3IgbW9yZSByZWxpYWJsZSByZWFjdGl2aXR5ICcgK1xuICAgICAgJ2FuZCBiZXR0ZXIgcGVyZm9ybWFuY2UuJ1xuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIFNldCBvbiBhbiBvYmplY3QgZnJvbSBhIHBhdGhcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBwYXRoXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgdmFsKSB7XG4gIHZhciBvcmlnaW5hbCA9IG9ialxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IGV4cG9ydHMucGFyc2UocGF0aClcbiAgfVxuICBpZiAoIXBhdGggfHwgIV8uaXNPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBsYXN0LCBrZXlcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxhc3QgPSBvYmpcbiAgICBrZXkgPSBwYXRoW2ldXG4gICAgaWYgKGtleS5jaGFyQXQoMCkgPT09ICcqJykge1xuICAgICAga2V5ID0gb3JpZ2luYWxba2V5LnNsaWNlKDEpXVxuICAgIH1cbiAgICBpZiAoaSA8IGwgLSAxKSB7XG4gICAgICBvYmogPSBvYmpba2V5XVxuICAgICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgb2JqID0ge31cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbGFzdC5faXNWdWUpIHtcbiAgICAgICAgICB3YXJuTm9uRXhpc3RlbnQocGF0aClcbiAgICAgICAgfVxuICAgICAgICBfLnNldChsYXN0LCBrZXksIG9iailcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF8uaXNBcnJheShvYmopKSB7XG4gICAgICAgIG9iai4kc2V0KGtleSwgdmFsKVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvYmouX2lzVnVlKSB7XG4gICAgICAgICAgd2Fybk5vbkV4aXN0ZW50KHBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgXy5zZXQob2JqLCBrZXksIHZhbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZScpXG52YXIgdGVtcGxhdGVDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKVxudmFyIGlkU2VsZWN0b3JDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKVxuXG52YXIgbWFwID0ge1xuICBfZGVmYXVsdDogWzAsICcnLCAnJ10sXG4gIGxlZ2VuZDogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gIHRyOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcbiAgY29sOiBbXG4gICAgMixcbiAgICAnPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4nLFxuICAgICc8L2NvbGdyb3VwPjwvdGFibGU+J1xuICBdXG59XG5cbm1hcC50ZCA9XG5tYXAudGggPSBbXG4gIDMsXG4gICc8dGFibGU+PHRib2R5Pjx0cj4nLFxuICAnPC90cj48L3Rib2R5PjwvdGFibGU+J1xuXVxuXG5tYXAub3B0aW9uID1cbm1hcC5vcHRncm91cCA9IFtcbiAgMSxcbiAgJzxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPicsXG4gICc8L3NlbGVjdD4nXG5dXG5cbm1hcC50aGVhZCA9XG5tYXAudGJvZHkgPVxubWFwLmNvbGdyb3VwID1cbm1hcC5jYXB0aW9uID1cbm1hcC50Zm9vdCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddXG5cbm1hcC5nID1cbm1hcC5kZWZzID1cbm1hcC5zeW1ib2wgPVxubWFwLnVzZSA9XG5tYXAuaW1hZ2UgPVxubWFwLnRleHQgPVxubWFwLmNpcmNsZSA9XG5tYXAuZWxsaXBzZSA9XG5tYXAubGluZSA9XG5tYXAucGF0aCA9XG5tYXAucG9seWdvbiA9XG5tYXAucG9seWxpbmUgPVxubWFwLnJlY3QgPSBbXG4gIDEsXG4gICc8c3ZnICcgK1xuICAgICd4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyArXG4gICAgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiICcgK1xuICAgICd4bWxuczpldj1cImh0dHA6Ly93d3cudzMub3JnLzIwMDEveG1sLWV2ZW50c1wiJyArXG4gICAgJ3ZlcnNpb249XCIxLjFcIj4nLFxuICAnPC9zdmc+J1xuXVxuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBhIHN1cHBvcnRlZCB0ZW1wbGF0ZSBub2RlIHdpdGggYVxuICogRG9jdW1lbnRGcmFnbWVudCBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1JlYWxUZW1wbGF0ZSAobm9kZSkge1xuICByZXR1cm4gXy5pc1RlbXBsYXRlKG5vZGUpICYmXG4gICAgbm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudFxufVxuXG52YXIgdGFnUkUgPSAvPChbXFx3Ol0rKS9cbnZhciBlbnRpdHlSRSA9IC8mXFx3Kzt8JiNcXGQrO3wmI3hbXFxkQS1GXSs7L1xuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgdGVtcGxhdGUgdG8gYSBEb2N1bWVudEZyYWdtZW50LlxuICogRGV0ZXJtaW5lcyBjb3JyZWN0IHdyYXBwaW5nIGJ5IHRhZyB0eXBlcy4gV3JhcHBpbmdcbiAqIHN0cmF0ZWd5IGZvdW5kIGluIGpRdWVyeSAmIGNvbXBvbmVudC9kb21pZnkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlU3RyaW5nXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ1RvRnJhZ21lbnQgKHRlbXBsYXRlU3RyaW5nKSB7XG4gIC8vIHRyeSBhIGNhY2hlIGhpdCBmaXJzdFxuICB2YXIgaGl0ID0gdGVtcGxhdGVDYWNoZS5nZXQodGVtcGxhdGVTdHJpbmcpXG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0XG4gIH1cblxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICB2YXIgdGFnTWF0Y2ggPSB0ZW1wbGF0ZVN0cmluZy5tYXRjaCh0YWdSRSlcbiAgdmFyIGVudGl0eU1hdGNoID0gZW50aXR5UkUudGVzdCh0ZW1wbGF0ZVN0cmluZylcblxuICBpZiAoIXRhZ01hdGNoICYmICFlbnRpdHlNYXRjaCkge1xuICAgIC8vIHRleHQgb25seSwgcmV0dXJuIGEgc2luZ2xlIHRleHQgbm9kZS5cbiAgICBmcmFnLmFwcGVuZENoaWxkKFxuICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGVtcGxhdGVTdHJpbmcpXG4gICAgKVxuICB9IGVsc2Uge1xuXG4gICAgdmFyIHRhZyA9IHRhZ01hdGNoICYmIHRhZ01hdGNoWzFdXG4gICAgdmFyIHdyYXAgPSBtYXBbdGFnXSB8fCBtYXAuX2RlZmF1bHRcbiAgICB2YXIgZGVwdGggPSB3cmFwWzBdXG4gICAgdmFyIHByZWZpeCA9IHdyYXBbMV1cbiAgICB2YXIgc3VmZml4ID0gd3JhcFsyXVxuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICAgIG5vZGUuaW5uZXJIVE1MID0gcHJlZml4ICsgdGVtcGxhdGVTdHJpbmcudHJpbSgpICsgc3VmZml4XG4gICAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZFxuICAgIH1cblxuICAgIHZhciBjaGlsZFxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgd2hpbGUgKGNoaWxkID0gbm9kZS5maXJzdENoaWxkKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZChjaGlsZClcbiAgICB9XG4gIH1cblxuICB0ZW1wbGF0ZUNhY2hlLnB1dCh0ZW1wbGF0ZVN0cmluZywgZnJhZylcbiAgcmV0dXJuIGZyYWdcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdGVtcGxhdGUgbm9kZSB0byBhIERvY3VtZW50RnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIG5vZGVUb0ZyYWdtZW50IChub2RlKSB7XG4gIC8vIGlmIGl0cyBhIHRlbXBsYXRlIHRhZyBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQsXG4gIC8vIGl0cyBjb250ZW50IGlzIGFscmVhZHkgYSBkb2N1bWVudCBmcmFnbWVudC5cbiAgaWYgKGlzUmVhbFRlbXBsYXRlKG5vZGUpKSB7XG4gICAgXy50cmltTm9kZShub2RlLmNvbnRlbnQpXG4gICAgcmV0dXJuIG5vZGUuY29udGVudFxuICB9XG4gIC8vIHNjcmlwdCB0ZW1wbGF0ZVxuICBpZiAobm9kZS50YWdOYW1lID09PSAnU0NSSVBUJykge1xuICAgIHJldHVybiBzdHJpbmdUb0ZyYWdtZW50KG5vZGUudGV4dENvbnRlbnQpXG4gIH1cbiAgLy8gbm9ybWFsIG5vZGUsIGNsb25lIGl0IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbFxuICB2YXIgY2xvbmUgPSBleHBvcnRzLmNsb25lKG5vZGUpXG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gIHZhciBjaGlsZFxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICB3aGlsZSAoY2hpbGQgPSBjbG9uZS5maXJzdENoaWxkKSB7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBmcmFnLmFwcGVuZENoaWxkKGNoaWxkKVxuICB9XG4gIF8udHJpbU5vZGUoZnJhZylcbiAgcmV0dXJuIGZyYWdcbn1cblxuLy8gVGVzdCBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZSBTYWZhcmkgdGVtcGxhdGUgY2xvbmluZyBidWdcbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzc3NTVcbnZhciBoYXNCcm9rZW5UZW1wbGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChfLmluQnJvd3Nlcikge1xuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBhLmlubmVySFRNTCA9ICc8dGVtcGxhdGU+MTwvdGVtcGxhdGU+J1xuICAgIHJldHVybiAhYS5jbG9uZU5vZGUodHJ1ZSkuZmlyc3RDaGlsZC5pbm5lckhUTUxcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vLyBUZXN0IGZvciBJRTEwLzExIHRleHRhcmVhIHBsYWNlaG9sZGVyIGNsb25lIGJ1Z1xudmFyIGhhc1RleHRhcmVhQ2xvbmVCdWcgPSAoZnVuY3Rpb24gKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoXy5pbkJyb3dzZXIpIHtcbiAgICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJylcbiAgICB0LnBsYWNlaG9sZGVyID0gJ3QnXG4gICAgcmV0dXJuIHQuY2xvbmVOb2RlKHRydWUpLnZhbHVlID09PSAndCdcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIDEuIERlYWwgd2l0aCBTYWZhcmkgY2xvbmluZyBuZXN0ZWQgPHRlbXBsYXRlPiBidWcgYnlcbiAqICAgIG1hbnVhbGx5IGNsb25pbmcgYWxsIHRlbXBsYXRlIGluc3RhbmNlcy5cbiAqIDIuIERlYWwgd2l0aCBJRTEwLzExIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1ZyBieSBzZXR0aW5nXG4gKiAgICB0aGUgY29ycmVjdCB2YWx1ZSBhZnRlciBjbG9uaW5nLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICghbm9kZS5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKClcbiAgfVxuICB2YXIgcmVzID0gbm9kZS5jbG9uZU5vZGUodHJ1ZSlcbiAgdmFyIGksIG9yaWdpbmFsLCBjbG9uZWRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChoYXNCcm9rZW5UZW1wbGF0ZSkge1xuICAgIHZhciBjbG9uZSA9IHJlc1xuICAgIGlmIChpc1JlYWxUZW1wbGF0ZShub2RlKSkge1xuICAgICAgbm9kZSA9IG5vZGUuY29udGVudFxuICAgICAgY2xvbmUgPSByZXMuY29udGVudFxuICAgIH1cbiAgICBvcmlnaW5hbCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgndGVtcGxhdGUnKVxuICAgIGlmIChvcmlnaW5hbC5sZW5ndGgpIHtcbiAgICAgIGNsb25lZCA9IGNsb25lLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RlbXBsYXRlJylcbiAgICAgIGkgPSBjbG9uZWQubGVuZ3RoXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNsb25lZFtpXS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChcbiAgICAgICAgICBleHBvcnRzLmNsb25lKG9yaWdpbmFsW2ldKSxcbiAgICAgICAgICBjbG9uZWRbaV1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGhhc1RleHRhcmVhQ2xvbmVCdWcpIHtcbiAgICBpZiAobm9kZS50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICByZXMudmFsdWUgPSBub2RlLnZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIG9yaWdpbmFsID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0YXJlYScpXG4gICAgICBpZiAob3JpZ2luYWwubGVuZ3RoKSB7XG4gICAgICAgIGNsb25lZCA9IHJlcy5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0YXJlYScpXG4gICAgICAgIGkgPSBjbG9uZWQubGVuZ3RoXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjbG9uZWRbaV0udmFsdWUgPSBvcmlnaW5hbFtpXS52YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHRoZSB0ZW1wbGF0ZSBvcHRpb24gYW5kIG5vcm1hbGl6ZXMgaXQgaW50byBhXG4gKiBhIERvY3VtZW50RnJhZ21lbnQgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHBhcnRpYWwgb3IgYVxuICogaW5zdGFuY2UgdGVtcGxhdGUuXG4gKlxuICogQHBhcmFtIHsqfSB0ZW1wbGF0ZVxuICogICAgUG9zc2libGUgdmFsdWVzIGluY2x1ZGU6XG4gKiAgICAtIERvY3VtZW50RnJhZ21lbnQgb2JqZWN0XG4gKiAgICAtIE5vZGUgb2JqZWN0IG9mIHR5cGUgVGVtcGxhdGVcbiAqICAgIC0gaWQgc2VsZWN0b3I6ICcjc29tZS10ZW1wbGF0ZS1pZCdcbiAqICAgIC0gdGVtcGxhdGUgc3RyaW5nOiAnPGRpdj48c3Bhbj57e21zZ319PC9zcGFuPjwvZGl2PidcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xvbmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9TZWxlY3RvclxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudHx1bmRlZmluZWR9XG4gKi9cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgY2xvbmUsIG5vU2VsZWN0b3IpIHtcbiAgdmFyIG5vZGUsIGZyYWdcblxuICAvLyBpZiB0aGUgdGVtcGxhdGUgaXMgYWxyZWFkeSBhIGRvY3VtZW50IGZyYWdtZW50LFxuICAvLyBkbyBub3RoaW5nXG4gIGlmICh0ZW1wbGF0ZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICBfLnRyaW1Ob2RlKHRlbXBsYXRlKVxuICAgIHJldHVybiBjbG9uZVxuICAgICAgPyBleHBvcnRzLmNsb25lKHRlbXBsYXRlKVxuICAgICAgOiB0ZW1wbGF0ZVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBpZCBzZWxlY3RvclxuICAgIGlmICghbm9TZWxlY3RvciAmJiB0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgLy8gaWQgc2VsZWN0b3IgY2FuIGJlIGNhY2hlZCB0b29cbiAgICAgIGZyYWcgPSBpZFNlbGVjdG9yQ2FjaGUuZ2V0KHRlbXBsYXRlKVxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0ZW1wbGF0ZS5zbGljZSgxKSlcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBmcmFnID0gbm9kZVRvRnJhZ21lbnQobm9kZSlcbiAgICAgICAgICAvLyBzYXZlIHNlbGVjdG9yIHRvIGNhY2hlXG4gICAgICAgICAgaWRTZWxlY3RvckNhY2hlLnB1dCh0ZW1wbGF0ZSwgZnJhZylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3JtYWwgc3RyaW5nIHRlbXBsYXRlXG4gICAgICBmcmFnID0gc3RyaW5nVG9GcmFnbWVudCh0ZW1wbGF0ZSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAvLyBhIGRpcmVjdCBub2RlXG4gICAgZnJhZyA9IG5vZGVUb0ZyYWdtZW50KHRlbXBsYXRlKVxuICB9XG5cbiAgcmV0dXJuIGZyYWcgJiYgY2xvbmVcbiAgICA/IGV4cG9ydHMuY2xvbmUoZnJhZylcbiAgICA6IGZyYWdcbn1cbiIsInZhciBDYWNoZSA9IHJlcXVpcmUoJy4uL2NhY2hlJylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxudmFyIGRpclBhcnNlciA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlJylcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZ1xudmFyIGNhY2hlLCB0YWdSRSwgaHRtbFJFXG5cbi8qKlxuICogRXNjYXBlIGEgc3RyaW5nIHNvIGl0IGNhbiBiZSB1c2VkIGluIGEgUmVnRXhwXG4gKiBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlUmVnZXggKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpXG59XG5cbmV4cG9ydHMuY29tcGlsZVJlZ2V4ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3BlbiA9IGVzY2FwZVJlZ2V4KGNvbmZpZy5kZWxpbWl0ZXJzWzBdKVxuICB2YXIgY2xvc2UgPSBlc2NhcGVSZWdleChjb25maWcuZGVsaW1pdGVyc1sxXSlcbiAgdmFyIHVuc2FmZU9wZW4gPSBlc2NhcGVSZWdleChjb25maWcudW5zYWZlRGVsaW1pdGVyc1swXSlcbiAgdmFyIHVuc2FmZUNsb3NlID0gZXNjYXBlUmVnZXgoY29uZmlnLnVuc2FmZURlbGltaXRlcnNbMV0pXG4gIHRhZ1JFID0gbmV3IFJlZ0V4cChcbiAgICB1bnNhZmVPcGVuICsgJyguKz8pJyArIHVuc2FmZUNsb3NlICsgJ3wnICtcbiAgICBvcGVuICsgJyguKz8pJyArIGNsb3NlLFxuICAgICdnJ1xuICApXG4gIGh0bWxSRSA9IG5ldyBSZWdFeHAoXG4gICAgJ14nICsgdW5zYWZlT3BlbiArICcuKicgKyB1bnNhZmVDbG9zZSArICckJ1xuICApXG4gIC8vIHJlc2V0IGNhY2hlXG4gIGNhY2hlID0gbmV3IENhY2hlKDEwMDApXG59XG5cbi8qKlxuICogUGFyc2UgYSB0ZW1wbGF0ZSB0ZXh0IHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0PiB8IG51bGx9XG4gKiAgICAgICAgICAgICAgIC0ge1N0cmluZ30gdHlwZVxuICogICAgICAgICAgICAgICAtIHtTdHJpbmd9IHZhbHVlXG4gKiAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IFtodG1sXVxuICogICAgICAgICAgICAgICAtIHtCb29sZWFufSBbb25lVGltZV1cbiAqL1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGV4cG9ydHMuY29tcGlsZVJlZ2V4KClcbiAgfVxuICB2YXIgaGl0ID0gY2FjaGUuZ2V0KHRleHQpXG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0XG4gIH1cbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxuL2csICcnKVxuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZhciB0b2tlbnMgPSBbXVxuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMFxuICB2YXIgbWF0Y2gsIGluZGV4LCBodG1sLCB2YWx1ZSwgZmlyc3QsIG9uZVRpbWVcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgd2hpbGUgKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkge1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaW5kZXggPSBtYXRjaC5pbmRleFxuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB2YWx1ZTogdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KVxuICAgICAgfSlcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgaHRtbCA9IGh0bWxSRS50ZXN0KG1hdGNoWzBdKVxuICAgIHZhbHVlID0gaHRtbCA/IG1hdGNoWzFdIDogbWF0Y2hbMl1cbiAgICBmaXJzdCA9IHZhbHVlLmNoYXJDb2RlQXQoMClcbiAgICBvbmVUaW1lID0gZmlyc3QgPT09IDQyIC8vICpcbiAgICB2YWx1ZSA9IG9uZVRpbWVcbiAgICAgID8gdmFsdWUuc2xpY2UoMSlcbiAgICAgIDogdmFsdWVcbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICB0YWc6IHRydWUsXG4gICAgICB2YWx1ZTogdmFsdWUudHJpbSgpLFxuICAgICAgaHRtbDogaHRtbCxcbiAgICAgIG9uZVRpbWU6IG9uZVRpbWVcbiAgICB9KVxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoXG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgdmFsdWU6IHRleHQuc2xpY2UobGFzdEluZGV4KVxuICAgIH0pXG4gIH1cbiAgY2FjaGUucHV0KHRleHQsIHRva2VucylcbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIGxpc3Qgb2YgdG9rZW5zIGludG8gYW4gZXhwcmVzc2lvbi5cbiAqIGUuZy4gdG9rZW5zIHBhcnNlZCBmcm9tICdhIHt7Yn19IGMnIGNhbiBiZSBzZXJpYWxpemVkXG4gKiBpbnRvIG9uZSBzaW5nbGUgZXhwcmVzc2lvbiBhcyAnXCJhIFwiICsgYiArIFwiIGNcIicuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdG9rZW5zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZXhwb3J0cy50b2tlbnNUb0V4cCA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICByZXR1cm4gZm9ybWF0VG9rZW4odG9rZW4pXG4gICAgfSkuam9pbignKycpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZvcm1hdFRva2VuKHRva2Vuc1swXSwgdHJ1ZSlcbiAgfVxufVxuXG4vKipcbiAqIEZvcm1hdCBhIHNpbmdsZSB0b2tlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2luZ2xlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0VG9rZW4gKHRva2VuLCBzaW5nbGUpIHtcbiAgcmV0dXJuIHRva2VuLnRhZ1xuICAgID8gaW5saW5lRmlsdGVycyh0b2tlbi52YWx1ZSwgc2luZ2xlKVxuICAgIDogJ1wiJyArIHRva2VuLnZhbHVlICsgJ1wiJ1xufVxuXG4vKipcbiAqIEZvciBhbiBhdHRyaWJ1dGUgd2l0aCBtdWx0aXBsZSBpbnRlcnBvbGF0aW9uIHRhZ3MsXG4gKiBlLmcuIGF0dHI9XCJzb21lLXt7dGhpbmcgfCBmaWx0ZXJ9fVwiLCBpbiBvcmRlciB0byBjb21iaW5lXG4gKiB0aGUgd2hvbGUgdGhpbmcgaW50byBhIHNpbmdsZSB3YXRjaGFibGUgZXhwcmVzc2lvbiwgd2VcbiAqIGhhdmUgdG8gaW5saW5lIHRob3NlIGZpbHRlcnMuIFRoaXMgZnVuY3Rpb24gZG9lcyBleGFjdGx5XG4gKiB0aGF0LiBUaGlzIGlzIGEgYml0IGhhY2t5IGJ1dCBpdCBhdm9pZHMgaGVhdnkgY2hhbmdlc1xuICogdG8gZGlyZWN0aXZlIHBhcnNlciBhbmQgd2F0Y2hlciBtZWNoYW5pc20uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHBhcmFtIHtCb29sZWFufSBzaW5nbGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgZmlsdGVyUkUgPSAvW158XVxcfFtefF0vXG5mdW5jdGlvbiBpbmxpbmVGaWx0ZXJzIChleHAsIHNpbmdsZSkge1xuICBpZiAoIWZpbHRlclJFLnRlc3QoZXhwKSkge1xuICAgIHJldHVybiBzaW5nbGVcbiAgICAgID8gZXhwXG4gICAgICA6ICcoJyArIGV4cCArICcpJ1xuICB9IGVsc2Uge1xuICAgIHZhciBkaXIgPSBkaXJQYXJzZXIucGFyc2UoZXhwKVxuICAgIGlmICghZGlyLmZpbHRlcnMpIHtcbiAgICAgIHJldHVybiAnKCcgKyBleHAgKyAnKSdcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICd0aGlzLl9hcHBseUZpbHRlcnMoJyArXG4gICAgICAgIGRpci5leHByZXNzaW9uICsgLy8gdmFsdWVcbiAgICAgICAgJyxudWxsLCcgKyAgICAgICAvLyBvbGRWYWx1ZSAobnVsbCBmb3IgcmVhZClcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGlyLmZpbHRlcnMpICsgLy8gZmlsdGVyIGRlc2NyaXB0b3JzXG4gICAgICAgICcsZmFsc2UpJyAgICAgICAgLy8gd3JpdGU/XG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuXG4vKipcbiAqIEFwcGVuZCB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmV4cG9ydHMuYXBwZW5kID0gZnVuY3Rpb24gKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICBhcHBseShlbCwgMSwgZnVuY3Rpb24gKCkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbClcbiAgfSwgdm0sIGNiKVxufVxuXG4vKipcbiAqIEluc2VydEJlZm9yZSB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmV4cG9ydHMuYmVmb3JlID0gZnVuY3Rpb24gKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICBhcHBseShlbCwgMSwgZnVuY3Rpb24gKCkge1xuICAgIF8uYmVmb3JlKGVsLCB0YXJnZXQpXG4gIH0sIHZtLCBjYilcbn1cblxuLyoqXG4gKiBSZW1vdmUgd2l0aCB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmV4cG9ydHMucmVtb3ZlID0gZnVuY3Rpb24gKGVsLCB2bSwgY2IpIHtcbiAgYXBwbHkoZWwsIC0xLCBmdW5jdGlvbiAoKSB7XG4gICAgXy5yZW1vdmUoZWwpXG4gIH0sIHZtLCBjYilcbn1cblxuLyoqXG4gKiBBcHBseSB0cmFuc2l0aW9ucyB3aXRoIGFuIG9wZXJhdGlvbiBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uXG4gKiAgICAgICAgICAgICAgICAgIDE6IGVudGVyXG4gKiAgICAgICAgICAgICAgICAgLTE6IGxlYXZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIHRoZSBhY3R1YWwgRE9NIG9wZXJhdGlvblxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxudmFyIGFwcGx5ID0gZXhwb3J0cy5hcHBseSA9IGZ1bmN0aW9uIChlbCwgZGlyZWN0aW9uLCBvcCwgdm0sIGNiKSB7XG4gIHZhciB0cmFuc2l0aW9uID0gZWwuX192X3RyYW5zXG4gIGlmIChcbiAgICAhdHJhbnNpdGlvbiB8fFxuICAgIC8vIHNraXAgaWYgdGhlcmUgYXJlIG5vIGpzIGhvb2tzIGFuZCBDU1MgdHJhbnNpdGlvbiBpc1xuICAgIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICAoIXRyYW5zaXRpb24uaG9va3MgJiYgIV8udHJhbnNpdGlvbkVuZEV2ZW50KSB8fFxuICAgIC8vIHNraXAgdHJhbnNpdGlvbnMgZm9yIGluaXRpYWwgY29tcGlsZVxuICAgICF2bS5faXNDb21waWxlZCB8fFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBtYW5pcHVsYXRlZCBieSBhIHBhcmVudCBkaXJlY3RpdmVcbiAgICAvLyBkdXJpbmcgdGhlIHBhcmVudCdzIGNvbXBpbGF0aW9uIHBoYXNlLCBza2lwIHRoZVxuICAgIC8vIGFuaW1hdGlvbi5cbiAgICAodm0uJHBhcmVudCAmJiAhdm0uJHBhcmVudC5faXNDb21waWxlZClcbiAgKSB7XG4gICAgb3AoKVxuICAgIGlmIChjYikgY2IoKVxuICAgIHJldHVyblxuICB9XG4gIHZhciBhY3Rpb24gPSBkaXJlY3Rpb24gPiAwID8gJ2VudGVyJyA6ICdsZWF2ZSdcbiAgdHJhbnNpdGlvblthY3Rpb25dKG9wLCBjYilcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgcXVldWUgPSBbXVxudmFyIHF1ZXVlZCA9IGZhbHNlXG5cbi8qKlxuICogUHVzaCBhIGpvYiBpbnRvIHRoZSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2JcbiAqL1xuXG5leHBvcnRzLnB1c2ggPSBmdW5jdGlvbiAoam9iKSB7XG4gIHF1ZXVlLnB1c2goam9iKVxuICBpZiAoIXF1ZXVlZCkge1xuICAgIHF1ZXVlZCA9IHRydWVcbiAgICBfLm5leHRUaWNrKGZsdXNoKVxuICB9XG59XG5cbi8qKlxuICogRmx1c2ggdGhlIHF1ZXVlLCBhbmQgZG8gb25lIGZvcmNlZCByZWZsb3cgYmVmb3JlXG4gKiB0cmlnZ2VyaW5nIHRyYW5zaXRpb25zLlxuICovXG5cbmZ1bmN0aW9uIGZsdXNoICgpIHtcbiAgLy8gRm9yY2UgbGF5b3V0XG4gIHZhciBmID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0oKVxuICB9XG4gIHF1ZXVlID0gW11cbiAgcXVldWVkID0gZmFsc2VcbiAgLy8gZHVtbXkgcmV0dXJuLCBzbyBqcyBsaW50ZXJzIGRvbid0IGNvbXBsYWluIGFib3V0XG4gIC8vIHVudXNlZCB2YXJpYWJsZSBmXG4gIHJldHVybiBmXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHF1ZXVlID0gcmVxdWlyZSgnLi9xdWV1ZScpXG52YXIgYWRkQ2xhc3MgPSBfLmFkZENsYXNzXG52YXIgcmVtb3ZlQ2xhc3MgPSBfLnJlbW92ZUNsYXNzXG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gXy50cmFuc2l0aW9uRW5kRXZlbnRcbnZhciBhbmltYXRpb25FbmRFdmVudCA9IF8uYW5pbWF0aW9uRW5kRXZlbnRcbnZhciB0cmFuc0R1cmF0aW9uUHJvcCA9IF8udHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXG52YXIgYW5pbUR1cmF0aW9uUHJvcCA9IF8uYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbidcblxudmFyIFRZUEVfVFJBTlNJVElPTiA9IDFcbnZhciBUWVBFX0FOSU1BVElPTiA9IDJcblxuLyoqXG4gKiBBIFRyYW5zaXRpb24gb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIHRoZSBzdGF0ZSBhbmQgbG9naWNcbiAqIG9mIHRoZSB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IGhvb2tzXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiBUcmFuc2l0aW9uIChlbCwgaWQsIGhvb2tzLCB2bSkge1xuICB0aGlzLmlkID0gaWRcbiAgdGhpcy5lbCA9IGVsXG4gIHRoaXMuZW50ZXJDbGFzcyA9IGlkICsgJy1lbnRlcidcbiAgdGhpcy5sZWF2ZUNsYXNzID0gaWQgKyAnLWxlYXZlJ1xuICB0aGlzLmhvb2tzID0gaG9va3NcbiAgdGhpcy52bSA9IHZtXG4gIC8vIGFzeW5jIHN0YXRlXG4gIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID1cbiAgdGhpcy5wZW5kaW5nQ3NzQ2IgPVxuICB0aGlzLmNhbmNlbCA9XG4gIHRoaXMucGVuZGluZ0pzQ2IgPVxuICB0aGlzLm9wID1cbiAgdGhpcy5jYiA9IG51bGxcbiAgdGhpcy5qdXN0RW50ZXJlZCA9IGZhbHNlXG4gIHRoaXMuZW50ZXJlZCA9IHRoaXMubGVmdCA9IGZhbHNlXG4gIHRoaXMudHlwZUNhY2hlID0ge31cbiAgLy8gYmluZFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgO1snZW50ZXJOZXh0VGljaycsICdlbnRlckRvbmUnLCAnbGVhdmVOZXh0VGljaycsICdsZWF2ZURvbmUnXVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICBzZWxmW21dID0gXy5iaW5kKHNlbGZbbV0sIHNlbGYpXG4gICAgfSlcbn1cblxudmFyIHAgPSBUcmFuc2l0aW9uLnByb3RvdHlwZVxuXG4vKipcbiAqIFN0YXJ0IGFuIGVudGVyaW5nIHRyYW5zaXRpb24uXG4gKlxuICogMS4gZW50ZXIgdHJhbnNpdGlvbiB0cmlnZ2VyZWRcbiAqIDIuIGNhbGwgYmVmb3JlRW50ZXIgaG9va1xuICogMy4gYWRkIGVudGVyIGNsYXNzXG4gKiA0LiBpbnNlcnQvc2hvdyBlbGVtZW50XG4gKiA1LiBjYWxsIGVudGVyIGhvb2sgKHdpdGggcG9zc2libGUgZXhwbGljaXQganMgY2FsbGJhY2spXG4gKiA2LiByZWZsb3dcbiAqIDcuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAqICAgIC0gdHJhbnNpdGlvbjpcbiAqICAgICAgICByZW1vdmUgY2xhc3Mgbm93LCB3YWl0IGZvciB0cmFuc2l0aW9uZW5kLFxuICogICAgICAgIHRoZW4gZG9uZSBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogICAgLSBhbmltYXRpb246XG4gKiAgICAgICAgd2FpdCBmb3IgYW5pbWF0aW9uZW5kLCByZW1vdmUgY2xhc3MsXG4gKiAgICAgICAgdGhlbiBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIG5vIGNzcyB0cmFuc2l0aW9uOlxuICogICAgICAgIGRvbmUgbm93IGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiA4LiB3YWl0IGZvciBlaXRoZXIgZG9uZSBvciBqcyBjYWxsYmFjaywgdGhlbiBjYWxsXG4gKiAgICBhZnRlckVudGVyIGhvb2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSBpbnNlcnQvc2hvdyB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbnAuZW50ZXIgPSBmdW5jdGlvbiAob3AsIGNiKSB7XG4gIHRoaXMuY2FuY2VsUGVuZGluZygpXG4gIHRoaXMuY2FsbEhvb2soJ2JlZm9yZUVudGVyJylcbiAgdGhpcy5jYiA9IGNiXG4gIGFkZENsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcylcbiAgb3AoKVxuICB0aGlzLmVudGVyZWQgPSBmYWxzZVxuICB0aGlzLmNhbGxIb29rV2l0aENiKCdlbnRlcicpXG4gIGlmICh0aGlzLmVudGVyZWQpIHtcbiAgICByZXR1cm4gLy8gdXNlciBjYWxsZWQgZG9uZSBzeW5jaHJvbm91c2x5LlxuICB9XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmVudGVyQ2FuY2VsbGVkXG4gIHF1ZXVlLnB1c2godGhpcy5lbnRlck5leHRUaWNrKVxufVxuXG4vKipcbiAqIFRoZSBcIm5leHRUaWNrXCIgcGhhc2Ugb2YgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbiwgd2hpY2ggaXNcbiAqIHRvIGJlIHB1c2hlZCBpbnRvIGEgcXVldWUgYW5kIGV4ZWN1dGVkIGFmdGVyIGEgcmVmbG93IHNvXG4gKiB0aGF0IHJlbW92aW5nIHRoZSBjbGFzcyBjYW4gdHJpZ2dlciBhIENTUyB0cmFuc2l0aW9uLlxuICovXG5cbnAuZW50ZXJOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcblxuICAvLyBJbXBvcnRhbnQgaGFjazpcbiAgLy8gaW4gQ2hyb21lLCBpZiBhIGp1c3QtZW50ZXJlZCBlbGVtZW50IGlzIGFwcGxpZWQgdGhlXG4gIC8vIGxlYXZlIGNsYXNzIHdoaWxlIGl0cyBpbnRlcnBvbGF0ZWQgcHJvcGVydHkgc3RpbGwgaGFzXG4gIC8vIGEgdmVyeSBzbWFsbCB2YWx1ZSAod2l0aGluIG9uZSBmcmFtZSksIENocm9tZSB3aWxsXG4gIC8vIHNraXAgdGhlIGxlYXZlIHRyYW5zaXRpb24gZW50aXJlbHkgYW5kIG5vdCBmaXJpbmcgdGhlXG4gIC8vIHRyYW5zdGlvbmVuZCBldmVudC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gcHJvdGVjdGVkXG4gIC8vIGFnYWluc3Qgc3VjaCBjYXNlcyB1c2luZyBhIG9uZS1mcmFtZSB0aW1lb3V0LlxuICB0aGlzLmp1c3RFbnRlcmVkID0gdHJ1ZVxuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5qdXN0RW50ZXJlZCA9IGZhbHNlXG4gIH0sIDE3KVxuXG4gIHZhciBlbnRlckRvbmUgPSB0aGlzLmVudGVyRG9uZVxuICB2YXIgdHlwZSA9IHRoaXMuZ2V0Q3NzVHJhbnNpdGlvblR5cGUodGhpcy5lbnRlckNsYXNzKVxuICBpZiAoIXRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICBpZiAodHlwZSA9PT0gVFlQRV9UUkFOU0lUSU9OKSB7XG4gICAgICAvLyB0cmlnZ2VyIHRyYW5zaXRpb24gYnkgcmVtb3ZpbmcgZW50ZXIgY2xhc3Mgbm93XG4gICAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpXG4gICAgICB0aGlzLnNldHVwQ3NzQ2IodHJhbnNpdGlvbkVuZEV2ZW50LCBlbnRlckRvbmUpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBUWVBFX0FOSU1BVElPTikge1xuICAgICAgdGhpcy5zZXR1cENzc0NiKGFuaW1hdGlvbkVuZEV2ZW50LCBlbnRlckRvbmUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyRG9uZSgpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTikge1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcylcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBcImNsZWFudXBcIiBwaGFzZSBvZiBhbiBlbnRlcmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAuZW50ZXJEb25lID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVudGVyZWQgPSB0cnVlXG4gIHRoaXMuY2FuY2VsID0gdGhpcy5wZW5kaW5nSnNDYiA9IG51bGxcbiAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKVxuICB0aGlzLmNhbGxIb29rKCdhZnRlckVudGVyJylcbiAgaWYgKHRoaXMuY2IpIHRoaXMuY2IoKVxufVxuXG4vKipcbiAqIFN0YXJ0IGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICpcbiAqIDEuIGxlYXZlIHRyYW5zaXRpb24gdHJpZ2dlcmVkLlxuICogMi4gY2FsbCBiZWZvcmVMZWF2ZSBob29rXG4gKiAzLiBhZGQgbGVhdmUgY2xhc3MgKHRyaWdnZXIgY3NzIHRyYW5zaXRpb24pXG4gKiA0LiBjYWxsIGxlYXZlIGhvb2sgKHdpdGggcG9zc2libGUgZXhwbGljaXQganMgY2FsbGJhY2spXG4gKiA1LiByZWZsb3cgaWYgbm8gZXhwbGljaXQganMgY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAqIDYuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAqICAgIC0gdHJhbnNpdGlvbiBvciBhbmltYXRpb246XG4gKiAgICAgICAgd2FpdCBmb3IgZW5kIGV2ZW50LCByZW1vdmUgY2xhc3MsIHRoZW4gZG9uZSBpZlxuICogICAgICAgIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIG5vIGNzcyB0cmFuc2l0aW9uOlxuICogICAgICAgIGRvbmUgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqIDcuIHdhaXQgZm9yIGVpdGhlciBkb25lIG9yIGpzIGNhbGxiYWNrLCB0aGVuIGNhbGxcbiAqICAgIGFmdGVyTGVhdmUgaG9vay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIHJlbW92ZS9oaWRlIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxucC5sZWF2ZSA9IGZ1bmN0aW9uIChvcCwgY2IpIHtcbiAgdGhpcy5jYW5jZWxQZW5kaW5nKClcbiAgdGhpcy5jYWxsSG9vaygnYmVmb3JlTGVhdmUnKVxuICB0aGlzLm9wID0gb3BcbiAgdGhpcy5jYiA9IGNiXG4gIGFkZENsYXNzKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcylcbiAgdGhpcy5sZWZ0ID0gZmFsc2VcbiAgdGhpcy5jYWxsSG9va1dpdGhDYignbGVhdmUnKVxuICBpZiAodGhpcy5sZWZ0KSB7XG4gICAgcmV0dXJuIC8vIHVzZXIgY2FsbGVkIGRvbmUgc3luY2hyb25vdXNseS5cbiAgfVxuICB0aGlzLmNhbmNlbCA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rcy5sZWF2ZUNhbmNlbGxlZFxuICAvLyBvbmx5IG5lZWQgdG8gaGFuZGxlIGxlYXZlRG9uZSBpZlxuICAvLyAxLiB0aGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGRvbmUgKHN5bmNocm9ub3VzbHkgY2FsbGVkXG4gIC8vICAgIGJ5IHRoZSB1c2VyLCB3aGljaCBjYXVzZXMgdGhpcy5vcCBzZXQgdG8gbnVsbClcbiAgLy8gMi4gdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFja1xuICBpZiAodGhpcy5vcCAmJiAhdGhpcy5wZW5kaW5nSnNDYikge1xuICAgIC8vIGlmIGEgQ1NTIHRyYW5zaXRpb24gbGVhdmVzIGltbWVkaWF0ZWx5IGFmdGVyIGVudGVyLFxuICAgIC8vIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50IG5ldmVyIGZpcmVzLiB0aGVyZWZvcmUgd2VcbiAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZW5kIHRoZSBsZWF2ZSBpbW1lZGlhdGVseS5cbiAgICBpZiAodGhpcy5qdXN0RW50ZXJlZCkge1xuICAgICAgdGhpcy5sZWF2ZURvbmUoKVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZS5wdXNoKHRoaXMubGVhdmVOZXh0VGljaylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgXCJuZXh0VGlja1wiIHBoYXNlIG9mIGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAubGVhdmVOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHR5cGUgPSB0aGlzLmdldENzc1RyYW5zaXRpb25UeXBlKHRoaXMubGVhdmVDbGFzcylcbiAgaWYgKHR5cGUpIHtcbiAgICB2YXIgZXZlbnQgPSB0eXBlID09PSBUWVBFX1RSQU5TSVRJT05cbiAgICAgID8gdHJhbnNpdGlvbkVuZEV2ZW50XG4gICAgICA6IGFuaW1hdGlvbkVuZEV2ZW50XG4gICAgdGhpcy5zZXR1cENzc0NiKGV2ZW50LCB0aGlzLmxlYXZlRG9uZSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxlYXZlRG9uZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgXCJjbGVhbnVwXCIgcGhhc2Ugb2YgYSBsZWF2aW5nIHRyYW5zaXRpb24uXG4gKi9cblxucC5sZWF2ZURvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGVmdCA9IHRydWVcbiAgdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbFxuICB0aGlzLm9wKClcbiAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKVxuICB0aGlzLmNhbGxIb29rKCdhZnRlckxlYXZlJylcbiAgaWYgKHRoaXMuY2IpIHRoaXMuY2IoKVxuICB0aGlzLm9wID0gbnVsbFxufVxuXG4vKipcbiAqIENhbmNlbCBhbnkgcGVuZGluZyBjYWxsYmFja3MgZnJvbSBhIHByZXZpb3VzbHkgcnVubmluZ1xuICogYnV0IG5vdCBmaW5pc2hlZCB0cmFuc2l0aW9uLlxuICovXG5cbnAuY2FuY2VsUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5vcCA9IHRoaXMuY2IgPSBudWxsXG4gIHZhciBoYXNQZW5kaW5nID0gZmFsc2VcbiAgaWYgKHRoaXMucGVuZGluZ0Nzc0NiKSB7XG4gICAgaGFzUGVuZGluZyA9IHRydWVcbiAgICBfLm9mZih0aGlzLmVsLCB0aGlzLnBlbmRpbmdDc3NFdmVudCwgdGhpcy5wZW5kaW5nQ3NzQ2IpXG4gICAgdGhpcy5wZW5kaW5nQ3NzRXZlbnQgPSB0aGlzLnBlbmRpbmdDc3NDYiA9IG51bGxcbiAgfVxuICBpZiAodGhpcy5wZW5kaW5nSnNDYikge1xuICAgIGhhc1BlbmRpbmcgPSB0cnVlXG4gICAgdGhpcy5wZW5kaW5nSnNDYi5jYW5jZWwoKVxuICAgIHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsXG4gIH1cbiAgaWYgKGhhc1BlbmRpbmcpIHtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpXG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKVxuICB9XG4gIGlmICh0aGlzLmNhbmNlbCkge1xuICAgIHRoaXMuY2FuY2VsLmNhbGwodGhpcy52bSwgdGhpcy5lbClcbiAgICB0aGlzLmNhbmNlbCA9IG51bGxcbiAgfVxufVxuXG4vKipcbiAqIENhbGwgYSB1c2VyLXByb3ZpZGVkIHN5bmNocm9ub3VzIGhvb2sgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5wLmNhbGxIb29rID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgaWYgKHRoaXMuaG9va3MgJiYgdGhpcy5ob29rc1t0eXBlXSkge1xuICAgIHRoaXMuaG9va3NbdHlwZV0uY2FsbCh0aGlzLnZtLCB0aGlzLmVsKVxuICB9XG59XG5cbi8qKlxuICogQ2FsbCBhIHVzZXItcHJvdmlkZWQsIHBvdGVudGlhbGx5LWFzeW5jIGhvb2sgZnVuY3Rpb24uXG4gKiBXZSBjaGVjayBmb3IgdGhlIGxlbmd0aCBvZiBhcmd1bWVudHMgdG8gc2VlIGlmIHRoZSBob29rXG4gKiBleHBlY3RzIGEgYGRvbmVgIGNhbGxiYWNrLiBJZiB0cnVlLCB0aGUgdHJhbnNpdGlvbidzIGVuZFxuICogd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHdoZW4gdGhlIHVzZXIgY2FsbHMgdGhhdCBjYWxsYmFjaztcbiAqIG90aGVyd2lzZSwgdGhlIGVuZCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBDU1MgdHJhbnNpdGlvbiBvclxuICogYW5pbWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cblxucC5jYWxsSG9va1dpdGhDYiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBob29rID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzW3R5cGVdXG4gIGlmIChob29rKSB7XG4gICAgaWYgKGhvb2subGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5wZW5kaW5nSnNDYiA9IF8uY2FuY2VsbGFibGUodGhpc1t0eXBlICsgJ0RvbmUnXSlcbiAgICB9XG4gICAgaG9vay5jYWxsKHRoaXMudm0sIHRoaXMuZWwsIHRoaXMucGVuZGluZ0pzQ2IpXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIHRyYW5zaXRpb24gdHlwZSBiYXNlZCBvbiB0aGVcbiAqIGNhbGN1bGF0ZWQgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuXG5wLmdldENzc1RyYW5zaXRpb25UeXBlID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgICF0cmFuc2l0aW9uRW5kRXZlbnQgfHxcbiAgICAvLyBza2lwIENTUyB0cmFuc2l0aW9ucyBpZiBwYWdlIGlzIG5vdCB2aXNpYmxlIC1cbiAgICAvLyB0aGlzIHNvbHZlcyB0aGUgaXNzdWUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHMgbm90XG4gICAgLy8gZmlyaW5nIHVudGlsIHRoZSBwYWdlIGlzIHZpc2libGUgYWdhaW4uXG4gICAgLy8gcGFnZVZpc2liaWxpdHkgQVBJIGlzIHN1cHBvcnRlZCBpbiBJRTEwKywgc2FtZSBhc1xuICAgIC8vIENTUyB0cmFuc2l0aW9ucy5cbiAgICBkb2N1bWVudC5oaWRkZW4gfHxcbiAgICAvLyBleHBsaWNpdCBqcy1vbmx5IHRyYW5zaXRpb25cbiAgICAodGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmNzcyA9PT0gZmFsc2UpIHx8XG4gICAgLy8gZWxlbWVudCBpcyBoaWRkZW5cbiAgICBpc0hpZGRlbih0aGlzLmVsKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHRoaXMudHlwZUNhY2hlW2NsYXNzTmFtZV1cbiAgaWYgKHR5cGUpIHJldHVybiB0eXBlXG4gIHZhciBpbmxpbmVTdHlsZXMgPSB0aGlzLmVsLnN0eWxlXG4gIHZhciBjb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpXG4gIHZhciB0cmFuc0R1cmF0aW9uID1cbiAgICBpbmxpbmVTdHlsZXNbdHJhbnNEdXJhdGlvblByb3BdIHx8XG4gICAgY29tcHV0ZWRTdHlsZXNbdHJhbnNEdXJhdGlvblByb3BdXG4gIGlmICh0cmFuc0R1cmF0aW9uICYmIHRyYW5zRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICB0eXBlID0gVFlQRV9UUkFOU0lUSU9OXG4gIH0gZWxzZSB7XG4gICAgdmFyIGFuaW1EdXJhdGlvbiA9XG4gICAgICBpbmxpbmVTdHlsZXNbYW5pbUR1cmF0aW9uUHJvcF0gfHxcbiAgICAgIGNvbXB1dGVkU3R5bGVzW2FuaW1EdXJhdGlvblByb3BdXG4gICAgaWYgKGFuaW1EdXJhdGlvbiAmJiBhbmltRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICAgIHR5cGUgPSBUWVBFX0FOSU1BVElPTlxuICAgIH1cbiAgfVxuICBpZiAodHlwZSkge1xuICAgIHRoaXMudHlwZUNhY2hlW2NsYXNzTmFtZV0gPSB0eXBlXG4gIH1cbiAgcmV0dXJuIHR5cGVcbn1cblxuLyoqXG4gKiBTZXR1cCBhIENTUyB0cmFuc2l0aW9uZW5kL2FuaW1hdGlvbmVuZCBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxucC5zZXR1cENzc0NiID0gZnVuY3Rpb24gKGV2ZW50LCBjYikge1xuICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IGV2ZW50XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgZWwgPSB0aGlzLmVsXG4gIHZhciBvbkVuZCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBfLm9mZihlbCwgZXZlbnQsIG9uRW5kKVxuICAgICAgc2VsZi5wZW5kaW5nQ3NzRXZlbnQgPSBzZWxmLnBlbmRpbmdDc3NDYiA9IG51bGxcbiAgICAgIGlmICghc2VsZi5wZW5kaW5nSnNDYiAmJiBjYikge1xuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIF8ub24oZWwsIGV2ZW50LCBvbkVuZClcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGhpZGRlbiAtIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdFxuICogc2tpcCB0aGUgdHJhbnNpdGlvbiBhbGx0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzSGlkZGVuIChlbCkge1xuICByZXR1cm4gIShcbiAgICBlbC5vZmZzZXRXaWR0aCAmJlxuICAgIGVsLm9mZnNldEhlaWdodCAmJlxuICAgIGVsLmdldENsaWVudFJlY3RzKCkubGVuZ3RoXG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vaW5kZXgnKVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSBjb21wb25lbnQsIGlmIHllcyByZXR1cm4gaXRzXG4gKiBjb21wb25lbnQgaWQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKi9cblxuZXhwb3J0cy5jb21tb25UYWdSRSA9IC9eKGRpdnxwfHNwYW58aW1nfGF8YnxpfGJyfHVsfG9sfGxpfGgxfGgyfGgzfGg0fGg1fGg2fGNvZGV8cHJlfHRhYmxlfHRofHRkfHRyfGZvcm18bGFiZWx8aW5wdXR8c2VsZWN0fG9wdGlvbnxuYXZ8YXJ0aWNsZXxzZWN0aW9ufGhlYWRlcnxmb290ZXIpJC9cbmV4cG9ydHMuY2hlY2tDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICB2YXIgaGFzQXR0cnMgPSBlbC5oYXNBdHRyaWJ1dGVzKClcbiAgaWYgKCFleHBvcnRzLmNvbW1vblRhZ1JFLnRlc3QodGFnKSAmJiB0YWcgIT09ICdjb21wb25lbnQnKSB7XG4gICAgaWYgKF8ucmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkge1xuICAgICAgcmV0dXJuIHsgaWQ6IHRhZyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpcyA9IGhhc0F0dHJzICYmIGdldElzQmluZGluZyhlbClcbiAgICAgIGlmIChpcykge1xuICAgICAgICByZXR1cm4gaXNcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGFnLmluZGV4T2YoJy0nKSA+IC0xIHx8XG4gICAgICAgICAgKFxuICAgICAgICAgICAgL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSAmJlxuICAgICAgICAgICAgLy8gQ2hyb21lIHJldHVybnMgdW5rbm93biBmb3Igc2V2ZXJhbCBIVE1MNSBlbGVtZW50cy5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01NDA1MjZcbiAgICAgICAgICAgICEvXihkYXRhfHRpbWV8cnRjfHJiKSQvLnRlc3QodGFnKVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgXy53YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PydcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaGFzQXR0cnMpIHtcbiAgICByZXR1cm4gZ2V0SXNCaW5kaW5nKGVsKVxuICB9XG59XG5cbi8qKlxuICogR2V0IFwiaXNcIiBiaW5kaW5nIGZyb20gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGdldElzQmluZGluZyAoZWwpIHtcbiAgLy8gZHluYW1pYyBzeW50YXhcbiAgdmFyIGV4cCA9IF8uYXR0cihlbCwgJ2lzJylcbiAgaWYgKGV4cCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHsgaWQ6IGV4cCB9XG4gIH0gZWxzZSB7XG4gICAgZXhwID0gXy5nZXRCaW5kQXR0cihlbCwgJ2lzJylcbiAgICBpZiAoZXhwICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGlkOiBleHAsIGR5bmFtaWM6IHRydWUgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIHByb3AncyBpbml0aWFsIHZhbHVlIG9uIGEgdm0gYW5kIGl0cyBkYXRhIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZXhwb3J0cy5pbml0UHJvcCA9IGZ1bmN0aW9uICh2bSwgcHJvcCwgdmFsdWUpIHtcbiAgaWYgKGV4cG9ydHMuYXNzZXJ0UHJvcChwcm9wLCB2YWx1ZSkpIHtcbiAgICB2YXIga2V5ID0gcHJvcC5wYXRoXG4gICAgdm1ba2V5XSA9IHZtLl9kYXRhW2tleV0gPSB2YWx1ZVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZXhwb3J0cy5hc3NlcnRQcm9wID0gZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gIC8vIGlmIGEgcHJvcCBpcyBub3QgcHJvdmlkZWQgYW5kIGlzIG5vdCByZXF1aXJlZCxcbiAgLy8gc2tpcCB0aGUgY2hlY2suXG4gIGlmIChwcm9wLnJhdyA9PT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgdmFyIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnNcbiAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGVcbiAgdmFyIHZhbGlkID0gdHJ1ZVxuICB2YXIgZXhwZWN0ZWRUeXBlXG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IFN0cmluZykge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ3N0cmluZydcbiAgICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGVcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IE51bWJlcikge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ251bWJlcidcbiAgICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQm9vbGVhbikge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nXG4gICAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBGdW5jdGlvbikge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ2Z1bmN0aW9uJ1xuICAgICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IE9iamVjdCkge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ29iamVjdCdcbiAgICAgIHZhbGlkID0gXy5pc1BsYWluT2JqZWN0KHZhbHVlKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQXJyYXkpIHtcbiAgICAgIGV4cGVjdGVkVHlwZSA9ICdhcnJheSdcbiAgICAgIHZhbGlkID0gXy5pc0FycmF5KHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZVxuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgJyArXG4gICAgICBwcm9wLnBhdGggKyAnPVwiJyArIHByb3AucmF3ICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZm9ybWF0VHlwZShleHBlY3RlZFR5cGUpICtcbiAgICAgICcsIGdvdCAnICsgZm9ybWF0VmFsdWUodmFsdWUpICsgJy4nXG4gICAgKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBvcHRpb25zLnZhbGlkYXRvclxuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IuY2FsbChudWxsLCB2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgJyArXG4gICAgICAgIHByb3AucGF0aCArICc9XCInICsgcHJvcC5yYXcgKyAnXCInXG4gICAgICApXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZm9ybWF0VHlwZSAodmFsKSB7XG4gIHJldHVybiB2YWxcbiAgICA/IHZhbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbC5zbGljZSgxKVxuICAgIDogJ2N1c3RvbSB0eXBlJ1xufVxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSAodmFsKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSlcbn1cbiIsIi8qKlxuICogRW5hYmxlIGRlYnVnIHV0aWxpdGllcy5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXG4gIHZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuXG4gIC8qKlxuICAgKiBMb2cgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnXG4gICAqL1xuXG4gIGV4cG9ydHMubG9nID0gZnVuY3Rpb24gKG1zZykge1xuICAgIGlmIChoYXNDb25zb2xlICYmIGNvbmZpZy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coJ1tWdWUgaW5mb106ICcgKyBtc2cpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdlJ3ZlIGdvdCBhIHByb2JsZW0gaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZ1xuICAgKi9cblxuICBleHBvcnRzLndhcm4gPSBmdW5jdGlvbiAobXNnLCBlKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50IHx8IGNvbmZpZy5kZWJ1ZykpIHtcbiAgICAgIGNvbnNvbGUud2FybignW1Z1ZSB3YXJuXTogJyArIG1zZylcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLndhcm4oKGUgfHwgbmV3IEVycm9yKCdXYXJuaW5nIFN0YWNrIFRyYWNlJykpLnN0YWNrKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgYXNzZXQgZXhpc3RzXG4gICAqL1xuXG4gIGV4cG9ydHMuYXNzZXJ0QXNzZXQgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBpZCkge1xuICAgIGlmICghdmFsKSB7XG4gICAgICBleHBvcnRzLndhcm4oJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlICsgJzogJyArIGlkKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuL2luZGV4JylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxudmFyIHRyYW5zaXRpb24gPSByZXF1aXJlKCcuLi90cmFuc2l0aW9uJylcblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuXG5leHBvcnRzLnF1ZXJ5ID0gZnVuY3Rpb24gKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gZWxcbiAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpXG4gICAgaWYgKCFlbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgc2VsZWN0b3JcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAqIE5vdGU6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyBzaG91bGQgd29yayBoZXJlXG4gKiBidXQgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGNvbW1lbnQgbm9kZXMgaW4gcGhhbnRvbWpzLFxuICogbWFraW5nIHVuaXQgdGVzdHMgZGlmZmljdWx0LiBUaGlzIGlzIGZpeGVkIGJ5IGRvaW5nIHRoZVxuICogY29udGFpbnMoKSBjaGVjayBvbiB0aGUgbm9kZSdzIHBhcmVudE5vZGUgaW5zdGVhZCBvZlxuICogdGhlIG5vZGUgaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmluRG9jID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICB2YXIgcGFyZW50ID0gbm9kZSAmJiBub2RlLnBhcmVudE5vZGVcbiAgcmV0dXJuIGRvYyA9PT0gbm9kZSB8fFxuICAgIGRvYyA9PT0gcGFyZW50IHx8XG4gICAgISEocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSAmJiAoZG9jLmNvbnRhaW5zKHBhcmVudCkpKVxufVxuXG4vKipcbiAqIEdldCBhbmQgcmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyXG4gKi9cblxuZXhwb3J0cy5hdHRyID0gZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgdmFyIHZhbCA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHIpXG4gIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBHZXQgYW4gYXR0cmlidXRlIHdpdGggY29sb24gb3Igdi1iaW5kOiBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cblxuZXhwb3J0cy5nZXRCaW5kQXR0ciA9IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gIHZhciB2YWwgPSBleHBvcnRzLmF0dHIobm9kZSwgJzonICsgbmFtZSlcbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHZhbCA9IGV4cG9ydHMuYXR0cihub2RlLCAndi1iaW5kOicgKyBuYW1lKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBJbnNlcnQgZWwgYmVmb3JlIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZXhwb3J0cy5iZWZvcmUgPSBmdW5jdGlvbiAoZWwsIHRhcmdldCkge1xuICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIHRhcmdldClcbn1cblxuLyoqXG4gKiBJbnNlcnQgZWwgYWZ0ZXIgdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xuXG5leHBvcnRzLmFmdGVyID0gZnVuY3Rpb24gKGVsLCB0YXJnZXQpIHtcbiAgaWYgKHRhcmdldC5uZXh0U2libGluZykge1xuICAgIGV4cG9ydHMuYmVmb3JlKGVsLCB0YXJnZXQubmV4dFNpYmxpbmcpXG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZWwgZnJvbSBET01cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZXhwb3J0cy5yZW1vdmUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbClcbn1cblxuLyoqXG4gKiBQcmVwZW5kIGVsIHRvIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZXhwb3J0cy5wcmVwZW5kID0gZnVuY3Rpb24gKGVsLCB0YXJnZXQpIHtcbiAgaWYgKHRhcmdldC5maXJzdENoaWxkKSB7XG4gICAgZXhwb3J0cy5iZWZvcmUoZWwsIHRhcmdldC5maXJzdENoaWxkKVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbClcbiAgfVxufVxuXG4vKipcbiAqIFJlcGxhY2UgdGFyZ2V0IHdpdGggZWxcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmV4cG9ydHMucmVwbGFjZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGVsKSB7XG4gIHZhciBwYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZVxuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50LnJlcGxhY2VDaGlsZChlbCwgdGFyZ2V0KVxuICB9XG59XG5cbi8qKlxuICogQWRkIGV2ZW50IGxpc3RlbmVyIHNob3J0aGFuZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZXhwb3J0cy5vbiA9IGZ1bmN0aW9uIChlbCwgZXZlbnQsIGNiKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNiKVxufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lciBzaG9ydGhhbmQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmV4cG9ydHMub2ZmID0gZnVuY3Rpb24gKGVsLCBldmVudCwgY2IpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2IpXG59XG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cm9uZ30gY2xzXG4gKi9cblxuZXhwb3J0cy5hZGRDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xzKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGNscylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyAnICdcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cm9uZ30gY2xzXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xzKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyAnICdcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnXG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpXG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIudHJpbSgpKVxuICB9XG4gIGlmICghZWwuY2xhc3NOYW1lKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpXG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IHJhdyBjb250ZW50IGluc2lkZSBhbiBlbGVtZW50IGludG8gYSB0ZW1wb3JhcnlcbiAqIGNvbnRhaW5lciBkaXZcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFzRnJhZ21lbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cblxuZXhwb3J0cy5leHRyYWN0Q29udGVudCA9IGZ1bmN0aW9uIChlbCwgYXNGcmFnbWVudCkge1xuICB2YXIgY2hpbGRcbiAgdmFyIHJhd0NvbnRlbnRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBleHBvcnRzLmlzVGVtcGxhdGUoZWwpICYmXG4gICAgZWwuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnRcbiAgKSB7XG4gICAgZWwgPSBlbC5jb250ZW50XG4gIH1cbiAgaWYgKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIGV4cG9ydHMudHJpbU5vZGUoZWwpXG4gICAgcmF3Q29udGVudCA9IGFzRnJhZ21lbnRcbiAgICAgID8gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICB3aGlsZSAoY2hpbGQgPSBlbC5maXJzdENoaWxkKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgcmF3Q29udGVudC5hcHBlbmRDaGlsZChjaGlsZClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhd0NvbnRlbnRcbn1cblxuLyoqXG4gKiBUcmltIHBvc3NpYmxlIGVtcHR5IGhlYWQvdGFpbCB0ZXh0Tm9kZXMgaW5zaWRlIGEgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICovXG5cbmV4cG9ydHMudHJpbU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0cmltKG5vZGUsIG5vZGUuZmlyc3RDaGlsZClcbiAgdHJpbShub2RlLCBub2RlLmxhc3RDaGlsZClcbn1cblxuZnVuY3Rpb24gdHJpbSAocGFyZW50LCBub2RlKSB7XG4gIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IDMgJiYgIW5vZGUuZGF0YS50cmltKCkpIHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSlcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSB0YWcuXG4gKiBOb3RlIGlmIHRoZSB0ZW1wbGF0ZSBhcHBlYXJzIGluc2lkZSBhbiBTVkcgaXRzIHRhZ05hbWVcbiAqIHdpbGwgYmUgaW4gbG93ZXJjYXNlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqL1xuXG5leHBvcnRzLmlzVGVtcGxhdGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZ05hbWUgJiZcbiAgICBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZW1wbGF0ZSdcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gXCJhbmNob3JcIiBmb3IgcGVyZm9ybWluZyBkb20gaW5zZXJ0aW9uL3JlbW92YWxzLlxuICogVGhpcyBpcyB1c2VkIGluIGEgbnVtYmVyIG9mIHNjZW5hcmlvczpcbiAqIC0gZnJhZ21lbnQgaW5zdGFuY2VcbiAqIC0gdi1odG1sXG4gKiAtIHYtaWZcbiAqIC0gdi1mb3JcbiAqIC0gY29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGVyc2lzdCAtIElFIHRyYXNoZXMgZW1wdHkgdGV4dE5vZGVzIG9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZU5vZGUodHJ1ZSksIHNvIGluIGNlcnRhaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VzIHRoZSBhbmNob3IgbmVlZHMgdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbi1lbXB0eSB0byBiZSBwZXJzaXN0ZWQgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5cbiAqIEByZXR1cm4ge0NvbW1lbnR8VGV4dH1cbiAqL1xuXG5leHBvcnRzLmNyZWF0ZUFuY2hvciA9IGZ1bmN0aW9uIChjb250ZW50LCBwZXJzaXN0KSB7XG4gIHJldHVybiBjb25maWcuZGVidWdcbiAgICA/IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udGVudClcbiAgICA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBlcnNpc3QgPyAnICcgOiAnJylcbn1cblxuLyoqXG4gKiBGaW5kIGEgY29tcG9uZW50IHJlZiBhdHRyaWJ1dGUgdGhhdCBzdGFydHMgd2l0aCAkLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7U3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuXG52YXIgcmVmUkUgPSAvXnYtcmVmOi9cbmV4cG9ydHMuZmluZFJlZiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cmlidXRlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJzW2ldLm5hbWVcbiAgICAgIGlmIChyZWZSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpXG4gICAgICAgIHJldHVybiBfLmNhbWVsaXplKG5hbWUucmVwbGFjZShyZWZSRSwgJycpKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hcCBhIGZ1bmN0aW9uIHRvIGEgcmFuZ2Ugb2Ygbm9kZXMgLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtOb2RlfSBlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wXG4gKi9cblxuZXhwb3J0cy5tYXBOb2RlUmFuZ2UgPSBmdW5jdGlvbiAobm9kZSwgZW5kLCBvcCkge1xuICB2YXIgbmV4dFxuICB3aGlsZSAobm9kZSAhPT0gZW5kKSB7XG4gICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmdcbiAgICBvcChub2RlKVxuICAgIG5vZGUgPSBuZXh0XG4gIH1cbiAgb3AoZW5kKVxufVxuXG4vKipcbiAqIFJlbW92ZSBhIHJhbmdlIG9mIG5vZGVzIHdpdGggdHJhbnNpdGlvbiwgc3RvcmVcbiAqIHRoZSBub2RlcyBpbiBhIGZyYWdtZW50IHdpdGggY29ycmVjdCBvcmRlcmluZyxcbiAqIGFuZCBjYWxsIGNhbGxiYWNrIHdoZW4gZG9uZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHN0YXJ0XG4gKiBAcGFyYW0ge05vZGV9IGVuZFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVOb2RlUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdm0sIGZyYWcsIGNiKSB7XG4gIHZhciBkb25lID0gZmFsc2VcbiAgdmFyIHJlbW92ZWQgPSAwXG4gIHZhciBub2RlcyA9IFtdXG4gIGV4cG9ydHMubWFwTm9kZVJhbmdlKHN0YXJ0LCBlbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGVuZCkgZG9uZSA9IHRydWVcbiAgICBub2Rlcy5wdXNoKG5vZGUpXG4gICAgdHJhbnNpdGlvbi5yZW1vdmUobm9kZSwgdm0sIG9uUmVtb3ZlZClcbiAgfSlcbiAgZnVuY3Rpb24gb25SZW1vdmVkICgpIHtcbiAgICByZW1vdmVkKytcbiAgICBpZiAoZG9uZSAmJiByZW1vdmVkID49IG5vZGVzLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGVzW2ldKVxuICAgICAgfVxuICAgICAgY2IgJiYgY2IoKVxuICAgIH1cbiAgfVxufVxuIiwiLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG5leHBvcnRzLmhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge31cblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IGV4cG9ydHMuaW5Ccm93c2VyID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdykgIT09ICdbb2JqZWN0IE9iamVjdF0nXG5cbmV4cG9ydHMuaXNJRTkgPVxuICBpbkJyb3dzZXIgJiZcbiAgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwXG5cbmV4cG9ydHMuaXNBbmRyb2lkID1cbiAgaW5Ccm93c2VyICYmXG4gIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdhbmRyb2lkJykgPiAwXG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbmlmIChpbkJyb3dzZXIgJiYgIWV4cG9ydHMuaXNJRTkpIHtcbiAgdmFyIGlzV2Via2l0VHJhbnMgPVxuICAgIHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICB2YXIgaXNXZWJraXRBbmltID1cbiAgICB3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gIGV4cG9ydHMudHJhbnNpdGlvblByb3AgPSBpc1dlYmtpdFRyYW5zXG4gICAgPyAnV2Via2l0VHJhbnNpdGlvbidcbiAgICA6ICd0cmFuc2l0aW9uJ1xuICBleHBvcnRzLnRyYW5zaXRpb25FbmRFdmVudCA9IGlzV2Via2l0VHJhbnNcbiAgICA/ICd3ZWJraXRUcmFuc2l0aW9uRW5kJ1xuICAgIDogJ3RyYW5zaXRpb25lbmQnXG4gIGV4cG9ydHMuYW5pbWF0aW9uUHJvcCA9IGlzV2Via2l0QW5pbVxuICAgID8gJ1dlYmtpdEFuaW1hdGlvbidcbiAgICA6ICdhbmltYXRpb24nXG4gIGV4cG9ydHMuYW5pbWF0aW9uRW5kRXZlbnQgPSBpc1dlYmtpdEFuaW1cbiAgICA/ICd3ZWJraXRBbmltYXRpb25FbmQnXG4gICAgOiAnYW5pbWF0aW9uZW5kJ1xufVxuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LiBJZGVhbGx5IHRoaXNcbiAqIHNob3VsZCBiZSBleGVjdXRlZCBhcyBhIG1pY3JvdGFzaywgc28gd2UgbGV2ZXJhZ2VcbiAqIE11dGF0aW9uT2JzZXJ2ZXIgaWYgaXQncyBhdmFpbGFibGUsIGFuZCBmYWxsYmFjayB0b1xuICogc2V0VGltZW91dCgwKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICovXG5cbmV4cG9ydHMubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW11cbiAgdmFyIHBlbmRpbmcgPSBmYWxzZVxuICB2YXIgdGltZXJGdW5jXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlXG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKVxuICAgIGNhbGxiYWNrcyA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGNvdW50ZXIgPSAxXG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKVxuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvdW50ZXIpXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyXG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gY291bnRlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lckZ1bmMgPSBzZXRUaW1lb3V0XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChjYiwgY3R4KSB7XG4gICAgdmFyIGZ1bmMgPSBjdHhcbiAgICAgID8gZnVuY3Rpb24gKCkgeyBjYi5jYWxsKGN0eCkgfVxuICAgICAgOiBjYlxuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmMpXG4gICAgaWYgKHBlbmRpbmcpIHJldHVyblxuICAgIHBlbmRpbmcgPSB0cnVlXG4gICAgdGltZXJGdW5jKG5leHRUaWNrSGFuZGxlciwgMClcbiAgfVxufSkoKVxuIiwidmFyIGxhbmcgPSByZXF1aXJlKCcuL2xhbmcnKVxudmFyIGV4dGVuZCA9IGxhbmcuZXh0ZW5kXG5cbmV4dGVuZChleHBvcnRzLCBsYW5nKVxuZXh0ZW5kKGV4cG9ydHMsIHJlcXVpcmUoJy4vZW52JykpXG5leHRlbmQoZXhwb3J0cywgcmVxdWlyZSgnLi9kb20nKSlcbmV4dGVuZChleHBvcnRzLCByZXF1aXJlKCcuL29wdGlvbnMnKSlcbmV4dGVuZChleHBvcnRzLCByZXF1aXJlKCcuL2NvbXBvbmVudCcpKVxuZXh0ZW5kKGV4cG9ydHMsIHJlcXVpcmUoJy4vZGVidWcnKSlcbiIsIi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0cy5zZXQgPSBmdW5jdGlvbiBzZXQgKG9iaiwga2V5LCB2YWwpIHtcbiAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgb2JqW2tleV0gPSB2YWxcbiAgICByZXR1cm5cbiAgfVxuICBpZiAob2JqLl9pc1Z1ZSkge1xuICAgIHNldChvYmouX2RhdGEsIGtleSwgdmFsKVxuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9IG9iai5fX29iX19cbiAgaWYgKCFvYikge1xuICAgIG9ialtrZXldID0gdmFsXG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuY29udmVydChrZXksIHZhbClcbiAgb2IuZGVwLm5vdGlmeSgpXG4gIGlmIChvYi52bXMpIHtcbiAgICB2YXIgaSA9IG9iLnZtcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdm0gPSBvYi52bXNbaV1cbiAgICAgIHZtLl9wcm94eShrZXkpXG4gICAgICB2bS5fZGlnZXN0KClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqL1xuXG5leHBvcnRzLmRlbGV0ZSA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIG9ialtrZXldXG4gIHZhciBvYiA9IG9iai5fX29iX19cbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKVxuICBpZiAob2Iudm1zKSB7XG4gICAgdmFyIGkgPSBvYi52bXMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHZtID0gb2Iudm1zW2ldXG4gICAgICB2bS5fdW5wcm94eShrZXkpXG4gICAgICB2bS5fZGlnZXN0KClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgbGl0ZXJhbCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnZhciBsaXRlcmFsVmFsdWVSRSA9IC9eXFxzPyh0cnVlfGZhbHNlfFtcXGRcXC5dK3wnW14nXSonfFwiW15cIl0qXCIpXFxzPyQvXG5leHBvcnRzLmlzTGl0ZXJhbCA9IGZ1bmN0aW9uIChleHApIHtcbiAgcmV0dXJuIGxpdGVyYWxWYWx1ZVJFLnRlc3QoZXhwKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc1Jlc2VydmVkID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKVxuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogR3VhcmQgdGV4dCBvdXRwdXQsIG1ha2Ugc3VyZSB1bmRlZmluZWQgb3V0cHV0c1xuICogZW1wdHkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmV4cG9ydHMudG9TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB2YWx1ZS50b1N0cmluZygpXG59XG5cbi8qKlxuICogQ2hlY2sgYW5kIGNvbnZlcnQgcG9zc2libGUgbnVtZXJpYyBzdHJpbmdzIHRvIG51bWJlcnNcbiAqIGJlZm9yZSBzZXR0aW5nIGJhY2sgdG8gZGF0YVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4geyp8TnVtYmVyfVxuICovXG5cbmV4cG9ydHMudG9OdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFyc2VkID0gTnVtYmVyKHZhbHVlKVxuICAgIHJldHVybiBpc05hTihwYXJzZWQpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IHBhcnNlZFxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBzdHJpbmcgYm9vbGVhbiBsaXRlcmFscyBpbnRvIHJlYWwgYm9vbGVhbnMuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7KnxCb29sZWFufVxuICovXG5cbmV4cG9ydHMudG9Cb29sZWFuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnXG4gICAgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgICAgPyBmYWxzZVxuICAgICAgOiB2YWx1ZVxufVxuXG4vKipcbiAqIFN0cmlwIHF1b3RlcyBmcm9tIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nIHwgZmFsc2V9XG4gKi9cblxuZXhwb3J0cy5zdHJpcFF1b3RlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGEgPSBzdHIuY2hhckNvZGVBdCgwKVxuICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KHN0ci5sZW5ndGggLSAxKVxuICByZXR1cm4gYSA9PT0gYiAmJiAoYSA9PT0gMHgyMiB8fCBhID09PSAweDI3KVxuICAgID8gc3RyLnNsaWNlKDEsIC0xKVxuICAgIDogc3RyXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsbWl0ZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZ1xuZXhwb3J0cy5jYW1lbGl6ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIHRvVXBwZXIpXG59XG5cbmZ1bmN0aW9uIHRvVXBwZXIgKF8sIGMpIHtcbiAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJ1xufVxuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBoeXBoZW5hdGVSRSA9IC8oW2EtelxcZF0pKFtBLVpdKS9nXG5leHBvcnRzLmh5cGhlbmF0ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59XG5cbi8qKlxuICogQ29udmVydHMgaHlwaGVuL3VuZGVyc2NvcmUvc2xhc2ggZGVsaW1pdGVyZWQgbmFtZXMgaW50b1xuICogY2FtZWxpemVkIGNsYXNzTmFtZXMuXG4gKlxuICogZS5nLiBteS1jb21wb25lbnQgPT4gTXlDb21wb25lbnRcbiAqICAgICAgc29tZV9lbHNlICAgID0+IFNvbWVFbHNlXG4gKiAgICAgIHNvbWUvY29tcCAgICA9PiBTb21lQ29tcFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX1xcL10pKFxcdykvZ1xuZXhwb3J0cy5jbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIHRvVXBwZXIpXG59XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnRzLmJpbmQgPSBmdW5jdGlvbiAoZm4sIGN0eCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXktbGlrZX0gbGlzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydF0gLSBzdGFydCBpbmRleFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZXhwb3J0cy50b0FycmF5ID0gZnVuY3Rpb24gKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMFxuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnRcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKVxuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tXG4gKi9cblxuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKVxuICB2YXIgaSA9IGtleXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICB0b1trZXlzW2ldXSA9IGZyb21ba2V5c1tpXV1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG52YXIgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IE9iamVjdF0nXG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkdcbn1cblxuLyoqXG4gKiBBcnJheSB0eXBlIGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXlcblxuLyoqXG4gKiBEZWZpbmUgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtlbnVtZXJhYmxlXVxuICovXG5cbmV4cG9ydHMuZGVmaW5lID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59XG5cbi8qKlxuICogRGVib3VuY2UgYSBmdW5jdGlvbiBzbyBpdCBvbmx5IGdldHMgY2FsbGVkIGFmdGVyIHRoZVxuICogaW5wdXQgc3RvcHMgYXJyaXZpbmcgYWZ0ZXIgdGhlIGdpdmVuIHdhaXQgcGVyaW9kLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0cy5kZWJvdW5jZSA9IGZ1bmN0aW9uIChmdW5jLCB3YWl0KSB7XG4gIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdFxuICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhc3QgPSBEYXRlLm5vdygpIC0gdGltZXN0YW1wXG4gICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbFxuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKVxuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb250ZXh0ID0gdGhpc1xuICAgIGFyZ3MgPSBhcmd1bWVudHNcbiAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpXG4gICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdClcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qKlxuICogTWFudWFsIGluZGV4T2YgYmVjYXVzZSBpdCdzIHNsaWdodGx5IGZhc3RlciB0aGFuXG4gKiBuYXRpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0geyp9IG9ialxuICovXG5cbmV4cG9ydHMuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnIsIG9iaikge1xuICB2YXIgaSA9IGFyci5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGlcbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBNYWtlIGEgY2FuY2VsbGFibGUgdmVyc2lvbiBvZiBhbiBhc3luYyBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZXhwb3J0cy5jYW5jZWxsYWJsZSA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGNiLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYi5jYW5jZWxsZWQgPSB0cnVlXG4gIH1cbiAgcmV0dXJuIGNiXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5sb29zZUVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gIHJldHVybiBhID09IGIgfHwgKFxuICAgIGV4cG9ydHMuaXNPYmplY3QoYSkgJiYgZXhwb3J0cy5pc09iamVjdChiKVxuICAgICAgPyBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYilcbiAgICAgIDogZmFsc2VcbiAgKVxuICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuL2luZGV4JylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxudmFyIGV4dGVuZCA9IF8uZXh0ZW5kXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICpcbiAqIEFsbCBzdHJhdGVneSBmdW5jdGlvbnMgZm9sbG93IHRoZSBzYW1lIHNpZ25hdHVyZTpcbiAqXG4gKiBAcGFyYW0geyp9IHBhcmVudFZhbFxuICogQHBhcmFtIHsqfSBjaGlsZFZhbFxuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqL1xuXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcyA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsXG4gIGZvciAoa2V5IGluIGZyb20pIHtcbiAgICB0b1ZhbCA9IHRvW2tleV1cbiAgICBmcm9tVmFsID0gZnJvbVtrZXldXG4gICAgaWYgKCF0by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBfLnNldCh0bywga2V5LCBmcm9tVmFsKVxuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdCh0b1ZhbCkgJiYgXy5pc09iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJ1xuICAgICAgKVxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIGNoaWxkVmFsLmNhbGwodGhpcyksXG4gICAgICAgIHBhcmVudFZhbC5jYWxsKHRoaXMpXG4gICAgICApXG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0pXG4gICAgICAgIDogY2hpbGRWYWxcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRWxcbiAqL1xuXG5zdHJhdHMuZWwgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSAmJiBjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICdUaGUgXCJlbFwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgJ2RlZmluaXRpb25zLidcbiAgICApXG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJldCA9IGNoaWxkVmFsIHx8IHBhcmVudFZhbFxuICAvLyBpbnZva2UgdGhlIGVsZW1lbnQgZmFjdG9yeSBpZiB0aGlzIGlzIGluc3RhbmNlIG1lcmdlXG4gIHJldHVybiB2bSAmJiB0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nXG4gICAgPyByZXQuY2FsbCh2bSlcbiAgICA6IHJldFxufVxuXG4vKipcbiAqIEhvb2tzIGFuZCBwYXJhbSBhdHRyaWJ1dGVzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5cbnN0cmF0cy5pbml0ID1cbnN0cmF0cy5jcmVhdGVkID1cbnN0cmF0cy5yZWFkeSA9XG5zdHJhdHMuYXR0YWNoZWQgPVxuc3RyYXRzLmRldGFjaGVkID1cbnN0cmF0cy5iZWZvcmVDb21waWxlID1cbnN0cmF0cy5jb21waWxlZCA9XG5zdHJhdHMuYmVmb3JlRGVzdHJveSA9XG5zdHJhdHMuZGVzdHJveWVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogXy5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbi8qKlxuICogMC4xMSBkZXByZWNhdGlvbiB3YXJuaW5nXG4gKi9cblxuc3RyYXRzLnBhcmFtQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgJ1wicGFyYW1BdHRyaWJ1dGVzXCIgb3B0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gMC4xMi4gJyArXG4gICAgJ1VzZSBcInByb3BzXCIgaW5zdGVhZC4nXG4gIClcbn1cblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwpXG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgZ3VhcmRBcnJheUFzc2V0cyhjaGlsZFZhbCkpXG4gICAgOiByZXNcbn1cblxuY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHNcbn0pXG5cbi8qKlxuICogRXZlbnRzICYgV2F0Y2hlcnMuXG4gKlxuICogRXZlbnRzICYgd2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cblxuc3RyYXRzLndhdGNoID1cbnN0cmF0cy5ldmVudHMgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSByZXR1cm4gcGFyZW50VmFsXG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWxcbiAgdmFyIHJldCA9IHt9XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbClcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldXG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XVxuICAgIGlmIChwYXJlbnQgJiYgIV8uaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XVxuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBbY2hpbGRdXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cblxuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWxcbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbFxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpXG4gIGV4dGVuZChyZXQsIGNoaWxkVmFsKVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xuXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn1cblxuLyoqXG4gKiBNYWtlIHN1cmUgY29tcG9uZW50IG9wdGlvbnMgZ2V0IGNvbnZlcnRlZCB0byBhY3R1YWxcbiAqIGNvbnN0cnVjdG9ycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGd1YXJkQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBvcHRpb25zLmNvbXBvbmVudHMgPVxuICAgICAgZ3VhcmRBcnJheUFzc2V0cyhvcHRpb25zLmNvbXBvbmVudHMpXG4gICAgdmFyIGRlZlxuICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyhjb21wb25lbnRzKVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaWRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGlkc1tpXVxuICAgICAgaWYgKF8uY29tbW9uVGFnUkUudGVzdChrZXkpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAgICdpZDogJyArIGtleVxuICAgICAgICApXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBkZWYgPSBjb21wb25lbnRzW2tleV1cbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QoZGVmKSkge1xuICAgICAgICBjb21wb25lbnRzW2tleV0gPSBfLlZ1ZS5leHRlbmQoZGVmKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGd1YXJkUHJvcHMgKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wc1xuICB2YXIgaVxuICBpZiAoXy5pc0FycmF5KHByb3BzKSkge1xuICAgIG9wdGlvbnMucHJvcHMgPSB7fVxuICAgIGkgPSBwcm9wcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBvcHRpb25zLnByb3BzW3Byb3BzW2ldXSA9IG51bGxcbiAgICB9XG4gIH0gZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpXG4gICAgaSA9IGtleXMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHZhbCA9IHByb3BzW2tleXNbaV1dXG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wc1trZXlzW2ldXSA9IHsgdHlwZTogdmFsIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHdWFyZCBhbiBBcnJheS1mb3JtYXQgYXNzZXRzIG9wdGlvbiBhbmQgY29udmVydGVkIGl0XG4gKiBpbnRvIHRoZSBrZXktdmFsdWUgT2JqZWN0IGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gYXNzZXRzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZ3VhcmRBcnJheUFzc2V0cyAoYXNzZXRzKSB7XG4gIGlmIChfLmlzQXJyYXkoYXNzZXRzKSkge1xuICAgIHZhciByZXMgPSB7fVxuICAgIHZhciBpID0gYXNzZXRzLmxlbmd0aFxuICAgIHZhciBhc3NldFxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFzc2V0ID0gYXNzZXRzW2ldXG4gICAgICB2YXIgaWQgPSB0eXBlb2YgYXNzZXQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyAoKGFzc2V0Lm9wdGlvbnMgJiYgYXNzZXQub3B0aW9ucy5uYW1lKSB8fCBhc3NldC5pZClcbiAgICAgICAgOiAoYXNzZXQubmFtZSB8fCBhc3NldC5pZClcbiAgICAgIGlmICghaWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICAgJ0FycmF5LXN5bnRheCBhc3NldHMgbXVzdCBwcm92aWRlIGEgXCJuYW1lXCIgb3IgXCJpZFwiIGZpZWxkLidcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzW2lkXSA9IGFzc2V0XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuICByZXR1cm4gYXNzZXRzXG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdH0gY2hpbGRcbiAqIEBwYXJhbSB7VnVlfSBbdm1dIC0gaWYgdm0gaXMgcHJlc2VudCwgaW5kaWNhdGVzIHRoaXMgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgYW4gaW5zdGFudGlhdGlvbiBtZXJnZS5cbiAqL1xuXG5leHBvcnRzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIG1lcmdlIChwYXJlbnQsIGNoaWxkLCB2bSkge1xuICBndWFyZENvbXBvbmVudHMoY2hpbGQpXG4gIGd1YXJkUHJvcHMoY2hpbGQpXG4gIHZhciBvcHRpb25zID0ge31cbiAgdmFyIGtleVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZShwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pXG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KVxuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCEocGFyZW50Lmhhc093blByb3BlcnR5KGtleSkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSlcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpXG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEByZXR1cm4ge09iamVjdHxGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnRzLnJlc29sdmVBc3NldCA9IGZ1bmN0aW9uIHJlc29sdmUgKG9wdGlvbnMsIHR5cGUsIGlkKSB7XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdXG4gIHZhciBjYW1lbGl6ZWRJZFxuICByZXR1cm4gYXNzZXRzW2lkXSB8fFxuICAgIC8vIGNhbWVsQ2FzZSBJRFxuICAgIGFzc2V0c1tjYW1lbGl6ZWRJZCA9IF8uY2FtZWxpemUoaWQpXSB8fFxuICAgIC8vIFBhc2NhbCBDYXNlIElEXG4gICAgYXNzZXRzW2NhbWVsaXplZElkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2FtZWxpemVkSWQuc2xpY2UoMSldXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vdXRpbCcpXG52YXIgZXh0ZW5kID0gXy5leHRlbmRcblxuLyoqXG4gKiBUaGUgZXhwb3NlZCBWdWUgY29uc3RydWN0b3IuXG4gKlxuICogQVBJIGNvbnZlbnRpb25zOlxuICogLSBwdWJsaWMgQVBJIG1ldGhvZHMvcHJvcGVydGllcyBhcmUgcHJlZmlleGVkIHdpdGggYCRgXG4gKiAtIGludGVybmFsIG1ldGhvZHMvcHJvcGVydGllcyBhcmUgcHJlZml4ZWQgd2l0aCBgX2BcbiAqIC0gbm9uLXByZWZpeGVkIHByb3BlcnRpZXMgYXJlIGFzc3VtZWQgdG8gYmUgcHJveGllZCB1c2VyXG4gKiAgIGRhdGEuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gIHRoaXMuX2luaXQob3B0aW9ucylcbn1cblxuLyoqXG4gKiBNaXhpbiBnbG9iYWwgQVBJXG4gKi9cblxuZXh0ZW5kKFZ1ZSwgcmVxdWlyZSgnLi9hcGkvZ2xvYmFsJykpXG5cbi8qKlxuICogVnVlIGFuZCBldmVyeSBjb25zdHJ1Y3RvciB0aGF0IGV4dGVuZHMgVnVlIGhhcyBhblxuICogYXNzb2NpYXRlZCBvcHRpb25zIG9iamVjdCwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkIGR1cmluZ1xuICogY29tcGlsYXRpb24gc3RlcHMgYXMgYHRoaXMuY29uc3RydWN0b3Iub3B0aW9uc2AuXG4gKlxuICogVGhlc2UgY2FuIGJlIHNlZW4gYXMgdGhlIGRlZmF1bHQgb3B0aW9ucyBvZiBldmVyeVxuICogVnVlIGluc3RhbmNlLlxuICovXG5cblZ1ZS5vcHRpb25zID0ge1xuICByZXBsYWNlOiB0cnVlLFxuICBkaXJlY3RpdmVzOiByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvcHVibGljJyksXG4gIGVsZW1lbnREaXJlY3RpdmVzOiByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZWxlbWVudCcpLFxuICBmaWx0ZXJzOiByZXF1aXJlKCcuL2ZpbHRlcnMnKSxcbiAgdHJhbnNpdGlvbnM6IHt9LFxuICBjb21wb25lbnRzOiB7fSxcbiAgcGFydGlhbHM6IHt9XG59XG5cbi8qKlxuICogQnVpbGQgdXAgdGhlIHByb3RvdHlwZVxuICovXG5cbnZhciBwID0gVnVlLnByb3RvdHlwZVxuXG4vKipcbiAqICRkYXRhIGhhcyBhIHNldHRlciB3aGljaCBkb2VzIGEgYnVuY2ggb2ZcbiAqIHRlYXJkb3duL3NldHVwIHdvcmtcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocCwgJyRkYXRhJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgaWYgKG5ld0RhdGEgIT09IHRoaXMuX2RhdGEpIHtcbiAgICAgIHRoaXMuX3NldERhdGEobmV3RGF0YSlcbiAgICB9XG4gIH1cbn0pXG5cbi8qKlxuICogTWl4aW4gaW50ZXJuYWwgaW5zdGFuY2UgbWV0aG9kc1xuICovXG5cbmV4dGVuZChwLCByZXF1aXJlKCcuL2luc3RhbmNlL2luaXQnKSlcbmV4dGVuZChwLCByZXF1aXJlKCcuL2luc3RhbmNlL2V2ZW50cycpKVxuZXh0ZW5kKHAsIHJlcXVpcmUoJy4vaW5zdGFuY2Uvc3RhdGUnKSlcbmV4dGVuZChwLCByZXF1aXJlKCcuL2luc3RhbmNlL2xpZmVjeWNsZScpKVxuZXh0ZW5kKHAsIHJlcXVpcmUoJy4vaW5zdGFuY2UvbWlzYycpKVxuXG4vKipcbiAqIE1peGluIHB1YmxpYyBBUEkgbWV0aG9kc1xuICovXG5cbmV4dGVuZChwLCByZXF1aXJlKCcuL2FwaS9kYXRhJykpXG5leHRlbmQocCwgcmVxdWlyZSgnLi9hcGkvZG9tJykpXG5leHRlbmQocCwgcmVxdWlyZSgnLi9hcGkvZXZlbnRzJykpXG5leHRlbmQocCwgcmVxdWlyZSgnLi9hcGkvbGlmZWN5Y2xlJykpXG5cblZ1ZS52ZXJzaW9uID0gJzEuMC40J1xubW9kdWxlLmV4cG9ydHMgPSBfLlZ1ZSA9IFZ1ZVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlmIChfLmluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXykge1xuICAgIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fLmVtaXQoJ2luaXQnLCBWdWUpXG4gIH1cbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi91dGlsJylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpXG52YXIgRGVwID0gcmVxdWlyZSgnLi9vYnNlcnZlci9kZXAnKVxudmFyIGV4cFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2Vycy9leHByZXNzaW9uJylcbnZhciBiYXRjaGVyID0gcmVxdWlyZSgnLi9iYXRjaGVyJylcbnZhciB1aWQgPSAwXG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgLSB7QXJyYXl9IGZpbHRlcnNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSB0d29XYXlcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBkZWVwXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gdXNlclxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHN5bmNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBsYXp5XG4gKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFtwcmVQcm9jZXNzXVxuICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbcG9zdFByb2Nlc3NdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBXYXRjaGVyICh2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcbiAgLy8gbWl4IGluIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBfLmV4dGVuZCh0aGlzLCBvcHRpb25zKVxuICB9XG4gIHZhciBpc0ZuID0gdHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbidcbiAgdGhpcy52bSA9IHZtXG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpXG4gIHRoaXMuZXhwcmVzc2lvbiA9IGlzRm4gPyBleHBPckZuLnRvU3RyaW5nKCkgOiBleHBPckZuXG4gIHRoaXMuY2IgPSBjYlxuICB0aGlzLmlkID0gKyt1aWQgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWVcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eSAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHRoaXMubmV3RGVwcyA9IG51bGxcbiAgdGhpcy5wcmV2RXJyb3IgPSBudWxsIC8vIGZvciBhc3luYyBlcnJvciBzdGFja3NcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyL3NldHRlclxuICBpZiAoaXNGbikge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGblxuICAgIHRoaXMuc2V0dGVyID0gdW5kZWZpbmVkXG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlcyA9IGV4cFBhcnNlci5wYXJzZShleHBPckZuLCB0aGlzLnR3b1dheSlcbiAgICB0aGlzLmdldHRlciA9IHJlcy5nZXRcbiAgICB0aGlzLnNldHRlciA9IHJlcy5zZXRcbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KClcbiAgLy8gc3RhdGUgZm9yIGF2b2lkaW5nIGZhbHNlIHRyaWdnZXJzIGZvciBkZWVwIGFuZCBBcnJheVxuICAvLyB3YXRjaGVycyBkdXJpbmcgdm0uX2RpZ2VzdCgpXG4gIHRoaXMucXVldWVkID0gdGhpcy5zaGFsbG93ID0gZmFsc2Vcbn1cblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RGVwfSBkZXBcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZFxuICBpZiAoIXRoaXMubmV3RGVwc1tpZF0pIHtcbiAgICB0aGlzLm5ld0RlcHNbaWRdID0gZGVwXG4gICAgaWYgKCF0aGlzLmRlcHNbaWRdKSB7XG4gICAgICB0aGlzLmRlcHNbaWRdID0gZGVwXG4gICAgICBkZXAuYWRkU3ViKHRoaXMpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5iZWZvcmVHZXQoKVxuICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlIHx8IHRoaXMudm1cbiAgdmFyIHZhbHVlXG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHNjb3BlLCBzY29wZSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIGNvbmZpZy53YXJuRXhwcmVzc2lvbkVycm9yc1xuICAgICkge1xuICAgICAgXy53YXJuKFxuICAgICAgICAnRXJyb3Igd2hlbiBldmFsdWF0aW5nIGV4cHJlc3Npb24gXCInICtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uICsgJ1wiLiAnICtcbiAgICAgICAgKGNvbmZpZy5kZWJ1Z1xuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdUdXJuIG9uIGRlYnVnIG1vZGUgdG8gc2VlIHN0YWNrIHRyYWNlLidcbiAgICAgICAgKSwgZVxuICAgICAgKVxuICAgIH1cbiAgfVxuICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gIGlmICh0aGlzLmRlZXApIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZSlcbiAgfVxuICBpZiAodGhpcy5wcmVQcm9jZXNzKSB7XG4gICAgdmFsdWUgPSB0aGlzLnByZVByb2Nlc3ModmFsdWUpXG4gIH1cbiAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgIHZhbHVlID0gc2NvcGUuX2FwcGx5RmlsdGVycyh2YWx1ZSwgbnVsbCwgdGhpcy5maWx0ZXJzLCBmYWxzZSlcbiAgfVxuICBpZiAodGhpcy5wb3N0UHJvY2Vzcykge1xuICAgIHZhbHVlID0gdGhpcy5wb3N0UHJvY2Vzcyh2YWx1ZSlcbiAgfVxuICB0aGlzLmFmdGVyR2V0KClcbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogU2V0IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHdpdGggdGhlIHNldHRlci5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bVxuICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgdmFsdWUgPSBzY29wZS5fYXBwbHlGaWx0ZXJzKFxuICAgICAgdmFsdWUsIHRoaXMudmFsdWUsIHRoaXMuZmlsdGVycywgdHJ1ZSlcbiAgfVxuICB0cnkge1xuICAgIHRoaXMuc2V0dGVyLmNhbGwoc2NvcGUsIHNjb3BlLCB2YWx1ZSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIGNvbmZpZy53YXJuRXhwcmVzc2lvbkVycm9yc1xuICAgICkge1xuICAgICAgXy53YXJuKFxuICAgICAgICAnRXJyb3Igd2hlbiBldmFsdWF0aW5nIHNldHRlciBcIicgK1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gKyAnXCInLCBlXG4gICAgICApXG4gICAgfVxuICB9XG4gIC8vIHR3by13YXkgc3luYyBmb3Igdi1mb3IgYWxpYXNcbiAgdmFyIGZvckNvbnRleHQgPSBzY29wZS4kZm9yQ29udGV4dFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChcbiAgICAgIGZvckNvbnRleHQgJiZcbiAgICAgIGZvckNvbnRleHQuZmlsdGVycyAmJlxuICAgICAgKG5ldyBSZWdFeHAoZm9yQ29udGV4dC5hbGlhcyArICdcXFxcYicpKS50ZXN0KHRoaXMuZXhwcmVzc2lvbilcbiAgICApIHtcbiAgICAgIF8ud2FybihcbiAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdHdvLXdheSBiaW5kaW5nIG9uICcgK1xuICAgICAgICAnYSB2LWZvciBhbGlhcyAoJyArIHRoaXMuZXhwcmVzc2lvbiArICcpLCBhbmQgdGhlICcgK1xuICAgICAgICAndi1mb3IgaGFzIGZpbHRlcnMuIFRoaXMgd2lsbCBub3Qgd29yayBwcm9wZXJseS4gJyArXG4gICAgICAgICdFaXRoZXIgcmVtb3ZlIHRoZSBmaWx0ZXJzIG9yIHVzZSBhbiBhcnJheSBvZiAnICtcbiAgICAgICAgJ29iamVjdHMgYW5kIGJpbmQgdG8gb2JqZWN0IHByb3BlcnRpZXMgaW5zdGVhZC4nXG4gICAgICApXG4gICAgfVxuICB9XG4gIGlmIChcbiAgICBmb3JDb250ZXh0ICYmXG4gICAgZm9yQ29udGV4dC5hbGlhcyA9PT0gdGhpcy5leHByZXNzaW9uICYmXG4gICAgIWZvckNvbnRleHQuZmlsdGVyc1xuICApIHtcbiAgICBpZiAoc2NvcGUuJGtleSkgeyAvLyBvcmlnaW5hbCBpcyBhbiBvYmplY3RcbiAgICAgIGZvckNvbnRleHQucmF3VmFsdWVbc2NvcGUuJGtleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JDb250ZXh0LnJhd1ZhbHVlLiRzZXQoc2NvcGUuJGluZGV4LCB2YWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQcmVwYXJlIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYmVmb3JlR2V0ID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0ID0gdGhpc1xuICB0aGlzLm5ld0RlcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG59XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZnRlckdldCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldCA9IG51bGxcbiAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKHRoaXMuZGVwcylcbiAgdmFyIGkgPSBpZHMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgaWQgPSBpZHNbaV1cbiAgICBpZiAoIXRoaXMubmV3RGVwc1tpZF0pIHtcbiAgICAgIHRoaXMuZGVwc1tpZF0ucmVtb3ZlU3ViKHRoaXMpXG4gICAgfVxuICB9XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwc1xufVxuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNoYWxsb3dcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoc2hhbGxvdykge1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWVcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMgfHwgIWNvbmZpZy5hc3luYykge1xuICAgIHRoaXMucnVuKClcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBxdWV1ZWQsIG9ubHkgb3ZlcndyaXRlIHNoYWxsb3cgd2l0aCBub24tc2hhbGxvdyxcbiAgICAvLyBidXQgbm90IHRoZSBvdGhlciB3YXkgYXJvdW5kLlxuICAgIHRoaXMuc2hhbGxvdyA9IHRoaXMucXVldWVkXG4gICAgICA/IHNoYWxsb3dcbiAgICAgICAgPyB0aGlzLnNoYWxsb3dcbiAgICAgICAgOiBmYWxzZVxuICAgICAgOiAhIXNoYWxsb3dcbiAgICB0aGlzLnF1ZXVlZCA9IHRydWVcbiAgICAvLyByZWNvcmQgYmVmb3JlLXB1c2ggZXJyb3Igc3RhY2sgaW4gZGVidWcgbW9kZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5kZWJ1Zykge1xuICAgICAgdGhpcy5wcmV2RXJyb3IgPSBuZXcgRXJyb3IoJ1t2dWVdIGFzeW5jIHN0YWNrIHRyYWNlJylcbiAgICB9XG4gICAgYmF0Y2hlci5wdXNoKHRoaXMpXG4gIH1cbn1cblxuLyoqXG4gKiBCYXRjaGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgYmF0Y2hlci5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KClcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgQXJyYXkgd2F0Y2hlcnMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkOyBidXQgb25seSBkbyBzbyBpZiB0aGlzIGlzIGFcbiAgICAgIC8vIG5vbi1zaGFsbG93IHVwZGF0ZSAoY2F1c2VkIGJ5IGEgdm0gZGlnZXN0KS5cbiAgICAgICgoXy5pc0FycmF5KHZhbHVlKSB8fCB0aGlzLmRlZXApICYmICF0aGlzLnNoYWxsb3cpXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICAgIC8vIGluIGRlYnVnICsgYXN5bmMgbW9kZSwgd2hlbiBhIHdhdGNoZXIgY2FsbGJhY2tzXG4gICAgICAvLyB0aHJvd3MsIHdlIGFsc28gdGhyb3cgdGhlIHNhdmVkIGJlZm9yZS1wdXNoIGVycm9yXG4gICAgICAvLyBzbyB0aGUgZnVsbCBjcm9zcy10aWNrIHN0YWNrIHRyYWNlIGlzIGF2YWlsYWJsZS5cbiAgICAgIHZhciBwcmV2RXJyb3IgPSB0aGlzLnByZXZFcnJvclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIGNvbmZpZy5kZWJ1ZyAmJiBwcmV2RXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcmV2RXJyb3IgPSBudWxsXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF8ubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgcHJldkVycm9yXG4gICAgICAgICAgfSwgMClcbiAgICAgICAgICB0aHJvdyBlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucXVldWVkID0gdGhpcy5zaGFsbG93ID0gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gYXZvaWQgb3ZlcndyaXRpbmcgYW5vdGhlciB3YXRjaGVyIHRoYXQgaXMgYmVpbmdcbiAgLy8gY29sbGVjdGVkLlxuICB2YXIgY3VycmVudCA9IERlcC50YXJnZXRcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KClcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlXG4gIERlcC50YXJnZXQgPSBjdXJyZW50XG59XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGVwSWRzID0gT2JqZWN0LmtleXModGhpcy5kZXBzKVxuICB2YXIgaSA9IGRlcElkcy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuZGVwc1tkZXBJZHNbaV1dLmRlcGVuZCgpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YmNyaWJlciBsaXN0LlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gd2UgY2FuIHNraXAgdGhpcyBpZiB0aGUgdm0gaWYgYmVpbmcgZGVzdHJveWVkXG4gICAgLy8gd2hpY2ggY2FuIGltcHJvdmUgdGVhcmRvd24gcGVyZm9ybWFuY2UuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICB0aGlzLnZtLl93YXRjaGVycy4kcmVtb3ZlKHRoaXMpXG4gICAgfVxuICAgIHZhciBkZXBJZHMgPSBPYmplY3Qua2V5cyh0aGlzLmRlcHMpXG4gICAgdmFyIGkgPSBkZXBJZHMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2RlcElkc1tpXV0ucmVtb3ZlU3ViKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2VcbiAgICB0aGlzLnZtID0gdGhpcy5jYiA9IHRoaXMudmFsdWUgPSBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBSZWNydXNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKlxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHZhciBpLCBrZXlzXG4gIGlmIChfLmlzQXJyYXkodmFsKSkge1xuICAgIGkgPSB2YWwubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkgdHJhdmVyc2UodmFsW2ldKVxuICB9IGVsc2UgaWYgKF8uaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpXG4gICAgaSA9IGtleXMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkgdHJhdmVyc2UodmFsW2tleXNbaV1dKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2F0Y2hlclxuIiwidmFyIGluc2VydGVkID0gZXhwb3J0cy5jYWNoZSA9IHt9XG5cbmV4cG9ydHMuaW5zZXJ0ID0gZnVuY3Rpb24gKGNzcykge1xuICBpZiAoaW5zZXJ0ZWRbY3NzXSkgcmV0dXJuXG4gIGluc2VydGVkW2Nzc10gPSB0cnVlXG5cbiAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIGVsZW0uc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJylcblxuICBpZiAoJ3RleHRDb250ZW50JyBpbiBlbGVtKSB7XG4gICAgZWxlbS50ZXh0Q29udGVudCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIGVsZW0uc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH1cblxuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGVsZW0pXG4gIHJldHVybiBlbGVtXG59XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHR2YXIgbWFrZVByb21pc2UgPSByZXF1aXJlKCcuL21ha2VQcm9taXNlJyk7XG5cdHZhciBTY2hlZHVsZXIgPSByZXF1aXJlKCcuL1NjaGVkdWxlcicpO1xuXHR2YXIgYXN5bmMgPSByZXF1aXJlKCcuL2VudicpLmFzYXA7XG5cblx0cmV0dXJuIG1ha2VQcm9taXNlKHtcblx0XHRzY2hlZHVsZXI6IG5ldyBTY2hlZHVsZXIoYXN5bmMpXG5cdH0pO1xuXG59KTtcbn0pKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG5cblx0Ly8gQ3JlZGl0IHRvIFR3aXNvbCAoaHR0cHM6Ly9naXRodWIuY29tL1R3aXNvbCkgZm9yIHN1Z2dlc3Rpbmdcblx0Ly8gdGhpcyB0eXBlIG9mIGV4dGVuc2libGUgcXVldWUgKyB0cmFtcG9saW5lIGFwcHJvYWNoIGZvciBuZXh0LXRpY2sgY29uZmxhdGlvbi5cblxuXHQvKipcblx0ICogQXN5bmMgdGFzayBzY2hlZHVsZXJcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gYXN5bmMgZnVuY3Rpb24gdG8gc2NoZWR1bGUgYSBzaW5nbGUgYXN5bmMgZnVuY3Rpb25cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBTY2hlZHVsZXIoYXN5bmMpIHtcblx0XHR0aGlzLl9hc3luYyA9IGFzeW5jO1xuXHRcdHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuX3F1ZXVlID0gdGhpcztcblx0XHR0aGlzLl9xdWV1ZUxlbiA9IDA7XG5cdFx0dGhpcy5fYWZ0ZXJRdWV1ZSA9IHt9O1xuXHRcdHRoaXMuX2FmdGVyUXVldWVMZW4gPSAwO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHRoaXMuZHJhaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYuX2RyYWluKCk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbnF1ZXVlIGEgdGFza1xuXHQgKiBAcGFyYW0ge3sgcnVuOmZ1bmN0aW9uIH19IHRhc2tcblx0ICovXG5cdFNjaGVkdWxlci5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uKHRhc2spIHtcblx0XHR0aGlzLl9xdWV1ZVt0aGlzLl9xdWV1ZUxlbisrXSA9IHRhc2s7XG5cdFx0dGhpcy5ydW4oKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5xdWV1ZSBhIHRhc2sgdG8gcnVuIGFmdGVyIHRoZSBtYWluIHRhc2sgcXVldWVcblx0ICogQHBhcmFtIHt7IHJ1bjpmdW5jdGlvbiB9fSB0YXNrXG5cdCAqL1xuXHRTY2hlZHVsZXIucHJvdG90eXBlLmFmdGVyUXVldWUgPSBmdW5jdGlvbih0YXNrKSB7XG5cdFx0dGhpcy5fYWZ0ZXJRdWV1ZVt0aGlzLl9hZnRlclF1ZXVlTGVuKytdID0gdGFzaztcblx0XHR0aGlzLnJ1bigpO1xuXHR9O1xuXG5cdFNjaGVkdWxlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9ydW5uaW5nKSB7XG5cdFx0XHR0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblx0XHRcdHRoaXMuX2FzeW5jKHRoaXMuZHJhaW4pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRHJhaW4gdGhlIGhhbmRsZXIgcXVldWUgZW50aXJlbHksIGFuZCB0aGVuIHRoZSBhZnRlciBxdWV1ZVxuXHQgKi9cblx0U2NoZWR1bGVyLnByb3RvdHlwZS5fZHJhaW4gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaSA9IDA7XG5cdFx0Zm9yICg7IGkgPCB0aGlzLl9xdWV1ZUxlbjsgKytpKSB7XG5cdFx0XHR0aGlzLl9xdWV1ZVtpXS5ydW4oKTtcblx0XHRcdHRoaXMuX3F1ZXVlW2ldID0gdm9pZCAwO1xuXHRcdH1cblxuXHRcdHRoaXMuX3F1ZXVlTGVuID0gMDtcblx0XHR0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYWZ0ZXJRdWV1ZUxlbjsgKytpKSB7XG5cdFx0XHR0aGlzLl9hZnRlclF1ZXVlW2ldLnJ1bigpO1xuXHRcdFx0dGhpcy5fYWZ0ZXJRdWV1ZVtpXSA9IHZvaWQgMDtcblx0XHR9XG5cblx0XHR0aGlzLl9hZnRlclF1ZXVlTGVuID0gMDtcblx0fTtcblxuXHRyZXR1cm4gU2NoZWR1bGVyO1xuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKCkge1xuXG5cdC8qKlxuXHQgKiBDdXN0b20gZXJyb3IgdHlwZSBmb3IgcHJvbWlzZXMgcmVqZWN0ZWQgYnkgcHJvbWlzZS50aW1lb3V0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gVGltZW91dEVycm9yIChtZXNzYWdlKSB7XG5cdFx0RXJyb3IuY2FsbCh0aGlzKTtcblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdHRoaXMubmFtZSA9IFRpbWVvdXRFcnJvci5uYW1lO1xuXHRcdGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFRpbWVvdXRFcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0VGltZW91dEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblx0VGltZW91dEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbWVvdXRFcnJvcjtcblxuXHRyZXR1cm4gVGltZW91dEVycm9yO1xufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7IH0pKTsiLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG5cblx0bWFrZUFwcGx5LnRyeUNhdGNoUmVzb2x2ZSA9IHRyeUNhdGNoUmVzb2x2ZTtcblxuXHRyZXR1cm4gbWFrZUFwcGx5O1xuXG5cdGZ1bmN0aW9uIG1ha2VBcHBseShQcm9taXNlLCBjYWxsKSB7XG5cdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcblx0XHRcdGNhbGwgPSB0cnlDYXRjaFJlc29sdmU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFwcGx5O1xuXG5cdFx0ZnVuY3Rpb24gYXBwbHkoZiwgdGhpc0FyZywgYXJncykge1xuXHRcdFx0dmFyIHAgPSBQcm9taXNlLl9kZWZlcigpO1xuXHRcdFx0dmFyIGwgPSBhcmdzLmxlbmd0aDtcblx0XHRcdHZhciBwYXJhbXMgPSBuZXcgQXJyYXkobCk7XG5cdFx0XHRjYWxsQW5kUmVzb2x2ZSh7IGY6ZiwgdGhpc0FyZzp0aGlzQXJnLCBhcmdzOmFyZ3MsIHBhcmFtczpwYXJhbXMsIGk6bC0xLCBjYWxsOmNhbGwgfSwgcC5faGFuZGxlcik7XG5cblx0XHRcdHJldHVybiBwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNhbGxBbmRSZXNvbHZlKGMsIGgpIHtcblx0XHRcdGlmKGMuaSA8IDApIHtcblx0XHRcdFx0cmV0dXJuIGNhbGwoYy5mLCBjLnRoaXNBcmcsIGMucGFyYW1zLCBoKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGhhbmRsZXIgPSBQcm9taXNlLl9oYW5kbGVyKGMuYXJnc1tjLmldKTtcblx0XHRcdGhhbmRsZXIuZm9sZChjYWxsQW5kUmVzb2x2ZU5leHQsIGMsIHZvaWQgMCwgaCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2FsbEFuZFJlc29sdmVOZXh0KGMsIHgsIGgpIHtcblx0XHRcdGMucGFyYW1zW2MuaV0gPSB4O1xuXHRcdFx0Yy5pIC09IDE7XG5cdFx0XHRjYWxsQW5kUmVzb2x2ZShjLCBoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiB0cnlDYXRjaFJlc29sdmUoZiwgdGhpc0FyZywgYXJncywgcmVzb2x2ZXIpIHtcblx0XHR0cnkge1xuXHRcdFx0cmVzb2x2ZXIucmVzb2x2ZShmLmFwcGx5KHRoaXNBcmcsIGFyZ3MpKTtcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdHJlc29sdmVyLnJlamVjdChlKTtcblx0XHR9XG5cdH1cblxufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7IH0pKTtcblxuXG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG5cdHZhciBzdGF0ZSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XG5cdHZhciBhcHBsaWVyID0gcmVxdWlyZSgnLi4vYXBwbHknKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gYXJyYXkoUHJvbWlzZSkge1xuXG5cdFx0dmFyIGFwcGx5Rm9sZCA9IGFwcGxpZXIoUHJvbWlzZSk7XG5cdFx0dmFyIHRvUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZTtcblx0XHR2YXIgYWxsID0gUHJvbWlzZS5hbGw7XG5cblx0XHR2YXIgYXIgPSBBcnJheS5wcm90b3R5cGUucmVkdWNlO1xuXHRcdHZhciBhcnIgPSBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQ7XG5cdFx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5cdFx0Ly8gQWRkaXRpb25hbCBhcnJheSBjb21iaW5hdG9yc1xuXG5cdFx0UHJvbWlzZS5hbnkgPSBhbnk7XG5cdFx0UHJvbWlzZS5zb21lID0gc29tZTtcblx0XHRQcm9taXNlLnNldHRsZSA9IHNldHRsZTtcblxuXHRcdFByb21pc2UubWFwID0gbWFwO1xuXHRcdFByb21pc2UuZmlsdGVyID0gZmlsdGVyO1xuXHRcdFByb21pc2UucmVkdWNlID0gcmVkdWNlO1xuXHRcdFByb21pc2UucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gdGhpcyBwcm9taXNlIGZ1bGZpbGxzIHdpdGggYW4gYXJyYXksIGRvXG5cdFx0ICogb25GdWxmaWxsZWQuYXBwbHkodm9pZCAwLCBhcnJheSlcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkZ1bGZpbGxlZCBmdW5jdGlvbiB0byBhcHBseVxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIG9uRnVsZmlsbGVkXG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24ob25GdWxmaWxsZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLnRoZW4oYWxsKS50aGVuKGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0XHRcdHJldHVybiBvbkZ1bGZpbGxlZC5hcHBseSh0aGlzLCBhcnJheSk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cblx0XHQvKipcblx0XHQgKiBPbmUtd2lubmVyIGNvbXBldGl0aXZlIHJhY2UuXG5cdFx0ICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCB3aGVuIG9uZSBvZiB0aGUgcHJvbWlzZXNcblx0XHQgKiBpbiB0aGUgaW5wdXQgYXJyYXkgZnVsZmlsbHMsIG9yIHdpbGwgcmVqZWN0IHdoZW4gYWxsIHByb21pc2VzXG5cdFx0ICogaGF2ZSByZWplY3RlZC5cblx0XHQgKiBAcGFyYW0ge2FycmF5fSBwcm9taXNlc1xuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIGZvciB0aGUgZmlyc3QgZnVsZmlsbGVkIHZhbHVlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gYW55KHByb21pc2VzKSB7XG5cdFx0XHR2YXIgcCA9IFByb21pc2UuX2RlZmVyKCk7XG5cdFx0XHR2YXIgcmVzb2x2ZXIgPSBwLl9oYW5kbGVyO1xuXHRcdFx0dmFyIGwgPSBwcm9taXNlcy5sZW5ndGg+Pj4wO1xuXG5cdFx0XHR2YXIgcGVuZGluZyA9IGw7XG5cdFx0XHR2YXIgZXJyb3JzID0gW107XG5cblx0XHRcdGZvciAodmFyIGgsIHgsIGkgPSAwOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRcdHggPSBwcm9taXNlc1tpXTtcblx0XHRcdFx0aWYoeCA9PT0gdm9pZCAwICYmICEoaSBpbiBwcm9taXNlcykpIHtcblx0XHRcdFx0XHQtLXBlbmRpbmc7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRoID0gUHJvbWlzZS5faGFuZGxlcih4KTtcblx0XHRcdFx0aWYoaC5zdGF0ZSgpID4gMCkge1xuXHRcdFx0XHRcdHJlc29sdmVyLmJlY29tZShoKTtcblx0XHRcdFx0XHRQcm9taXNlLl92aXNpdFJlbWFpbmluZyhwcm9taXNlcywgaSwgaCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aC52aXNpdChyZXNvbHZlciwgaGFuZGxlRnVsZmlsbCwgaGFuZGxlUmVqZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZihwZW5kaW5nID09PSAwKSB7XG5cdFx0XHRcdHJlc29sdmVyLnJlamVjdChuZXcgUmFuZ2VFcnJvcignYW55KCk6IGFycmF5IG11c3Qgbm90IGJlIGVtcHR5JykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcDtcblxuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlRnVsZmlsbCh4KSB7XG5cdFx0XHRcdC8qanNoaW50IHZhbGlkdGhpczp0cnVlKi9cblx0XHRcdFx0ZXJyb3JzID0gbnVsbDtcblx0XHRcdFx0dGhpcy5yZXNvbHZlKHgpOyAvLyB0aGlzID09PSByZXNvbHZlclxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBoYW5kbGVSZWplY3QoZSkge1xuXHRcdFx0XHQvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSovXG5cdFx0XHRcdGlmKHRoaXMucmVzb2x2ZWQpIHsgLy8gdGhpcyA9PT0gcmVzb2x2ZXJcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlcnJvcnMucHVzaChlKTtcblx0XHRcdFx0aWYoLS1wZW5kaW5nID09PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5yZWplY3QoZXJyb3JzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIE4td2lubmVyIGNvbXBldGl0aXZlIHJhY2Vcblx0XHQgKiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBmdWxmaWxsIHdoZW4gbiBpbnB1dCBwcm9taXNlcyBoYXZlXG5cdFx0ICogZnVsZmlsbGVkLCBvciB3aWxsIHJlamVjdCB3aGVuIGl0IGJlY29tZXMgaW1wb3NzaWJsZSBmb3IgblxuXHRcdCAqIGlucHV0IHByb21pc2VzIHRvIGZ1bGZpbGwgKGllIHdoZW4gcHJvbWlzZXMubGVuZ3RoIC0gbiArIDFcblx0XHQgKiBoYXZlIHJlamVjdGVkKVxuXHRcdCAqIEBwYXJhbSB7YXJyYXl9IHByb21pc2VzXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IG5cblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSBmb3IgdGhlIGVhcmxpZXN0IG4gZnVsZmlsbG1lbnQgdmFsdWVzXG5cdFx0ICpcblx0XHQgKiBAZGVwcmVjYXRlZFxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHNvbWUocHJvbWlzZXMsIG4pIHtcblx0XHRcdC8qanNoaW50IG1heGNvbXBsZXhpdHk6NyovXG5cdFx0XHR2YXIgcCA9IFByb21pc2UuX2RlZmVyKCk7XG5cdFx0XHR2YXIgcmVzb2x2ZXIgPSBwLl9oYW5kbGVyO1xuXG5cdFx0XHR2YXIgcmVzdWx0cyA9IFtdO1xuXHRcdFx0dmFyIGVycm9ycyA9IFtdO1xuXG5cdFx0XHR2YXIgbCA9IHByb21pc2VzLmxlbmd0aD4+PjA7XG5cdFx0XHR2YXIgbkZ1bGZpbGwgPSAwO1xuXHRcdFx0dmFyIG5SZWplY3Q7XG5cdFx0XHR2YXIgeCwgaTsgLy8gcmV1c2VkIGluIGJvdGggZm9yKCkgbG9vcHNcblxuXHRcdFx0Ly8gRmlyc3QgcGFzczogY291bnQgYWN0dWFsIGFycmF5IGl0ZW1zXG5cdFx0XHRmb3IoaT0wOyBpPGw7ICsraSkge1xuXHRcdFx0XHR4ID0gcHJvbWlzZXNbaV07XG5cdFx0XHRcdGlmKHggPT09IHZvaWQgMCAmJiAhKGkgaW4gcHJvbWlzZXMpKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0KytuRnVsZmlsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcHV0ZSBhY3R1YWwgZ29hbHNcblx0XHRcdG4gPSBNYXRoLm1heChuLCAwKTtcblx0XHRcdG5SZWplY3QgPSAobkZ1bGZpbGwgLSBuICsgMSk7XG5cdFx0XHRuRnVsZmlsbCA9IE1hdGgubWluKG4sIG5GdWxmaWxsKTtcblxuXHRcdFx0aWYobiA+IG5GdWxmaWxsKSB7XG5cdFx0XHRcdHJlc29sdmVyLnJlamVjdChuZXcgUmFuZ2VFcnJvcignc29tZSgpOiBhcnJheSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJ1xuXHRcdFx0XHQrIG4gKyAnIGl0ZW0ocyksIGJ1dCBoYWQgJyArIG5GdWxmaWxsKSk7XG5cdFx0XHR9IGVsc2UgaWYobkZ1bGZpbGwgPT09IDApIHtcblx0XHRcdFx0cmVzb2x2ZXIucmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2Vjb25kIHBhc3M6IG9ic2VydmUgZWFjaCBhcnJheSBpdGVtLCBtYWtlIHByb2dyZXNzIHRvd2FyZCBnb2Fsc1xuXHRcdFx0Zm9yKGk9MDsgaTxsOyArK2kpIHtcblx0XHRcdFx0eCA9IHByb21pc2VzW2ldO1xuXHRcdFx0XHRpZih4ID09PSB2b2lkIDAgJiYgIShpIGluIHByb21pc2VzKSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0UHJvbWlzZS5faGFuZGxlcih4KS52aXNpdChyZXNvbHZlciwgZnVsZmlsbCwgcmVqZWN0LCByZXNvbHZlci5ub3RpZnkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcDtcblxuXHRcdFx0ZnVuY3Rpb24gZnVsZmlsbCh4KSB7XG5cdFx0XHRcdC8qanNoaW50IHZhbGlkdGhpczp0cnVlKi9cblx0XHRcdFx0aWYodGhpcy5yZXNvbHZlZCkgeyAvLyB0aGlzID09PSByZXNvbHZlclxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdHMucHVzaCh4KTtcblx0XHRcdFx0aWYoLS1uRnVsZmlsbCA9PT0gMCkge1xuXHRcdFx0XHRcdGVycm9ycyA9IG51bGw7XG5cdFx0XHRcdFx0dGhpcy5yZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHJlamVjdChlKSB7XG5cdFx0XHRcdC8qanNoaW50IHZhbGlkdGhpczp0cnVlKi9cblx0XHRcdFx0aWYodGhpcy5yZXNvbHZlZCkgeyAvLyB0aGlzID09PSByZXNvbHZlclxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVycm9ycy5wdXNoKGUpO1xuXHRcdFx0XHRpZigtLW5SZWplY3QgPT09IDApIHtcblx0XHRcdFx0XHRyZXN1bHRzID0gbnVsbDtcblx0XHRcdFx0XHR0aGlzLnJlamVjdChlcnJvcnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQXBwbHkgZiB0byB0aGUgdmFsdWUgb2YgZWFjaCBwcm9taXNlIGluIGEgbGlzdCBvZiBwcm9taXNlc1xuXHRcdCAqIGFuZCByZXR1cm4gYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSByZXN1bHRzLlxuXHRcdCAqIEBwYXJhbSB7YXJyYXl9IHByb21pc2VzXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbih4OiosIGluZGV4Ok51bWJlcik6Kn0gZiBtYXBwaW5nIGZ1bmN0aW9uXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbWFwKHByb21pc2VzLCBmKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5fdHJhdmVyc2UoZiwgcHJvbWlzZXMpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEZpbHRlciB0aGUgcHJvdmlkZWQgYXJyYXkgb2YgcHJvbWlzZXMgdXNpbmcgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZS4gIElucHV0IG1heVxuXHRcdCAqIGNvbnRhaW4gcHJvbWlzZXMgYW5kIHZhbHVlc1xuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIGFuZCB2YWx1ZXNcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uKHg6KiwgaW5kZXg6TnVtYmVyKTpib29sZWFufSBwcmVkaWNhdGUgZmlsdGVyaW5nIHByZWRpY2F0ZS5cblx0XHQgKiAgTXVzdCByZXR1cm4gdHJ1dGh5IChvciBwcm9taXNlIGZvciB0cnV0aHkpIGZvciBpdGVtcyB0byByZXRhaW4uXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgd2l0aCBhbiBhcnJheSBjb250YWluaW5nIGFsbCBpdGVtc1xuXHRcdCAqICBmb3Igd2hpY2ggcHJlZGljYXRlIHJldHVybmVkIHRydXRoeS5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBmaWx0ZXIocHJvbWlzZXMsIHByZWRpY2F0ZSkge1xuXHRcdFx0dmFyIGEgPSBzbGljZS5jYWxsKHByb21pc2VzKTtcblx0XHRcdHJldHVybiBQcm9taXNlLl90cmF2ZXJzZShwcmVkaWNhdGUsIGEpLnRoZW4oZnVuY3Rpb24oa2VlcCkge1xuXHRcdFx0XHRyZXR1cm4gZmlsdGVyU3luYyhhLCBrZWVwKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpbHRlclN5bmMocHJvbWlzZXMsIGtlZXApIHtcblx0XHRcdC8vIFNhZmUgYmVjYXVzZSB3ZSBrbm93IGFsbCBwcm9taXNlcyBoYXZlIGZ1bGZpbGxlZCBpZiB3ZSd2ZSBtYWRlIGl0IHRoaXMgZmFyXG5cdFx0XHR2YXIgbCA9IGtlZXAubGVuZ3RoO1xuXHRcdFx0dmFyIGZpbHRlcmVkID0gbmV3IEFycmF5KGwpO1xuXHRcdFx0Zm9yKHZhciBpPTAsIGo9MDsgaTxsOyArK2kpIHtcblx0XHRcdFx0aWYoa2VlcFtpXSkge1xuXHRcdFx0XHRcdGZpbHRlcmVkW2orK10gPSBQcm9taXNlLl9oYW5kbGVyKHByb21pc2VzW2ldKS52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZmlsdGVyZWQubGVuZ3RoID0gajtcblx0XHRcdHJldHVybiBmaWx0ZXJlZDtcblxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGFsd2F5cyBmdWxmaWxsIHdpdGggYW4gYXJyYXkgY29udGFpbmluZ1xuXHRcdCAqIHRoZSBvdXRjb21lIHN0YXRlcyBvZiBhbGwgaW5wdXQgcHJvbWlzZXMuICBUaGUgcmV0dXJuZWQgcHJvbWlzZVxuXHRcdCAqIHdpbGwgbmV2ZXIgcmVqZWN0LlxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgZm9yIGFycmF5IG9mIHNldHRsZWQgc3RhdGUgZGVzY3JpcHRvcnNcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzZXR0bGUocHJvbWlzZXMpIHtcblx0XHRcdHJldHVybiBhbGwocHJvbWlzZXMubWFwKHNldHRsZU9uZSkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldHRsZU9uZShwKSB7XG5cdFx0XHR2YXIgaCA9IFByb21pc2UuX2hhbmRsZXIocCk7XG5cdFx0XHRpZihoLnN0YXRlKCkgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIHRvUHJvbWlzZShwKS50aGVuKHN0YXRlLmZ1bGZpbGxlZCwgc3RhdGUucmVqZWN0ZWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRoLl91bnJlcG9ydCgpO1xuXHRcdFx0cmV0dXJuIHN0YXRlLmluc3BlY3QoaCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogVHJhZGl0aW9uYWwgcmVkdWNlIGZ1bmN0aW9uLCBzaW1pbGFyIHRvIGBBcnJheS5wcm90b3R5cGUucmVkdWNlKClgLCBidXRcblx0XHQgKiBpbnB1dCBtYXkgY29udGFpbiBwcm9taXNlcyBhbmQvb3IgdmFsdWVzLCBhbmQgcmVkdWNlRnVuY1xuXHRcdCAqIG1heSByZXR1cm4gZWl0aGVyIGEgdmFsdWUgb3IgYSBwcm9taXNlLCAqYW5kKiBpbml0aWFsVmFsdWUgbWF5XG5cdFx0ICogYmUgYSBwcm9taXNlIGZvciB0aGUgc3RhcnRpbmcgdmFsdWUuXG5cdFx0ICogQHBhcmFtIHtBcnJheXxQcm9taXNlfSBwcm9taXNlcyBhcnJheSBvciBwcm9taXNlIGZvciBhbiBhcnJheSBvZiBhbnl0aGluZyxcblx0XHQgKiAgICAgIG1heSBjb250YWluIGEgbWl4IG9mIHByb21pc2VzIGFuZCB2YWx1ZXMuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbihhY2N1bXVsYXRlZDoqLCB4OiosIGluZGV4Ok51bWJlcik6Kn0gZiByZWR1Y2UgZnVuY3Rpb25cblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhhdCB3aWxsIHJlc29sdmUgdG8gdGhlIGZpbmFsIHJlZHVjZWQgdmFsdWVcblx0XHQgKi9cblx0XHRmdW5jdGlvbiByZWR1Y2UocHJvbWlzZXMsIGYgLyosIGluaXRpYWxWYWx1ZSAqLykge1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXIuY2FsbChwcm9taXNlcywgbGlmdENvbWJpbmUoZiksIGFyZ3VtZW50c1syXSlcblx0XHRcdFx0XHQ6IGFyLmNhbGwocHJvbWlzZXMsIGxpZnRDb21iaW5lKGYpKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBUcmFkaXRpb25hbCByZWR1Y2UgZnVuY3Rpb24sIHNpbWlsYXIgdG8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodCgpYCwgYnV0XG5cdFx0ICogaW5wdXQgbWF5IGNvbnRhaW4gcHJvbWlzZXMgYW5kL29yIHZhbHVlcywgYW5kIHJlZHVjZUZ1bmNcblx0XHQgKiBtYXkgcmV0dXJuIGVpdGhlciBhIHZhbHVlIG9yIGEgcHJvbWlzZSwgKmFuZCogaW5pdGlhbFZhbHVlIG1heVxuXHRcdCAqIGJlIGEgcHJvbWlzZSBmb3IgdGhlIHN0YXJ0aW5nIHZhbHVlLlxuXHRcdCAqIEBwYXJhbSB7QXJyYXl8UHJvbWlzZX0gcHJvbWlzZXMgYXJyYXkgb3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgYW55dGhpbmcsXG5cdFx0ICogICAgICBtYXkgY29udGFpbiBhIG1peCBvZiBwcm9taXNlcyBhbmQgdmFsdWVzLlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24oYWNjdW11bGF0ZWQ6KiwgeDoqLCBpbmRleDpOdW1iZXIpOip9IGYgcmVkdWNlIGZ1bmN0aW9uXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgd2lsbCByZXNvbHZlIHRvIHRoZSBmaW5hbCByZWR1Y2VkIHZhbHVlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmVkdWNlUmlnaHQocHJvbWlzZXMsIGYgLyosIGluaXRpYWxWYWx1ZSAqLykge1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJyLmNhbGwocHJvbWlzZXMsIGxpZnRDb21iaW5lKGYpLCBhcmd1bWVudHNbMl0pXG5cdFx0XHRcdFx0OiBhcnIuY2FsbChwcm9taXNlcywgbGlmdENvbWJpbmUoZikpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGxpZnRDb21iaW5lKGYpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbih6LCB4LCBpKSB7XG5cdFx0XHRcdHJldHVybiBhcHBseUZvbGQoZiwgdm9pZCAwLCBbeix4LGldKTtcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0pKTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbigpIHtcblxuXHRyZXR1cm4gZnVuY3Rpb24gZmxvdyhQcm9taXNlKSB7XG5cblx0XHR2YXIgcmVzb2x2ZSA9IFByb21pc2UucmVzb2x2ZTtcblx0XHR2YXIgcmVqZWN0ID0gUHJvbWlzZS5yZWplY3Q7XG5cdFx0dmFyIG9yaWdDYXRjaCA9IFByb21pc2UucHJvdG90eXBlWydjYXRjaCddO1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlIHRoZSB1bHRpbWF0ZSBmdWxmaWxsbWVudCB2YWx1ZSBvciByZWplY3Rpb24gcmVhc29uLCBhbmQgYXNzdW1lXG5cdFx0ICogcmVzcG9uc2liaWxpdHkgZm9yIGFsbCBlcnJvcnMuICBJZiBhbiBlcnJvciBwcm9wYWdhdGVzIG91dCBvZiByZXN1bHRcblx0XHQgKiBvciBoYW5kbGVGYXRhbEVycm9yLCBpdCB3aWxsIGJlIHJldGhyb3duIHRvIHRoZSBob3N0LCByZXN1bHRpbmcgaW4gYVxuXHRcdCAqIGxvdWQgc3RhY2sgdHJhY2sgb24gbW9zdCBwbGF0Zm9ybXMgYW5kIGEgY3Jhc2ggb24gc29tZS5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uP30gb25SZXN1bHRcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uP30gb25FcnJvclxuXHRcdCAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uKG9uUmVzdWx0LCBvbkVycm9yKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVyLnZpc2l0KHRoaXMuX2hhbmRsZXIucmVjZWl2ZXIsIG9uUmVzdWx0LCBvbkVycm9yKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkIEVycm9yLXR5cGUgYW5kIHByZWRpY2F0ZSBtYXRjaGluZyB0byBjYXRjaC4gIEV4YW1wbGVzOlxuXHRcdCAqIHByb21pc2UuY2F0Y2goVHlwZUVycm9yLCBoYW5kbGVUeXBlRXJyb3IpXG5cdFx0ICogICAuY2F0Y2gocHJlZGljYXRlLCBoYW5kbGVNYXRjaGVkRXJyb3JzKVxuXHRcdCAqICAgLmNhdGNoKGhhbmRsZVJlbWFpbmluZ0Vycm9ycylcblx0XHQgKiBAcGFyYW0gb25SZWplY3RlZFxuXHRcdCAqIEByZXR1cm5zIHsqfVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gUHJvbWlzZS5wcm90b3R5cGUub3RoZXJ3aXNlID0gZnVuY3Rpb24ob25SZWplY3RlZCkge1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG5cdFx0XHRcdHJldHVybiBvcmlnQ2F0Y2guY2FsbCh0aGlzLCBvblJlamVjdGVkKTtcblx0XHRcdH1cblxuXHRcdFx0aWYodHlwZW9mIG9uUmVqZWN0ZWQgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZW5zdXJlKHJlamVjdEludmFsaWRQcmVkaWNhdGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3JpZ0NhdGNoLmNhbGwodGhpcywgY3JlYXRlQ2F0Y2hGaWx0ZXIoYXJndW1lbnRzWzFdLCBvblJlamVjdGVkKSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFdyYXBzIHRoZSBwcm92aWRlZCBjYXRjaCBoYW5kbGVyLCBzbyB0aGF0IGl0IHdpbGwgb25seSBiZSBjYWxsZWRcblx0XHQgKiBpZiB0aGUgcHJlZGljYXRlIGV2YWx1YXRlcyB0cnV0aHlcblx0XHQgKiBAcGFyYW0gez9mdW5jdGlvbn0gaGFuZGxlclxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZVxuXHRcdCAqIEByZXR1cm5zIHtmdW5jdGlvbn0gY29uZGl0aW9uYWwgY2F0Y2ggaGFuZGxlclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNhdGNoRmlsdGVyKGhhbmRsZXIsIHByZWRpY2F0ZSkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0cmV0dXJuIGV2YWx1YXRlUHJlZGljYXRlKGUsIHByZWRpY2F0ZSlcblx0XHRcdFx0XHQ/IGhhbmRsZXIuY2FsbCh0aGlzLCBlKVxuXHRcdFx0XHRcdDogcmVqZWN0KGUpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBFbnN1cmVzIHRoYXQgb25GdWxmaWxsZWRPclJlamVjdGVkIHdpbGwgYmUgY2FsbGVkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlclxuXHRcdCAqIHRoaXMgcHJvbWlzZSBpcyBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuICBvbkZ1bGZpbGxlZE9yUmVqZWN0ZWQgV0lMTCBOT1Rcblx0XHQgKiByZWNlaXZlIHRoZSBwcm9taXNlcycgdmFsdWUgb3IgcmVhc29uLiAgQW55IHJldHVybmVkIHZhbHVlIHdpbGwgYmUgZGlzcmVnYXJkZWQuXG5cdFx0ICogb25GdWxmaWxsZWRPclJlamVjdGVkIG1heSB0aHJvdyBvciByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIHRvIHNpZ25hbFxuXHRcdCAqIGFuIGFkZGl0aW9uYWwgZXJyb3IuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBoYW5kbGVyIHRvIGJlIGNhbGxlZCByZWdhcmRsZXNzIG9mXG5cdFx0ICogIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvblxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlWydmaW5hbGx5J10gPSBQcm9taXNlLnByb3RvdHlwZS5lbnN1cmUgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdFx0XHRpZih0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbih4KSB7XG5cdFx0XHRcdHJldHVybiBydW5TaWRlRWZmZWN0KGhhbmRsZXIsIHRoaXMsIGlkZW50aXR5LCB4KTtcblx0XHRcdH0sIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0cmV0dXJuIHJ1blNpZGVFZmZlY3QoaGFuZGxlciwgdGhpcywgcmVqZWN0LCBlKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBydW5TaWRlRWZmZWN0IChoYW5kbGVyLCB0aGlzQXJnLCBwcm9wYWdhdGUsIHZhbHVlKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gaGFuZGxlci5jYWxsKHRoaXNBcmcpO1xuXHRcdFx0cmV0dXJuIG1heWJlVGhlbmFibGUocmVzdWx0KVxuXHRcdFx0XHQ/IHByb3BhZ2F0ZVZhbHVlKHJlc3VsdCwgcHJvcGFnYXRlLCB2YWx1ZSlcblx0XHRcdFx0OiBwcm9wYWdhdGUodmFsdWUpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHByb3BhZ2F0ZVZhbHVlIChyZXN1bHQsIHByb3BhZ2F0ZSwgeCkge1xuXHRcdFx0cmV0dXJuIHJlc29sdmUocmVzdWx0KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHByb3BhZ2F0ZSh4KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJlY292ZXIgZnJvbSBhIGZhaWx1cmUgYnkgcmV0dXJuaW5nIGEgZGVmYXVsdFZhbHVlLiAgSWYgZGVmYXVsdFZhbHVlXG5cdFx0ICogaXMgYSBwcm9taXNlLCBpdCdzIGZ1bGZpbGxtZW50IHZhbHVlIHdpbGwgYmUgdXNlZC4gIElmIGRlZmF1bHRWYWx1ZSBpc1xuXHRcdCAqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMsIHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgcmVqZWN0IHdpdGggdGhlXG5cdFx0ICogc2FtZSByZWFzb24uXG5cdFx0ICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWVcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gbmV3IHByb21pc2Vcblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZVsnZWxzZSddID0gUHJvbWlzZS5wcm90b3R5cGUub3JFbHNlID0gZnVuY3Rpb24oZGVmYXVsdFZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBkZWZhdWx0VmFsdWU7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogU2hvcnRjdXQgZm9yIC50aGVuKGZ1bmN0aW9uKCkgeyByZXR1cm4gdmFsdWU7IH0pXG5cdFx0ICogQHBhcmFtICB7Kn0gdmFsdWVcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdDpcblx0XHQgKiAgLSBpcyBmdWxmaWxsZWQgaWYgdmFsdWUgaXMgbm90IGEgcHJvbWlzZSwgb3Jcblx0XHQgKiAgLSBpZiB2YWx1ZSBpcyBhIHByb21pc2UsIHdpbGwgZnVsZmlsbCB3aXRoIGl0cyB2YWx1ZSwgb3IgcmVqZWN0XG5cdFx0ICogICAgd2l0aCBpdHMgcmVhc29uLlxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlWyd5aWVsZCddID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSdW5zIGEgc2lkZSBlZmZlY3Qgd2hlbiB0aGlzIHByb21pc2UgZnVsZmlsbHMsIHdpdGhvdXQgY2hhbmdpbmcgdGhlXG5cdFx0ICogZnVsZmlsbG1lbnQgdmFsdWUuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gb25GdWxmaWxsZWRTaWRlRWZmZWN0XG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUudGFwID0gZnVuY3Rpb24ob25GdWxmaWxsZWRTaWRlRWZmZWN0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50aGVuKG9uRnVsZmlsbGVkU2lkZUVmZmVjdClbJ3lpZWxkJ10odGhpcyk7XG5cdFx0fTtcblxuXHRcdHJldHVybiBQcm9taXNlO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIHJlamVjdEludmFsaWRQcmVkaWNhdGUoKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignY2F0Y2ggcHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXZhbHVhdGVQcmVkaWNhdGUoZSwgcHJlZGljYXRlKSB7XG5cdFx0cmV0dXJuIGlzRXJyb3IocHJlZGljYXRlKSA/IGUgaW5zdGFuY2VvZiBwcmVkaWNhdGUgOiBwcmVkaWNhdGUoZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0Vycm9yKHByZWRpY2F0ZSkge1xuXHRcdHJldHVybiBwcmVkaWNhdGUgPT09IEVycm9yXG5cdFx0XHR8fCAocHJlZGljYXRlICE9IG51bGwgJiYgcHJlZGljYXRlLnByb3RvdHlwZSBpbnN0YW5jZW9mIEVycm9yKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1heWJlVGhlbmFibGUoeCkge1xuXHRcdHJldHVybiAodHlwZW9mIHggPT09ICdvYmplY3QnIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nKSAmJiB4ICE9PSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuXHRcdHJldHVybiB4O1xuXHR9XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cbi8qKiBAYXV0aG9yIEplZmYgRXNjYWxhbnRlICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKCkge1xuXG5cdHJldHVybiBmdW5jdGlvbiBmb2xkKFByb21pc2UpIHtcblxuXHRcdFByb21pc2UucHJvdG90eXBlLmZvbGQgPSBmdW5jdGlvbihmLCB6KSB7XG5cdFx0XHR2YXIgcHJvbWlzZSA9IHRoaXMuX2JlZ2V0KCk7XG5cblx0XHRcdHRoaXMuX2hhbmRsZXIuZm9sZChmdW5jdGlvbih6LCB4LCB0bykge1xuXHRcdFx0XHRQcm9taXNlLl9oYW5kbGVyKHopLmZvbGQoZnVuY3Rpb24oeCwgeiwgdG8pIHtcblx0XHRcdFx0XHR0by5yZXNvbHZlKGYuY2FsbCh0aGlzLCB6LCB4KSk7XG5cdFx0XHRcdH0sIHgsIHRoaXMsIHRvKTtcblx0XHRcdH0sIHosIHByb21pc2UuX2hhbmRsZXIucmVjZWl2ZXIsIHByb21pc2UuX2hhbmRsZXIpO1xuXG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cdH07XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG5cdHZhciBpbnNwZWN0ID0gcmVxdWlyZSgnLi4vc3RhdGUnKS5pbnNwZWN0O1xuXG5cdHJldHVybiBmdW5jdGlvbiBpbnNwZWN0aW9uKFByb21pc2UpIHtcblxuXHRcdFByb21pc2UucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBpbnNwZWN0KFByb21pc2UuX2hhbmRsZXIodGhpcykpO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gUHJvbWlzZTtcblx0fTtcblxufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIGdlbmVyYXRlKFByb21pc2UpIHtcblxuXHRcdHZhciByZXNvbHZlID0gUHJvbWlzZS5yZXNvbHZlO1xuXG5cdFx0UHJvbWlzZS5pdGVyYXRlID0gaXRlcmF0ZTtcblx0XHRQcm9taXNlLnVuZm9sZCA9IHVuZm9sZDtcblxuXHRcdHJldHVybiBQcm9taXNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQGRlcHJlY2F0ZWQgVXNlIGdpdGh1Yi5jb20vY3Vqb2pzL21vc3Qgc3RyZWFtcyBhbmQgbW9zdC5pdGVyYXRlXG5cdFx0ICogR2VuZXJhdGUgYSAocG90ZW50aWFsbHkgaW5maW5pdGUpIHN0cmVhbSBvZiBwcm9taXNlZCB2YWx1ZXM6XG5cdFx0ICogeCwgZih4KSwgZihmKHgpKSwgZXRjLiB1bnRpbCBjb25kaXRpb24oeCkgcmV0dXJucyB0cnVlXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZiBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIG5ldyB4IGZyb20gdGhlIHByZXZpb3VzIHhcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gdGhlIGN1cnJlbnQgeCwgcmV0dXJuc1xuXHRcdCAqICB0cnV0aHkgd2hlbiB0aGUgaXRlcmF0ZSBzaG91bGQgc3RvcFxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSB2YWx1ZSBwcm9kdWNlZCBieSBmXG5cdFx0ICogQHBhcmFtIHsqfFByb21pc2V9IHggc3RhcnRpbmcgdmFsdWUsIG1heSBiZSBhIHByb21pc2Vcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfSB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGNhbGwgdG8gZiBiZWZvcmVcblx0XHQgKiAgY29uZGl0aW9uIHJldHVybnMgdHJ1ZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGl0ZXJhdGUoZiwgY29uZGl0aW9uLCBoYW5kbGVyLCB4KSB7XG5cdFx0XHRyZXR1cm4gdW5mb2xkKGZ1bmN0aW9uKHgpIHtcblx0XHRcdFx0cmV0dXJuIFt4LCBmKHgpXTtcblx0XHRcdH0sIGNvbmRpdGlvbiwgaGFuZGxlciwgeCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQGRlcHJlY2F0ZWQgVXNlIGdpdGh1Yi5jb20vY3Vqb2pzL21vc3Qgc3RyZWFtcyBhbmQgbW9zdC51bmZvbGRcblx0XHQgKiBHZW5lcmF0ZSBhIChwb3RlbnRpYWxseSBpbmZpbml0ZSkgc3RyZWFtIG9mIHByb21pc2VkIHZhbHVlc1xuXHRcdCAqIGJ5IGFwcGx5aW5nIGhhbmRsZXIoZ2VuZXJhdG9yKHNlZWQpKSBpdGVyYXRpdmVseSB1bnRpbFxuXHRcdCAqIGNvbmRpdGlvbihzZWVkKSByZXR1cm5zIHRydWUuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gdW5zcG9vbCBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhIFt2YWx1ZSwgbmV3U2VlZF1cblx0XHQgKiAgZ2l2ZW4gYSBzZWVkLlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiBmdW5jdGlvbiB0aGF0LCBnaXZlbiB0aGUgY3VycmVudCBzZWVkLCByZXR1cm5zXG5cdFx0ICogIHRydXRoeSB3aGVuIHRoZSB1bmZvbGQgc2hvdWxkIHN0b3Bcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgdmFsdWUgcHJvZHVjZWQgYnkgdW5zcG9vbFxuXHRcdCAqIEBwYXJhbSB4IHsqfFByb21pc2V9IHN0YXJ0aW5nIHZhbHVlLCBtYXkgYmUgYSBwcm9taXNlXG5cdFx0ICogQHJldHVybiB7UHJvbWlzZX0gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCB2YWx1ZSBwcm9kdWNlZCBieSB1bnNwb29sIGJlZm9yZVxuXHRcdCAqICBjb25kaXRpb24gcmV0dXJucyB0cnVlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdW5mb2xkKHVuc3Bvb2wsIGNvbmRpdGlvbiwgaGFuZGxlciwgeCkge1xuXHRcdFx0cmV0dXJuIHJlc29sdmUoeCkudGhlbihmdW5jdGlvbihzZWVkKSB7XG5cdFx0XHRcdHJldHVybiByZXNvbHZlKGNvbmRpdGlvbihzZWVkKSkudGhlbihmdW5jdGlvbihkb25lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRvbmUgPyBzZWVkIDogcmVzb2x2ZSh1bnNwb29sKHNlZWQpKS5zcHJlYWQobmV4dCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZ1bmN0aW9uIG5leHQoaXRlbSwgbmV3U2VlZCkge1xuXHRcdFx0XHRyZXR1cm4gcmVzb2x2ZShoYW5kbGVyKGl0ZW0pKS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB1bmZvbGQodW5zcG9vbCwgY29uZGl0aW9uLCBoYW5kbGVyLCBuZXdTZWVkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKCkge1xuXG5cdHJldHVybiBmdW5jdGlvbiBwcm9ncmVzcyhQcm9taXNlKSB7XG5cblx0XHQvKipcblx0XHQgKiBAZGVwcmVjYXRlZFxuXHRcdCAqIFJlZ2lzdGVyIGEgcHJvZ3Jlc3MgaGFuZGxlciBmb3IgdGhpcyBwcm9taXNlXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gb25Qcm9ncmVzc1xuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24ob25Qcm9ncmVzcykge1xuXHRcdFx0cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHZvaWQgMCwgb25Qcm9ncmVzcyk7XG5cdFx0fTtcblxuXHRcdHJldHVybiBQcm9taXNlO1xuXHR9O1xuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuXHR2YXIgZW52ID0gcmVxdWlyZSgnLi4vZW52Jyk7XG5cdHZhciBUaW1lb3V0RXJyb3IgPSByZXF1aXJlKCcuLi9UaW1lb3V0RXJyb3InKTtcblxuXHRmdW5jdGlvbiBzZXRUaW1lb3V0KGYsIG1zLCB4LCB5KSB7XG5cdFx0cmV0dXJuIGVudi5zZXRUaW1lcihmdW5jdGlvbigpIHtcblx0XHRcdGYoeCwgeSwgbXMpO1xuXHRcdH0sIG1zKTtcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbiB0aW1lZChQcm9taXNlKSB7XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGEgbmV3IHByb21pc2Ugd2hvc2UgZnVsZmlsbG1lbnQgdmFsdWUgaXMgcmV2ZWFsZWQgb25seVxuXHRcdCAqIGFmdGVyIG1zIG1pbGxpc2Vjb25kc1xuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBtcyBtaWxsaXNlY29uZHNcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uKG1zKSB7XG5cdFx0XHR2YXIgcCA9IHRoaXMuX2JlZ2V0KCk7XG5cdFx0XHR0aGlzLl9oYW5kbGVyLmZvbGQoaGFuZGxlRGVsYXksIG1zLCB2b2lkIDAsIHAuX2hhbmRsZXIpO1xuXHRcdFx0cmV0dXJuIHA7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZURlbGF5KG1zLCB4LCBoKSB7XG5cdFx0XHRzZXRUaW1lb3V0KHJlc29sdmVEZWxheSwgbXMsIHgsIGgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc29sdmVEZWxheSh4LCBoKSB7XG5cdFx0XHRoLnJlc29sdmUoeCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGEgbmV3IHByb21pc2UgdGhhdCByZWplY3RzIGFmdGVyIG1zIG1pbGxpc2Vjb25kcyB1bmxlc3Ncblx0XHQgKiB0aGlzIHByb21pc2UgZnVsZmlsbHMgZWFybGllciwgaW4gd2hpY2ggY2FzZSB0aGUgcmV0dXJuZWQgcHJvbWlzZVxuXHRcdCAqIGZ1bGZpbGxzIHdpdGggdGhlIHNhbWUgdmFsdWUuXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IG1zIG1pbGxpc2Vjb25kc1xuXHRcdCAqIEBwYXJhbSB7RXJyb3J8Kj19IHJlYXNvbiBvcHRpb25hbCByZWplY3Rpb24gcmVhc29uIHRvIHVzZSwgZGVmYXVsdHNcblx0XHQgKiAgIHRvIGEgVGltZW91dEVycm9yIGlmIG5vdCBwcm92aWRlZFxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbihtcywgcmVhc29uKSB7XG5cdFx0XHR2YXIgcCA9IHRoaXMuX2JlZ2V0KCk7XG5cdFx0XHR2YXIgaCA9IHAuX2hhbmRsZXI7XG5cblx0XHRcdHZhciB0ID0gc2V0VGltZW91dChvblRpbWVvdXQsIG1zLCByZWFzb24sIHAuX2hhbmRsZXIpO1xuXG5cdFx0XHR0aGlzLl9oYW5kbGVyLnZpc2l0KGgsXG5cdFx0XHRcdGZ1bmN0aW9uIG9uRnVsZmlsbCh4KSB7XG5cdFx0XHRcdFx0ZW52LmNsZWFyVGltZXIodCk7XG5cdFx0XHRcdFx0dGhpcy5yZXNvbHZlKHgpOyAvLyB0aGlzID0gaFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBvblJlamVjdCh4KSB7XG5cdFx0XHRcdFx0ZW52LmNsZWFyVGltZXIodCk7XG5cdFx0XHRcdFx0dGhpcy5yZWplY3QoeCk7IC8vIHRoaXMgPSBoXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGgubm90aWZ5KTtcblxuXHRcdFx0cmV0dXJuIHA7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIG9uVGltZW91dChyZWFzb24sIGgsIG1zKSB7XG5cdFx0XHR2YXIgZSA9IHR5cGVvZiByZWFzb24gPT09ICd1bmRlZmluZWQnXG5cdFx0XHRcdD8gbmV3IFRpbWVvdXRFcnJvcigndGltZWQgb3V0IGFmdGVyICcgKyBtcyArICdtcycpXG5cdFx0XHRcdDogcmVhc29uO1xuXHRcdFx0aC5yZWplY3QoZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cdH07XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuXHR2YXIgc2V0VGltZXIgPSByZXF1aXJlKCcuLi9lbnYnKS5zZXRUaW1lcjtcblx0dmFyIGZvcm1hdCA9IHJlcXVpcmUoJy4uL2Zvcm1hdCcpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1bmhhbmRsZWRSZWplY3Rpb24oUHJvbWlzZSkge1xuXG5cdFx0dmFyIGxvZ0Vycm9yID0gbm9vcDtcblx0XHR2YXIgbG9nSW5mbyA9IG5vb3A7XG5cdFx0dmFyIGxvY2FsQ29uc29sZTtcblxuXHRcdGlmKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0Ly8gQWxpYXMgY29uc29sZSB0byBwcmV2ZW50IHRoaW5ncyBsaWtlIHVnbGlmeSdzIGRyb3BfY29uc29sZSBvcHRpb24gZnJvbVxuXHRcdFx0Ly8gcmVtb3ZpbmcgY29uc29sZS5sb2cvZXJyb3IuIFVuaGFuZGxlZCByZWplY3Rpb25zIGZhbGwgaW50byB0aGUgc2FtZVxuXHRcdFx0Ly8gY2F0ZWdvcnkgYXMgdW5jYXVnaHQgZXhjZXB0aW9ucywgYW5kIGJ1aWxkIHRvb2xzIHNob3VsZG4ndCBzaWxlbmNlIHRoZW0uXG5cdFx0XHRsb2NhbENvbnNvbGUgPSBjb25zb2xlO1xuXHRcdFx0bG9nRXJyb3IgPSB0eXBlb2YgbG9jYWxDb25zb2xlLmVycm9yICE9PSAndW5kZWZpbmVkJ1xuXHRcdFx0XHQ/IGZ1bmN0aW9uIChlKSB7IGxvY2FsQ29uc29sZS5lcnJvcihlKTsgfVxuXHRcdFx0XHQ6IGZ1bmN0aW9uIChlKSB7IGxvY2FsQ29uc29sZS5sb2coZSk7IH07XG5cblx0XHRcdGxvZ0luZm8gPSB0eXBlb2YgbG9jYWxDb25zb2xlLmluZm8gIT09ICd1bmRlZmluZWQnXG5cdFx0XHRcdD8gZnVuY3Rpb24gKGUpIHsgbG9jYWxDb25zb2xlLmluZm8oZSk7IH1cblx0XHRcdFx0OiBmdW5jdGlvbiAoZSkgeyBsb2NhbENvbnNvbGUubG9nKGUpOyB9O1xuXHRcdH1cblxuXHRcdFByb21pc2Uub25Qb3RlbnRpYWxseVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uKHJlamVjdGlvbikge1xuXHRcdFx0ZW5xdWV1ZShyZXBvcnQsIHJlamVjdGlvbik7XG5cdFx0fTtcblxuXHRcdFByb21pc2Uub25Qb3RlbnRpYWxseVVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQgPSBmdW5jdGlvbihyZWplY3Rpb24pIHtcblx0XHRcdGVucXVldWUodW5yZXBvcnQsIHJlamVjdGlvbik7XG5cdFx0fTtcblxuXHRcdFByb21pc2Uub25GYXRhbFJlamVjdGlvbiA9IGZ1bmN0aW9uKHJlamVjdGlvbikge1xuXHRcdFx0ZW5xdWV1ZSh0aHJvd2l0LCByZWplY3Rpb24udmFsdWUpO1xuXHRcdH07XG5cblx0XHR2YXIgdGFza3MgPSBbXTtcblx0XHR2YXIgcmVwb3J0ZWQgPSBbXTtcblx0XHR2YXIgcnVubmluZyA9IG51bGw7XG5cblx0XHRmdW5jdGlvbiByZXBvcnQocikge1xuXHRcdFx0aWYoIXIuaGFuZGxlZCkge1xuXHRcdFx0XHRyZXBvcnRlZC5wdXNoKHIpO1xuXHRcdFx0XHRsb2dFcnJvcignUG90ZW50aWFsbHkgdW5oYW5kbGVkIHJlamVjdGlvbiBbJyArIHIuaWQgKyAnXSAnICsgZm9ybWF0LmZvcm1hdEVycm9yKHIudmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bnJlcG9ydChyKSB7XG5cdFx0XHR2YXIgaSA9IHJlcG9ydGVkLmluZGV4T2Yocik7XG5cdFx0XHRpZihpID49IDApIHtcblx0XHRcdFx0cmVwb3J0ZWQuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRsb2dJbmZvKCdIYW5kbGVkIHByZXZpb3VzIHJlamVjdGlvbiBbJyArIHIuaWQgKyAnXSAnICsgZm9ybWF0LmZvcm1hdE9iamVjdChyLnZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW5xdWV1ZShmLCB4KSB7XG5cdFx0XHR0YXNrcy5wdXNoKGYsIHgpO1xuXHRcdFx0aWYocnVubmluZyA9PT0gbnVsbCkge1xuXHRcdFx0XHRydW5uaW5nID0gc2V0VGltZXIoZmx1c2gsIDApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZsdXNoKCkge1xuXHRcdFx0cnVubmluZyA9IG51bGw7XG5cdFx0XHR3aGlsZSh0YXNrcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHRhc2tzLnNoaWZ0KCkodGFza3Muc2hpZnQoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cdH07XG5cblx0ZnVuY3Rpb24gdGhyb3dpdChlKSB7XG5cdFx0dGhyb3cgZTtcblx0fVxuXG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0pKTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbigpIHtcblxuXHRyZXR1cm4gZnVuY3Rpb24gYWRkV2l0aChQcm9taXNlKSB7XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIHByb21pc2Ugd2hvc2UgaGFuZGxlcnMgd2lsbCBiZSBjYWxsZWQgd2l0aCBgdGhpc2Agc2V0IHRvXG5cdFx0ICogdGhlIHN1cHBsaWVkIHJlY2VpdmVyLiAgU3Vic2VxdWVudCBwcm9taXNlcyBkZXJpdmVkIGZyb20gdGhlXG5cdFx0ICogcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGFsc28gaGF2ZSB0aGVpciBoYW5kbGVycyBjYWxsZWQgd2l0aCByZWNlaXZlclxuXHRcdCAqIGFzIGB0aGlzYC4gQ2FsbGluZyBgd2l0aGAgd2l0aCB1bmRlZmluZWQgb3Igbm8gYXJndW1lbnRzIHdpbGwgcmV0dXJuXG5cdFx0ICogYSBwcm9taXNlIHdob3NlIGhhbmRsZXJzIHdpbGwgYWdhaW4gYmUgY2FsbGVkIGluIHRoZSB1c3VhbCBQcm9taXNlcy9BK1xuXHRcdCAqIHdheSAobm8gYHRoaXNgKSB0aHVzIHNhZmVseSB1bmRvaW5nIGFueSBwcmV2aW91cyBgd2l0aGAgaW4gdGhlXG5cdFx0ICogcHJvbWlzZSBjaGFpbi5cblx0XHQgKlxuXHRcdCAqIFdBUk5JTkc6IFByb21pc2VzIHJldHVybmVkIGZyb20gYHdpdGhgL2B3aXRoVGhpc2AgYXJlIE5PVCBQcm9taXNlcy9BK1xuXHRcdCAqIGNvbXBsaWFudCwgc3BlY2lmaWNhbGx5IHZpb2xhdGluZyAyLjIuNSAoaHR0cDovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00MSlcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSByZWNlaXZlciBgdGhpc2AgdmFsdWUgZm9yIGFsbCBoYW5kbGVycyBhdHRhY2hlZCB0b1xuXHRcdCAqICB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZVsnd2l0aCddID0gUHJvbWlzZS5wcm90b3R5cGUud2l0aFRoaXMgPSBmdW5jdGlvbihyZWNlaXZlcikge1xuXHRcdFx0dmFyIHAgPSB0aGlzLl9iZWdldCgpO1xuXHRcdFx0dmFyIGNoaWxkID0gcC5faGFuZGxlcjtcblx0XHRcdGNoaWxkLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG5cdFx0XHR0aGlzLl9oYW5kbGVyLmNoYWluKGNoaWxkLCByZWNlaXZlcik7XG5cdFx0XHRyZXR1cm4gcDtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cdH07XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG5cbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4vKmdsb2JhbCBwcm9jZXNzLGRvY3VtZW50LHNldFRpbWVvdXQsY2xlYXJUaW1lb3V0LE11dGF0aW9uT2JzZXJ2ZXIsV2ViS2l0TXV0YXRpb25PYnNlcnZlciovXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG5cdC8qanNoaW50IG1heGNvbXBsZXhpdHk6NiovXG5cblx0Ly8gU25pZmYgXCJiZXN0XCIgYXN5bmMgc2NoZWR1bGluZyBvcHRpb25cblx0Ly8gUHJlZmVyIHByb2Nlc3MubmV4dFRpY2sgb3IgTXV0YXRpb25PYnNlcnZlciwgdGhlbiBjaGVjayBmb3Jcblx0Ly8gc2V0VGltZW91dCwgYW5kIGZpbmFsbHkgdmVydHgsIHNpbmNlIGl0cyB0aGUgb25seSBlbnYgdGhhdCBkb2Vzbid0XG5cdC8vIGhhdmUgc2V0VGltZW91dFxuXG5cdHZhciBNdXRhdGlvbk9icztcblx0dmFyIGNhcHR1cmVkU2V0VGltZW91dCA9IHR5cGVvZiBzZXRUaW1lb3V0ICE9PSAndW5kZWZpbmVkJyAmJiBzZXRUaW1lb3V0O1xuXG5cdC8vIERlZmF1bHQgZW52XG5cdHZhciBzZXRUaW1lciA9IGZ1bmN0aW9uKGYsIG1zKSB7IHJldHVybiBzZXRUaW1lb3V0KGYsIG1zKTsgfTtcblx0dmFyIGNsZWFyVGltZXIgPSBmdW5jdGlvbih0KSB7IHJldHVybiBjbGVhclRpbWVvdXQodCk7IH07XG5cdHZhciBhc2FwID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGNhcHR1cmVkU2V0VGltZW91dChmLCAwKTsgfTtcblxuXHQvLyBEZXRlY3Qgc3BlY2lmaWMgZW52XG5cdGlmIChpc05vZGUoKSkgeyAvLyBOb2RlXG5cdFx0YXNhcCA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGYpOyB9O1xuXG5cdH0gZWxzZSBpZiAoTXV0YXRpb25PYnMgPSBoYXNNdXRhdGlvbk9ic2VydmVyKCkpIHsgLy8gTW9kZXJuIGJyb3dzZXJcblx0XHRhc2FwID0gaW5pdE11dGF0aW9uT2JzZXJ2ZXIoTXV0YXRpb25PYnMpO1xuXG5cdH0gZWxzZSBpZiAoIWNhcHR1cmVkU2V0VGltZW91dCkgeyAvLyB2ZXJ0Lnhcblx0XHR2YXIgdmVydHhSZXF1aXJlID0gcmVxdWlyZTtcblx0XHR2YXIgdmVydHggPSB2ZXJ0eFJlcXVpcmUoJ3ZlcnR4Jyk7XG5cdFx0c2V0VGltZXIgPSBmdW5jdGlvbiAoZiwgbXMpIHsgcmV0dXJuIHZlcnR4LnNldFRpbWVyKG1zLCBmKTsgfTtcblx0XHRjbGVhclRpbWVyID0gdmVydHguY2FuY2VsVGltZXI7XG5cdFx0YXNhcCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHNldFRpbWVyOiBzZXRUaW1lcixcblx0XHRjbGVhclRpbWVyOiBjbGVhclRpbWVyLFxuXHRcdGFzYXA6IGFzYXBcblx0fTtcblxuXHRmdW5jdGlvbiBpc05vZGUgKCkge1xuXHRcdHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRcdE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXHR9XG5cblx0ZnVuY3Rpb24gaGFzTXV0YXRpb25PYnNlcnZlciAoKSB7XG5cdFx0cmV0dXJuICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBNdXRhdGlvbk9ic2VydmVyKSB8fFxuXHRcdFx0KHR5cGVvZiBXZWJLaXRNdXRhdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nICYmIFdlYktpdE11dGF0aW9uT2JzZXJ2ZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIoTXV0YXRpb25PYnNlcnZlcikge1xuXHRcdHZhciBzY2hlZHVsZWQ7XG5cdFx0dmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG5cdFx0dmFyIG8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcihydW4pO1xuXHRcdG8ub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cblx0XHRmdW5jdGlvbiBydW4oKSB7XG5cdFx0XHR2YXIgZiA9IHNjaGVkdWxlZDtcblx0XHRcdHNjaGVkdWxlZCA9IHZvaWQgMDtcblx0XHRcdGYoKTtcblx0XHR9XG5cblx0XHR2YXIgaSA9IDA7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChmKSB7XG5cdFx0XHRzY2hlZHVsZWQgPSBmO1xuXHRcdFx0bm9kZS5kYXRhID0gKGkgXj0gMSk7XG5cdFx0fTtcblx0fVxufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG5cblx0cmV0dXJuIHtcblx0XHRmb3JtYXRFcnJvcjogZm9ybWF0RXJyb3IsXG5cdFx0Zm9ybWF0T2JqZWN0OiBmb3JtYXRPYmplY3QsXG5cdFx0dHJ5U3RyaW5naWZ5OiB0cnlTdHJpbmdpZnlcblx0fTtcblxuXHQvKipcblx0ICogRm9ybWF0IGFuIGVycm9yIGludG8gYSBzdHJpbmcuICBJZiBlIGlzIGFuIEVycm9yIGFuZCBoYXMgYSBzdGFjayBwcm9wZXJ0eSxcblx0ICogaXQncyByZXR1cm5lZC4gIE90aGVyd2lzZSwgZSBpcyBmb3JtYXR0ZWQgdXNpbmcgZm9ybWF0T2JqZWN0LCB3aXRoIGFcblx0ICogd2FybmluZyBhZGRlZCBhYm91dCBlIG5vdCBiZWluZyBhIHByb3BlciBFcnJvci5cblx0ICogQHBhcmFtIHsqfSBlXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IGZvcm1hdHRlZCBzdHJpbmcsIHN1aXRhYmxlIGZvciBvdXRwdXQgdG8gZGV2ZWxvcGVyc1xuXHQgKi9cblx0ZnVuY3Rpb24gZm9ybWF0RXJyb3IoZSkge1xuXHRcdHZhciBzID0gdHlwZW9mIGUgPT09ICdvYmplY3QnICYmIGUgIT09IG51bGwgJiYgKGUuc3RhY2sgfHwgZS5tZXNzYWdlKSA/IGUuc3RhY2sgfHwgZS5tZXNzYWdlIDogZm9ybWF0T2JqZWN0KGUpO1xuXHRcdHJldHVybiBlIGluc3RhbmNlb2YgRXJyb3IgPyBzIDogcyArICcgKFdBUk5JTkc6IG5vbi1FcnJvciB1c2VkKSc7XG5cdH1cblxuXHQvKipcblx0ICogRm9ybWF0IGFuIG9iamVjdCwgZGV0ZWN0aW5nIFwicGxhaW5cIiBvYmplY3RzIGFuZCBydW5uaW5nIHRoZW0gdGhyb3VnaFxuXHQgKiBKU09OLnN0cmluZ2lmeSBpZiBwb3NzaWJsZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIGZvcm1hdE9iamVjdChvKSB7XG5cdFx0dmFyIHMgPSBTdHJpbmcobyk7XG5cdFx0aWYocyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgdHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRzID0gdHJ5U3RyaW5naWZ5KG8sIHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gcztcblx0fVxuXG5cdC8qKlxuXHQgKiBUcnkgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgSlNPTi5zdHJpbmdpZnkoeCkuICBJZiB0aGF0IGZhaWxzLCByZXR1cm5cblx0ICogZGVmYXVsdFZhbHVlXG5cdCAqIEBwYXJhbSB7Kn0geFxuXHQgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZVxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfCp9IEpTT04uc3RyaW5naWZ5KHgpIG9yIGRlZmF1bHRWYWx1ZVxuXHQgKi9cblx0ZnVuY3Rpb24gdHJ5U3RyaW5naWZ5KHgsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoeCk7XG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRyZXR1cm4gZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fVxuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKCkge1xuXG5cdHJldHVybiBmdW5jdGlvbiBtYWtlUHJvbWlzZShlbnZpcm9ubWVudCkge1xuXG5cdFx0dmFyIHRhc2tzID0gZW52aXJvbm1lbnQuc2NoZWR1bGVyO1xuXHRcdHZhciBlbWl0UmVqZWN0aW9uID0gaW5pdEVtaXRSZWplY3Rpb24oKTtcblxuXHRcdHZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8XG5cdFx0XHRmdW5jdGlvbihwcm90bykge1xuXHRcdFx0XHRmdW5jdGlvbiBDaGlsZCgpIHt9XG5cdFx0XHRcdENoaWxkLnByb3RvdHlwZSA9IHByb3RvO1xuXHRcdFx0XHRyZXR1cm4gbmV3IENoaWxkKCk7XG5cdFx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgcHJvbWlzZSB3aG9zZSBmYXRlIGlzIGRldGVybWluZWQgYnkgcmVzb2x2ZXJcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZVxuXHRcdCAqIEBuYW1lIFByb21pc2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyLCBoYW5kbGVyKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVyID0gcmVzb2x2ZXIgPT09IEhhbmRsZXIgPyBoYW5kbGVyIDogaW5pdChyZXNvbHZlcik7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUnVuIHRoZSBzdXBwbGllZCByZXNvbHZlclxuXHRcdCAqIEBwYXJhbSByZXNvbHZlclxuXHRcdCAqIEByZXR1cm5zIHtQZW5kaW5nfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGluaXQocmVzb2x2ZXIpIHtcblx0XHRcdHZhciBoYW5kbGVyID0gbmV3IFBlbmRpbmcoKTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzb2x2ZXIocHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3QsIHByb21pc2VOb3RpZnkpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRwcm9taXNlUmVqZWN0KGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaGFuZGxlcjtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUcmFuc2l0aW9uIGZyb20gcHJlLXJlc29sdXRpb24gc3RhdGUgdG8gcG9zdC1yZXNvbHV0aW9uIHN0YXRlLCBub3RpZnlpbmdcblx0XHRcdCAqIGFsbCBsaXN0ZW5lcnMgb2YgdGhlIHVsdGltYXRlIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvblxuXHRcdFx0ICogQHBhcmFtIHsqfSB4IHJlc29sdXRpb24gdmFsdWVcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcHJvbWlzZVJlc29sdmUgKHgpIHtcblx0XHRcdFx0aGFuZGxlci5yZXNvbHZlKHgpO1xuXHRcdFx0fVxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZWplY3QgdGhpcyBwcm9taXNlIHdpdGggcmVhc29uLCB3aGljaCB3aWxsIGJlIHVzZWQgdmVyYmF0aW1cblx0XHRcdCAqIEBwYXJhbSB7RXJyb3J8Kn0gcmVhc29uIHJlamVjdGlvbiByZWFzb24sIHN0cm9uZ2x5IHN1Z2dlc3RlZFxuXHRcdFx0ICogICB0byBiZSBhbiBFcnJvciB0eXBlXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHByb21pc2VSZWplY3QgKHJlYXNvbikge1xuXHRcdFx0XHRoYW5kbGVyLnJlamVjdChyZWFzb24pO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBkZXByZWNhdGVkXG5cdFx0XHQgKiBJc3N1ZSBhIHByb2dyZXNzIGV2ZW50LCBub3RpZnlpbmcgYWxsIHByb2dyZXNzIGxpc3RlbmVyc1xuXHRcdFx0ICogQHBhcmFtIHsqfSB4IHByb2dyZXNzIGV2ZW50IHBheWxvYWQgdG8gcGFzcyB0byBhbGwgbGlzdGVuZXJzXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHByb21pc2VOb3RpZnkgKHgpIHtcblx0XHRcdFx0aGFuZGxlci5ub3RpZnkoeCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRpb25cblxuXHRcdFByb21pc2UucmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0UHJvbWlzZS5yZWplY3QgPSByZWplY3Q7XG5cdFx0UHJvbWlzZS5uZXZlciA9IG5ldmVyO1xuXG5cdFx0UHJvbWlzZS5fZGVmZXIgPSBkZWZlcjtcblx0XHRQcm9taXNlLl9oYW5kbGVyID0gZ2V0SGFuZGxlcjtcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYSB0cnVzdGVkIHByb21pc2UuIElmIHggaXMgYWxyZWFkeSBhIHRydXN0ZWQgcHJvbWlzZSwgaXQgaXNcblx0XHQgKiByZXR1cm5lZCwgb3RoZXJ3aXNlIHJldHVybnMgYSBuZXcgdHJ1c3RlZCBQcm9taXNlIHdoaWNoIGZvbGxvd3MgeC5cblx0XHQgKiBAcGFyYW0gIHsqfSB4XG5cdFx0ICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuXHRcdFx0cmV0dXJuIGlzUHJvbWlzZSh4KSA/IHhcblx0XHRcdFx0OiBuZXcgUHJvbWlzZShIYW5kbGVyLCBuZXcgQXN5bmMoZ2V0SGFuZGxlcih4KSkpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBhIHJlamVjdCBwcm9taXNlIHdpdGggeCBhcyBpdHMgcmVhc29uICh4IGlzIHVzZWQgdmVyYmF0aW0pXG5cdFx0ICogQHBhcmFtIHsqfSB4XG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IHJlamVjdGVkIHByb21pc2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiByZWplY3QoeCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKEhhbmRsZXIsIG5ldyBBc3luYyhuZXcgUmVqZWN0ZWQoeCkpKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVtYWlucyBwZW5kaW5nIGZvcmV2ZXJcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gZm9yZXZlci1wZW5kaW5nIHByb21pc2UuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbmV2ZXIoKSB7XG5cdFx0XHRyZXR1cm4gZm9yZXZlclBlbmRpbmdQcm9taXNlOyAvLyBTaG91bGQgYmUgZnJvemVuXG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhbiBpbnRlcm5hbCB7cHJvbWlzZSwgcmVzb2x2ZXJ9IHBhaXJcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGRlZmVyKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKEhhbmRsZXIsIG5ldyBQZW5kaW5nKCkpO1xuXHRcdH1cblxuXHRcdC8vIFRyYW5zZm9ybWF0aW9uIGFuZCBmbG93IGNvbnRyb2xcblxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zZm9ybSB0aGlzIHByb21pc2UncyBmdWxmaWxsbWVudCB2YWx1ZSwgcmV0dXJuaW5nIGEgbmV3IFByb21pc2Vcblx0XHQgKiBmb3IgdGhlIHRyYW5zZm9ybWVkIHJlc3VsdC4gIElmIHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQsIG9uUmVqZWN0ZWRcblx0XHQgKiBpcyBjYWxsZWQgd2l0aCB0aGUgcmVhc29uLiAgb25Qcm9ncmVzcyAqbWF5KiBiZSBjYWxsZWQgd2l0aCB1cGRhdGVzIHRvd2FyZFxuXHRcdCAqIHRoaXMgcHJvbWlzZSdzIGZ1bGZpbGxtZW50LlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb249fSBvbkZ1bGZpbGxlZCBmdWxmaWxsbWVudCBoYW5kbGVyXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbj19IG9uUmVqZWN0ZWQgcmVqZWN0aW9uIGhhbmRsZXJcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb25Qcm9ncmVzcyBAZGVwcmVjYXRlZCBwcm9ncmVzcyBoYW5kbGVyXG5cdFx0ICogQHJldHVybiB7UHJvbWlzZX0gbmV3IHByb21pc2Vcblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLl9oYW5kbGVyO1xuXHRcdFx0dmFyIHN0YXRlID0gcGFyZW50LmpvaW4oKS5zdGF0ZSgpO1xuXG5cdFx0XHRpZiAoKHR5cGVvZiBvbkZ1bGZpbGxlZCAhPT0gJ2Z1bmN0aW9uJyAmJiBzdGF0ZSA+IDApIHx8XG5cdFx0XHRcdCh0eXBlb2Ygb25SZWplY3RlZCAhPT0gJ2Z1bmN0aW9uJyAmJiBzdGF0ZSA8IDApKSB7XG5cdFx0XHRcdC8vIFNob3J0IGNpcmN1aXQ6IHZhbHVlIHdpbGwgbm90IGNoYW5nZSwgc2ltcGx5IHNoYXJlIGhhbmRsZXJcblx0XHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKEhhbmRsZXIsIHBhcmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwID0gdGhpcy5fYmVnZXQoKTtcblx0XHRcdHZhciBjaGlsZCA9IHAuX2hhbmRsZXI7XG5cblx0XHRcdHBhcmVudC5jaGFpbihjaGlsZCwgcGFyZW50LnJlY2VpdmVyLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyk7XG5cblx0XHRcdHJldHVybiBwO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBJZiB0aGlzIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZCBkdWUgdG8gYW4gZXJyb3IsIGNhbGwgb25SZWplY3RlZCB0b1xuXHRcdCAqIGhhbmRsZSB0aGUgZXJyb3IuIFNob3J0Y3V0IGZvciAudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbj99IG9uUmVqZWN0ZWRcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24ob25SZWplY3RlZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIG9uUmVqZWN0ZWQpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGEgbmV3LCBwZW5kaW5nIHByb21pc2Ugb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGlzIHByb21pc2Vcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlLl9iZWdldCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGJlZ2V0RnJvbSh0aGlzLl9oYW5kbGVyLCB0aGlzLmNvbnN0cnVjdG9yKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gYmVnZXRGcm9tKHBhcmVudCwgUHJvbWlzZSkge1xuXHRcdFx0dmFyIGNoaWxkID0gbmV3IFBlbmRpbmcocGFyZW50LnJlY2VpdmVyLCBwYXJlbnQuam9pbigpLmNvbnRleHQpO1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKEhhbmRsZXIsIGNoaWxkKTtcblx0XHR9XG5cblx0XHQvLyBBcnJheSBjb21iaW5hdG9yc1xuXG5cdFx0UHJvbWlzZS5hbGwgPSBhbGw7XG5cdFx0UHJvbWlzZS5yYWNlID0gcmFjZTtcblx0XHRQcm9taXNlLl90cmF2ZXJzZSA9IHRyYXZlcnNlO1xuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCB3aGVuIGFsbCBwcm9taXNlcyBpbiB0aGVcblx0XHQgKiBpbnB1dCBhcnJheSBoYXZlIGZ1bGZpbGxlZCwgb3Igd2lsbCByZWplY3Qgd2hlbiBvbmUgb2YgdGhlXG5cdFx0ICogcHJvbWlzZXMgcmVqZWN0cy5cblx0XHQgKiBAcGFyYW0ge2FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlc1xuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIGZvciBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXNcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcblx0XHRcdHJldHVybiB0cmF2ZXJzZVdpdGgoc25kLCBudWxsLCBwcm9taXNlcyk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQXJyYXk8UHJvbWlzZTxYPj4gLT4gUHJvbWlzZTxBcnJheTxmKFgpPj5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGYgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBwcm9taXNlJ3MgdmFsdWVcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlc1xuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIGZvciB0cmFuc2Zvcm1lZCB2YWx1ZXNcblx0XHQgKi9cblx0XHRmdW5jdGlvbiB0cmF2ZXJzZShmLCBwcm9taXNlcykge1xuXHRcdFx0cmV0dXJuIHRyYXZlcnNlV2l0aCh0cnlDYXRjaDIsIGYsIHByb21pc2VzKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmF2ZXJzZVdpdGgodHJ5TWFwLCBmLCBwcm9taXNlcykge1xuXHRcdFx0dmFyIGhhbmRsZXIgPSB0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJyA/IG1hcEF0IDogc2V0dGxlQXQ7XG5cblx0XHRcdHZhciByZXNvbHZlciA9IG5ldyBQZW5kaW5nKCk7XG5cdFx0XHR2YXIgcGVuZGluZyA9IHByb21pc2VzLmxlbmd0aCA+Pj4gMDtcblx0XHRcdHZhciByZXN1bHRzID0gbmV3IEFycmF5KHBlbmRpbmcpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgeDsgaSA8IHByb21pc2VzLmxlbmd0aCAmJiAhcmVzb2x2ZXIucmVzb2x2ZWQ7ICsraSkge1xuXHRcdFx0XHR4ID0gcHJvbWlzZXNbaV07XG5cblx0XHRcdFx0aWYgKHggPT09IHZvaWQgMCAmJiAhKGkgaW4gcHJvbWlzZXMpKSB7XG5cdFx0XHRcdFx0LS1wZW5kaW5nO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJhdmVyc2VBdChwcm9taXNlcywgaGFuZGxlciwgaSwgeCwgcmVzb2x2ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihwZW5kaW5nID09PSAwKSB7XG5cdFx0XHRcdHJlc29sdmVyLmJlY29tZShuZXcgRnVsZmlsbGVkKHJlc3VsdHMpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKEhhbmRsZXIsIHJlc29sdmVyKTtcblxuXHRcdFx0ZnVuY3Rpb24gbWFwQXQoaSwgeCwgcmVzb2x2ZXIpIHtcblx0XHRcdFx0aWYoIXJlc29sdmVyLnJlc29sdmVkKSB7XG5cdFx0XHRcdFx0dHJhdmVyc2VBdChwcm9taXNlcywgc2V0dGxlQXQsIGksIHRyeU1hcChmLCB4LCBpKSwgcmVzb2x2ZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHNldHRsZUF0KGksIHgsIHJlc29sdmVyKSB7XG5cdFx0XHRcdHJlc3VsdHNbaV0gPSB4O1xuXHRcdFx0XHRpZigtLXBlbmRpbmcgPT09IDApIHtcblx0XHRcdFx0XHRyZXNvbHZlci5iZWNvbWUobmV3IEZ1bGZpbGxlZChyZXN1bHRzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmF2ZXJzZUF0KHByb21pc2VzLCBoYW5kbGVyLCBpLCB4LCByZXNvbHZlcikge1xuXHRcdFx0aWYgKG1heWJlVGhlbmFibGUoeCkpIHtcblx0XHRcdFx0dmFyIGggPSBnZXRIYW5kbGVyTWF5YmVUaGVuYWJsZSh4KTtcblx0XHRcdFx0dmFyIHMgPSBoLnN0YXRlKCk7XG5cblx0XHRcdFx0aWYgKHMgPT09IDApIHtcblx0XHRcdFx0XHRoLmZvbGQoaGFuZGxlciwgaSwgdm9pZCAwLCByZXNvbHZlcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAocyA+IDApIHtcblx0XHRcdFx0XHRoYW5kbGVyKGksIGgudmFsdWUsIHJlc29sdmVyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlci5iZWNvbWUoaCk7XG5cdFx0XHRcdFx0dmlzaXRSZW1haW5pbmcocHJvbWlzZXMsIGkrMSwgaCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXIoaSwgeCwgcmVzb2x2ZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdFByb21pc2UuX3Zpc2l0UmVtYWluaW5nID0gdmlzaXRSZW1haW5pbmc7XG5cdFx0ZnVuY3Rpb24gdmlzaXRSZW1haW5pbmcocHJvbWlzZXMsIHN0YXJ0LCBoYW5kbGVyKSB7XG5cdFx0XHRmb3IodmFyIGk9c3RhcnQ7IGk8cHJvbWlzZXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0bWFya0FzSGFuZGxlZChnZXRIYW5kbGVyKHByb21pc2VzW2ldKSwgaGFuZGxlcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWFya0FzSGFuZGxlZChoLCBoYW5kbGVyKSB7XG5cdFx0XHRpZihoID09PSBoYW5kbGVyKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHMgPSBoLnN0YXRlKCk7XG5cdFx0XHRpZihzID09PSAwKSB7XG5cdFx0XHRcdGgudmlzaXQoaCwgdm9pZCAwLCBoLl91bnJlcG9ydCk7XG5cdFx0XHR9IGVsc2UgaWYocyA8IDApIHtcblx0XHRcdFx0aC5fdW5yZXBvcnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBGdWxmaWxsLXJlamVjdCBjb21wZXRpdGl2ZSByYWNlLiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBzZXR0bGVcblx0XHQgKiB0byB0aGUgc2FtZSBzdGF0ZSBhcyB0aGUgZWFybGllc3QgaW5wdXQgcHJvbWlzZSB0byBzZXR0bGUuXG5cdFx0ICpcblx0XHQgKiBXQVJOSU5HOiBUaGUgRVM2IFByb21pc2Ugc3BlYyByZXF1aXJlcyB0aGF0IHJhY2UoKWluZyBhbiBlbXB0eSBhcnJheVxuXHRcdCAqIG11c3QgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlci4gIFRoaXMgaW1wbGVtZW50YXRpb25cblx0XHQgKiByZXR1cm5zIGEgc2luZ2xldG9uIGZvcmV2ZXItcGVuZGluZyBwcm9taXNlLCB0aGUgc2FtZSBzaW5nbGV0b24gdGhhdCBpc1xuXHRcdCAqIHJldHVybmVkIGJ5IFByb21pc2UubmV2ZXIoKSwgdGh1cyBjYW4gYmUgY2hlY2tlZCB3aXRoID09PVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHthcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgdG8gcmFjZVxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBpZiBpbnB1dCBpcyBub24tZW1wdHksIGEgcHJvbWlzZSB0aGF0IHdpbGwgc2V0dGxlXG5cdFx0ICogdG8gdGhlIHNhbWUgb3V0Y29tZSBhcyB0aGUgZWFybGllc3QgaW5wdXQgcHJvbWlzZSB0byBzZXR0bGUuIGlmIGVtcHR5XG5cdFx0ICogaXMgZW1wdHksIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBuZXZlciBzZXR0bGUuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmFjZShwcm9taXNlcykge1xuXHRcdFx0aWYodHlwZW9mIHByb21pc2VzICE9PSAnb2JqZWN0JyB8fCBwcm9taXNlcyA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ25vbi1pdGVyYWJsZSBwYXNzZWQgdG8gcmFjZSgpJykpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaWdoLCByYWNlKFtdKSBpcyB1bnRlc3RhYmxlIHVubGVzcyB3ZSByZXR1cm4gKnNvbWV0aGluZypcblx0XHRcdC8vIHRoYXQgaXMgcmVjb2duaXphYmxlIHdpdGhvdXQgY2FsbGluZyAudGhlbigpIG9uIGl0LlxuXHRcdFx0cmV0dXJuIHByb21pc2VzLmxlbmd0aCA9PT0gMCA/IG5ldmVyKClcblx0XHRcdFx0IDogcHJvbWlzZXMubGVuZ3RoID09PSAxID8gcmVzb2x2ZShwcm9taXNlc1swXSlcblx0XHRcdFx0IDogcnVuUmFjZShwcm9taXNlcyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcnVuUmFjZShwcm9taXNlcykge1xuXHRcdFx0dmFyIHJlc29sdmVyID0gbmV3IFBlbmRpbmcoKTtcblx0XHRcdHZhciBpLCB4LCBoO1xuXHRcdFx0Zm9yKGk9MDsgaTxwcm9taXNlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR4ID0gcHJvbWlzZXNbaV07XG5cdFx0XHRcdGlmICh4ID09PSB2b2lkIDAgJiYgIShpIGluIHByb21pc2VzKSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aCA9IGdldEhhbmRsZXIoeCk7XG5cdFx0XHRcdGlmKGguc3RhdGUoKSAhPT0gMCkge1xuXHRcdFx0XHRcdHJlc29sdmVyLmJlY29tZShoKTtcblx0XHRcdFx0XHR2aXNpdFJlbWFpbmluZyhwcm9taXNlcywgaSsxLCBoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoLnZpc2l0KHJlc29sdmVyLCByZXNvbHZlci5yZXNvbHZlLCByZXNvbHZlci5yZWplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoSGFuZGxlciwgcmVzb2x2ZXIpO1xuXHRcdH1cblxuXHRcdC8vIFByb21pc2UgaW50ZXJuYWxzXG5cdFx0Ly8gQmVsb3cgdGhpcywgZXZlcnl0aGluZyBpcyBAcHJpdmF0ZVxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IGFuIGFwcHJvcHJpYXRlIGhhbmRsZXIgZm9yIHgsIHdpdGhvdXQgY2hlY2tpbmcgZm9yIGN5Y2xlc1xuXHRcdCAqIEBwYXJhbSB7Kn0geFxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9IGhhbmRsZXJcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBnZXRIYW5kbGVyKHgpIHtcblx0XHRcdGlmKGlzUHJvbWlzZSh4KSkge1xuXHRcdFx0XHRyZXR1cm4geC5faGFuZGxlci5qb2luKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF5YmVUaGVuYWJsZSh4KSA/IGdldEhhbmRsZXJVbnRydXN0ZWQoeCkgOiBuZXcgRnVsZmlsbGVkKHgpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEdldCBhIGhhbmRsZXIgZm9yIHRoZW5hYmxlIHguXG5cdFx0ICogTk9URTogWW91IG11c3Qgb25seSBjYWxsIHRoaXMgaWYgbWF5YmVUaGVuYWJsZSh4KSA9PSB0cnVlXG5cdFx0ICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258UHJvbWlzZX0geFxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9IGhhbmRsZXJcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBnZXRIYW5kbGVyTWF5YmVUaGVuYWJsZSh4KSB7XG5cdFx0XHRyZXR1cm4gaXNQcm9taXNlKHgpID8geC5faGFuZGxlci5qb2luKCkgOiBnZXRIYW5kbGVyVW50cnVzdGVkKHgpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEdldCBhIGhhbmRsZXIgZm9yIHBvdGVudGlhbGx5IHVudHJ1c3RlZCB0aGVuYWJsZSB4XG5cdFx0ICogQHBhcmFtIHsqfSB4XG5cdFx0ICogQHJldHVybnMge29iamVjdH0gaGFuZGxlclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGdldEhhbmRsZXJVbnRydXN0ZWQoeCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHVudHJ1c3RlZFRoZW4gPSB4LnRoZW47XG5cdFx0XHRcdHJldHVybiB0eXBlb2YgdW50cnVzdGVkVGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdD8gbmV3IFRoZW5hYmxlKHVudHJ1c3RlZFRoZW4sIHgpXG5cdFx0XHRcdFx0OiBuZXcgRnVsZmlsbGVkKHgpO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgUmVqZWN0ZWQoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3IgYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gSGFuZGxlcigpIHt9XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS53aGVuXG5cdFx0XHQ9IEhhbmRsZXIucHJvdG90eXBlLmJlY29tZVxuXHRcdFx0PSBIYW5kbGVyLnByb3RvdHlwZS5ub3RpZnkgLy8gZGVwcmVjYXRlZFxuXHRcdFx0PSBIYW5kbGVyLnByb3RvdHlwZS5mYWlsXG5cdFx0XHQ9IEhhbmRsZXIucHJvdG90eXBlLl91bnJlcG9ydFxuXHRcdFx0PSBIYW5kbGVyLnByb3RvdHlwZS5fcmVwb3J0XG5cdFx0XHQ9IG5vb3A7XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS5fc3RhdGUgPSAwO1xuXG5cdFx0SGFuZGxlci5wcm90b3R5cGUuc3RhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9zdGF0ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVjdXJzaXZlbHkgY29sbGFwc2UgaGFuZGxlciBjaGFpbiB0byBmaW5kIHRoZSBoYW5kbGVyXG5cdFx0ICogbmVhcmVzdCB0byB0aGUgZnVsbHkgcmVzb2x2ZWQgdmFsdWUuXG5cdFx0ICogQHJldHVybnMge29iamVjdH0gaGFuZGxlciBuZWFyZXN0IHRoZSBmdWxseSByZXNvbHZlZCB2YWx1ZVxuXHRcdCAqL1xuXHRcdEhhbmRsZXIucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoID0gdGhpcztcblx0XHRcdHdoaWxlKGguaGFuZGxlciAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdGggPSBoLmhhbmRsZXI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaDtcblx0XHR9O1xuXG5cdFx0SGFuZGxlci5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbih0bywgcmVjZWl2ZXIsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG5cdFx0XHR0aGlzLndoZW4oe1xuXHRcdFx0XHRyZXNvbHZlcjogdG8sXG5cdFx0XHRcdHJlY2VpdmVyOiByZWNlaXZlcixcblx0XHRcdFx0ZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG5cdFx0XHRcdHJlamVjdGVkOiByZWplY3RlZCxcblx0XHRcdFx0cHJvZ3Jlc3M6IHByb2dyZXNzXG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0SGFuZGxlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbihyZWNlaXZlciwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcblx0XHRcdHRoaXMuY2hhaW4oZmFpbElmUmVqZWN0ZWQsIHJlY2VpdmVyLCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcyk7XG5cdFx0fTtcblxuXHRcdEhhbmRsZXIucHJvdG90eXBlLmZvbGQgPSBmdW5jdGlvbihmLCB6LCBjLCB0bykge1xuXHRcdFx0dGhpcy53aGVuKG5ldyBGb2xkKGYsIHosIGMsIHRvKSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgdGhhdCBpbnZva2VzIGZhaWwoKSBvbiBhbnkgaGFuZGxlciBpdCBiZWNvbWVzXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gRmFpbElmUmVqZWN0ZWQoKSB7fVxuXG5cdFx0aW5oZXJpdChIYW5kbGVyLCBGYWlsSWZSZWplY3RlZCk7XG5cblx0XHRGYWlsSWZSZWplY3RlZC5wcm90b3R5cGUuYmVjb21lID0gZnVuY3Rpb24oaCkge1xuXHRcdFx0aC5mYWlsKCk7XG5cdFx0fTtcblxuXHRcdHZhciBmYWlsSWZSZWplY3RlZCA9IG5ldyBGYWlsSWZSZWplY3RlZCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciB0aGF0IG1hbmFnZXMgYSBxdWV1ZSBvZiBjb25zdW1lcnMgd2FpdGluZyBvbiBhIHBlbmRpbmcgcHJvbWlzZVxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIFBlbmRpbmcocmVjZWl2ZXIsIGluaGVyaXRlZENvbnRleHQpIHtcblx0XHRcdFByb21pc2UuY3JlYXRlQ29udGV4dCh0aGlzLCBpbmhlcml0ZWRDb250ZXh0KTtcblxuXHRcdFx0dGhpcy5jb25zdW1lcnMgPSB2b2lkIDA7XG5cdFx0XHR0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSB2b2lkIDA7XG5cdFx0XHR0aGlzLnJlc29sdmVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aW5oZXJpdChIYW5kbGVyLCBQZW5kaW5nKTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLl9zdGF0ZSA9IDA7XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0dGhpcy5iZWNvbWUoZ2V0SGFuZGxlcih4KSk7XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdGlmKHRoaXMucmVzb2x2ZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJlY29tZShuZXcgUmVqZWN0ZWQoeCkpO1xuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBoID0gdGhpcztcblxuXHRcdFx0d2hpbGUgKGguaGFuZGxlciAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdGggPSBoLmhhbmRsZXI7XG5cdFx0XHRcdGlmIChoID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuaGFuZGxlciA9IGN5Y2xlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGg7XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHEgPSB0aGlzLmNvbnN1bWVycztcblx0XHRcdHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyO1xuXHRcdFx0dGhpcy5oYW5kbGVyID0gdGhpcy5oYW5kbGVyLmpvaW4oKTtcblx0XHRcdHRoaXMuY29uc3VtZXJzID0gdm9pZCAwO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0aGFuZGxlci53aGVuKHFbaV0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5iZWNvbWUgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdFx0XHRpZih0aGlzLnJlc29sdmVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5yZXNvbHZlZCA9IHRydWU7XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXHRcdFx0aWYodGhpcy5jb25zdW1lcnMgIT09IHZvaWQgMCkge1xuXHRcdFx0XHR0YXNrcy5lbnF1ZXVlKHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLmNvbnRleHQgIT09IHZvaWQgMCkge1xuXHRcdFx0XHRoYW5kbGVyLl9yZXBvcnQodGhpcy5jb250ZXh0KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uKGNvbnRpbnVhdGlvbikge1xuXHRcdFx0aWYodGhpcy5yZXNvbHZlZCkge1xuXHRcdFx0XHR0YXNrcy5lbnF1ZXVlKG5ldyBDb250aW51YXRpb25UYXNrKGNvbnRpbnVhdGlvbiwgdGhpcy5oYW5kbGVyKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0aGlzLmNvbnN1bWVycyA9PT0gdm9pZCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5jb25zdW1lcnMgPSBbY29udGludWF0aW9uXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmNvbnN1bWVycy5wdXNoKGNvbnRpbnVhdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQGRlcHJlY2F0ZWRcblx0XHQgKi9cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRpZighdGhpcy5yZXNvbHZlZCkge1xuXHRcdFx0XHR0YXNrcy5lbnF1ZXVlKG5ldyBQcm9ncmVzc1Rhc2soeCwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0dmFyIGMgPSB0eXBlb2YgY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmNvbnRleHQgOiBjb250ZXh0O1xuXHRcdFx0dGhpcy5yZXNvbHZlZCAmJiB0aGlzLmhhbmRsZXIuam9pbigpLmZhaWwoYyk7XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLl9yZXBvcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkICYmIHRoaXMuaGFuZGxlci5qb2luKCkuX3JlcG9ydChjb250ZXh0KTtcblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUuX3VucmVwb3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkICYmIHRoaXMuaGFuZGxlci5qb2luKCkuX3VucmVwb3J0KCk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFdyYXAgYW5vdGhlciBoYW5kbGVyIGFuZCBmb3JjZSBpdCBpbnRvIGEgZnV0dXJlIHN0YWNrXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZXJcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBBc3luYyhoYW5kbGVyKSB7XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXHRcdH1cblxuXHRcdGluaGVyaXQoSGFuZGxlciwgQXN5bmMpO1xuXG5cdFx0QXN5bmMucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbihjb250aW51YXRpb24pIHtcblx0XHRcdHRhc2tzLmVucXVldWUobmV3IENvbnRpbnVhdGlvblRhc2soY29udGludWF0aW9uLCB0aGlzKSk7XG5cdFx0fTtcblxuXHRcdEFzeW5jLnByb3RvdHlwZS5fcmVwb3J0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0dGhpcy5qb2luKCkuX3JlcG9ydChjb250ZXh0KTtcblx0XHR9O1xuXG5cdFx0QXN5bmMucHJvdG90eXBlLl91bnJlcG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5qb2luKCkuX3VucmVwb3J0KCk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgdGhhdCB3cmFwcyBhbiB1bnRydXN0ZWQgdGhlbmFibGUgYW5kIGFzc2ltaWxhdGVzIGl0IGluIGEgZnV0dXJlIHN0YWNrXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlblxuXHRcdCAqIEBwYXJhbSB7e3RoZW46IGZ1bmN0aW9ufX0gdGhlbmFibGVcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBUaGVuYWJsZSh0aGVuLCB0aGVuYWJsZSkge1xuXHRcdFx0UGVuZGluZy5jYWxsKHRoaXMpO1xuXHRcdFx0dGFza3MuZW5xdWV1ZShuZXcgQXNzaW1pbGF0ZVRhc2sodGhlbiwgdGhlbmFibGUsIHRoaXMpKTtcblx0XHR9XG5cblx0XHRpbmhlcml0KFBlbmRpbmcsIFRoZW5hYmxlKTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIGEgZnVsZmlsbGVkIHByb21pc2Vcblx0XHQgKiBAcGFyYW0geyp9IHggZnVsZmlsbG1lbnQgdmFsdWVcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBGdWxmaWxsZWQoeCkge1xuXHRcdFx0UHJvbWlzZS5jcmVhdGVDb250ZXh0KHRoaXMpO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHg7XG5cdFx0fVxuXG5cdFx0aW5oZXJpdChIYW5kbGVyLCBGdWxmaWxsZWQpO1xuXG5cdFx0RnVsZmlsbGVkLnByb3RvdHlwZS5fc3RhdGUgPSAxO1xuXG5cdFx0RnVsZmlsbGVkLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24oZiwgeiwgYywgdG8pIHtcblx0XHRcdHJ1bkNvbnRpbnVhdGlvbjMoZiwgeiwgdGhpcywgYywgdG8pO1xuXHRcdH07XG5cblx0XHRGdWxmaWxsZWQucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbihjb250KSB7XG5cdFx0XHRydW5Db250aW51YXRpb24xKGNvbnQuZnVsZmlsbGVkLCB0aGlzLCBjb250LnJlY2VpdmVyLCBjb250LnJlc29sdmVyKTtcblx0XHR9O1xuXG5cdFx0dmFyIGVycm9ySWQgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3IgYSByZWplY3RlZCBwcm9taXNlXG5cdFx0ICogQHBhcmFtIHsqfSB4IHJlamVjdGlvbiByZWFzb25cblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBSZWplY3RlZCh4KSB7XG5cdFx0XHRQcm9taXNlLmNyZWF0ZUNvbnRleHQodGhpcyk7XG5cblx0XHRcdHRoaXMuaWQgPSArK2Vycm9ySWQ7XG5cdFx0XHR0aGlzLnZhbHVlID0geDtcblx0XHRcdHRoaXMuaGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5yZXBvcnRlZCA9IGZhbHNlO1xuXG5cdFx0XHR0aGlzLl9yZXBvcnQoKTtcblx0XHR9XG5cblx0XHRpbmhlcml0KEhhbmRsZXIsIFJlamVjdGVkKTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5fc3RhdGUgPSAtMTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24oZiwgeiwgYywgdG8pIHtcblx0XHRcdHRvLmJlY29tZSh0aGlzKTtcblx0XHR9O1xuXG5cdFx0UmVqZWN0ZWQucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbihjb250KSB7XG5cdFx0XHRpZih0eXBlb2YgY29udC5yZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aGlzLl91bnJlcG9ydCgpO1xuXHRcdFx0fVxuXHRcdFx0cnVuQ29udGludWF0aW9uMShjb250LnJlamVjdGVkLCB0aGlzLCBjb250LnJlY2VpdmVyLCBjb250LnJlc29sdmVyKTtcblx0XHR9O1xuXG5cdFx0UmVqZWN0ZWQucHJvdG90eXBlLl9yZXBvcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0XHR0YXNrcy5hZnRlclF1ZXVlKG5ldyBSZXBvcnRUYXNrKHRoaXMsIGNvbnRleHQpKTtcblx0XHR9O1xuXG5cdFx0UmVqZWN0ZWQucHJvdG90eXBlLl91bnJlcG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYodGhpcy5oYW5kbGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGFuZGxlZCA9IHRydWU7XG5cdFx0XHR0YXNrcy5hZnRlclF1ZXVlKG5ldyBVbnJlcG9ydFRhc2sodGhpcykpO1xuXHRcdH07XG5cblx0XHRSZWplY3RlZC5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHRcdHRoaXMucmVwb3J0ZWQgPSB0cnVlO1xuXHRcdFx0ZW1pdFJlamVjdGlvbigndW5oYW5kbGVkUmVqZWN0aW9uJywgdGhpcyk7XG5cdFx0XHRQcm9taXNlLm9uRmF0YWxSZWplY3Rpb24odGhpcywgY29udGV4dCA9PT0gdm9pZCAwID8gdGhpcy5jb250ZXh0IDogY29udGV4dCk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIFJlcG9ydFRhc2socmVqZWN0aW9uLCBjb250ZXh0KSB7XG5cdFx0XHR0aGlzLnJlamVjdGlvbiA9IHJlamVjdGlvbjtcblx0XHRcdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cdFx0fVxuXG5cdFx0UmVwb3J0VGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZighdGhpcy5yZWplY3Rpb24uaGFuZGxlZCAmJiAhdGhpcy5yZWplY3Rpb24ucmVwb3J0ZWQpIHtcblx0XHRcdFx0dGhpcy5yZWplY3Rpb24ucmVwb3J0ZWQgPSB0cnVlO1xuXHRcdFx0XHRlbWl0UmVqZWN0aW9uKCd1bmhhbmRsZWRSZWplY3Rpb24nLCB0aGlzLnJlamVjdGlvbikgfHxcblx0XHRcdFx0XHRQcm9taXNlLm9uUG90ZW50aWFsbHlVbmhhbmRsZWRSZWplY3Rpb24odGhpcy5yZWplY3Rpb24sIHRoaXMuY29udGV4dCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIFVucmVwb3J0VGFzayhyZWplY3Rpb24pIHtcblx0XHRcdHRoaXMucmVqZWN0aW9uID0gcmVqZWN0aW9uO1xuXHRcdH1cblxuXHRcdFVucmVwb3J0VGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZih0aGlzLnJlamVjdGlvbi5yZXBvcnRlZCkge1xuXHRcdFx0XHRlbWl0UmVqZWN0aW9uKCdyZWplY3Rpb25IYW5kbGVkJywgdGhpcy5yZWplY3Rpb24pIHx8XG5cdFx0XHRcdFx0UHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCh0aGlzLnJlamVjdGlvbik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIFVuaGFuZGxlZCByZWplY3Rpb24gaG9va3Ncblx0XHQvLyBCeSBkZWZhdWx0LCBldmVyeXRoaW5nIGlzIGEgbm9vcFxuXG5cdFx0UHJvbWlzZS5jcmVhdGVDb250ZXh0XG5cdFx0XHQ9IFByb21pc2UuZW50ZXJDb250ZXh0XG5cdFx0XHQ9IFByb21pc2UuZXhpdENvbnRleHRcblx0XHRcdD0gUHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uXG5cdFx0XHQ9IFByb21pc2Uub25Qb3RlbnRpYWxseVVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWRcblx0XHRcdD0gUHJvbWlzZS5vbkZhdGFsUmVqZWN0aW9uXG5cdFx0XHQ9IG5vb3A7XG5cblx0XHQvLyBFcnJvcnMgYW5kIHNpbmdsZXRvbnNcblxuXHRcdHZhciBmb3JldmVyUGVuZGluZ0hhbmRsZXIgPSBuZXcgSGFuZGxlcigpO1xuXHRcdHZhciBmb3JldmVyUGVuZGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZShIYW5kbGVyLCBmb3JldmVyUGVuZGluZ0hhbmRsZXIpO1xuXG5cdFx0ZnVuY3Rpb24gY3ljbGUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFJlamVjdGVkKG5ldyBUeXBlRXJyb3IoJ1Byb21pc2UgY3ljbGUnKSk7XG5cdFx0fVxuXG5cdFx0Ly8gVGFzayBydW5uZXJzXG5cblx0XHQvKipcblx0XHQgKiBSdW4gYSBzaW5nbGUgY29uc3VtZXJcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBDb250aW51YXRpb25UYXNrKGNvbnRpbnVhdGlvbiwgaGFuZGxlcikge1xuXHRcdFx0dGhpcy5jb250aW51YXRpb24gPSBjb250aW51YXRpb247XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXHRcdH1cblxuXHRcdENvbnRpbnVhdGlvblRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5oYW5kbGVyLmpvaW4oKS53aGVuKHRoaXMuY29udGludWF0aW9uKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUnVuIGEgcXVldWUgb2YgcHJvZ3Jlc3MgaGFuZGxlcnNcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBQcm9ncmVzc1Rhc2sodmFsdWUsIGhhbmRsZXIpIHtcblx0XHRcdHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0UHJvZ3Jlc3NUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBxID0gdGhpcy5oYW5kbGVyLmNvbnN1bWVycztcblx0XHRcdGlmKHEgPT09IHZvaWQgMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGMsIGkgPSAwOyBpIDwgcS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRjID0gcVtpXTtcblx0XHRcdFx0cnVuTm90aWZ5KGMucHJvZ3Jlc3MsIHRoaXMudmFsdWUsIHRoaXMuaGFuZGxlciwgYy5yZWNlaXZlciwgYy5yZXNvbHZlcik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFzc2ltaWxhdGUgYSB0aGVuYWJsZSwgc2VuZGluZyBpdCdzIHZhbHVlIHRvIHJlc29sdmVyXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlblxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSB0aGVuYWJsZVxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSByZXNvbHZlclxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEFzc2ltaWxhdGVUYXNrKHRoZW4sIHRoZW5hYmxlLCByZXNvbHZlcikge1xuXHRcdFx0dGhpcy5fdGhlbiA9IHRoZW47XG5cdFx0XHR0aGlzLnRoZW5hYmxlID0gdGhlbmFibGU7XG5cdFx0XHR0aGlzLnJlc29sdmVyID0gcmVzb2x2ZXI7XG5cdFx0fVxuXG5cdFx0QXNzaW1pbGF0ZVRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGggPSB0aGlzLnJlc29sdmVyO1xuXHRcdFx0dHJ5QXNzaW1pbGF0ZSh0aGlzLl90aGVuLCB0aGlzLnRoZW5hYmxlLCBfcmVzb2x2ZSwgX3JlamVjdCwgX25vdGlmeSk7XG5cblx0XHRcdGZ1bmN0aW9uIF9yZXNvbHZlKHgpIHsgaC5yZXNvbHZlKHgpOyB9XG5cdFx0XHRmdW5jdGlvbiBfcmVqZWN0KHgpICB7IGgucmVqZWN0KHgpOyB9XG5cdFx0XHRmdW5jdGlvbiBfbm90aWZ5KHgpICB7IGgubm90aWZ5KHgpOyB9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHRyeUFzc2ltaWxhdGUodGhlbiwgdGhlbmFibGUsIHJlc29sdmUsIHJlamVjdCwgbm90aWZ5KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGVuLmNhbGwodGhlbmFibGUsIHJlc29sdmUsIHJlamVjdCwgbm90aWZ5KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVqZWN0KGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEZvbGQgYSBoYW5kbGVyIHZhbHVlIHdpdGggelxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEZvbGQoZiwgeiwgYywgdG8pIHtcblx0XHRcdHRoaXMuZiA9IGY7IHRoaXMueiA9IHo7IHRoaXMuYyA9IGM7IHRoaXMudG8gPSB0bztcblx0XHRcdHRoaXMucmVzb2x2ZXIgPSBmYWlsSWZSZWplY3RlZDtcblx0XHRcdHRoaXMucmVjZWl2ZXIgPSB0aGlzO1xuXHRcdH1cblxuXHRcdEZvbGQucHJvdG90eXBlLmZ1bGZpbGxlZCA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHRoaXMuZi5jYWxsKHRoaXMuYywgdGhpcy56LCB4LCB0aGlzLnRvKTtcblx0XHR9O1xuXG5cdFx0Rm9sZC5wcm90b3R5cGUucmVqZWN0ZWQgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHR0aGlzLnRvLnJlamVjdCh4KTtcblx0XHR9O1xuXG5cdFx0Rm9sZC5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHR0aGlzLnRvLm5vdGlmeSh4KTtcblx0XHR9O1xuXG5cdFx0Ly8gT3RoZXIgaGVscGVyc1xuXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHsqfSB4XG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWZmIHggaXMgYSB0cnVzdGVkIFByb21pc2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBpc1Byb21pc2UoeCkge1xuXHRcdFx0cmV0dXJuIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFRlc3QganVzdCBlbm91Z2ggdG8gcnVsZSBvdXQgcHJpbWl0aXZlcywgaW4gb3JkZXIgdG8gdGFrZSBmYXN0ZXJcblx0XHQgKiBwYXRocyBpbiBzb21lIGNvZGVcblx0XHQgKiBAcGFyYW0geyp9IHhcblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWZmIHggaXMgZ3VhcmFudGVlZCAqbm90KiB0byBiZSBhIHRoZW5hYmxlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbWF5YmVUaGVuYWJsZSh4KSB7XG5cdFx0XHRyZXR1cm4gKHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJykgJiYgeCAhPT0gbnVsbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBydW5Db250aW51YXRpb24xKGYsIGgsIHJlY2VpdmVyLCBuZXh0KSB7XG5cdFx0XHRpZih0eXBlb2YgZiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gbmV4dC5iZWNvbWUoaCk7XG5cdFx0XHR9XG5cblx0XHRcdFByb21pc2UuZW50ZXJDb250ZXh0KGgpO1xuXHRcdFx0dHJ5Q2F0Y2hSZWplY3QoZiwgaC52YWx1ZSwgcmVjZWl2ZXIsIG5leHQpO1xuXHRcdFx0UHJvbWlzZS5leGl0Q29udGV4dCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJ1bkNvbnRpbnVhdGlvbjMoZiwgeCwgaCwgcmVjZWl2ZXIsIG5leHQpIHtcblx0XHRcdGlmKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJldHVybiBuZXh0LmJlY29tZShoKTtcblx0XHRcdH1cblxuXHRcdFx0UHJvbWlzZS5lbnRlckNvbnRleHQoaCk7XG5cdFx0XHR0cnlDYXRjaFJlamVjdDMoZiwgeCwgaC52YWx1ZSwgcmVjZWl2ZXIsIG5leHQpO1xuXHRcdFx0UHJvbWlzZS5leGl0Q29udGV4dCgpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEBkZXByZWNhdGVkXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcnVuTm90aWZ5KGYsIHgsIGgsIHJlY2VpdmVyLCBuZXh0KSB7XG5cdFx0XHRpZih0eXBlb2YgZiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gbmV4dC5ub3RpZnkoeCk7XG5cdFx0XHR9XG5cblx0XHRcdFByb21pc2UuZW50ZXJDb250ZXh0KGgpO1xuXHRcdFx0dHJ5Q2F0Y2hSZXR1cm4oZiwgeCwgcmVjZWl2ZXIsIG5leHQpO1xuXHRcdFx0UHJvbWlzZS5leGl0Q29udGV4dCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyeUNhdGNoMihmLCBhLCBiKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gZihhLCBiKTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRyZXR1cm4gcmVqZWN0KGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBmLmNhbGwodGhpc0FyZywgeCksIG9yIGlmIGl0IHRocm93cyByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIGZvclxuXHRcdCAqIHRoZSB0aHJvd24gZXhjZXB0aW9uXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdHJ5Q2F0Y2hSZWplY3QoZiwgeCwgdGhpc0FyZywgbmV4dCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bmV4dC5iZWNvbWUoZ2V0SGFuZGxlcihmLmNhbGwodGhpc0FyZywgeCkpKTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRuZXh0LmJlY29tZShuZXcgUmVqZWN0ZWQoZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBpbmNsdWRlcyB0aGUgZXh0cmEgYXJndW1lbnQgcGFyYW1ldGVyLlxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHRyeUNhdGNoUmVqZWN0MyhmLCB4LCB5LCB0aGlzQXJnLCBuZXh0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmLmNhbGwodGhpc0FyZywgeCwgeSwgbmV4dCk7XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0bmV4dC5iZWNvbWUobmV3IFJlamVjdGVkKGUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAZGVwcmVjYXRlZFxuXHRcdCAqIFJldHVybiBmLmNhbGwodGhpc0FyZywgeCksIG9yIGlmIGl0IHRocm93cywgKnJldHVybiogdGhlIGV4Y2VwdGlvblxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHRyeUNhdGNoUmV0dXJuKGYsIHgsIHRoaXNBcmcsIG5leHQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdG5leHQubm90aWZ5KGYuY2FsbCh0aGlzQXJnLCB4KSk7XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0bmV4dC5ub3RpZnkoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5oZXJpdChQYXJlbnQsIENoaWxkKSB7XG5cdFx0XHRDaGlsZC5wcm90b3R5cGUgPSBvYmplY3RDcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG5cdFx0XHRDaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaGlsZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzbmQoeCwgeSkge1xuXHRcdFx0cmV0dXJuIHk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cblx0XHRmdW5jdGlvbiBpbml0RW1pdFJlamVjdGlvbigpIHtcblx0XHRcdC8qZ2xvYmFsIHByb2Nlc3MsIHNlbGYsIEN1c3RvbUV2ZW50Ki9cblx0XHRcdGlmKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzICE9PSBudWxsXG5cdFx0XHRcdCYmIHR5cGVvZiBwcm9jZXNzLmVtaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Ly8gUmV0dXJuaW5nIGZhbHN5IGhlcmUgbWVhbnMgdG8gY2FsbCB0aGUgZGVmYXVsdFxuXHRcdFx0XHQvLyBvblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uIEFQSS4gIFRoaXMgaXMgc2FmZSBldmVuIGluXG5cdFx0XHRcdC8vIGJyb3dzZXJpZnkgc2luY2UgcHJvY2Vzcy5lbWl0IGFsd2F5cyByZXR1cm5zIGZhbHN5IGluIGJyb3dzZXJpZnk6XG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWZ1bmN0em9tYmllL25vZGUtcHJvY2Vzcy9ibG9iL21hc3Rlci9icm93c2VyLmpzI0w0MC1MNDZcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHR5cGUsIHJlamVjdGlvbikge1xuXHRcdFx0XHRcdHJldHVybiB0eXBlID09PSAndW5oYW5kbGVkUmVqZWN0aW9uJ1xuXHRcdFx0XHRcdFx0PyBwcm9jZXNzLmVtaXQodHlwZSwgcmVqZWN0aW9uLnZhbHVlLCByZWplY3Rpb24pXG5cdFx0XHRcdFx0XHQ6IHByb2Nlc3MuZW1pdCh0eXBlLCByZWplY3Rpb24pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmV0dXJuIChmdW5jdGlvbihub29wLCBzZWxmLCBDdXN0b21FdmVudCkge1xuXHRcdFx0XHRcdHZhciBoYXNDdXN0b21FdmVudCA9IGZhbHNlO1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR2YXIgZXYgPSBuZXcgQ3VzdG9tRXZlbnQoJ3VuaGFuZGxlZFJlamVjdGlvbicpO1xuXHRcdFx0XHRcdFx0aGFzQ3VzdG9tRXZlbnQgPSBldiBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50O1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cblx0XHRcdFx0XHRyZXR1cm4gIWhhc0N1c3RvbUV2ZW50ID8gbm9vcCA6IGZ1bmN0aW9uKHR5cGUsIHJlamVjdGlvbikge1xuXHRcdFx0XHRcdFx0dmFyIGV2ID0gbmV3IEN1c3RvbUV2ZW50KHR5cGUsIHtcblx0XHRcdFx0XHRcdFx0ZGV0YWlsOiB7XG5cdFx0XHRcdFx0XHRcdFx0cmVhc29uOiByZWplY3Rpb24udmFsdWUsXG5cdFx0XHRcdFx0XHRcdFx0a2V5OiByZWplY3Rpb25cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0YnViYmxlczogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdGNhbmNlbGFibGU6IHRydWVcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gIXNlbGYuZGlzcGF0Y2hFdmVudChldik7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fShub29wLCBzZWxmLCBDdXN0b21FdmVudCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbm9vcDtcblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZTtcblx0fTtcbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG5cblx0cmV0dXJuIHtcblx0XHRwZW5kaW5nOiB0b1BlbmRpbmdTdGF0ZSxcblx0XHRmdWxmaWxsZWQ6IHRvRnVsZmlsbGVkU3RhdGUsXG5cdFx0cmVqZWN0ZWQ6IHRvUmVqZWN0ZWRTdGF0ZSxcblx0XHRpbnNwZWN0OiBpbnNwZWN0XG5cdH07XG5cblx0ZnVuY3Rpb24gdG9QZW5kaW5nU3RhdGUoKSB7XG5cdFx0cmV0dXJuIHsgc3RhdGU6ICdwZW5kaW5nJyB9O1xuXHR9XG5cblx0ZnVuY3Rpb24gdG9SZWplY3RlZFN0YXRlKGUpIHtcblx0XHRyZXR1cm4geyBzdGF0ZTogJ3JlamVjdGVkJywgcmVhc29uOiBlIH07XG5cdH1cblxuXHRmdW5jdGlvbiB0b0Z1bGZpbGxlZFN0YXRlKHgpIHtcblx0XHRyZXR1cm4geyBzdGF0ZTogJ2Z1bGZpbGxlZCcsIHZhbHVlOiB4IH07XG5cdH1cblxuXHRmdW5jdGlvbiBpbnNwZWN0KGhhbmRsZXIpIHtcblx0XHR2YXIgc3RhdGUgPSBoYW5kbGVyLnN0YXRlKCk7XG5cdFx0cmV0dXJuIHN0YXRlID09PSAwID8gdG9QZW5kaW5nU3RhdGUoKVxuXHRcdFx0IDogc3RhdGUgPiAwICAgPyB0b0Z1bGZpbGxlZFN0YXRlKGhhbmRsZXIudmFsdWUpXG5cdFx0XHQgICAgICAgICAgICAgICA6IHRvUmVqZWN0ZWRTdGF0ZShoYW5kbGVyLnZhbHVlKTtcblx0fVxuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG5cbi8qKlxuICogUHJvbWlzZXMvQSsgYW5kIHdoZW4oKSBpbXBsZW1lbnRhdGlvblxuICogd2hlbiBpcyBwYXJ0IG9mIHRoZSBjdWpvSlMgZmFtaWx5IG9mIGxpYnJhcmllcyAoaHR0cDovL2N1am9qcy5jb20vKVxuICogQGF1dGhvciBCcmlhbiBDYXZhbGllclxuICogQGF1dGhvciBKb2huIEhhbm5cbiAqL1xuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHR2YXIgdGltZWQgPSByZXF1aXJlKCcuL2xpYi9kZWNvcmF0b3JzL3RpbWVkJyk7XG5cdHZhciBhcnJheSA9IHJlcXVpcmUoJy4vbGliL2RlY29yYXRvcnMvYXJyYXknKTtcblx0dmFyIGZsb3cgPSByZXF1aXJlKCcuL2xpYi9kZWNvcmF0b3JzL2Zsb3cnKTtcblx0dmFyIGZvbGQgPSByZXF1aXJlKCcuL2xpYi9kZWNvcmF0b3JzL2ZvbGQnKTtcblx0dmFyIGluc3BlY3QgPSByZXF1aXJlKCcuL2xpYi9kZWNvcmF0b3JzL2luc3BlY3QnKTtcblx0dmFyIGdlbmVyYXRlID0gcmVxdWlyZSgnLi9saWIvZGVjb3JhdG9ycy9pdGVyYXRlJyk7XG5cdHZhciBwcm9ncmVzcyA9IHJlcXVpcmUoJy4vbGliL2RlY29yYXRvcnMvcHJvZ3Jlc3MnKTtcblx0dmFyIHdpdGhUaGlzID0gcmVxdWlyZSgnLi9saWIvZGVjb3JhdG9ycy93aXRoJyk7XG5cdHZhciB1bmhhbmRsZWRSZWplY3Rpb24gPSByZXF1aXJlKCcuL2xpYi9kZWNvcmF0b3JzL3VuaGFuZGxlZFJlamVjdGlvbicpO1xuXHR2YXIgVGltZW91dEVycm9yID0gcmVxdWlyZSgnLi9saWIvVGltZW91dEVycm9yJyk7XG5cblx0dmFyIFByb21pc2UgPSBbYXJyYXksIGZsb3csIGZvbGQsIGdlbmVyYXRlLCBwcm9ncmVzcyxcblx0XHRpbnNwZWN0LCB3aXRoVGhpcywgdGltZWQsIHVuaGFuZGxlZFJlamVjdGlvbl1cblx0XHQucmVkdWNlKGZ1bmN0aW9uKFByb21pc2UsIGZlYXR1cmUpIHtcblx0XHRcdHJldHVybiBmZWF0dXJlKFByb21pc2UpO1xuXHRcdH0sIHJlcXVpcmUoJy4vbGliL1Byb21pc2UnKSk7XG5cblx0dmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9saWIvYXBwbHknKShQcm9taXNlKTtcblxuXHQvLyBQdWJsaWMgQVBJXG5cblx0d2hlbi5wcm9taXNlICAgICA9IHByb21pc2U7ICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBwZW5kaW5nIHByb21pc2Vcblx0d2hlbi5yZXNvbHZlICAgICA9IFByb21pc2UucmVzb2x2ZTsgICAgICAvLyBDcmVhdGUgYSByZXNvbHZlZCBwcm9taXNlXG5cdHdoZW4ucmVqZWN0ICAgICAgPSBQcm9taXNlLnJlamVjdDsgICAgICAgLy8gQ3JlYXRlIGEgcmVqZWN0ZWQgcHJvbWlzZVxuXG5cdHdoZW4ubGlmdCAgICAgICAgPSBsaWZ0OyAgICAgICAgICAgICAgICAgLy8gbGlmdCBhIGZ1bmN0aW9uIHRvIHJldHVybiBwcm9taXNlc1xuXHR3aGVuWyd0cnknXSAgICAgID0gYXR0ZW1wdDsgICAgICAgICAgICAgIC8vIGNhbGwgYSBmdW5jdGlvbiBhbmQgcmV0dXJuIGEgcHJvbWlzZVxuXHR3aGVuLmF0dGVtcHQgICAgID0gYXR0ZW1wdDsgICAgICAgICAgICAgIC8vIGFsaWFzIGZvciB3aGVuLnRyeVxuXG5cdHdoZW4uaXRlcmF0ZSAgICAgPSBQcm9taXNlLml0ZXJhdGU7ICAgICAgLy8gREVQUkVDQVRFRCAodXNlIGN1am9qcy9tb3N0IHN0cmVhbXMpIEdlbmVyYXRlIGEgc3RyZWFtIG9mIHByb21pc2VzXG5cdHdoZW4udW5mb2xkICAgICAgPSBQcm9taXNlLnVuZm9sZDsgICAgICAgLy8gREVQUkVDQVRFRCAodXNlIGN1am9qcy9tb3N0IHN0cmVhbXMpIEdlbmVyYXRlIGEgc3RyZWFtIG9mIHByb21pc2VzXG5cblx0d2hlbi5qb2luICAgICAgICA9IGpvaW47ICAgICAgICAgICAgICAgICAvLyBKb2luIDIgb3IgbW9yZSBwcm9taXNlc1xuXG5cdHdoZW4uYWxsICAgICAgICAgPSBhbGw7ICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSBhIGxpc3Qgb2YgcHJvbWlzZXNcblx0d2hlbi5zZXR0bGUgICAgICA9IHNldHRsZTsgICAgICAgICAgICAgICAvLyBTZXR0bGUgYSBsaXN0IG9mIHByb21pc2VzXG5cblx0d2hlbi5hbnkgICAgICAgICA9IGxpZnQoUHJvbWlzZS5hbnkpOyAgICAvLyBPbmUtd2lubmVyIHJhY2Vcblx0d2hlbi5zb21lICAgICAgICA9IGxpZnQoUHJvbWlzZS5zb21lKTsgICAvLyBNdWx0aS13aW5uZXIgcmFjZVxuXHR3aGVuLnJhY2UgICAgICAgID0gbGlmdChQcm9taXNlLnJhY2UpOyAgIC8vIEZpcnN0LXRvLXNldHRsZSByYWNlXG5cblx0d2hlbi5tYXAgICAgICAgICA9IG1hcDsgICAgICAgICAgICAgICAgICAvLyBBcnJheS5tYXAoKSBmb3IgcHJvbWlzZXNcblx0d2hlbi5maWx0ZXIgICAgICA9IGZpbHRlcjsgICAgICAgICAgICAgICAvLyBBcnJheS5maWx0ZXIoKSBmb3IgcHJvbWlzZXNcblx0d2hlbi5yZWR1Y2UgICAgICA9IGxpZnQoUHJvbWlzZS5yZWR1Y2UpOyAgICAgICAvLyBBcnJheS5yZWR1Y2UoKSBmb3IgcHJvbWlzZXNcblx0d2hlbi5yZWR1Y2VSaWdodCA9IGxpZnQoUHJvbWlzZS5yZWR1Y2VSaWdodCk7ICAvLyBBcnJheS5yZWR1Y2VSaWdodCgpIGZvciBwcm9taXNlc1xuXG5cdHdoZW4uaXNQcm9taXNlTGlrZSA9IGlzUHJvbWlzZUxpa2U7ICAgICAgLy8gSXMgc29tZXRoaW5nIHByb21pc2UtbGlrZSwgYWthIHRoZW5hYmxlXG5cblx0d2hlbi5Qcm9taXNlICAgICA9IFByb21pc2U7ICAgICAgICAgICAgICAvLyBQcm9taXNlIGNvbnN0cnVjdG9yXG5cdHdoZW4uZGVmZXIgICAgICAgPSBkZWZlcjsgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEge3Byb21pc2UsIHJlc29sdmUsIHJlamVjdH0gdHVwbGVcblxuXHQvLyBFcnJvciB0eXBlc1xuXG5cdHdoZW4uVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuXG5cdC8qKlxuXHQgKiBHZXQgYSB0cnVzdGVkIHByb21pc2UgZm9yIHgsIG9yIGJ5IHRyYW5zZm9ybWluZyB4IHdpdGggb25GdWxmaWxsZWRcblx0ICpcblx0ICogQHBhcmFtIHsqfSB4XG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBvbkZ1bGZpbGxlZCBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiB4IGlzXG5cdCAqICAgc3VjY2Vzc2Z1bGx5IGZ1bGZpbGxlZC4gIElmIHByb21pc2VPclZhbHVlIGlzIGFuIGltbWVkaWF0ZSB2YWx1ZSwgY2FsbGJhY2tcblx0ICogICB3aWxsIGJlIGludm9rZWQgaW1tZWRpYXRlbHkuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBvblJlamVjdGVkIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIHggaXNcblx0ICogICByZWplY3RlZC5cblx0ICogQHBhcmFtIHtmdW5jdGlvbj99IG9uUHJvZ3Jlc3MgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gcHJvZ3Jlc3MgdXBkYXRlc1xuXHQgKiAgIGFyZSBpc3N1ZWQgZm9yIHguIEBkZXByZWNhdGVkXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfSBhIG5ldyBwcm9taXNlIHRoYXQgd2lsbCBmdWxmaWxsIHdpdGggdGhlIHJldHVyblxuXHQgKiAgIHZhbHVlIG9mIGNhbGxiYWNrIG9yIGVycmJhY2sgb3IgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgcHJvbWlzZU9yVmFsdWUgaWZcblx0ICogICBjYWxsYmFjayBhbmQvb3IgZXJyYmFjayBpcyBub3Qgc3VwcGxpZWQuXG5cdCAqL1xuXHRmdW5jdGlvbiB3aGVuKHgsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzKSB7XG5cdFx0dmFyIHAgPSBQcm9taXNlLnJlc29sdmUoeCk7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG5cdFx0XHRyZXR1cm4gcDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcC50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHByb21pc2Ugd2hvc2UgZmF0ZSBpcyBkZXRlcm1pbmVkIGJ5IHJlc29sdmVyLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlciBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QsIG5vdGlmeSlcblx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hvc2UgZmF0ZSBpcyBkZXRlcm1pbmUgYnkgcmVzb2x2ZXJcblx0ICovXG5cdGZ1bmN0aW9uIHByb21pc2UocmVzb2x2ZXIpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZnQgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uLCBjcmVhdGluZyBhIHZlcnNpb24gb2YgZiB0aGF0IHJldHVybnNcblx0ICogcHJvbWlzZXMsIGFuZCBhY2NlcHRzIHByb21pc2VzIGFzIGFyZ3VtZW50cy5cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IHZlcnNpb24gb2YgZiB0aGF0IHJldHVybnMgcHJvbWlzZXNcblx0ICovXG5cdGZ1bmN0aW9uIGxpZnQoZikge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGZvcih2YXIgaT0wLCBsPWFyZ3VtZW50cy5sZW5ndGgsIGE9bmV3IEFycmF5KGwpOyBpPGw7ICsraSkge1xuXHRcdFx0XHRhW2ldID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFwcGx5KGYsIHRoaXMsIGEpO1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbCBmIGluIGEgZnV0dXJlIHR1cm4sIHdpdGggdGhlIHN1cHBsaWVkIGFyZ3MsIGFuZCByZXR1cm4gYSBwcm9taXNlXG5cdCAqIGZvciB0aGUgcmVzdWx0LlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHQgKi9cblx0ZnVuY3Rpb24gYXR0ZW1wdChmIC8qLCBhcmdzLi4uICovKSB7XG5cdFx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblx0XHRmb3IodmFyIGk9MCwgbD1hcmd1bWVudHMubGVuZ3RoLTEsIGE9bmV3IEFycmF5KGwpOyBpPGw7ICsraSkge1xuXHRcdFx0YVtpXSA9IGFyZ3VtZW50c1tpKzFdO1xuXHRcdH1cblx0XHRyZXR1cm4gYXBwbHkoZiwgdGhpcywgYSk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHtwcm9taXNlLCByZXNvbHZlcn0gcGFpciwgZWl0aGVyIG9yIGJvdGggb2Ygd2hpY2hcblx0ICogbWF5IGJlIGdpdmVuIG91dCBzYWZlbHkgdG8gY29uc3VtZXJzLlxuXHQgKiBAcmV0dXJuIHt7cHJvbWlzZTogUHJvbWlzZSwgcmVzb2x2ZTogZnVuY3Rpb24sIHJlamVjdDogZnVuY3Rpb24sIG5vdGlmeTogZnVuY3Rpb259fVxuXHQgKi9cblx0ZnVuY3Rpb24gZGVmZXIoKSB7XG5cdFx0cmV0dXJuIG5ldyBEZWZlcnJlZCgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gRGVmZXJyZWQoKSB7XG5cdFx0dmFyIHAgPSBQcm9taXNlLl9kZWZlcigpO1xuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZSh4KSB7IHAuX2hhbmRsZXIucmVzb2x2ZSh4KTsgfVxuXHRcdGZ1bmN0aW9uIHJlamVjdCh4KSB7IHAuX2hhbmRsZXIucmVqZWN0KHgpOyB9XG5cdFx0ZnVuY3Rpb24gbm90aWZ5KHgpIHsgcC5faGFuZGxlci5ub3RpZnkoeCk7IH1cblxuXHRcdHRoaXMucHJvbWlzZSA9IHA7XG5cdFx0dGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHR0aGlzLnJlamVjdCA9IHJlamVjdDtcblx0XHR0aGlzLm5vdGlmeSA9IG5vdGlmeTtcblx0XHR0aGlzLnJlc29sdmVyID0geyByZXNvbHZlOiByZXNvbHZlLCByZWplY3Q6IHJlamVjdCwgbm90aWZ5OiBub3RpZnkgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHggaXMgcHJvbWlzZS1saWtlLCBpLmUuIGEgdGhlbmFibGUgb2JqZWN0XG5cdCAqIE5PVEU6IFdpbGwgcmV0dXJuIHRydWUgZm9yICphbnkgdGhlbmFibGUgb2JqZWN0KiwgYW5kIGlzbid0IHRydWx5XG5cdCAqIHNhZmUsIHNpbmNlIGl0IG1heSBhdHRlbXB0IHRvIGFjY2VzcyB0aGUgYHRoZW5gIHByb3BlcnR5IG9mIHggKGkuZS5cblx0ICogIGNsZXZlci9tYWxpY2lvdXMgZ2V0dGVycyBtYXkgZG8gd2VpcmQgdGhpbmdzKVxuXHQgKiBAcGFyYW0geyp9IHggYW55dGhpbmdcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgeCBpcyBwcm9taXNlLWxpa2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzUHJvbWlzZUxpa2UoeCkge1xuXHRcdHJldHVybiB4ICYmIHR5cGVvZiB4LnRoZW4gPT09ICdmdW5jdGlvbic7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBvbmx5IG9uY2UgYWxsIHRoZSBzdXBwbGllZCBhcmd1bWVudHNcblx0ICogaGF2ZSByZXNvbHZlZC4gVGhlIHJlc29sdXRpb24gdmFsdWUgb2YgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSBhbiBhcnJheVxuXHQgKiBjb250YWluaW5nIHRoZSByZXNvbHV0aW9uIHZhbHVlcyBvZiBlYWNoIG9mIHRoZSBhcmd1bWVudHMuXG5cdCAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzIG1heSBiZSBhIG1peCBvZiBwcm9taXNlcyBhbmQgdmFsdWVzXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHQgKi9cblx0ZnVuY3Rpb24gam9pbigvKiAuLi5wcm9taXNlcyAqLykge1xuXHRcdHJldHVybiBQcm9taXNlLmFsbChhcmd1bWVudHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgb25jZSBhbGwgaW5wdXQgcHJvbWlzZXMgaGF2ZVxuXHQgKiBmdWxmaWxsZWQsIG9yIHJlamVjdCB3aGVuIGFueSBvbmUgaW5wdXQgcHJvbWlzZSByZWplY3RzLlxuXHQgKiBAcGFyYW0ge2FycmF5fFByb21pc2V9IHByb21pc2VzIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgcHJvbWlzZXNcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcblx0XHRyZXR1cm4gd2hlbihwcm9taXNlcywgUHJvbWlzZS5hbGwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGFsd2F5cyBmdWxmaWxsIHdpdGggYW4gYXJyYXkgY29udGFpbmluZ1xuXHQgKiB0aGUgb3V0Y29tZSBzdGF0ZXMgb2YgYWxsIGlucHV0IHByb21pc2VzLiAgVGhlIHJldHVybmVkIHByb21pc2Vcblx0ICogd2lsbCBvbmx5IHJlamVjdCBpZiBgcHJvbWlzZXNgIGl0c2VsZiBpcyBhIHJlamVjdGVkIHByb21pc2UuXG5cdCAqIEBwYXJhbSB7YXJyYXl8UHJvbWlzZX0gcHJvbWlzZXMgYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiBwcm9taXNlc1xuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSBmb3IgYXJyYXkgb2Ygc2V0dGxlZCBzdGF0ZSBkZXNjcmlwdG9yc1xuXHQgKi9cblx0ZnVuY3Rpb24gc2V0dGxlKHByb21pc2VzKSB7XG5cdFx0cmV0dXJuIHdoZW4ocHJvbWlzZXMsIFByb21pc2Uuc2V0dGxlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9taXNlLWF3YXJlIGFycmF5IG1hcCBmdW5jdGlvbiwgc2ltaWxhciB0byBgQXJyYXkucHJvdG90eXBlLm1hcCgpYCxcblx0ICogYnV0IGlucHV0IGFycmF5IG1heSBjb250YWluIHByb21pc2VzIG9yIHZhbHVlcy5cblx0ICogQHBhcmFtIHtBcnJheXxQcm9taXNlfSBwcm9taXNlcyBhcnJheSBvZiBhbnl0aGluZywgbWF5IGNvbnRhaW4gcHJvbWlzZXMgYW5kIHZhbHVlc1xuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKHg6KiwgaW5kZXg6TnVtYmVyKToqfSBtYXBGdW5jIG1hcCBmdW5jdGlvbiB3aGljaCBtYXlcblx0ICogIHJldHVybiBhIHByb21pc2Ugb3IgdmFsdWVcblx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgd2l0aCBhbiBhcnJheSBvZiBtYXBwZWQgdmFsdWVzXG5cdCAqICBvciByZWplY3QgaWYgYW55IGlucHV0IHByb21pc2UgcmVqZWN0cy5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChwcm9taXNlcywgbWFwRnVuYykge1xuXHRcdHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbihwcm9taXNlcykge1xuXHRcdFx0cmV0dXJuIFByb21pc2UubWFwKHByb21pc2VzLCBtYXBGdW5jKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGaWx0ZXIgdGhlIHByb3ZpZGVkIGFycmF5IG9mIHByb21pc2VzIHVzaW5nIHRoZSBwcm92aWRlZCBwcmVkaWNhdGUuICBJbnB1dCBtYXlcblx0ICogY29udGFpbiBwcm9taXNlcyBhbmQgdmFsdWVzXG5cdCAqIEBwYXJhbSB7QXJyYXl8UHJvbWlzZX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgYW5kIHZhbHVlc1xuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKHg6KiwgaW5kZXg6TnVtYmVyKTpib29sZWFufSBwcmVkaWNhdGUgZmlsdGVyaW5nIHByZWRpY2F0ZS5cblx0ICogIE11c3QgcmV0dXJuIHRydXRoeSAob3IgcHJvbWlzZSBmb3IgdHJ1dGh5KSBmb3IgaXRlbXMgdG8gcmV0YWluLlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCB3aXRoIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGl0ZW1zXG5cdCAqICBmb3Igd2hpY2ggcHJlZGljYXRlIHJldHVybmVkIHRydXRoeS5cblx0ICovXG5cdGZ1bmN0aW9uIGZpbHRlcihwcm9taXNlcywgcHJlZGljYXRlKSB7XG5cdFx0cmV0dXJuIHdoZW4ocHJvbWlzZXMsIGZ1bmN0aW9uKHByb21pc2VzKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5maWx0ZXIocHJvbWlzZXMsIHByZWRpY2F0ZSk7XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gd2hlbjtcbn0pO1xufSkodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9KTtcbiIsIi8vIEltcG9ydCByZXF1aXJlbWVudHMgdXNpbmcgYnJvd3NlcmlmeVxud2luZG93LlZ1ZSA9IHJlcXVpcmUoJ3Z1ZScpO1xud2luZG93LlZ1ZVJvdXRlciA9IHJlcXVpcmUoJ3Z1ZS1yb3V0ZXInKTtcblxuVnVlLnVzZShyZXF1aXJlKCd2dWUtcmVzb3VyY2UnKSk7XG5cbi8vIEluc2VydCB2dWUtcm91dGVyIGFuZCB2dWUtcmVzb3VyY2UgaW50byBWdWVcblxuLy8gSW1wb3J0IHRoZSBhY3R1YWwgcm91dGVzLCBhbGlhc2VzLCAuLi5cbmltcG9ydCB7IGNvbmZpZ1JvdXRlciB9IGZyb20gJy4vcm91dGVzJztcblxuLy8gQ3JlYXRlIG91ciByb3V0ZXIgb2JqZWN0IGFuZCBzZXQgb3B0aW9ucyBvbiBpdFxuY29uc3Qgcm91dGVyID0gbmV3IFZ1ZVJvdXRlcih7fSk7XG5cbi8vIEluamVjdCB0aGUgcm91dGVzIGludG8gdGhlIFZ1ZVJvdXRlciBvYmplY3RcbmNvbmZpZ1JvdXRlcihyb3V0ZXIpO1xuXG4vLyBDb25maWd1cmUgdGhlIGFwcGxpY2F0aW9uXG53aW5kb3cuY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblZ1ZS5jb25maWcuZGVidWcgPSB0cnVlO1xuXG4vLyBDb25maWd1cmUgb3VyIEhUVFAgY2xpZW50XG52YXIgcmVzdCA9IHJlcXVpcmUoJ3Jlc3QnKTtcbnZhciBwYXRoUHJlZml4ID0gcmVxdWlyZSgncmVzdC9pbnRlcmNlcHRvci9wYXRoUHJlZml4Jyk7XG52YXIgbWltZSA9IHJlcXVpcmUoJ3Jlc3QvaW50ZXJjZXB0b3IvbWltZScpO1xudmFyIGRlZmF1bHRSZXF1ZXN0ID0gcmVxdWlyZSgncmVzdC9pbnRlcmNlcHRvci9kZWZhdWx0UmVxdWVzdCcpO1xudmFyIGVycm9yQ29kZSA9IHJlcXVpcmUoJ3Jlc3QvaW50ZXJjZXB0b3IvZXJyb3JDb2RlJyk7XG52YXIgaW50ZXJjZXB0b3IgPSByZXF1aXJlKCdyZXN0L2ludGVyY2VwdG9yJyk7XG52YXIgand0QXV0aCA9IHJlcXVpcmUoJy4vaW50ZXJjZXB0b3JzL2p3dEF1dGgnKTtcblxud2luZG93LmNsaWVudCA9IHJlc3Qud3JhcChwYXRoUHJlZml4LCB7cHJlZml4OiBjb25maWcuYXBpLmJhc2VfdXJsfSlcbiAgICAud3JhcChtaW1lKVxuICAgIC53cmFwKGRlZmF1bHRSZXF1ZXN0LCBjb25maWcuYXBpLmRlZmF1bHRSZXF1ZXN0KVxuICAgIC53cmFwKGVycm9yQ29kZSwge2NvZGU6IDQwMH0pO1xuICAgIC8vLndyYXAoand0QXV0aCk7XG5cbi8vIEJvb3RzdHJhcCB0aGUgYXBwXG4vLyBIUmlzIENvbXBvbmVudHNcblZ1ZS5jb21wb25lbnQoJ2NvcHlsZWZ0JywgcmVxdWlyZSgnLi9jb21waWxlZC9wYXJ0aWFscy9jb3B5bGVmdC52dWUnKSk7XG5WdWUuY29tcG9uZW50KCdhY3Rpb24tYXJlYScsIHJlcXVpcmUoJy4vY29tcGlsZWQvcGFydGlhbHMvYWN0aW9uLWFyZWEudnVlJykpO1xuVnVlLmNvbXBvbmVudCgnbmF2YmFyLXN0YXRpYy1zaWRlJywgcmVxdWlyZSgnLi9jb21waWxlZC9wYXJ0aWFscy9uYXZiYXItc3RhdGljLXNpZGUudnVlJykpO1xuVnVlLmNvbXBvbmVudCgnbmF2YmFyLXN0YXRpYy1wcm9maWxlLXRvcCcsIHJlcXVpcmUoJy4vY29tcGlsZWQvcGFydGlhbHMvbmF2YmFyLXN0YXRpYy1wcm9maWxlLXRvcC52dWUnKSk7XG5WdWUuY29tcG9uZW50KCduYXZiYXItc3RhdGljLXRvcCcsIHJlcXVpcmUoJy4vY29tcGlsZWQvcGFydGlhbHMvbmF2YmFyLXN0YXRpYy10b3AudnVlJykpO1xuVnVlLmNvbXBvbmVudCgnc3RhdGljLWZvb3RlcicsIHJlcXVpcmUoJy4vY29tcGlsZWQvcGFydGlhbHMvc3RhdGljLWZvb3Rlci52dWUnKSk7XG5WdWUuY29tcG9uZW50KCdjaG9zZW4nLCByZXF1aXJlKCcuL2NvbXBpbGVkL3BhcnRpYWxzL2Nob3Nlbi52dWUnKSk7XG5cblZ1ZS5kaXJlY3RpdmUoJ3RyYW5zJywge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdHJhbnNsYXRlKHZhbHVlKTtcbiAgICAgICAgdmFyIGFyZyA9IHRoaXMuYXJnO1xuICAgICAgICBzd2l0Y2ggKGFyZykge1xuICAgICAgICAgICAgY2FzZSAncGxhY2Vob2xkZXInOlxuICAgICAgICAgICAgICAgIHRoaXMuZWwucGxhY2Vob2xkZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNvbnN0IEFwcCA9IFZ1ZS5leHRlbmQocmVxdWlyZSgnLi9jb21waWxlZC9hcHAudnVlJykpO1xucm91dGVyLnN0YXJ0KEFwcCwgJ2JvZHknKTtcbndpbmRvdy5yb3V0ZXIgPSByb3V0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHByb3BzOiBbJ2VtcGxveWVlJywgJ3BhZ2VfdGl0bGUnLCAnam9iX3RpdGxlcycsICdlbXBsb3ltZW50X3N0YXR1c2VzJywgJ3JvdXRlcycsICdoYXNfYWNjZXNzJywgJ3Blcm1pc3Npb24nXSxcbiAgICByZXBsYWNlOiBmYWxzZSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wbG95ZWU6IHtcbiAgICAgICAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogJycsXG4gICAgICAgICAgICAgICAgZmlyc3RfbmFtZTogJycsXG4gICAgICAgICAgICAgICAgbWlkZGxlX25hbWU6ICcnLFxuICAgICAgICAgICAgICAgIGxhc3RfbmFtZTogJycsXG4gICAgICAgICAgICAgICAgZW1wbG95ZWVfaWQ6ICcnLFxuICAgICAgICAgICAgICAgIGZhY2VfaWQ6ICcnLFxuICAgICAgICAgICAgICAgIGdlbmRlcjogJycsXG4gICAgICAgICAgICAgICAgbmF0aW9uYWxpdHlfaWQ6ICcnLFxuICAgICAgICAgICAgICAgIG1hcml0YWxfc3RhdHVzX2lkOiAnJyxcbiAgICAgICAgICAgICAgICBqb2JfaGlzdG9yeTogW10sXG4gICAgICAgICAgICAgICAgZW1lcmdlbmN5X2NvbnRhY3RzOiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc19hY2Nlc3M6ICcnXG4gICAgICAgIH07XG4gICAgfSxcbiAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7XG5cbiAgICAgICAgdGhpcy50ID0gMTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy4kb24oJ3VzZXJIYXNMb2dnZWRPdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lMb2dpbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLiRvbigndXNlckhhc0xvZ2dlZEluJywgZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgIHRoYXQuc2V0TG9naW4odXNlcik7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbG9nZ2VkJywgYnRvYShKU09OLnN0cmluZ2lmeSh1c2VyKSkpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2VtcGxveWVlX2lkJywgdXNlci5lbXBsb3llZS5kYXRhLmVtcGxveWVlX2lkKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdmF0YXInLCB1c2VyLmVtcGxveWVlLmRhdGEuYXZhdGFyKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwZXJtaXNzaW9ucycsIGJ0b2EoSlNPTi5zdHJpbmdpZnkodXNlci5yb2xlLmRhdGFbMF0ucGVybWlzc2lvbnMpKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuJG9uKCd1cGRhdGUtcGFnZS10aXRsZScsIGZ1bmN0aW9uIChwYWdlX3RpdGxlKSB7XG4gICAgICAgICAgICB0aGF0LnBhZ2VfdGl0bGUgPSBwYWdlX3RpdGxlO1xuICAgICAgICAgICAgdmFyIHJvdXRlID0gW107XG4gICAgICAgICAgICB2YXIgcm91dGVfcGF0aCA9IHRoaXMuJHJvdXRlLnBhdGguc3Vic3RyKDEpO1xuICAgICAgICAgICAgdmFyIHJvdXRlX3NlZ21lbnRzID0gcm91dGVfcGF0aC5zcGxpdCgnLycpO1xuXG4gICAgICAgICAgICB2YXIgcm91dGVfbmFtZSA9IHJvdXRlX3NlZ21lbnRzWzBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3V0ZV9zZWdtZW50cy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgJiYgcm91dGVfc2VnbWVudHNbaV0uaW5kZXhPZignSFJpcycpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZ2V0IGVtcGxveWVlX2lkX3ByZWZpeCBmcm9tIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICByb3V0ZV9uYW1lICs9ICctJyArIHJvdXRlX3NlZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZV9zZWdtZW50c1tpXSA9PSAncGltJykge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZV9zZWdtZW50c1tpXSA9ICdQSU0nO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJvdXRlX3NlZ21lbnRzW2ldLmluZGV4T2YoJ0hSaXMnKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGdldCBlbXBsb3llZV9pZF9wcmVmaXggZnJvbSBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgcm91dGVfc2VnbWVudHNbaV0gPSByb3V0ZV9zZWdtZW50c1tpXS5yZXBsYWNlKCctJywgJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVfc2VnbWVudHNbaV0gPSB0aGlzLnRvVGl0bGVDYXNlKHJvdXRlX3NlZ21lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocm91dGVfc2VnbWVudHNbaV0uaW5kZXhPZignSFJpcycpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZ2V0IGVtcGxveWVlX2lkX3ByZWZpeCBmcm9tIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICByb3V0ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZWdtZW50Jzogcm91dGVfc2VnbWVudHNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IHJvdXRlX25hbWUgKyAnLXBlcnNvbmFsLWRldGFpbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BhcmFtcyc6IHsgJ2VtcGxveWVlX2lkJzogcm91dGVfc2VnbWVudHNbaV0gfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZWdtZW50Jzogcm91dGVfc2VnbWVudHNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IHJvdXRlX25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFyYW1zJzogeyAnZW1wbG95ZWVfaWQnOiByb3V0ZV9zZWdtZW50c1tpIC0gMV0gfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucm91dGVzID0gcm91dGU7XG4gICAgICAgICAgICB0aGlzLnByZXBhcmVQZXJtaXNzaW9uKCk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LnRpdGxlID0gJ0hSaXMgfCAnICsgcGFnZV90aXRsZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy4kb24oJ3VwZGF0ZS1lbXBsb3llZScsIGZ1bmN0aW9uIChlbXBsb3llZSkge1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuZW1wbG95ZWUgPSBlbXBsb3llZTtcbiAgICAgICAgICAgIHRoaXMuZW1wbG95ZWUuYmlydGhfZGF0ZSA9IHRoaXMuZW1wbG95ZWUuYmlydGhfZGF0ZSA/IHRoaXMuZW1wbG95ZWUuYmlydGhfZGF0ZS5kYXRlLnN1YnN0cmluZygwLCAxMCkgOiBudWxsO1xuXG4gICAgICAgICAgICBjbGllbnQoe1xuICAgICAgICAgICAgICAgIHBhdGg6ICcvam9iLXRpdGxlcz90YWJsZV92aWV3PXRydWUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnand0LXRva2VuJykgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmpvYl90aXRsZXMgPSByZXNwb25zZS5lbnRpdHk7XG4gICAgICAgICAgICAgICAgdGhhdC4kYnJvYWRjYXN0KCdzZXQtam9iLXRpdGxlcy1kZWZhdWx0Jyk7XG4gICAgICAgICAgICAgICAgdGhhdC4kYnJvYWRjYXN0KCdzZXQtam9iLXRpdGxlcy1hY3Rpb24tYXJlYScpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNsaWVudCh7XG4gICAgICAgICAgICAgICAgcGF0aDogJy9lbXBsb3ltZW50LXN0YXR1c2VzP3RhYmxlX3ZpZXc9dHJ1ZScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdqd3QtdG9rZW4nKSB9XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZW1wbG95bWVudF9zdGF0dXNlcyA9IHJlc3BvbnNlLmVudGl0eTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ2VtcGxveWVlLWxvYWRlZCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaGUgYXBwIGhhcyBqdXN0IGJlZW4gaW5pdGlhbGl6ZWQsIGNoZWNrIGlmIHdlIGNhbiBnZXQgdGhlIHVzZXIgZGF0YSB3aXRoIGFuIGFscmVhZHkgZXhpc3RpbmcgdG9rZW5cbiAgICAgICAgdmFyIHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2p3dC10b2tlbicpO1xuICAgICAgICBpZiAodG9rZW4gIT09IG51bGwgJiYgdG9rZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIGNsaWVudCh7XG4gICAgICAgICAgICAgICAgcGF0aDogJy91c2Vycy9tZT9pbmNsdWRlPWVtcGxveWVlLHJvbGUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnand0LXRva2VuJykgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2VyIGhhcyBzdWNjZXNzZnVsbHkgbG9nZ2VkIGluIHVzaW5nIHRoZSB0b2tlbiBmcm9tIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICB0aGF0LnNldExvZ2luKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAvLyBicm9hZGNhc3QgYW4gZXZlbnQgdGVsbGluZyBvdXIgY2hpbGRyZW4gdGhhdCB0aGUgZGF0YSBpcyByZWFkeSBhbmQgdmlld3MgY2FuIGJlIHJlbmRlcmVkXG4gICAgICAgICAgICAgICAgdGhhdC4kYnJvYWRjYXN0KCdkYXRhLWxvYWRlZCcpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9naW4gd2l0aCBvdXIgdG9rZW4gZmFpbGVkLCBkbyBzb21lIGNsZWFudXAgYW5kIHJlZGlyZWN0IGlmIHdlJ3JlIG9uIGFuIGF1dGhlbnRpY2F0ZWQgcm91dGVcbiAgICAgICAgICAgICAgICB0aGF0LmRlc3Ryb3lMb2dpbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZXI6IG51bGwsXG4gICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0ZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBzZXRMb2dpbjogZnVuY3Rpb24gc2V0TG9naW4odXNlcikge1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgbG9naW4gaW5mbyBpbiBvdXIgZGF0YSBhbmQgc2V0IGhlYWRlciBpbiBjYXNlIGl0J3Mgbm90IHNldCBhbHJlYWR5XG4gICAgICAgICAgICB0aGlzLnVzZXIgPSB1c2VyO1xuICAgICAgICAgICAgdGhpcy5hdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsaWVudCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgcGF0aDogJy9zaWRlYmFyJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2p3dC10b2tlbicpIH1cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3NpZGViYXInLCBidG9hKHJlc3BvbnNlLmVudGl0eS5zaWRlYmFyKSk7XG4gICAgICAgICAgICAgICAgdGhhdC4kYnJvYWRjYXN0KCdzZXQtc2lkZWJhcicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVzdHJveUxvZ2luOiBmdW5jdGlvbiBkZXN0cm95TG9naW4odXNlcikge1xuICAgICAgICAgICAgLy8gQ2xlYW51cCB3aGVuIHRva2VuIHdhcyBpbnZhbGlkIG91ciB1c2VyIGhhcyBsb2dnZWQgb3V0XG4gICAgICAgICAgICB0aGlzLnVzZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmF1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdmF0YXInKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdlbXBsb3llZV9pZCcpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2p3dC10b2tlbicpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2xvZ2dlZCcpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Blcm1pc3Npb25zJyk7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnc2lkZWJhcicpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHJvdXRlLmF1dGgpIHRoaXMuJHJvdXRlLnJvdXRlci5nbygnL2xvZ2luJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9UaXRsZUNhc2U6IGZ1bmN0aW9uIHRvVGl0bGVDYXNlKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHdcXFMqL2csIGZ1bmN0aW9uICh0eHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHh0LnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlcGFyZVBlcm1pc3Npb246IGZ1bmN0aW9uIHByZXBhcmVQZXJtaXNzaW9uKCkge1xuICAgICAgICAgICAgdmFyIHJvdXRlX3BhdGggPSB0aGlzLiRyb3V0ZS5wYXRoLnN1YnN0cigxKTsgLy8gcmVtb3ZlcyB0aGUgZmlyc3QgY2hhcmFjdGVyICgnLycpIGluIHRoZSBwYXRoXG4gICAgICAgICAgICB2YXIgcm91dGVfZG90dGVkID0gcm91dGVfcGF0aC5yZXBsYWNlKC9cXC8vZywgJy4nKTtcbiAgICAgICAgICAgIHZhciByb3V0ZV9zZWdtZW50ID0gcm91dGVfcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICAgICAgdmFyIHJvdXRlX2lzX3BpbSA9IHJvdXRlX3NlZ21lbnRbMF0gPT0gJ3BpbSc7XG5cbiAgICAgICAgICAgIHRoaXMucGVybWlzc2lvbiA9IHJvdXRlX2RvdHRlZDtcbiAgICAgICAgICAgIGlmIChyb3V0ZV9pc19waW0pIHtcbiAgICAgICAgICAgICAgICByb3V0ZV9zZWdtZW50ID0gcm91dGVfc2VnbWVudFtyb3V0ZV9zZWdtZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMucGVybWlzc2lvbiA9ICdwaW0uJyArIHJvdXRlX3NlZ21lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucm91dGUgPSB7ICdwYXRoJzogcm91dGVfcGF0aCwgJ2RvdHRlZCc6IHJvdXRlX2RvdHRlZCwgJ3NlZ21lbnQnOiByb3V0ZV9zZWdtZW50LCAncGltJzogcm91dGVfaXNfcGltIH07XG5cbiAgICAgICAgICAgIHRoaXMuaGFzX2FjY2VzcyA9IEpTT04ucGFyc2UoYXRvYihsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGVybWlzc2lvbnMnKSkpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48cm91dGVyLXZpZXcgOmVtcGxveWVlPVxcXCJlbXBsb3llZVxcXCIgOnBhZ2VfdGl0bGU9XFxcInBhZ2VfdGl0bGVcXFwiIDpqb2JfdGl0bGVzPVxcXCJqb2JfdGl0bGVzXFxcIiA6ZW1wbG95bWVudF9zdGF0dXNlcz1cXFwiZW1wbG95bWVudF9zdGF0dXNlc1xcXCIgOnJvdXRlcz1cXFwicm91dGVzXFxcIiA6aGFzX2FjY2Vzcz1cXFwiaGFzX2FjY2Vzc1xcXCIgOnBlcm1pc3Npb249XFxcInBlcm1pc3Npb25cXFwiPjwvcm91dGVyLXZpZXc+XFxuXCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL2JraW50YW5hci9TaXRlcy9ocmlzL3dlYi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL2FwcC52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCJ2YXIgX192dWVpZnlfc3R5bGVfXyA9IHJlcXVpcmUoXCJ2dWVpZnktaW5zZXJ0LWNzc1wiKS5pbnNlcnQoXCJcXG4udGl0bGUge1xcbiAgICBjb2xvcjogIzk5OTtcXG4gICAgZm9udC13ZWlnaHQ6IDEwMDtcXG4gICAgZm9udC1mYW1pbHk6ICdMYXRvJywgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcbiAgICBmb250LXNpemU6IDYwcHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDQwcHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgbWFyZ2luLXRvcDogMjAlO1xcbn1cXG4udGl0bGUgYSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBtYXJnaW4tdG9wOiAyMHB4O1xcbn1cXG4udGl0bGUgYTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XCIpXG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImNvbnRhaW5lci1mbHVpZFxcXCI+XFxuXFx0PGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtM1xcXCI+PC9kaXY+XFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLW1kLTYgdGl0bGVcXFwiPlxcblxcdFxcdFxcdFNvcnJ5LCB3ZSBjb3VsZG4ndCBmaW5kIHdoYXQgeW91IHdlcmUgbG9va2luZyBmb3IgOi0oPGJyPlxcblxcdFxcdFxcdDxhIGhyZWY9XFxcIi9cXFwiPkdvIGJhY2sgdG8gdGhlIGhvbWVwYWdlPC9hPlxcblxcdFxcdDwvZGl2PlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbC1tZC0zXFxcIj48L2Rpdj5cXG5cXHQ8L2Rpdj5cXG48L2Rpdj5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvYmtpbnRhbmFyL1NpdGVzL2hyaXMvd2ViL3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvNDA0LnZ1ZVwiXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgcmVxdWlyZShcInZ1ZWlmeS1pbnNlcnQtY3NzXCIpLmNhY2hlW1wiXFxuLnRpdGxlIHtcXG4gICAgY29sb3I6ICM5OTk7XFxuICAgIGZvbnQtd2VpZ2h0OiAxMDA7XFxuICAgIGZvbnQtZmFtaWx5OiAnTGF0bycsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcXG4gICAgZm9udC1zaXplOiA2MHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiA0MHB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIG1hcmdpbi10b3A6IDIwJTtcXG59XFxuLnRpdGxlIGEge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgbWFyZ2luLXRvcDogMjBweDtcXG59XFxuLnRpdGxlIGE6aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxufVwiXSA9IGZhbHNlXG4gICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChfX3Z1ZWlmeV9zdHlsZV9fKVxuICB9KVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgICB0aGlzLiRkaXNwYXRjaCgndXBkYXRlUGFnZVRpdGxlJywgJ0xvZ2luJyk7XG4gICAgfSxcblxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAgICAgZW1haWw6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlczogW11cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgICBhdHRlbXB0OiBmdW5jdGlvbiBhdHRlbXB0KGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnL2xvZ2luJyxcbiAgICAgICAgICAgICAgICBlbnRpdHk6IHsgJ2VtYWlsJzogdGhpcy51c2VyLmVtYWlsLCAncGFzc3dvcmQnOiB0aGlzLnVzZXIucGFzc3dvcmQgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2xpZW50KHBhcmFtcykudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnand0LXRva2VuJywgJ0JlYXJlciAnICsgcmVzcG9uc2UuZW50aXR5LnRva2VuKTtcbiAgICAgICAgICAgICAgICB0aGF0LmdldFVzZXJEYXRhKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aGF0Lm1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVudGl0eS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1lc3NhZ2VzLnB1c2goeyB0eXBlOiAnZGFuZ2VyJywgbWVzc2FnZTogJ1NvcnJ5LCB5b3UgcHJvdmlkZWQgaW52YWxpZCBjcmVkZW50aWFscycgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VXNlckRhdGE6IGZ1bmN0aW9uIGdldFVzZXJEYXRhKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICBjbGllbnQoe1xuICAgICAgICAgICAgICAgIHBhdGg6ICcvdXNlcnMvbWU/aW5jbHVkZT1lbXBsb3llZSxyb2xlJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2p3dC10b2tlbicpIH1cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgndXNlckhhc0xvZ2dlZEluJywgcmVzcG9uc2UuZW50aXR5LmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoYXQuJHJvdXRlLnJvdXRlci5nbygnL2Rhc2hib2FyZCcpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcm91dGU6IHtcbiAgICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uIGFjdGl2YXRlKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCd1c2VySGFzTG9nZ2VkT3V0Jyk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcbjxkaXYgY2xhc3M9XFxcIm1pZGRsZS1ib3ggdGV4dC1jZW50ZXIgbG9naW5zY3JlZW4gYW5pbWF0ZWQgZmFkZUluRG93blxcXCI+XFxuICAgIDxkaXY+XFxuICAgICAgICA8ZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxvZ28td3JhcHBlclxcXCI+XFxuICAgICAgICAgICAgICAgIDxpbWcgc3JjPVxcXCIvaW1hZ2VzL2hyaXMtbG9nby5wbmdcXFwiPlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8aDM+V2VsY29tZSB0byBIUmlzPC9oMz5cXG5cXG4gICAgICAgIDxkaXYgaWQ9XFxcImFsZXJ0c1xcXCIgdi1pZj1cXFwibWVzc2FnZXMubGVuZ3RoID4gMFxcXCI+XFxuICAgICAgICAgICAgPGRpdiB2LWZvcj1cXFwibWVzc2FnZSBpbiBtZXNzYWdlc1xcXCIgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LXt7IG1lc3NhZ2UudHlwZSB9fSBhbGVydC1kaXNtaXNzaWJsZVxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiPlxcbiAgICAgICAgICAgICAgICB7eyBtZXNzYWdlLm1lc3NhZ2UgfX1cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGZvcm0gY2xhc3M9XFxcIm0tdFxcXCIgcm9sZT1cXFwiZm9ybVxcXCIgYWN0aW9uPVxcXCIvbG9naW5cXFwiIG1ldGhvZD1cXFwicG9zdFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCBmb3JtLWdyb3VwLWRlZmF1bHRcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiZW1haWxcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIHBsYWNlaG9sZGVyPVxcXCJFbWFpbFxcXCIgbmFtZT1cXFwiZW1haWxcXFwiIHJlcXVpcmVkPVxcXCJcXFwiIHYtbW9kZWw9XFxcInVzZXIuZW1haWxcXFwiIGFyaWEtcmVxdWlyZWQ9XFxcInRydWVcXFwiPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXAgZm9ybS1ncm91cC1kZWZhdWx0XFxcIj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInBhc3N3b3JkXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBwbGFjZWhvbGRlcj1cXFwiUGFzc3dvcmRcXFwiIG5hbWU9XFxcInBhc3N3b3JkXFxcIiByZXF1aXJlZD1cXFwiXFxcIiB2LW1vZGVsPVxcXCJ1c2VyLnBhc3N3b3JkXFxcIiBhcmlhLXJlcXVpcmVkPVxcXCJ0cnVlXFxcIj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnkgYmxvY2sgZnVsbC13aWR0aCBtLWJcXFwiIEBjbGljaz1cXFwiYXR0ZW1wdFxcXCI+TG9naW48L2J1dHRvbj5cXG5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNtYWxsPkZvcmdvdCBwYXNzd29yZD88L3NtYWxsPlxcbiAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8cCBjbGFzcz1cXFwidGV4dC1tdXRlZCB0ZXh0LWNlbnRlclxcXCI+XFxuICAgICAgICAgICAgICAgIDxzbWFsbD5EbyBub3QgaGF2ZSBhbiBhY2NvdW50Pzwvc21hbGw+XFxuICAgICAgICAgICAgPC9wPlxcbiAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi13aGl0ZSBidG4tYmxvY2tcXFwiIGhyZWY9XFxcIi9hdXRoL3JlZ2lzdGVyXFxcIj5DcmVhdGUgYW4gYWNjb3VudDwvYT5cXG4gICAgICAgIDwvZm9ybT5cXG4gICAgICAgIDxwIGNsYXNzPVxcXCJtLXRcXFwiPlxcbiAgICAgICAgICAgIDxzbWFsbD5iMyBTdHVkaW9zIMKpIDIwMTQ8L3NtYWxsPlxcbiAgICAgICAgPC9wPlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvYmtpbnRhbmFyL1NpdGVzL2hyaXMvd2ViL3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvYXV0aC9sb2dpbi52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHByb3BzOiBbJ2VtcGxveWVlJywgJ3BhZ2VfdGl0bGUnLCAnam9iX3RpdGxlcycsICdlbXBsb3ltZW50X3N0YXR1c2VzJywgJ3JvdXRlcycsICdoYXNfYWNjZXNzJywgJ3Blcm1pc3Npb24nXSxcbiAgICByb3V0ZToge1xuICAgICAgICBjYW5SZXVzZTogZmFsc2VcbiAgICB9LFxuICAgIGNvbXBpbGVkOiBmdW5jdGlvbiBjb21waWxlZCgpIHtcbiAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3VwZGF0ZS1wYWdlLXRpdGxlJywgJ0Rhc2hib2FyZCcpO1xuICAgIH0sXG4gICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuJHJvdXRlLnBhdGguaW5kZXhPZignL3BpbScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZW1wbG95ZWVfaWQgPSB0aGlzLiRyb3V0ZS5wYXJhbXMuZW1wbG95ZWVfaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtcGxveWVlX2lkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2VtcGxveWVlX2lkJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgcGF0aDogJy9lbXBsb3llZS9nZXQtYnktZW1wbG95ZWUtaWQ/aW5jbHVkZT11c2VyJyxcbiAgICAgICAgICAgIGVudGl0eTogeyAnZW1wbG95ZWVfaWQnOiB0aGlzLmVtcGxveWVlX2lkIH0sXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2p3dC10b2tlbicpIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjbGllbnQocGFyYW1zKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgndXBkYXRlLWVtcGxveWVlJywgcmVzcG9uc2UuZW50aXR5LmRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJyb3cgd3JhcHBlciBib3JkZXItYm90dG9tIHBhZ2UtaGVhZGluZ1xcXCIgOmNsYXNzPVxcXCJ7ICdncmFkLXJlZCc6ICgkcm91dGUucGF0aC5pbmRleE9mKCcvcGltJykgPT0gMCB8fCAkcm91dGUucGF0aC5pbmRleE9mKCcvYWRtaW4nKSA9PSAwKSwgJ2dyZWVucHJvLWJnJzogKCRyb3V0ZS5wYXRoLmluZGV4T2YoJy9waW0nKSA9PSAtMSAmYW1wOyZhbXA7ICRyb3V0ZS5wYXRoLmluZGV4T2YoJy9hZG1pbicpID09IC0xKSB9XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTZcXFwiPlxcbiAgICAgICAgPGgyPnt7cGFnZV90aXRsZX19PC9oMj5cXG4gICAgICAgIDwhLS0gQnJlYWRjcnVtYnMgLS0+XFxuICAgICAgICA8b2wgY2xhc3M9XFxcImJyZWFkY3J1bWJcXFwiPlxcbiAgICAgICAgICAgIDxsaT5cXG4gICAgICAgICAgICAgICAgPGEgdi1saW5rPVxcXCJ7bmFtZTogJ2Rhc2hib2FyZCd9XFxcIj5Ib21lPC9hPlxcbiAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPGxpIHYtZm9yPVxcXCJyb3V0ZSBpbiByb3V0ZXNcXFwiPlxcbiAgICAgICAgICAgICAgICA8YSB2LWxpbms9XFxcIntuYW1lOiByb3V0ZS5uYW1lLCBwYXJhbXM6IHtlbXBsb3llZV9pZDogcm91dGUucGFyYW1zLmVtcGxveWVlX2lkfSB9XFxcIj57e3JvdXRlLnNlZ21lbnR9fTwvYT5cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgPC9vbD5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLWxnLTEyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIndyYXBwZXIgd3JhcHBlci1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICA8cm91dGVyLXZpZXcgOmVtcGxveWVlPVxcXCJlbXBsb3llZVxcXCIgOnBhZ2VfdGl0bGU9XFxcInBhZ2VfdGl0bGVcXFwiIDpqb2JfdGl0bGVzPVxcXCJqb2JfdGl0bGVzXFxcIiA6ZW1wbG95bWVudF9zdGF0dXNlcz1cXFwiZW1wbG95bWVudF9zdGF0dXNlc1xcXCIgOnJvdXRlcz1cXFwicm91dGVzXFxcIiA6aGFzX2FjY2Vzcz1cXFwiaGFzX2FjY2Vzc1xcXCIgOnBlcm1pc3Npb249XFxcInBlcm1pc3Npb25cXFwiPjwvcm91dGVyLXZpZXc+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL2JraW50YW5hci9TaXRlcy9ocmlzL3dlYi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL2Rhc2hib2FyZC52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHByb3BzOiBbJ2VtcGxveWVlJywgJ3BhZ2VfdGl0bGUnLCAnam9iX3RpdGxlcycsICdlbXBsb3ltZW50X3N0YXR1c2VzJywgJ3JvdXRlcycsICdoYXNfYWNjZXNzJywgJ3Blcm1pc3Npb24nXSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9nZ2VkOiB7XG4gICAgICAgICAgICAgICAgYXZhdGFyOiAnJyxcbiAgICAgICAgICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbXBsb3llZToge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdF9uYW1lOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfbmFtZTogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2JfaGlzdG9yeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgam9iX3RpdGxlX2lkOiAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgY29tcGlsZWQ6IGZ1bmN0aW9uIGNvbXBpbGVkKCkge1xuICAgICAgICB0aGlzLmxvZ2dlZCA9IEpTT04ucGFyc2UoYXRvYihsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbG9nZ2VkJykpKTtcbiAgICAgICAgdGhpcy5sb2dnZWQuZW1wbG95ZWVfaWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZW1wbG95ZWVfaWQnKTtcbiAgICAgICAgdGhpcy5sb2dnZWQuYXZhdGFyID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F2YXRhcicpO1xuICAgICAgICB0aGlzLmxvZ2dlZC5oYXNfYWNjZXNzID0gSlNPTi5wYXJzZShhdG9iKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZXJtaXNzaW9ucycpKSk7XG4gICAgfVxufTtcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPGRpdiBpZD1cXFwid3JhcHBlclxcXCI+XFxuICAgIDxuYXYgY2xhc3M9XFxcIm5hdmJhci1kZWZhdWx0IG5hdmJhci1zdGF0aWMtc2lkZVxcXCIgcm9sZT1cXFwibmF2aWdhdGlvblxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzaWRlYmFyLWNvbGxhcHNlXFxcIj5cXG4gICAgICAgICAgICA8dWwgY2xhc3M9XFxcIm5hdiBtZXRpc21lbnVcXFwiIGlkPVxcXCJzaWRlLW1lbnVcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcIm5hdi1oZWFkZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZHJvcGRvd24gcHJvZmlsZS1lbGVtZW50XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBhbHQ9XFxcImltYWdlXFxcIiBpZD1cXFwicHJvZmlsZS1pbWFnZS1uYXZcXFwiIGNsYXNzPVxcXCJpbWctY2lyY2xlXFxcIiBzcmM9XFxcIi9pbWFnZXMvcHJvZmlsZS9kZWZhdWx0LzAucG5nXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIiBjbGFzcz1cXFwiZHJvcGRvd24tdG9nZ2xlXFxcIiBocmVmPVxcXCIjXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImNsZWFyXFxcIj4gPHNwYW4gY2xhc3M9XFxcImJsb2NrIG0tdC14c1xcXCI+IDxzdHJvbmcgY2xhc3M9XFxcImZvbnQtYm9sZFxcXCI+e3tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlZC5lbXBsb3llZS5kYXRhLmZpcnN0X25hbWUgfX0ge3sgbG9nZ2VkLmVtcGxveWVlLmRhdGEubGFzdF9uYW1lIH19PC9zdHJvbmc+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+IDxzcGFuIGNsYXNzPVxcXCJ0ZXh0LW11dGVkIHRleHQteHMgYmxvY2tcXFwiIHYtaWY9XFxcImpvYl90aXRsZXNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7am9iX3RpdGxlc1tsb2dnZWQuZW1wbG95ZWUuZGF0YS5qb2JfaGlzdG9yeS5kYXRhLmpvYl90aXRsZV9pZF19fVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGIgY2xhc3M9XFxcImNhcmV0XFxcIj48L2I+PC9zcGFuPiA8L3NwYW4+IDwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcImRyb3Bkb3duLW1lbnUgYW5pbWF0ZWQgZmFkZUluUmlnaHQgbS10LXhzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxhIGhyZWY9XFxcIi9wcm9maWxlXFxcIj5Qcm9maWxlPC9hPjwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48YSBocmVmPVxcXCJjb250YWN0cy5odG1sXFxcIj5Db250YWN0czwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwibWFpbGJveC5odG1sXFxcIj5NYWlsYm94PC9hPjwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwiZGl2aWRlclxcXCI+PC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxhIGhyZWY9XFxcIiMwXFxcIj5Mb2dvdXQ8L2E+PC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsb2dvLWVsZW1lbnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIEhSaXNcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8bmF2YmFyLXN0YXRpYy1zaWRlPjwvbmF2YmFyLXN0YXRpYy1zaWRlPlxcbiAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9uYXY+XFxuICAgIDxkaXYgaWQ9XFxcInBhZ2Utd3JhcHBlclxcXCIgY2xhc3M9XFxcImdyYXktYmdcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93IGJvcmRlci1ib3R0b21cXFwiPlxcbiAgICAgICAgICAgIDxuYXZiYXItc3RhdGljLXRvcD48L25hdmJhci1zdGF0aWMtdG9wPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8cm91dGVyLXZpZXcgOmVtcGxveWVlPVxcXCJlbXBsb3llZVxcXCIgOnBhZ2VfdGl0bGU9XFxcInBhZ2VfdGl0bGVcXFwiIDpqb2JfdGl0bGVzPVxcXCJqb2JfdGl0bGVzXFxcIiA6ZW1wbG95bWVudF9zdGF0dXNlcz1cXFwiZW1wbG95bWVudF9zdGF0dXNlc1xcXCIgOnJvdXRlcz1cXFwicm91dGVzXFxcIiA6aGFzX2FjY2Vzcz1cXFwiaGFzX2FjY2Vzc1xcXCIgOnBlcm1pc3Npb249XFxcInBlcm1pc3Npb25cXFwiPjwvcm91dGVyLXZpZXc+XFxuICAgICAgICA8c3RhdGljLWZvb3Rlcj48L3N0YXRpYy1mb290ZXI+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9ia2ludGFuYXIvU2l0ZXMvaHJpcy93ZWIvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9kZWZhdWx0LXBhZ2UudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBwcm9wczogWydlbXBsb3llZScsICdwYWdlX3RpdGxlJywgJ2pvYl90aXRsZXMnLCAnZW1wbG95bWVudF9zdGF0dXNlcycsICdyb3V0ZXMnLCAnaGFzX2FjY2VzcycsICdwZXJtaXNzaW9uJ10sXG4gICAgcm91dGU6IHtcbiAgICAgICAgY2FuUmV1c2U6IGZhbHNlXG4gICAgfVxufTtcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPGRpdiBjbGFzcz1cXFwicm93IHdyYXBwZXIgYm9yZGVyLWJvdHRvbSBwYWdlLWhlYWRpbmdcXFwiIDpjbGFzcz1cXFwieyAnZ3JhZC1yZWQnOiAoJHJvdXRlLnBhdGguaW5kZXhPZignL3BpbScpID09IDAgfHwgJHJvdXRlLnBhdGguaW5kZXhPZignL2FkbWluJykgPT0gMCksICdncmVlbnByby1iZyc6ICgkcm91dGUucGF0aC5pbmRleE9mKCcvcGltJykgPT0gLTEgJmFtcDsmYW1wOyAkcm91dGUucGF0aC5pbmRleE9mKCcvYWRtaW4nKSA9PSAtMSkgfVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS02XFxcIj5cXG4gICAgICAgIDxoMj57e3BhZ2VfdGl0bGV9fTwvaDI+XFxuICAgICAgICA8IS0tIEJyZWFkY3J1bWJzIC0tPlxcbiAgICAgICAgPG9sIGNsYXNzPVxcXCJicmVhZGNydW1iXFxcIj5cXG4gICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgIDxhIHYtbGluaz1cXFwie25hbWU6ICdkYXNoYm9hcmQnfVxcXCI+SG9tZTwvYT5cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDxsaSB2LWZvcj1cXFwicm91dGUgaW4gcm91dGVzXFxcIj5cXG4gICAgICAgICAgICAgICAgPGEgdi1saW5rPVxcXCJ7bmFtZTogcm91dGUubmFtZSwgcGFyYW1zOiB7ZW1wbG95ZWVfaWQ6IHJvdXRlLnBhcmFtcy5lbXBsb3llZV9pZH0gfVxcXCI+e3tyb3V0ZS5zZWdtZW50fX08L2E+XFxuICAgICAgICAgICAgPC9saT5cXG4gICAgICAgIDwvb2w+XFxuICAgIDwvZGl2PlxcbiAgICA8YWN0aW9uLWFyZWEgOmVtcGxveWVlPVxcXCJlbXBsb3llZVxcXCIgOmpvYl90aXRsZXM9XFxcImpvYl90aXRsZXNcXFwiIDplbXBsb3ltZW50X3N0YXR1c2VzPVxcXCJlbXBsb3ltZW50X3N0YXR1c2VzXFxcIiB2LWlmPVxcXCIkcm91dGUucGF0aC5pbmRleE9mKCdlbXBsb3llZS1saXN0LycpID4gLTEgfHwgJHJvdXRlLnBhdGguaW5kZXhPZigncHJvZmlsZS8nKSA+IC0xXFxcIj48L2FjdGlvbi1hcmVhPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1sZy0xMlxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ3cmFwcGVyIHdyYXBwZXItY29udGVudFxcXCI+XFxuICAgICAgICAgICAgPHJvdXRlci12aWV3IDplbXBsb3llZT1cXFwiZW1wbG95ZWVcXFwiIDpwYWdlX3RpdGxlPVxcXCJwYWdlX3RpdGxlXFxcIiA6am9iX3RpdGxlcz1cXFwiam9iX3RpdGxlc1xcXCIgOmVtcGxveW1lbnRfc3RhdHVzZXM9XFxcImVtcGxveW1lbnRfc3RhdHVzZXNcXFwiIDpyb3V0ZXM9XFxcInJvdXRlc1xcXCIgOmhhc19hY2Nlc3M9XFxcImhhc19hY2Nlc3NcXFwiIDpwZXJtaXNzaW9uPVxcXCJwZXJtaXNzaW9uXFxcIj48L3JvdXRlci12aWV3PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9ia2ludGFuYXIvU2l0ZXMvaHJpcy93ZWIvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9wYWdlLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcHJvcHM6IFsnZW1wbG95ZWUnLCAncGFnZV90aXRsZScsICdqb2JfdGl0bGVzJywgJ2VtcGxveW1lbnRfc3RhdHVzZXMnLCAncm91dGVzJywgJ2hhc19hY2Nlc3MnLCAncGVybWlzc2lvbiddLFxuICAgIGNvbXBpbGVkOiBmdW5jdGlvbiBjb21waWxlZCgpIHtcbiAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3VwZGF0ZS1wYWdlLXRpdGxlJywgKHRoaXMuJHJvdXRlLnBhdGguaW5kZXhPZigncGltJykgPiAtMSA/ICdFbXBsb3llZVxcJ3MgJyA6ICdNeSAnKSArICdDb250YWN0IERldGFpbHMnKTtcbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogJycsXG4gICAgICAgICAgICBhZGRyZXNzX2NpdHlfb2JqOiB7fSxcbiAgICAgICAgICAgIGFkZHJlc3NfcHJvdmluY2Vfb2JqOiB7fSxcbiAgICAgICAgICAgIGFkZHJlc3NfY291bnRyeV9vYmo6IHt9LFxuICAgICAgICAgICAgY2l0eTogJycsXG4gICAgICAgICAgICBjaXRpZXNfY2hvc2VuOiBbe31dLFxuICAgICAgICAgICAgcHJvdmluY2U6ICcnLFxuICAgICAgICAgICAgcHJvdmluY2VzX2Nob3NlbjogW3t9XSxcbiAgICAgICAgICAgIGNvdW50cnk6ICcnLFxuICAgICAgICAgICAgY291bnRyaWVzX2Nob3NlbjogW3t9XVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICB3YXRjaDoge1xuICAgICAgICAnYWRkcmVzc19wcm92aW5jZV9vYmonOiBmdW5jdGlvbiBhZGRyZXNzX3Byb3ZpbmNlX29iaigpIHtcbiAgICAgICAgICAgIC8vIHJldHJpZXZlIGNpdGllc1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRkcmVzc19wcm92aW5jZV9vYmopIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNob3NlbkNpdGllcyh0aGlzLmFkZHJlc3NfcHJvdmluY2Vfb2JqLmlkLCBmYWxzZSk7IC8vIGNhbGwgdHdpY2Ugc2luY2UgdGhlcmUncyBhIGJ1ZyBpbiBjaG9zZW4uanMgdnVlIGRpcmVjdGl2ZS5cbiAgICAgICAgICAgICAgICB0aGlzLmNob3NlbkNpdGllcyh0aGlzLmFkZHJlc3NfcHJvdmluY2Vfb2JqLmlkLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ2NpdGllc19jaG9zZW4nOiBmdW5jdGlvbiBjaXRpZXNfY2hvc2VuKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNpdGllc19jaG9zZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbXBsb3llZS5hZGRyZXNzX2NpdHlfaWQgPT0gdGhpcy5jaXRpZXNfY2hvc2VuW2ldLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkcmVzc19jaXR5X29iaiA9IHRoaXMuY2l0aWVzX2Nob3NlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgdGhpcy5xdWVyeURhdGFiYXNlKCk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHF1ZXJ5RGF0YWJhc2U6IGZ1bmN0aW9uIHF1ZXJ5RGF0YWJhc2UoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLiRyb3V0ZS5wYXRoLmluZGV4T2YoJy9waW0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbXBsb3llZV9pZCA9IHRoaXMuJHJvdXRlLnBhcmFtcy5lbXBsb3llZV9pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbXBsb3llZV9pZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdlbXBsb3llZV9pZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHBhdGg6ICcvZW1wbG95ZWUvZ2V0LWJ5LWVtcGxveWVlLWlkP2luY2x1ZGU9dXNlcicsXG4gICAgICAgICAgICAgICAgZW50aXR5OiB7ICdlbXBsb3llZV9pZCc6IHRoaXMuZW1wbG95ZWVfaWQgfSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2p3dC10b2tlbicpIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNsaWVudChwYXJhbXMpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgndXBkYXRlLWVtcGxveWVlJywgcmVzcG9uc2UuZW50aXR5LmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5jaG9zZW5Qcm92aW5jZXMoKTtcbiAgICAgICAgICAgICAgICB0aGF0LmNob3NlbkNvdW50cmllcygpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3VibWl0Rm9ybTogZnVuY3Rpb24gc3VibWl0Rm9ybSgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gamFzbnkgYnVnIHdvcmsgYXJvdW5kXG4gICAgICAgICAgICAkKCcjYWRkcmVzc18xJykuZm9jdXMoKTtcblxuICAgICAgICAgICAgLy8gU2V0IHZhbHVlc1xuICAgICAgICAgICAgdGhpcy5lbXBsb3llZS5hZGRyZXNzX2NpdHlfaWQgPSB0aGlzLmFkZHJlc3NfY2l0eV9vYmouaWQ7XG4gICAgICAgICAgICB0aGlzLmVtcGxveWVlLmFkZHJlc3NfcHJvdmluY2VfaWQgPSB0aGlzLmFkZHJlc3NfcHJvdmluY2Vfb2JqLmlkO1xuICAgICAgICAgICAgdGhpcy5lbXBsb3llZS5hZGRyZXNzX2NvdW50cnlfaWQgPSB0aGlzLmFkZHJlc3NfY291bnRyeV9vYmouaWQ7XG5cbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcGF0aDogJy9wcm9maWxlL2NvbnRhY3QtZGV0YWlscycsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGVudGl0eTogeyAnZW1wbG95ZWUnOiB0aGlzLmVtcGxveWVlIH0sXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdqd3QtdG9rZW4nKSB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjbGllbnQocGFyYW1zKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LiRyb3V0ZS5wYXRoLmluZGV4T2YoJy9waW0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC4kcm91dGUucm91dGVyLmdvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3BpbS1lbXBsb3llZS1saXN0LWNvbnRhY3QtZGV0YWlscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogeyBlbXBsb3llZV9pZDogcmVzcG9uc2UuZW50aXR5LmVtcGxveWVlLmVtcGxveWVlX2lkIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc3dhbCh7IHRpdGxlOiByZXNwb25zZS5lbnRpdHkuc3RhdHVzLCB0eXBlOiAnc3VjY2VzcycsIHRpbWVyOiAyMDAwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jYW5jZWxGb3JtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FsKHsgdGl0bGU6IHJlc3BvbnNlLmVudGl0eS5zdGF0dXMsIHR5cGU6ICd3YXJuaW5nJywgdGltZXI6IDIwMDAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1MDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjZmlyc3RfbmFtZScpLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FsKHsgdGl0bGU6IHJlc3BvbnNlLmVudGl0eS5zdGF0dXMsIHR5cGU6ICdlcnJvcicsIHRpbWVyOiAyMDAwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW9kaWZ5Rm9ybTogZnVuY3Rpb24gbW9kaWZ5Rm9ybSgpIHtcblxuICAgICAgICAgICAgJCgnLnNhdmUtZm9ybScpLmNzcygnZGlzcGxheScsICcnKTtcbiAgICAgICAgICAgICQoJy5tb2RpZnktZm9ybScpLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgICAgICAkKCcudnVlLWNob3NlbicpLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpLnRyaWdnZXIoXCJjaG9zZW46dXBkYXRlZFwiKTtcbiAgICAgICAgICAgICQoJy5mb3JtLWNvbnRyb2wnKS5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcblxuICAgICAgICAgICAgJCgnI2FkZHJlc3NfMScpLmZvY3VzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FuY2VsRm9ybTogZnVuY3Rpb24gY2FuY2VsRm9ybSgpIHtcbiAgICAgICAgICAgIC8vIHJldHJpZXZlIG9yaWdpbmFsIGRhdGEgc2luY2UgY2FuY2VsIGJ1dHRvbiB3YXMgcHJlc3NlZC5cbiAgICAgICAgICAgIHRoaXMucXVlcnlEYXRhYmFzZSgpO1xuXG4gICAgICAgICAgICAkKCcuc2F2ZS1mb3JtJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICAgICQoJy5tb2RpZnktZm9ybScpLmNzcygnZGlzcGxheScsICcnKTtcbiAgICAgICAgICAgICQoJy52dWUtY2hvc2VuJykucHJvcCgnZGlzYWJsZWQnLCB0cnVlKS50cmlnZ2VyKFwiY2hvc2VuOnVwZGF0ZWRcIik7XG4gICAgICAgICAgICAkKCcuZm9ybS1jb250cm9sJykucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjaG9zZW5Qcm92aW5jZXM6IGZ1bmN0aW9uIGNob3NlblByb3ZpbmNlcygpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gcmV0cmlldmUgcHJvdmluY2VzXG4gICAgICAgICAgICBjbGllbnQoe1xuICAgICAgICAgICAgICAgIHBhdGg6ICcvcHJvdmluY2VzJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2p3dC10b2tlbicpIH1cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucHJvdmluY2VzX2Nob3NlbiA9IHJlc3BvbnNlLmVudGl0eTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGF0LmFkZHJlc3NfcHJvdmluY2Vfb2JqID0gdGhhdC5wcm92aW5jZXNfY2hvc2VuW3RoYXQuZW1wbG95ZWUuYWRkcmVzc19wcm92aW5jZV9pZCAtIDFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2hvc2VuQ291bnRyaWVzOiBmdW5jdGlvbiBjaG9zZW5Db3VudHJpZXMoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIHJldHJpZXZlIGNvdW50cmllc1xuICAgICAgICAgICAgY2xpZW50KHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnL2NvdW50cmllcycsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdqd3QtdG9rZW4nKSB9XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmNvdW50cmllc19jaG9zZW4gPSByZXNwb25zZS5lbnRpdHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhhdC5hZGRyZXNzX2NvdW50cnlfb2JqID0gdGhhdC5jb3VudHJpZXNfY2hvc2VuW3RoYXQuZW1wbG95ZWUuYWRkcmVzc19jb3VudHJ5X2lkIC0gMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjaG9zZW5DaXRpZXM6IGZ1bmN0aW9uIGNob3NlbkNpdGllcyh2YWx1ZSwgb3Blbikge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyByZXRyaWV2ZSBjaXRpZXNcbiAgICAgICAgICAgIGNsaWVudCh7XG4gICAgICAgICAgICAgICAgcGF0aDogJy9jaXRpZXM/cHJvdmluY2VfaWQ9JyArIHZhbHVlLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnand0LXRva2VuJykgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jaXRpZXNfY2hvc2VuID0gcmVzcG9uc2UuZW50aXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkKCcudnVlLWNob3NlbicpLnRyaWdnZXIoXCJjaG9zZW46dXBkYXRlZFwiKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICQoJyNhZGRyZXNzX2NpdHlfaWQnKS50cmlnZ2VyKFwiY2hvc2VuOm9wZW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJyb3dcXFwiIHYtaWY9XFxcImVtcGxveWVlXFxcIj5cXG4gICAgPG5hdmJhci1zdGF0aWMtcHJvZmlsZS10b3A+PC9uYXZiYXItc3RhdGljLXByb2ZpbGUtdG9wPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbGctMTJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaWJveCBmbG9hdC1lLW1hcmdpbnNcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImlib3gtdGl0bGVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aDU+Q29udGFjdCBEZXRhaWxzPC9oNT5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaWJveC10b29sc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwiY29sbGFwc2UtbGlua1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tdXBcXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaWJveC1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICAgICAgPGZvcm0gbWV0aG9kPVxcXCJQT1NUXFxcIiBvbnN1Ym1pdD1cXFwicmV0dXJuIGZhbHNlO1xcXCIgYWNjZXB0LWNoYXJzZXQ9XFxcIlVURi04XFxcIiBjbGFzcz1cXFwiZm9ybS1ob3Jpem9udGFsXFxcIiBpZD1cXFwicGVyc29uYWxEZXRhaWxzRm9ybVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgbmFtZT1cXFwidXNlcltpZF1cXFwiIHR5cGU9XFxcImhpZGRlblxcXCIgdi1tb2RlbD1cXFwiZW1wbG95ZWUudXNlci5pZFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgbmFtZT1cXFwiaWRcXFwiIHR5cGU9XFxcImhpZGRlblxcXCIgdi1tb2RlbD1cXFwiZW1wbG95ZWUuaWRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPCEtLSBTdGFydCAtIEFkZHJlc3MgU3RyZWV0IC0tPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiYWRkcmVzc18xXFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCI+QWRkcmVzcyBTdHJlZXQgMTwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiB2LW1vZGVsPVxcXCJlbXBsb3llZS5hZGRyZXNzXzFcXFwiIGlkPVxcXCJhZGRyZXNzXzFcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImFkZHJlc3NfMlxcXCIgY2xhc3M9XFxcImNvbC1tZC0yIGNvbnRyb2wtbGFiZWxcXFwiPkFkZHJlc3MgU3RyZWV0IDI8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC00XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgbmFtZT1cXFwiYWRkcmVzc18yXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiB2LW1vZGVsPVxcXCJlbXBsb3llZS5hZGRyZXNzXzJcXFwiIGlkPVxcXCJhZGRyZXNzXzJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8IS0tIEVuZCAtIEFkZHJlc3MgU3RyZWV0IC0tPlxcblxcbiAgICAgICAgICAgICAgICAgICAgPCEtLSBTdGFydCAtIENpdHkgJiBQcm92aW5jZSAtLT5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImFkZHJlc3NfY2l0eV9pZFxcXCIgY2xhc3M9XFxcImNvbC1tZC0yIGNvbnRyb2wtbGFiZWxcXFwiPkNpdHk8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC00XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNob3NlbiBpZD1cXFwiYWRkcmVzc19jaXR5X2lkXFxcIiBkaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIGNsYXNzPVxcXCJ2dWUtY2hvc2VuXFxcIiA6b3B0aW9ucz1cXFwiY2l0aWVzX2Nob3NlblxcXCIgOnYtbW9kZWwuc3luYz1cXFwiYWRkcmVzc19jaXR5X29ialxcXCIgOmNob3Nlbj1cXFwieyB3aWR0aDonMTAwJScgfVxcXCIgcGxhY2Vob2xkZXI9XFxcIi0tLSBTZWxlY3QgLS0tXFxcIiB0ZXh0LWtleT1cXFwibmFtZVxcXCI+PC9jaG9zZW4+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiYWRkcmVzc19wcm92aW5jZV9pZFxcXCIgY2xhc3M9XFxcImNvbC1tZC0yIGNvbnRyb2wtbGFiZWxcXFwiPlByb3ZpbmNlPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaG9zZW4gaWQ9XFxcImFkZHJlc3NfcHJvdmluY2VfaWRcXFwiIGRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgY2xhc3M9XFxcInZ1ZS1jaG9zZW5cXFwiIDpvcHRpb25zPVxcXCJwcm92aW5jZXNfY2hvc2VuXFxcIiA6di1tb2RlbC5zeW5jPVxcXCJhZGRyZXNzX3Byb3ZpbmNlX29ialxcXCIgOmNob3Nlbj1cXFwieyB3aWR0aDonMTAwJScgfVxcXCIgcGxhY2Vob2xkZXI9XFxcIi0tLSBTZWxlY3QgLS0tXFxcIiB0ZXh0LWtleT1cXFwibmFtZVxcXCI+PC9jaG9zZW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gRW5kIC0gQ2l0eSAmIFByb3ZpbmNlIC0tPlxcblxcbiAgICAgICAgICAgICAgICAgICAgPCEtLSBTdGFydCAtIFppcC9Qb3N0YWwgQ29kZSAmIENvdW50cnkgLS0+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJhZGRyZXNzX3Bvc3RhbF9jb2RlXFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCIgZGF0YS1tYXNrPVxcXCI5OTk5XFxcIj5aaXAvUG9zdGFsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvZGU8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC00XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgbmFtZT1cXFwiYWRkcmVzc19wb3N0YWxfY29kZVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgdi1tb2RlbD1cXFwiZW1wbG95ZWUuYWRkcmVzc19wb3N0YWxfY29kZVxcXCIgaWQ9XFxcImFkZHJlc3NfcG9zdGFsX2NvZGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImFkZHJlc3NfY291bnRyeV9pZFxcXCIgY2xhc3M9XFxcImNvbC1tZC0yIGNvbnRyb2wtbGFiZWxcXFwiPkNvdW50cnk8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC00XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNob3NlbiBpZD1cXFwiYWRkcmVzc19jb3VudHJ5X2lkXFxcIiBkaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIGNsYXNzPVxcXCJ2dWUtY2hvc2VuXFxcIiA6b3B0aW9ucz1cXFwiY291bnRyaWVzX2Nob3NlblxcXCIgOnYtbW9kZWwuc3luYz1cXFwiYWRkcmVzc19jb3VudHJ5X29ialxcXCIgOmNob3Nlbj1cXFwieyB3aWR0aDonMTAwJScgfVxcXCIgcGxhY2Vob2xkZXI9XFxcIi0tLSBTZWxlY3QgLS0tXFxcIiB0ZXh0LWtleT1cXFwibmFtZVxcXCI+PC9jaG9zZW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gRW5kIC0gWmlwL1Bvc3RhbCBDb2RlICYgQ291bnRyeSAtLT5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhyLWxpbmUtZGFzaGVkXFxcIj48L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gU3RhcnQgLSBIb21lICYgTW9iaWxlIC0tPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiaG9tZV9waG9uZVxcXCIgY2xhc3M9XFxcImNvbC1tZC0yIGNvbnRyb2wtbGFiZWxcXFwiPkhvbWUgVGVsZXBob25lPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBkYXRhLW1hc2s9XFxcIjA5OSA5OTkgOTk5OVxcXCIgZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIiBuYW1lPVxcXCJob21lX3Bob25lXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiB2LW1vZGVsPVxcXCJlbXBsb3llZS5ob21lX3Bob25lXFxcIiBpZD1cXFwiaG9tZV9waG9uZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwibW9iaWxlX3Bob25lXFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCI+TW9iaWxlPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBkYXRhLW1hc2s9XFxcIjA5OTkgOTk5IDk5OTlcXFwiIGRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgbmFtZT1cXFwibW9iaWxlX3Bob25lXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiB2LW1vZGVsPVxcXCJlbXBsb3llZS5tb2JpbGVfcGhvbmVcXFwiIGlkPVxcXCJtb2JpbGVfcGhvbmVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8IS0tIEVuZCAtIEhvbWUgJiBNb2JpbGUgLS0+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoci1saW5lLWRhc2hlZFxcXCI+PC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8IS0tIFN0YXJ0IC0gRW1haWwgLS0+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJ3b3JrX2VtYWlsXFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCI+V29yayBFbWFpbDwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIiBuYW1lPVxcXCJ3b3JrX2VtYWlsXFxcIiB0eXBlPVxcXCJlbWFpbFxcXCIgdi1tb2RlbD1cXFwiZW1wbG95ZWUud29ya19lbWFpbFxcXCIgaWQ9XFxcIndvcmtfZW1haWxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcIm90aGVyX2VtYWlsXFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCI+T3RoZXIgRW1haWw8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC00XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgbmFtZT1cXFwib3RoZXJfZW1haWxcXFwiIHR5cGU9XFxcImVtYWlsXFxcIiB2LW1vZGVsPVxcXCJlbXBsb3llZS5vdGhlcl9lbWFpbFxcXCIgaWQ9XFxcIm90aGVyX2VtYWlsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaHItbGluZS1kYXNoZWRcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPCEtLSBFbmQgLSBFbWFpbCAtLT5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gU3RhcnQgLSBDb250cm9sIEJ1dHRvbnMgLS0+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIHNhdmUtZm9ybVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTtcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS00IGNvbC1zbS1vZmZzZXQtMlxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJidG4gYnRuLXdoaXRlIGJ0bi14cyBjYW5jZWwtZm9ybVxcXCIgQGNsaWNrPVxcXCJjYW5jZWxGb3JtXFxcIj5DYW5jZWw8L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi14c1xcXCIgdHlwZT1cXFwic3VibWl0XFxcIiBAY2xpY2s9XFxcInN1Ym1pdEZvcm1cXFwiIHZhbHVlPVxcXCJTYXZlIGNoYW5nZXNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIiB2LWlmPVxcXCJoYXNfYWNjZXNzICZhbXA7JmFtcDsgaGFzX2FjY2Vzc1twZXJtaXNzaW9uICsgJy51cGRhdGUnXVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTQgY29sLXNtLW9mZnNldC0yXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeSBidG4teHMgbW9kaWZ5LWZvcm1cXFwiIEBjbGljaz1cXFwibW9kaWZ5Rm9ybVxcXCI+TW9kaWZ5PC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8IS0tIEVuZCAtIENvbnRyb2wgQnV0dG9ucyAtLT5cXG4gICAgICAgICAgICAgICAgPC9mb3JtPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9ia2ludGFuYXIvU2l0ZXMvaHJpcy93ZWIvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9wcm9maWxlL2NvbnRhY3QtZGV0YWlscy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHByb3BzOiBbJ2VtcGxveWVlJywgJ3BhZ2VfdGl0bGUnLCAnam9iX3RpdGxlcycsICdlbXBsb3ltZW50X3N0YXR1c2VzJywgJ3JvdXRlcycsICdoYXNfYWNjZXNzJywgJ3Blcm1pc3Npb24nXSxcbiAgICBjb21waWxlZDogZnVuY3Rpb24gY29tcGlsZWQoKSB7XG4gICAgICAgIHRoaXMuJGRpc3BhdGNoKCd1cGRhdGUtcGFnZS10aXRsZScsICh0aGlzLiRyb3V0ZS5wYXRoLmluZGV4T2YoJ3BpbScpID4gLTEgPyAnRW1wbG95ZWVcXCdzICcgOiAnTXkgJykgKyAnRGVwZW5kZW50cycpO1xuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVkaXRNb2RlOiBmYWxzZSxcbiAgICAgICAgICAgIGVtcGxveWVlX2lkOiAnJyxcbiAgICAgICAgICAgIGRlcGVuZGVudHM6IFtdLFxuICAgICAgICAgICAgcmVsYXRpb25zaGlwczogW10sXG4gICAgICAgICAgICByZWxhdGlvbnNoaXBzX2Nob3NlbjogW3t9XSxcbiAgICAgICAgICAgIHJlbGF0aW9uc2hpcF9vYmo6IHt9LFxuICAgICAgICAgICAgbW9kYWw6IHtcbiAgICAgICAgICAgICAgICBmaXJzdF9uYW1lOiAnJyxcbiAgICAgICAgICAgICAgICBtaWRkbGVfbmFtZTogJycsXG4gICAgICAgICAgICAgICAgbGFzdF9uYW1lOiAnJyxcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBfaWQ6ICcnLFxuICAgICAgICAgICAgICAgIGJpcnRoX2RhdGU6ICcnLFxuICAgICAgICAgICAgICAgIGRlcGVuZGVudF9pZDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMucXVlcnlEYXRhYmFzZSgpO1xuICAgICAgICB0aGlzLmNob3NlblJlbGF0aW9uc2hpcHMoKTtcblxuICAgICAgICAkKFwiI2RlcGVuZGVudHNGb3JtXCIpLnN1Ym1pdChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgcXVlcnlEYXRhYmFzZTogZnVuY3Rpb24gcXVlcnlEYXRhYmFzZSgpIHtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAodGhpcy4kcm91dGUucGF0aC5pbmRleE9mKCcvcGltJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1wbG95ZWVfaWQgPSB0aGlzLiRyb3V0ZS5wYXJhbXMuZW1wbG95ZWVfaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1wbG95ZWVfaWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZW1wbG95ZWVfaWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnL2VtcGxveWVlL2dldC1ieS1lbXBsb3llZS1pZD9pbmNsdWRlPXVzZXIsZGVwZW5kZW50cycsXG4gICAgICAgICAgICAgICAgZW50aXR5OiB7ICdlbXBsb3llZV9pZCc6IHRoaXMuZW1wbG95ZWVfaWQgfSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2p3dC10b2tlbicpIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNsaWVudChwYXJhbXMpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgndXBkYXRlLWVtcGxveWVlJywgcmVzcG9uc2UuZW50aXR5LmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgY2xpZW50KHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9yZWxhdGlvbnNoaXBzP3RhYmxlX3ZpZXc9dHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnand0LXRva2VuJykgfVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucmVsYXRpb25zaGlwcyA9IHJlc3BvbnNlLmVudGl0eTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMuY29kZSA9PSA0MjIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC4kcm91dGUucm91dGVyLmdvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdlcnJvci00MDQnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZS5lbnRpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGVNb2RhbDogZnVuY3Rpb24gdG9nZ2xlTW9kYWwoKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZWRpdE1vZGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgdGhpcy5tb2RhbC5maXJzdF9uYW1lID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1vZGFsLm1pZGRsZV9uYW1lID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1vZGFsLmxhc3RfbmFtZSA9ICcnO1xuICAgICAgICAgICAgdGhpcy5tb2RhbC5yZWxhdGlvbnNoaXBfaWQgPSAnJztcbiAgICAgICAgICAgIHRoaXMucmVsYXRpb25zaGlwX29iaiA9ICcnO1xuICAgICAgICAgICAgdGhpcy5tb2RhbC5iaXJ0aF9kYXRlID0gJyc7XG5cbiAgICAgICAgICAgIC8vIGRhdGVwaWNrZXIgZm9yIGJpcnRoX2RhdGVcbiAgICAgICAgICAgICQoJy5pbnB1dC1ncm91cC5kYXRlJykuZGF0ZXBpY2tlcih7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAneXl5eS1tbS1kZCcsXG4gICAgICAgICAgICAgICAga2V5Ym9hcmROYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmb3JjZVBhcnNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNhbGVuZGFyV2Vla3M6IHRydWUsXG4gICAgICAgICAgICAgICAgYXV0b2Nsb3NlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNsZWFyQnRuOiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJCgnI2RlcGVuZGVudF9tb2RhbCcpLm1vZGFsKCd0b2dnbGUnKTtcbiAgICAgICAgICAgICQoJyNkZXBlbmRlbnRfbW9kYWwnKS5vbignc2hvd24uYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJCgnLnZ1ZS1jaG9zZW4nLCB0aGlzKS50cmlnZ2VyKCdjaG9zZW46dXBkYXRlZCcpO1xuICAgICAgICAgICAgICAgICQoJyNmaXJzdF9uYW1lJykuZm9jdXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzdWJtaXRGb3JtOiBmdW5jdGlvbiBzdWJtaXRGb3JtKCkge1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGphc255IGJ1ZyB3b3JrIGFyb3VuZFxuICAgICAgICAgICAgJCgnI2ZpcnN0X25hbWUnKS5mb2N1cygpO1xuXG4gICAgICAgICAgICB0aGF0Lm1vZGFsLmVtcGxveWVlX2lkID0gdGhhdC5lbXBsb3llZS5pZDtcbiAgICAgICAgICAgIHRoYXQubW9kYWwucmVsYXRpb25zaGlwX2lkID0gdGhhdC5yZWxhdGlvbnNoaXBfb2JqLmlkO1xuXG4gICAgICAgICAgICBpZiAodGhhdC5tb2RhbC5yZWxhdGlvbnNoaXBfaWQgJiYgdGhhdC5tb2RhbC5maXJzdF9uYW1lICYmIHRoYXQubW9kYWwubGFzdF9uYW1lKSB7XG5cbiAgICAgICAgICAgICAgICBjbGllbnQoe1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnL3Byb2ZpbGUvZGVwZW5kZW50cycsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogdGhhdC5lZGl0TW9kZSA/ICdQQVRDSCcgOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eTogdGhhdC5tb2RhbCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdqd3QtdG9rZW4nKSB9XG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyZXNwb25zZS5zdGF0dXMuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2RlcGVuZGVudF9tb2RhbCcpLm1vZGFsKCd0b2dnbGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5lZGl0TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVJvd0luVGFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dhbCh7IHRpdGxlOiByZXNwb25zZS5lbnRpdHkuc3RhdHVzLCB0eXBlOiAnc3VjY2VzcycsIHRpbWVyOiAyMDAwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZW1wbG95ZWUuZGVwZW5kZW50cy5kYXRhLnB1c2gocmVzcG9uc2UuZW50aXR5LmRlcGVuZGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3YWwoeyB0aXRsZTogcmVzcG9uc2UuZW50aXR5LnN0YXR1cywgdHlwZTogJ3N1Y2Nlc3MnLCB0aW1lcjogMjAwMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2FsKHsgdGl0bGU6IHJlc3BvbnNlLmVudGl0eS5zdGF0dXMsIHR5cGU6ICdlcnJvcicsIHRpbWVyOiAyMDAwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICQoJy52dWUtY2hvc2VuJykudHJpZ2dlcignY2hvc2VuOnVwZGF0ZWQnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCgnI2RlcGVuZGVudF9tb2RhbCcpLm9uKCdzaG93bi5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgJCgnLnZ1ZS1jaG9zZW4nLCB0aGlzKS50cmlnZ2VyKCdjaG9zZW46b3BlbicpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVSb3dJblRhYmxlOiBmdW5jdGlvbiB1cGRhdGVSb3dJblRhYmxlKCkge1xuICAgICAgICAgICAgdGhpcy5lbXBsb3llZS5kZXBlbmRlbnRzLmRhdGFbdGhpcy5lZGl0SW5kZXhdLmZpcnN0X25hbWUgPSB0aGlzLm1vZGFsLmZpcnN0X25hbWU7XG4gICAgICAgICAgICB0aGlzLmVtcGxveWVlLmRlcGVuZGVudHMuZGF0YVt0aGlzLmVkaXRJbmRleF0ubWlkZGxlX25hbWUgPSB0aGlzLm1vZGFsLm1pZGRsZV9uYW1lO1xuICAgICAgICAgICAgdGhpcy5lbXBsb3llZS5kZXBlbmRlbnRzLmRhdGFbdGhpcy5lZGl0SW5kZXhdLmxhc3RfbmFtZSA9IHRoaXMubW9kYWwubGFzdF9uYW1lO1xuICAgICAgICAgICAgdGhpcy5lbXBsb3llZS5kZXBlbmRlbnRzLmRhdGFbdGhpcy5lZGl0SW5kZXhdLnJlbGF0aW9uc2hpcF9pZCA9IHRoaXMubW9kYWwucmVsYXRpb25zaGlwX2lkO1xuICAgICAgICAgICAgdGhpcy5lbXBsb3llZS5kZXBlbmRlbnRzLmRhdGFbdGhpcy5lZGl0SW5kZXhdLmJpcnRoX2RhdGUgPSB0aGlzLm1vZGFsLmJpcnRoX2RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRSZWNvcmQ6IGZ1bmN0aW9uIGVkaXRSZWNvcmQoZGVwZW5kZW50LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZWRpdEluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgICAgIHRoYXQuYXNzaWduVmFsdWVzVG9Nb2RhbChkZXBlbmRlbnQpO1xuXG4gICAgICAgICAgICAvLyBkYXRlcGlja2VyIGZvciBiaXJ0aF9kYXRlXG4gICAgICAgICAgICAkKCcuaW5wdXQtZ3JvdXAuZGF0ZScpLmRhdGVwaWNrZXIoe1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ3l5eXktbW0tZGQnLFxuICAgICAgICAgICAgICAgIGtleWJvYXJkTmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgZm9yY2VQYXJzZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYWxlbmRhcldlZWtzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF1dG9jbG9zZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjbGVhckJ0bjogdHJ1ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICQoJyNkZXBlbmRlbnRfbW9kYWwnKS5tb2RhbCgndG9nZ2xlJyk7XG4gICAgICAgICAgICAkKCcjZGVwZW5kZW50X21vZGFsJykub24oJ3Nob3duLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICQoJy52dWUtY2hvc2VuJywgdGhpcykudHJpZ2dlcignY2hvc2VuOnVwZGF0ZWQnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkKCcjZmlyc3RfbmFtZScpLmZvY3VzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZVJlY29yZDogZnVuY3Rpb24gZGVsZXRlUmVjb3JkKGRlcGVuZGVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHByZXZpb3VzV2luZG93S2V5RG93biA9IHdpbmRvdy5vbmtleWRvd247IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90NHQ1L3N3ZWV0YWxlcnQvaXNzdWVzLzEyN1xuICAgICAgICAgICAgc3dhbCh7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdBcmUgeW91IHN1cmU/JyxcbiAgICAgICAgICAgICAgICB0ZXh0OiAnWW91IHdpbGwgbm90IGJlIGFibGUgdG8gcmVjb3ZlciB0aGlzIHJlY29yZCEnLFxuICAgICAgICAgICAgICAgIHNob3dDYW5jZWxCdXR0b246IHRydWUsXG4gICAgICAgICAgICAgICAgY2FuY2VsQnV0dG9uQ29sb3I6ICcjZDMzJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgY29uZmlybUJ1dHRvbkNsYXNzOiAnY29uZmlybS1jbGFzcycsXG4gICAgICAgICAgICAgICAgY2FuY2VsQnV0dG9uQ2xhc3M6ICdjYW5jZWwtY2xhc3MnLFxuICAgICAgICAgICAgICAgIGNvbmZpcm1CdXR0b25UZXh0OiAnWWVzLCBkZWxldGUgaXQhJyxcbiAgICAgICAgICAgICAgICBjbG9zZU9uQ29uZmlybTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2xvc2VPbkNhbmNlbDogZmFsc2VcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChpc0NvbmZpcm0pIHtcbiAgICAgICAgICAgICAgICBzd2FsLmRpc2FibGVCdXR0b25zKCk7XG4gICAgICAgICAgICAgICAgd2luZG93Lm9ua2V5ZG93biA9IHByZXZpb3VzV2luZG93S2V5RG93bjsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Q0dDUvc3dlZXRhbGVydC9pc3N1ZXMvMTI3XG4gICAgICAgICAgICAgICAgaWYgKGlzQ29uZmlybSkge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9wcm9maWxlL2RlcGVuZGVudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0eTogeyBpZDogZGVwZW5kZW50LmlkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2p3dC10b2tlbicpIH1cbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIwMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dhbCh7IHRpdGxlOiByZXNwb25zZS5lbnRpdHkuc3RhdHVzLCB0eXBlOiAnc3VjY2VzcycsIHRpbWVyOiAyMDAwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmVtcGxveWVlLmRlcGVuZGVudHMuZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dhbCh7IHRpdGxlOiByZXNwb25zZS5lbnRpdHkuc3RhdHVzLCB0eXBlOiAnZXJyb3InLCB0aW1lcjogMjAwMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN3YWwoJ0NhbmNlbGxlZCcsICdObyByZWNvcmQgaGFzIGJlZW4gZGVsZXRlZCcsICdlcnJvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhc3NpZ25WYWx1ZXNUb01vZGFsOiBmdW5jdGlvbiBhc3NpZ25WYWx1ZXNUb01vZGFsKGRlcGVuZGVudCkge1xuICAgICAgICAgICAgdGhpcy5tb2RhbC5kZXBlbmRlbnRfaWQgPSBkZXBlbmRlbnQuaWQ7XG4gICAgICAgICAgICB0aGlzLm1vZGFsLmZpcnN0X25hbWUgPSBkZXBlbmRlbnQuZmlyc3RfbmFtZTtcbiAgICAgICAgICAgIHRoaXMubW9kYWwubWlkZGxlX25hbWUgPSBkZXBlbmRlbnQubWlkZGxlX25hbWU7XG4gICAgICAgICAgICB0aGlzLm1vZGFsLmxhc3RfbmFtZSA9IGRlcGVuZGVudC5sYXN0X25hbWU7XG4gICAgICAgICAgICB0aGlzLm1vZGFsLnJlbGF0aW9uc2hpcF9pZCA9IGRlcGVuZGVudC5yZWxhdGlvbnNoaXBfaWQ7XG4gICAgICAgICAgICB0aGlzLnJlbGF0aW9uc2hpcF9vYmogPSB0aGlzLnJlbGF0aW9uc2hpcHNfY2hvc2VuW2RlcGVuZGVudC5yZWxhdGlvbnNoaXBfaWQgLSAxXTtcbiAgICAgICAgICAgIHRoaXMubW9kYWwuYmlydGhfZGF0ZSA9IGRlcGVuZGVudC5iaXJ0aF9kYXRlLnN1YnN0cmluZygwLCAxMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNob3NlblJlbGF0aW9uc2hpcHM6IGZ1bmN0aW9uIGNob3NlblJlbGF0aW9uc2hpcHMoKSB7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gcmV0cmlldmUgcmVsYXRpb25zaG9wc1xuICAgICAgICAgICAgY2xpZW50KHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnL3JlbGF0aW9uc2hpcHMnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnand0LXRva2VuJykgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5yZWxhdGlvbnNoaXBzX2Nob3NlbiA9IHJlc3BvbnNlLmVudGl0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJCgnLnZ1ZS1jaG9zZW4nKS50cmlnZ2VyKCdjaG9zZW46dXBkYXRlZCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJyb3dcXFwiIHYtaWY9XFxcImVtcGxveWVlXFxcIj5cXG4gICAgPG5hdmJhci1zdGF0aWMtcHJvZmlsZS10b3A+PC9uYXZiYXItc3RhdGljLXByb2ZpbGUtdG9wPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbGctMTJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaWJveCBmbG9hdC1lLW1hcmdpbnNcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImlib3gtdGl0bGVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aDU+QXNzaWduZWQgRGVwZW5kZW50czwvaDU+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImlib3gtdG9vbHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcImNvbGxhcHNlLWxpbmtcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLXVwXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImlib3gtY29udGVudFxcXCI+XFxuXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIlxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8YSBpZD1cXFwiYWRkX2RlcGVuZGVudFxcXCIgdi1pZj1cXFwiaGFzX2FjY2VzcyAmYW1wOyZhbXA7IGhhc19hY2Nlc3NbcGVybWlzc2lvbiArICcuY3JlYXRlJ11cXFwiIEBjbGljaz1cXFwidG9nZ2xlTW9kYWxcXFwiIGhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZCgwKTtcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnkgYnRuLXhzXFxcIj5BZGQgYSBuZXcgcm93PC9hPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidGFibGUtcmVzcG9uc2l2ZVxcXCIgdi1pZj1cXFwiZW1wbG95ZWUuZGVwZW5kZW50c1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3M9XFxcInRhYmxlIHRhYmxlLXN0cmlwZWRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aGVhZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5GdWxsIE5hbWU8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGg+UmVsYXRpb25zaGlwPC90aD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPkJpcnRoIERhdGU8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XFxcImZpeC13aWR0aFxcXCI+QWN0aW9uPC90aD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5IGlkPVxcXCJkZXBlbmRlbnRzX2JvZHlcXFwiPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ciB2LWZvcj1cXFwiZGVwZW5kZW50IGluIGVtcGxveWVlLmRlcGVuZGVudHMuZGF0YVxcXCIgY2xhc3M9XFxcIml0ZW0te3skaW5kZXh9fVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57e2RlcGVuZGVudC5maXJzdF9uYW1lICsgJyAnICsgZGVwZW5kZW50Lmxhc3RfbmFtZX19PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPnt7cmVsYXRpb25zaGlwc1tkZXBlbmRlbnQucmVsYXRpb25zaGlwX2lkXX19PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPnt7ZGVwZW5kZW50LmJpcnRoX2RhdGV9fTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gcmVsPVxcXCJlZGl0XFxcIiBpZD1cXFwiZWRpdF97e2RlcGVuZGVudC5pZH19XFxcIiB2LWlmPVxcXCJoYXNfYWNjZXNzW3Blcm1pc3Npb24gKyAnLnVwZGF0ZSddXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi14cyBidG4td2FybmluZ1xcXCIgZGF0YS10b2dnbGU9XFxcInRvb2x0aXBcXFwiIGRhdGEtcGxhY2VtZW50PVxcXCJib3R0b21cXFwiIHRpdGxlPVxcXCJcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgQGNsaWNrPVxcXCJlZGl0UmVjb3JkKGRlcGVuZGVudCwgJGluZGV4KVxcXCIgZGF0YS1vcmlnaW5hbC10aXRsZT1cXFwiRWRpdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWVkaXRcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gcmVsPVxcXCJkZWxldGVcXFwiIGlkPVxcXCJkZWxldGVfe3tkZXBlbmRlbnQuaWR9fVxcXCIgdi1pZj1cXFwiaGFzX2FjY2Vzc1twZXJtaXNzaW9uICsgJy5kZWxldGUnXVxcXCIgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeSBidG4teHMgYnRuLWRhbmdlclxcXCIgZGF0YS10b2dnbGU9XFxcInRvb2x0aXBcXFwiIGRhdGEtcGxhY2VtZW50PVxcXCJib3R0b21cXFwiIHRpdGxlPVxcXCJcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgQGNsaWNrPVxcXCJkZWxldGVSZWNvcmQoZGVwZW5kZW50LCAkaW5kZXgpXFxcIiBkYXRhLW9yaWdpbmFsLXRpdGxlPVxcXCJEZWxldGVcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS10aW1lc1xcXCI+PC9pPjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyIHYtaWY9XFxcImVtcGxveWVlLmRlcGVuZGVudHMgJmFtcDsmYW1wOyBlbXBsb3llZS5kZXBlbmRlbnRzLmRhdGEubGVuZ3RoID09IDBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cXFwiNFxcXCI+Tm8gZGVwZW5kZW50cyBsaXN0ZWQ8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8IS0tIE1vZGFsIC0tPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbCBmYWRlXFxcIiBpZD1cXFwiZGVwZW5kZW50X21vZGFsXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWRpYWxvZ1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWhlYWRlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJjbG9zZVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj7DlzwvYnV0dG9uPlxcblxcbiAgICAgICAgICAgICAgICAgICAgPGg0IGNsYXNzPVxcXCJtb2RhbC10aXRsZVxcXCIgaWQ9XFxcIm15X21vZGFsX2xhYmVsXFxcIj5EZXBlbmRlbnQgRGV0YWlsczwvaDQ+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1ib2R5XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDwhLS1BZGQgZm9ybS0tPlxcbiAgICAgICAgICAgICAgICAgICAgPGZvcm0gbWV0aG9kPVxcXCJQT1NUXFxcIiBvbnN1Ym1pdD1cXFwicmV0dXJuIGZhbHNlO1xcXCIgYWNjZXB0LWNoYXJzZXQ9XFxcIlVURi04XFxcIiBjbGFzcz1cXFwiZm9ybS1ob3Jpem9udGFsXFxcIiBpZD1cXFwiZGVwZW5kZW50c0Zvcm1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIHYtbW9kZWwuc3luYz1cXFwibW9kYWwuZGVwZW5kZW50X2lkXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiZmlyc3RfbmFtZVxcXCIgY2xhc3M9XFxcImNvbC1tZC0zIGNvbnRyb2wtbGFiZWxcXFwiPkZpcnN0IE5hbWU8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgcmVxdWlyZWQ9XFxcInJlcXVpcmVkXFxcIiB2LW1vZGVsLnN5bmM9XFxcIm1vZGFsLmZpcnN0X25hbWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIGlkPVxcXCJmaXJzdF9uYW1lXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcIm1pZGRsZV9uYW1lXFxcIiBjbGFzcz1cXFwiY29sLW1kLTMgY29udHJvbC1sYWJlbFxcXCI+TWlkZGxlIE5hbWU8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdi1tb2RlbC5zeW5jPVxcXCJtb2RhbC5taWRkbGVfbmFtZVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgaWQ9XFxcIm1pZGRsZV9uYW1lXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImxhc3RfbmFtZVxcXCIgY2xhc3M9XFxcImNvbC1tZC0zIGNvbnRyb2wtbGFiZWxcXFwiPkxhc3QgTmFtZTwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiByZXF1aXJlZD1cXFwicmVxdWlyZWRcXFwiIHYtbW9kZWwuc3luYz1cXFwibW9kYWwubGFzdF9uYW1lXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBpZD1cXFwibGFzdF9uYW1lXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInJlbGF0aW9uc2hpcF9pZFxcXCIgY2xhc3M9XFxcImNvbC1tZC0zIGNvbnRyb2wtbGFiZWxcXFwiPlJlbGF0aW9uc2hpcDwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaG9zZW4gaWQ9XFxcInJlbGF0aW9uc2hpcF9pZFxcXCIgY2xhc3M9XFxcInZ1ZS1jaG9zZW5cXFwiIDpvcHRpb25zPVxcXCJyZWxhdGlvbnNoaXBzX2Nob3NlblxcXCIgOnYtbW9kZWwuc3luYz1cXFwicmVsYXRpb25zaGlwX29ialxcXCIgOmNob3Nlbj1cXFwieyB3aWR0aDonMTAwJScgfVxcXCIgcGxhY2Vob2xkZXI9XFxcIi0tLSBTZWxlY3QgLS0tXFxcIiB0ZXh0LWtleT1cXFwibmFtZVxcXCI+PC9jaG9zZW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJiaXJ0aF9kYXRlXFxcIiBjbGFzcz1cXFwiY29sLW1kLTMgY29udHJvbC1sYWJlbFxcXCI+QmlydGggRGF0ZTwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIiBpZD1cXFwiZGF0ZXBpY2tlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cCBkYXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYWRkb25cXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jYWxlbmRhclxcXCI+PC9pPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgZGF0YS1tYXNrPVxcXCI5OTk5LTk5LTk5XFxcIiB2LW1vZGVsLnN5bmM9XFxcIm1vZGFsLmJpcnRoX2RhdGVcXFwiIHR5cGU9XFxcInRleHRcXFwiIGlkPVxcXCJiaXJ0aF9kYXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1mb290ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLXdoaXRlIGJ0bi14c1xcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj5DbG9zZTwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeSBidG4teHNcXFwiIHR5cGU9XFxcInN1Ym1pdFxcXCIgQGNsaWNrPVxcXCJzdWJtaXRGb3JtXFxcIiB2YWx1ZT1cXFwiU2F2ZSBjaGFuZ2VzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDwvZm9ybT48IS0tLy8gZm9ybS0tPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj48IS0tIC8ubW9kYWwtY29udGVudCAtLT5cXG4gICAgICAgIDwvZGl2PjwhLS0gLy5tb2RhbC1kaWFsb2cgLS0+XFxuICAgIDwvZGl2PjwhLS0gLy5tb2RhbCAtLT5cXG48L2Rpdj5cXG5cXG5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvYmtpbnRhbmFyL1NpdGVzL2hyaXMvd2ViL3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvcHJvZmlsZS9kZXBlbmRlbnRzLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcHJvcHM6IFsnZW1wbG95ZWUnLCAncGFnZV90aXRsZScsICdqb2JfdGl0bGVzJywgJ2VtcGxveW1lbnRfc3RhdHVzZXMnLCAncm91dGVzJywgJ2hhc19hY2Nlc3MnLCAncGVybWlzc2lvbiddLFxuICAgIGNvbXBpbGVkOiBmdW5jdGlvbiBjb21waWxlZCgpIHtcbiAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3VwZGF0ZS1wYWdlLXRpdGxlJywgKHRoaXMuJHJvdXRlLnBhdGguaW5kZXhPZigncGltJykgPiAtMSA/ICdFbXBsb3llZVxcJ3MgJyA6ICdNeSAnKSArICdFbWVyZ2VuY3kgQ29udGFjdHMnKTtcbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlZGl0TW9kZTogZmFsc2UsXG4gICAgICAgICAgICBlbXBsb3llZV9pZDogJycsXG4gICAgICAgICAgICBlbWVyZ2VuY3lfY29udGFjdHM6IFtdLFxuICAgICAgICAgICAgcmVsYXRpb25zaGlwczogW10sXG4gICAgICAgICAgICByZWxhdGlvbnNoaXBzX2Nob3NlbjogW3t9XSxcbiAgICAgICAgICAgIHJlbGF0aW9uc2hpcF9vYmo6IHt9LFxuICAgICAgICAgICAgbW9kYWw6IHtcbiAgICAgICAgICAgICAgICBmaXJzdF9uYW1lOiAnJyxcbiAgICAgICAgICAgICAgICBtaWRkbGVfbmFtZTogJycsXG4gICAgICAgICAgICAgICAgbGFzdF9uYW1lOiAnJyxcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBfaWQ6ICcnLFxuICAgICAgICAgICAgICAgIGhvbWVfcGhvbmU6ICcnLFxuICAgICAgICAgICAgICAgIG1vYmlsZV9waG9uZTogJycsXG4gICAgICAgICAgICAgICAgZW1lcmdlbmN5X2NvbnRhY3RfaWQ6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLnF1ZXJ5RGF0YWJhc2UoKTtcbiAgICAgICAgdGhpcy5jaG9zZW5SZWxhdGlvbnNoaXBzKCk7XG5cbiAgICAgICAgJChcIiNlbWVyZ2VuY3lDb250YWN0c0Zvcm1cIikuc3VibWl0KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBxdWVyeURhdGFiYXNlOiBmdW5jdGlvbiBxdWVyeURhdGFiYXNlKCkge1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLiRyb3V0ZS5wYXRoLmluZGV4T2YoJy9waW0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbXBsb3llZV9pZCA9IHRoaXMuJHJvdXRlLnBhcmFtcy5lbXBsb3llZV9pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbXBsb3llZV9pZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdlbXBsb3llZV9pZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHBhdGg6ICcvZW1wbG95ZWUvZ2V0LWJ5LWVtcGxveWVlLWlkP2luY2x1ZGU9dXNlcixlbWVyZ2VuY3lfY29udGFjdHMnLFxuICAgICAgICAgICAgICAgIGVudGl0eTogeyAnZW1wbG95ZWVfaWQnOiB0aGlzLmVtcGxveWVlX2lkIH0sXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdqd3QtdG9rZW4nKSB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjbGllbnQocGFyYW1zKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ3VwZGF0ZS1lbXBsb3llZScsIHJlc3BvbnNlLmVudGl0eS5kYXRhKTtcblxuICAgICAgICAgICAgICAgIGNsaWVudCh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvcmVsYXRpb25zaGlwcz90YWJsZV92aWV3PXRydWUnLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2p3dC10b2tlbicpIH1cbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnJlbGF0aW9uc2hpcHMgPSByZXNwb25zZS5lbnRpdHk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzLmNvZGUgPT0gNDIyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuJHJvdXRlLnJvdXRlci5nbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZXJyb3ItNDA0J1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UuZW50aXR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlTW9kYWw6IGZ1bmN0aW9uIHRvZ2dsZU1vZGFsKCkge1xuXG4gICAgICAgICAgICB0aGlzLmVkaXRNb2RlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHRoaXMubW9kYWwuZmlyc3RfbmFtZSA9ICcnO1xuICAgICAgICAgICAgdGhpcy5tb2RhbC5taWRkbGVfbmFtZSA9ICcnO1xuICAgICAgICAgICAgdGhpcy5tb2RhbC5sYXN0X25hbWUgPSAnJztcbiAgICAgICAgICAgIHRoaXMubW9kYWwucmVsYXRpb25zaGlwX2lkID0gJyc7XG4gICAgICAgICAgICB0aGlzLnJlbGF0aW9uc2hpcF9vYmogPSAnJztcbiAgICAgICAgICAgIHRoaXMubW9kYWwuaG9tZV9waG9uZSA9ICcnO1xuICAgICAgICAgICAgdGhpcy5tb2RhbC5tb2JpbGVfcGhvbmUgPSAnJztcblxuICAgICAgICAgICAgJCgnI2VtZXJnZW5jeV9jb250YWN0X21vZGFsJykubW9kYWwoJ3RvZ2dsZScpO1xuICAgICAgICAgICAgJCgnI2VtZXJnZW5jeV9jb250YWN0X21vZGFsJykub24oJ3Nob3duLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICQoJy52dWUtY2hvc2VuJywgdGhpcykudHJpZ2dlcignY2hvc2VuOnVwZGF0ZWQnKTtcbiAgICAgICAgICAgICAgICAkKCcjZmlyc3RfbmFtZScpLmZvY3VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3VibWl0Rm9ybTogZnVuY3Rpb24gc3VibWl0Rm9ybSgpIHtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBqYXNueSBidWcgd29yayBhcm91bmRcbiAgICAgICAgICAgICQoJyNmaXJzdF9uYW1lJykuZm9jdXMoKTtcblxuICAgICAgICAgICAgdGhhdC5tb2RhbC5lbXBsb3llZV9pZCA9IHRoYXQuZW1wbG95ZWUuaWQ7XG4gICAgICAgICAgICB0aGF0Lm1vZGFsLnJlbGF0aW9uc2hpcF9pZCA9IHRoYXQucmVsYXRpb25zaGlwX29iai5pZDtcblxuICAgICAgICAgICAgaWYgKHRoYXQubW9kYWwucmVsYXRpb25zaGlwX2lkICYmIHRoYXQubW9kYWwuZmlyc3RfbmFtZSAmJiB0aGF0Lm1vZGFsLmxhc3RfbmFtZSkge1xuXG4gICAgICAgICAgICAgICAgY2xpZW50KHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9wcm9maWxlL2VtZXJnZW5jeS1jb250YWN0cycsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogdGhhdC5lZGl0TW9kZSA/ICdQQVRDSCcgOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eTogdGhhdC5tb2RhbCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdqd3QtdG9rZW4nKSB9XG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyZXNwb25zZS5zdGF0dXMuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2VtZXJnZW5jeV9jb250YWN0X21vZGFsJykubW9kYWwoJ3RvZ2dsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmVkaXRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlUm93SW5UYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2FsKHsgdGl0bGU6IHJlc3BvbnNlLmVudGl0eS5zdGF0dXMsIHR5cGU6ICdzdWNjZXNzJywgdGltZXI6IDIwMDAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5lbXBsb3llZS5lbWVyZ2VuY3lfY29udGFjdHMuZGF0YS5wdXNoKHJlc3BvbnNlLmVudGl0eS5lbWVyZ2VuY3lfY29udGFjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3YWwoeyB0aXRsZTogcmVzcG9uc2UuZW50aXR5LnN0YXR1cywgdHlwZTogJ3N1Y2Nlc3MnLCB0aW1lcjogMjAwMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2FsKHsgdGl0bGU6IHJlc3BvbnNlLmVudGl0eS5zdGF0dXMsIHR5cGU6ICdlcnJvcicsIHRpbWVyOiAyMDAwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICQoJy52dWUtY2hvc2VuJykudHJpZ2dlcignY2hvc2VuOnVwZGF0ZWQnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCgnI2VtZXJnZW5jeV9jb250YWN0X21vZGFsJykub24oJ3Nob3duLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkKCcudnVlLWNob3NlbicsIHRoaXMpLnRyaWdnZXIoJ2Nob3NlbjpvcGVuJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVJvd0luVGFibGU6IGZ1bmN0aW9uIHVwZGF0ZVJvd0luVGFibGUoKSB7XG4gICAgICAgICAgICB0aGlzLmVtcGxveWVlLmVtZXJnZW5jeV9jb250YWN0cy5kYXRhW3RoaXMuZWRpdEluZGV4XS5maXJzdF9uYW1lID0gdGhpcy5tb2RhbC5maXJzdF9uYW1lO1xuICAgICAgICAgICAgdGhpcy5lbXBsb3llZS5lbWVyZ2VuY3lfY29udGFjdHMuZGF0YVt0aGlzLmVkaXRJbmRleF0ubWlkZGxlX25hbWUgPSB0aGlzLm1vZGFsLm1pZGRsZV9uYW1lO1xuICAgICAgICAgICAgdGhpcy5lbXBsb3llZS5lbWVyZ2VuY3lfY29udGFjdHMuZGF0YVt0aGlzLmVkaXRJbmRleF0ubGFzdF9uYW1lID0gdGhpcy5tb2RhbC5sYXN0X25hbWU7XG4gICAgICAgICAgICB0aGlzLmVtcGxveWVlLmVtZXJnZW5jeV9jb250YWN0cy5kYXRhW3RoaXMuZWRpdEluZGV4XS5yZWxhdGlvbnNoaXBfaWQgPSB0aGlzLm1vZGFsLnJlbGF0aW9uc2hpcF9pZDtcbiAgICAgICAgICAgIHRoaXMuZW1wbG95ZWUuZW1lcmdlbmN5X2NvbnRhY3RzLmRhdGFbdGhpcy5lZGl0SW5kZXhdLmhvbWVfcGhvbmUgPSB0aGlzLm1vZGFsLmhvbWVfcGhvbmU7XG4gICAgICAgICAgICB0aGlzLmVtcGxveWVlLmVtZXJnZW5jeV9jb250YWN0cy5kYXRhW3RoaXMuZWRpdEluZGV4XS5tb2JpbGVfcGhvbmUgPSB0aGlzLm1vZGFsLm1vYmlsZV9waG9uZTtcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdFJlY29yZDogZnVuY3Rpb24gZWRpdFJlY29yZChlbWVyZ2VuY3lfY29udGFjdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5lZGl0TW9kZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVkaXRJbmRleCA9IGluZGV4O1xuXG4gICAgICAgICAgICB0aGF0LmFzc2lnblZhbHVlc1RvTW9kYWwoZW1lcmdlbmN5X2NvbnRhY3QpO1xuXG4gICAgICAgICAgICAkKCcjZW1lcmdlbmN5X2NvbnRhY3RfbW9kYWwnKS5tb2RhbCgndG9nZ2xlJyk7XG5cbiAgICAgICAgICAgICQoJyNlbWVyZ2VuY3lfY29udGFjdF9tb2RhbCcpLm9uKCdzaG93bi5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkKCcudnVlLWNob3NlbicsIHRoaXMpLnRyaWdnZXIoJ2Nob3Nlbjp1cGRhdGVkJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJCgnI2ZpcnN0X25hbWUnKS5mb2N1cygpO1xuICAgICAgICB9LFxuICAgICAgICBkZWxldGVSZWNvcmQ6IGZ1bmN0aW9uIGRlbGV0ZVJlY29yZChlbWVyZ2VuY3lfY29udGFjdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHByZXZpb3VzV2luZG93S2V5RG93biA9IHdpbmRvdy5vbmtleWRvd247IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90NHQ1L3N3ZWV0YWxlcnQvaXNzdWVzLzEyN1xuICAgICAgICAgICAgc3dhbCh7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdBcmUgeW91IHN1cmU/JyxcbiAgICAgICAgICAgICAgICB0ZXh0OiAnWW91IHdpbGwgbm90IGJlIGFibGUgdG8gcmVjb3ZlciB0aGlzIHJlY29yZCEnLFxuICAgICAgICAgICAgICAgIHNob3dDYW5jZWxCdXR0b246IHRydWUsXG4gICAgICAgICAgICAgICAgY2FuY2VsQnV0dG9uQ29sb3I6ICcjZDMzJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgY29uZmlybUJ1dHRvbkNsYXNzOiAnY29uZmlybS1jbGFzcycsXG4gICAgICAgICAgICAgICAgY2FuY2VsQnV0dG9uQ2xhc3M6ICdjYW5jZWwtY2xhc3MnLFxuICAgICAgICAgICAgICAgIGNvbmZpcm1CdXR0b25UZXh0OiAnWWVzLCBkZWxldGUgaXQhJyxcbiAgICAgICAgICAgICAgICBjbG9zZU9uQ29uZmlybTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2xvc2VPbkNhbmNlbDogZmFsc2VcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChpc0NvbmZpcm0pIHtcbiAgICAgICAgICAgICAgICBzd2FsLmRpc2FibGVCdXR0b25zKCk7XG4gICAgICAgICAgICAgICAgd2luZG93Lm9ua2V5ZG93biA9IHByZXZpb3VzV2luZG93S2V5RG93bjsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Q0dDUvc3dlZXRhbGVydC9pc3N1ZXMvMTI3XG4gICAgICAgICAgICAgICAgaWYgKGlzQ29uZmlybSkge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9wcm9maWxlL2VtZXJnZW5jeS1jb250YWN0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXR5OiB7IGlkOiBlbWVyZ2VuY3lfY29udGFjdC5pZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdqd3QtdG9rZW4nKSB9XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLnN0YXR1cy5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3YWwoeyB0aXRsZTogcmVzcG9uc2UuZW50aXR5LnN0YXR1cywgdHlwZTogJ3N1Y2Nlc3MnLCB0aW1lcjogMjAwMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5lbXBsb3llZS5lbWVyZ2VuY3lfY29udGFjdHMuZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dhbCh7IHRpdGxlOiByZXNwb25zZS5lbnRpdHkuc3RhdHVzLCB0eXBlOiAnZXJyb3InLCB0aW1lcjogMjAwMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN3YWwoJ0NhbmNlbGxlZCcsICdObyByZWNvcmQgaGFzIGJlZW4gZGVsZXRlZCcsICdlcnJvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhc3NpZ25WYWx1ZXNUb01vZGFsOiBmdW5jdGlvbiBhc3NpZ25WYWx1ZXNUb01vZGFsKGVtZXJnZW5jeV9jb250YWN0KSB7XG4gICAgICAgICAgICB0aGlzLm1vZGFsLmVtZXJnZW5jeV9jb250YWN0X2lkID0gZW1lcmdlbmN5X2NvbnRhY3QuaWQ7XG4gICAgICAgICAgICB0aGlzLm1vZGFsLmZpcnN0X25hbWUgPSBlbWVyZ2VuY3lfY29udGFjdC5maXJzdF9uYW1lO1xuICAgICAgICAgICAgdGhpcy5tb2RhbC5taWRkbGVfbmFtZSA9IGVtZXJnZW5jeV9jb250YWN0Lm1pZGRsZV9uYW1lO1xuICAgICAgICAgICAgdGhpcy5tb2RhbC5sYXN0X25hbWUgPSBlbWVyZ2VuY3lfY29udGFjdC5sYXN0X25hbWU7XG4gICAgICAgICAgICB0aGlzLm1vZGFsLnJlbGF0aW9uc2hpcF9pZCA9IGVtZXJnZW5jeV9jb250YWN0LnJlbGF0aW9uc2hpcF9pZDtcbiAgICAgICAgICAgIHRoaXMucmVsYXRpb25zaGlwX29iaiA9IHRoaXMucmVsYXRpb25zaGlwc19jaG9zZW5bZW1lcmdlbmN5X2NvbnRhY3QucmVsYXRpb25zaGlwX2lkIC0gMV07XG4gICAgICAgICAgICB0aGlzLm1vZGFsLmhvbWVfcGhvbmUgPSBlbWVyZ2VuY3lfY29udGFjdC5ob21lX3Bob25lO1xuICAgICAgICAgICAgdGhpcy5tb2RhbC5tb2JpbGVfcGhvbmUgPSBlbWVyZ2VuY3lfY29udGFjdC5tb2JpbGVfcGhvbmU7XG4gICAgICAgIH0sXG4gICAgICAgIGNob3NlblJlbGF0aW9uc2hpcHM6IGZ1bmN0aW9uIGNob3NlblJlbGF0aW9uc2hpcHMoKSB7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gcmV0cmlldmUgcmVsYXRpb25zaG9wc1xuICAgICAgICAgICAgY2xpZW50KHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnL3JlbGF0aW9uc2hpcHMnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnand0LXRva2VuJykgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5yZWxhdGlvbnNoaXBzX2Nob3NlbiA9IHJlc3BvbnNlLmVudGl0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJCgnLnZ1ZS1jaG9zZW4nKS50cmlnZ2VyKCdjaG9zZW46dXBkYXRlZCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJyb3dcXFwiIHYtaWY9XFxcImVtcGxveWVlXFxcIj5cXG4gICAgPG5hdmJhci1zdGF0aWMtcHJvZmlsZS10b3A+PC9uYXZiYXItc3RhdGljLXByb2ZpbGUtdG9wPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbGctMTJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaWJveCBmbG9hdC1lLW1hcmdpbnNcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImlib3gtdGl0bGVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aDU+SW4gY2FzZSBvZiBFbWVyZ2VuY3k8L2g1PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpYm94LXRvb2xzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJjb2xsYXBzZS1saW5rXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi11cFxcXCI+PC9pPlxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpYm94LWNvbnRlbnRcXFwiPlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGEgaWQ9XFxcImFkZF9lbWVyZ2VuY3lfY29udGFjdFxcXCIgdi1pZj1cXFwiaGFzX2FjY2VzcyAmYW1wOyZhbXA7IGhhc19hY2Nlc3NbcGVybWlzc2lvbiArICcuY3JlYXRlJ11cXFwiIEBjbGljaz1cXFwidG9nZ2xlTW9kYWxcXFwiIGhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZCgwKTtcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnkgYnRuLXhzXFxcIj5BZGQgYSBuZXcgcm93PC9hPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidGFibGUtcmVzcG9uc2l2ZVxcXCIgdi1pZj1cXFwiZW1wbG95ZWUuZW1lcmdlbmN5X2NvbnRhY3RzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtc3RyaXBlZFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoZWFkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPkZ1bGwgTmFtZTwvdGg+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5SZWxhdGlvbnNoaXA8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGg+SG9tZSBUZWxlcGhvbmU8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGg+TW9iaWxlPC90aD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVxcXCJmaXgtd2lkdGhcXFwiPkFjdGlvbjwvdGg+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RoZWFkPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keSBpZD1cXFwiZW1lcmdlbmN5X2NvbnRhY3RzX2JvZHlcXFwiPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ciB2LWZvcj1cXFwiZW1lcmdlbmN5X2NvbnRhY3QgaW4gZW1wbG95ZWUuZW1lcmdlbmN5X2NvbnRhY3RzLmRhdGFcXFwiIGNsYXNzPVxcXCJpdGVtLXt7JGluZGV4fX1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e3tlbWVyZ2VuY3lfY29udGFjdC5maXJzdF9uYW1lICsgJyAnICsgZW1lcmdlbmN5X2NvbnRhY3QubGFzdF9uYW1lfX08L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e3tyZWxhdGlvbnNoaXBzW2VtZXJnZW5jeV9jb250YWN0LnJlbGF0aW9uc2hpcF9pZF19fTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57e2VtZXJnZW5jeV9jb250YWN0LmhvbWVfcGhvbmV9fTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57e2VtZXJnZW5jeV9jb250YWN0Lm1vYmlsZV9waG9uZX19PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiByZWw9XFxcImVkaXRcXFwiIGlkPVxcXCJlZGl0X3t7ZW1lcmdlbmN5X2NvbnRhY3QuaWR9fVxcXCIgdi1pZj1cXFwiaGFzX2FjY2Vzc1twZXJtaXNzaW9uICsgJy51cGRhdGUnXVxcXCIgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeSBidG4teHMgYnRuLXdhcm5pbmdcXFwiIGRhdGEtdG9nZ2xlPVxcXCJ0b29sdGlwXFxcIiBkYXRhLXBsYWNlbWVudD1cXFwiYm90dG9tXFxcIiB0aXRsZT1cXFwiXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIEBjbGljaz1cXFwiZWRpdFJlY29yZChlbWVyZ2VuY3lfY29udGFjdCwgJGluZGV4KVxcXCIgZGF0YS1vcmlnaW5hbC10aXRsZT1cXFwiRWRpdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWVkaXRcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gcmVsPVxcXCJkZWxldGVcXFwiIGlkPVxcXCJkZWxldGVfe3tlbWVyZ2VuY3lfY29udGFjdC5pZH19XFxcIiB2LWlmPVxcXCJoYXNfYWNjZXNzW3Blcm1pc3Npb24gKyAnLmRlbGV0ZSddXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi14cyBidG4tZGFuZ2VyXFxcIiBkYXRhLXRvZ2dsZT1cXFwidG9vbHRpcFxcXCIgZGF0YS1wbGFjZW1lbnQ9XFxcImJvdHRvbVxcXCIgdGl0bGU9XFxcIlxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBAY2xpY2s9XFxcImRlbGV0ZVJlY29yZChlbWVyZ2VuY3lfY29udGFjdCwgJGluZGV4KVxcXCIgZGF0YS1vcmlnaW5hbC10aXRsZT1cXFwiRGVsZXRlXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtdGltZXNcXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ciB2LWlmPVxcXCJlbXBsb3llZS5lbWVyZ2VuY3lfY29udGFjdHMgJmFtcDsmYW1wOyBlbXBsb3llZS5lbWVyZ2VuY3lfY29udGFjdHMuZGF0YS5sZW5ndGggPT0gMFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVxcXCI1XFxcIj5ObyBlbWVyZ2VuY3kgY29udGFjdHMgbGlzdGVkPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPCEtLSBNb2RhbCAtLT5cXG4gICAgPGRpdiBjbGFzcz1cXFwibW9kYWwgZmFkZVxcXCIgaWQ9XFxcImVtZXJnZW5jeV9jb250YWN0X21vZGFsXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWRpYWxvZ1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWhlYWRlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJjbG9zZVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj7DlzwvYnV0dG9uPlxcblxcbiAgICAgICAgICAgICAgICAgICAgPGg0IGNsYXNzPVxcXCJtb2RhbC10aXRsZVxcXCIgaWQ9XFxcIm15X21vZGFsX2xhYmVsXFxcIj5FbWVyZ2VuY3kgQ29udGFjdCBEZXRhaWxzPC9oND5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWJvZHlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPCEtLUFkZCBmb3JtLS0+XFxuICAgICAgICAgICAgICAgICAgICA8Zm9ybSBtZXRob2Q9XFxcIlBPU1RcXFwiIG9uc3VibWl0PVxcXCJyZXR1cm4gZmFsc2U7XFxcIiBhY2NlcHQtY2hhcnNldD1cXFwiVVRGLThcXFwiIGNsYXNzPVxcXCJmb3JtLWhvcml6b250YWxcXFwiIGlkPVxcXCJlbWVyZ2VuY3lDb250YWN0c0Zvcm1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIHYtbW9kZWwuc3luYz1cXFwibW9kYWwuZW1lcmdlbmN5X2NvbnRhY3RfaWRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJmaXJzdF9uYW1lXFxcIiBjbGFzcz1cXFwiY29sLW1kLTMgY29udHJvbC1sYWJlbFxcXCI+Rmlyc3QgTmFtZTwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiByZXF1aXJlZD1cXFwicmVxdWlyZWRcXFwiIHYtbW9kZWwuc3luYz1cXFwibW9kYWwuZmlyc3RfbmFtZVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgaWQ9XFxcImZpcnN0X25hbWVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwibWlkZGxlX25hbWVcXFwiIGNsYXNzPVxcXCJjb2wtbWQtMyBjb250cm9sLWxhYmVsXFxcIj5NaWRkbGUgTmFtZTwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB2LW1vZGVsLnN5bmM9XFxcIm1vZGFsLm1pZGRsZV9uYW1lXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBpZD1cXFwibWlkZGxlX25hbWVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwibGFzdF9uYW1lXFxcIiBjbGFzcz1cXFwiY29sLW1kLTMgY29udHJvbC1sYWJlbFxcXCI+TGFzdCBOYW1lPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIHJlcXVpcmVkPVxcXCJyZXF1aXJlZFxcXCIgdi1tb2RlbC5zeW5jPVxcXCJtb2RhbC5sYXN0X25hbWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIGlkPVxcXCJsYXN0X25hbWVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwicmVsYXRpb25zaGlwX2lkXFxcIiBjbGFzcz1cXFwiY29sLW1kLTMgY29udHJvbC1sYWJlbFxcXCI+UmVsYXRpb25zaGlwPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNob3NlbiBpZD1cXFwicmVsYXRpb25zaGlwX2lkXFxcIiBjbGFzcz1cXFwidnVlLWNob3NlblxcXCIgOm9wdGlvbnM9XFxcInJlbGF0aW9uc2hpcHNfY2hvc2VuXFxcIiA6di1tb2RlbC5zeW5jPVxcXCJyZWxhdGlvbnNoaXBfb2JqXFxcIiA6Y2hvc2VuPVxcXCJ7IHdpZHRoOicxMDAlJyB9XFxcIiBwbGFjZWhvbGRlcj1cXFwiLS0tIFNlbGVjdCAtLS1cXFwiIHRleHQta2V5PVxcXCJuYW1lXFxcIj48L2Nob3Nlbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcIm1vYmlsZV9waG9uZVxcXCIgY2xhc3M9XFxcImNvbC1tZC0zIGNvbnRyb2wtbGFiZWxcXFwiPk1vYmlsZTwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBkYXRhLW1hc2s9XFxcIjA5OTkgOTk5IDk5OTlcXFwiIHYtbW9kZWwuc3luYz1cXFwibW9kYWwubW9iaWxlX3Bob25lXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBpZD1cXFwibW9iaWxlX3Bob25lXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImhvbWVfcGhvbmVcXFwiIGNsYXNzPVxcXCJjb2wtbWQtMyBjb250cm9sLWxhYmVsXFxcIj5Ib21lIFRlbGVwaG9uZTwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBkYXRhLW1hc2s9XFxcIjA5OSA5OTkgOTk5OVxcXCIgdi1tb2RlbC5zeW5jPVxcXCJtb2RhbC5ob21lX3Bob25lXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBpZD1cXFwiaG9tZV9waG9uZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4td2hpdGUgYnRuLXhzXFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiPkNsb3NlPC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi14c1xcXCIgdHlwZT1cXFwic3VibWl0XFxcIiBAY2xpY2s9XFxcInN1Ym1pdEZvcm1cXFwiIHZhbHVlPVxcXCJTYXZlIGNoYW5nZXNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgPC9mb3JtPjwhLS0vLyBmb3JtLS0+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PjwhLS0gLy5tb2RhbC1jb250ZW50IC0tPlxcbiAgICAgICAgPC9kaXY+PCEtLSAvLm1vZGFsLWRpYWxvZyAtLT5cXG4gICAgPC9kaXY+PCEtLSAvLm1vZGFsIC0tPlxcbjwvZGl2PlxcblxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9ia2ludGFuYXIvU2l0ZXMvaHJpcy93ZWIvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9wcm9maWxlL2VtZXJnZW5jeS1jb250YWN0cy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHByb3BzOiBbJ2VtcGxveWVlJywgJ3BhZ2VfdGl0bGUnLCAnam9iX3RpdGxlcycsICdlbXBsb3ltZW50X3N0YXR1c2VzJywgJ3JvdXRlcycsICdoYXNfYWNjZXNzJywgJ3Blcm1pc3Npb24nXSxcbiAgICBjb21waWxlZDogZnVuY3Rpb24gY29tcGlsZWQoKSB7XG4gICAgICAgIHRoaXMuJGRpc3BhdGNoKCd1cGRhdGUtcGFnZS10aXRsZScsICh0aGlzLiRyb3V0ZS5wYXRoLmluZGV4T2YoJ3BpbScpID4gLTEgPyAnRW1wbG95ZWVcXCdzICcgOiAnTXkgJykgKyAnUGVyc29uYWwgRGV0YWlscycpO1xuICAgIH0sXG5cbiAgICByb3V0ZToge1xuICAgICAgICBjYW5SZXVzZTogZmFsc2VcbiAgICB9LFxuXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiAnJyxcbiAgICAgICAgICAgIG5hdGlvbmFsaXR5OiAnJyxcbiAgICAgICAgICAgIG5hdGlvbmFsaXR5X29iajoge30sXG4gICAgICAgICAgICBtYXJpdGFsX3N0YXR1c19vYmo6IHt9LFxuICAgICAgICAgICAgbmF0aW9uYWxpdGllc19jaG9zZW46IFt7fV0sXG4gICAgICAgICAgICBtYXJpdGFsX3N0YXR1czogJycsXG4gICAgICAgICAgICBtYXJpdGFsX3N0YXR1c2VzX2Nob3NlbjogW3t9XSxcbiAgICAgICAgICAgIG9yaWdpbmFsX2VtcGxveWVlX2lkOiAnJ1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgICB0aGlzLnF1ZXJ5RGF0YWJhc2UoKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBxdWVyeURhdGFiYXNlOiBmdW5jdGlvbiBxdWVyeURhdGFiYXNlKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAodGhpcy4kcm91dGUucGF0aC5pbmRleE9mKCcvcGltJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1wbG95ZWVfaWQgPSB0aGlzLiRyb3V0ZS5wYXJhbXMuZW1wbG95ZWVfaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1wbG95ZWVfaWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZW1wbG95ZWVfaWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnL2VtcGxveWVlL2dldC1ieS1lbXBsb3llZS1pZD9pbmNsdWRlPXVzZXInLFxuICAgICAgICAgICAgICAgIGVudGl0eTogeyAnZW1wbG95ZWVfaWQnOiB0aGlzLmVtcGxveWVlX2lkIH0sXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdqd3QtdG9rZW4nKSB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjbGllbnQocGFyYW1zKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ3VwZGF0ZS1lbXBsb3llZScsIHJlc3BvbnNlLmVudGl0eS5kYXRhKTtcblxuICAgICAgICAgICAgICAgIHRoYXQub3JpZ2luYWxfZW1wbG95ZWVfaWQgPSByZXNwb25zZS5lbnRpdHkuZGF0YS5lbXBsb3llZV9pZDtcblxuICAgICAgICAgICAgICAgIHRoYXQuY2hvc2VuTmF0aW9uYWxpdGllcygpO1xuICAgICAgICAgICAgICAgIHRoYXQuY2hvc2VuTWFyaXRhbFN0YXR1c2VzKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWFyaXRhbFN0YXR1c0Nob3NlbldhdGNoZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmVtcGxveWVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlDaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnLmktY2hlY2tzJykuaUNoZWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2JveENsYXNzOiAnaWNoZWNrYm94X3NxdWFyZS1ncmVlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaW9DbGFzczogJ2lyYWRpb19zcXVhcmUtZ3JlZW4nXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwobWFyaXRhbFN0YXR1c0Nob3NlbldhdGNoZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhhdC5lbXBsb3llZSkge1xuICAgICAgICAgICAgICAgICAgICAkKCdpbnB1dFtuYW1lPVwiZ2VuZGVyXCJdJykub24oJ2lmQ2hlY2tlZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5lbXBsb3llZS5nZW5kZXIgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0LnN3aXRjaEdlbmRlcih0aGF0LmVtcGxveWVlLmdlbmRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cy5jb2RlID09IDQyMikge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LiRyb3V0ZS5yb3V0ZXIuZ28oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Vycm9yLTQwNCdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlLmVudGl0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN1Ym1pdEZvcm06IGZ1bmN0aW9uIHN1Ym1pdEZvcm0oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGphc255IGJ1ZyB3b3JrIGFyb3VuZFxuICAgICAgICAgICAgJCgnI2ZpcnN0X25hbWUnKS5mb2N1cygpO1xuXG4gICAgICAgICAgICB0aGlzLmVtcGxveWVlLm1hcml0YWxfc3RhdHVzX2lkID0gdGhpcy5tYXJpdGFsX3N0YXR1c19vYmouaWQ7XG4gICAgICAgICAgICB0aGlzLmVtcGxveWVlLm5hdGlvbmFsaXR5X2lkID0gdGhpcy5uYXRpb25hbGl0eV9vYmouaWQ7XG5cbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcGF0aDogJy9wcm9maWxlL3BlcnNvbmFsLWRldGFpbHMnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBlbnRpdHk6IHsgJ2VtcGxveWVlJzogdGhpcy5lbXBsb3llZSB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnand0LXRva2VuJykgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2xpZW50KHBhcmFtcykudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLnN0YXR1cy5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjAwOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUxvY2FsU3RvcmFnZShyZXNwb25zZS5lbnRpdHkuZW1wbG95ZWUuZW1wbG95ZWVfaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi4kcm91dGUucGF0aC5pbmRleE9mKCcvcGltJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuJHJvdXRlLnJvdXRlci5nbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwaW0tZW1wbG95ZWUtbGlzdC1wZXJzb25hbC1kZXRhaWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7IGVtcGxveWVlX2lkOiByZXNwb25zZS5lbnRpdHkuZW1wbG95ZWUuZW1wbG95ZWVfaWQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLiRyb3V0ZS5wYXJhbXMuZW1wbG95ZWVfaWQgPSByZXNwb25zZS5lbnRpdHkuZW1wbG95ZWUuZW1wbG95ZWVfaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FsKHsgdGl0bGU6IHJlc3BvbnNlLmVudGl0eS5zdGF0dXMsIHR5cGU6ICdzdWNjZXNzJywgdGltZXI6IDIwMDAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbmNlbEZvcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3YWwoeyB0aXRsZTogcmVzcG9uc2UuZW50aXR5LnN0YXR1cywgdHlwZTogJ3dhcm5pbmcnLCB0aW1lcjogMjAwMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyNmaXJzdF9uYW1lJykuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3YWwoeyB0aXRsZTogcmVzcG9uc2UuZW50aXR5LnN0YXR1cywgdHlwZTogJ2Vycm9yJywgdGltZXI6IDIwMDAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbW9kaWZ5Rm9ybTogZnVuY3Rpb24gbW9kaWZ5Rm9ybSgpIHtcblxuICAgICAgICAgICAgJCgnLmF2YXRhcicpLmNzcygnZGlzcGxheScsICcnKTtcbiAgICAgICAgICAgICQoJy5qb2ItdGl0bGUnKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG4gICAgICAgICAgICAkKCcuc2F2ZS1mb3JtJykuY3NzKCdkaXNwbGF5JywgJycpO1xuICAgICAgICAgICAgJCgnLm1vZGlmeS1mb3JtJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICAgICQoJy52dWUtY2hvc2VuJykucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSkudHJpZ2dlcihcImNob3Nlbjp1cGRhdGVkXCIpO1xuICAgICAgICAgICAgJCgnLmZvcm0tY29udHJvbCcpLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICAgICAgJCgnLmktY2hlY2tzJykuaUNoZWNrKCdlbmFibGUnKTtcblxuICAgICAgICAgICAgLy8gZGF0ZXBpY2tlciBmb3IgYmlydGhfZGF0ZVxuICAgICAgICAgICAgJCgnLmlucHV0LWdyb3VwLmRhdGUnKS5kYXRlcGlja2VyKHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICd5eXl5LW1tLWRkJyxcbiAgICAgICAgICAgICAgICBrZXlib2FyZE5hdmlnYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZvcmNlUGFyc2U6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJXZWVrczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhdXRvY2xvc2U6IHRydWUsXG4gICAgICAgICAgICAgICAgY2xlYXJCdG46IHRydWVcbiAgICAgICAgICAgIH0pLmRhdGVwaWNrZXIoJ3VwZGF0ZScsIHRoaXMuZW1wbG95ZWUuYmlydGhfZGF0ZSk7XG5cbiAgICAgICAgICAgICQoJyNmaXJzdF9uYW1lJykuZm9jdXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsRm9ybTogZnVuY3Rpb24gY2FuY2VsRm9ybSgpIHtcbiAgICAgICAgICAgIC8vIHJldHJpZXZlIG9yaWdpbmFsIGRhdGEgc2luY2UgY2FuY2VsIGJ1dHRvbiB3YXMgcHJlc3NlZC5cbiAgICAgICAgICAgIHRoaXMucXVlcnlEYXRhYmFzZSgpO1xuXG4gICAgICAgICAgICAkKCcuYXZhdGFyJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICAgICQoJy5qb2ItdGl0bGUnKS5jc3MoJ2Rpc3BsYXknLCAnJyk7XG5cbiAgICAgICAgICAgICQoJy5zYXZlLWZvcm0nKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICAgICAgJCgnLm1vZGlmeS1mb3JtJykuY3NzKCdkaXNwbGF5JywgJycpO1xuICAgICAgICAgICAgJCgnLnZ1ZS1jaG9zZW4nKS5wcm9wKCdkaXNhYmxlZCcsIHRydWUpLnRyaWdnZXIoXCJjaG9zZW46dXBkYXRlZFwiKTtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgICQoJy5mb3JtLWNvbnRyb2wnKS5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgJCgnLmktY2hlY2tzJykuaUNoZWNrKCdkaXNhYmxlJyk7XG5cbiAgICAgICAgICAgIC8vIGRhdGVwaWNrZXIgZm9yIGJpcnRoX2RhdGVcbiAgICAgICAgICAgICQoJyNkYXRlcGlja2VyX2JpcnRoX2RhdGUgLmlucHV0LWdyb3VwLmRhdGUnKS5kYXRlcGlja2VyKCdyZW1vdmUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3dpdGNoR2VuZGVyOiBmdW5jdGlvbiBzd2l0Y2hHZW5kZXIoZ2VuZGVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGdlbmRlcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAkKCdpbnB1dFtpZD1cImdlbmRlclsxXVwiXScpLmlDaGVjaygnY2hlY2snKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRic6XG4gICAgICAgICAgICAgICAgICAgICQoJ2lucHV0W2lkPVwiZ2VuZGVyWzJdXCJdJykuaUNoZWNrKCdjaGVjaycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlTG9jYWxTdG9yYWdlOiBmdW5jdGlvbiB1cGRhdGVMb2NhbFN0b3JhZ2UobmV3X2VtcGxveWVlX2lkKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLm9yaWdpbmFsX2VtcGxveWVlX2lkID09IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdlbXBsb3llZV9pZCcpKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2VtcGxveWVlX2lkJywgbmV3X2VtcGxveWVlX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2hvc2VuTmF0aW9uYWxpdGllczogZnVuY3Rpb24gY2hvc2VuTmF0aW9uYWxpdGllcygpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgLy8gcmV0cmlldmUgbmF0aW9uYWxpdGllc1xuICAgICAgICAgICAgY2xpZW50KHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnL25hdGlvbmFsaXRpZXMnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnand0LXRva2VuJykgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5uYXRpb25hbGl0aWVzX2Nob3NlbiA9IHJlc3BvbnNlLmVudGl0eTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLm5hdGlvbmFsaXR5X29iaiA9IHNlbGYubmF0aW9uYWxpdGllc19jaG9zZW5bc2VsZi5lbXBsb3llZS5uYXRpb25hbGl0eV9pZCAtIDFdO1xuICAgICAgICAgICAgICAgICQoJy52dWUtY2hvc2VuJykudHJpZ2dlcihcImNob3Nlbjp1cGRhdGVkXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNob3Nlbk1hcml0YWxTdGF0dXNlczogZnVuY3Rpb24gY2hvc2VuTWFyaXRhbFN0YXR1c2VzKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyByZXRyaWV2ZSBtYXJpdGFsIHN0YXR1c1xuICAgICAgICAgICAgY2xpZW50KHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnL21hcml0YWwtc3RhdHVzZXMnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnand0LXRva2VuJykgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tYXJpdGFsX3N0YXR1c2VzX2Nob3NlbiA9IHJlc3BvbnNlLmVudGl0eTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLm1hcml0YWxfc3RhdHVzX29iaiA9IHNlbGYubWFyaXRhbF9zdGF0dXNlc19jaG9zZW5bc2VsZi5lbXBsb3llZS5tYXJpdGFsX3N0YXR1c19pZCAtIDFdO1xuICAgICAgICAgICAgICAgICQoJy52dWUtY2hvc2VuJykudHJpZ2dlcihcImNob3Nlbjp1cGRhdGVkXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJyb3dcXFwiIHYtaWY9XFxcImVtcGxveWVlXFxcIj5cXG4gICAgPG5hdmJhci1zdGF0aWMtcHJvZmlsZS10b3A+PC9uYXZiYXItc3RhdGljLXByb2ZpbGUtdG9wPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbGctMTJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaWJveCBmbG9hdC1lLW1hcmdpbnNcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImlib3gtdGl0bGVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aDU+UGVyc29uYWwgRGV0YWlsczwvaDU+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImlib3gtdG9vbHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcImNvbGxhcHNlLWxpbmtcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLXVwXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImlib3gtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgICAgIDxmb3JtIG9uc3VibWl0PVxcXCJyZXR1cm4gZmFsc2U7XFxcIiBhY2NlcHQtY2hhcnNldD1cXFwiVVRGLThcXFwiIGNsYXNzPVxcXCJmb3JtLWhvcml6b250YWxcXFwiIGlkPVxcXCJwZXJzb25hbERldGFpbHNGb3JtXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBuYW1lPVxcXCJ1c2VyW2lkXVxcXCIgdHlwZT1cXFwiaGlkZGVuXFxcIiB2LW1vZGVsPVxcXCJlbXBsb3llZS51c2VyLmRhdGEuaWRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IG5hbWU9XFxcImlkXFxcIiB0eXBlPVxcXCJoaWRkZW5cXFwiIHYtbW9kZWw9XFxcImVtcGxveWVlLmlkXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gU3RhcnQgLSBGdWxsIE5hbWUgLS0+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJmaXJzdF9uYW1lXFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCI+RnVsbCBOYW1lPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBkaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIHR5cGU9XFxcInRleHRcXFwiIHYtbW9kZWw9XFxcImVtcGxveWVlLmZpcnN0X25hbWVcXFwiIGlkPVxcXCJmaXJzdF9uYW1lXFxcIiByZXF1aXJlZD1cXFwicmVxdWlyZWRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBtLWItbm9uZVxcXCI+Rmlyc3QgTmFtZTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMlxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBkaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIHR5cGU9XFxcInRleHRcXFwiIHYtbW9kZWw9XFxcImVtcGxveWVlLm1pZGRsZV9uYW1lXFxcIiBpZD1cXFwibWlkZGxlX25hbWVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVscC1ibG9jayBtLWItbm9uZVxcXCI+TWlkZGxlIE5hbWU8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiB2LW1vZGVsPVxcXCJlbXBsb3llZS5sYXN0X25hbWVcXFwiIGlkPVxcXCJsYXN0X25hbWVcXFwiIHJlcXVpcmVkPVxcXCJyZXF1aXJlZFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrIG0tYi1ub25lXFxcIj5MYXN0IE5hbWU8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gRW5kIC0gRnVsbCBOYW1lIC0tPlxcblxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaHItbGluZS1kYXNoZWRcXFwiPjwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgPCEtLSBTdGFydCAtIEVtcGxveWVlIElkICYgRmFjZSBJZCAtLT5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImVtcGxveWVlX2lkXFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCI+RW1wbG95ZWUgSWQ8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS00XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGRhdGEtbWFzaz1cXFwiSFJpcy05OTk5XFxcIiBkaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIHR5cGU9XFxcInRleHRcXFwiIHYtbW9kZWw9XFxcImVtcGxveWVlLmVtcGxveWVlX2lkXFxcIiBpZD1cXFwiZW1wbG95ZWVfaWRcXFwiIHJlcXVpcmVkPVxcXCJyZXF1aXJlZFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiZmFjZV9pZFxcXCIgY2xhc3M9XFxcImNvbC1tZC0yIGNvbnRyb2wtbGFiZWxcXFwiPkZhY2UgSWQ8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS00XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGRhdGEtbWFzaz1cXFwiOTk5XFxcIiBkaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIHR5cGU9XFxcInRleHRcXFwiIHYtbW9kZWw9XFxcImVtcGxveWVlLmZhY2VfaWRcXFwiIGlkPVxcXCJmYWNlX2lkXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPCEtLSBFbmQgLSBFbXBsb3llZSBJZCAmIEZhY2UgSWQgLS0+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoci1saW5lLWRhc2hlZFxcXCI+PC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8IS0tIFN0YXJ0IC0gR2VuZGVyICYgTWFyaXRhbCBTdGF0dXMgLS0+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJnZW5kZXJbMV1cXFwiIGNsYXNzPVxcXCJjb2wtbWQtMiBjb250cm9sLWxhYmVsXFxcIj5HZW5kZXI8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS00XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJyYWRpby1pbmxpbmUgaS1jaGVja3NcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgdHlwZT1cXFwicmFkaW9cXFwiIG5hbWU9XFxcImdlbmRlclxcXCIgdmFsdWU9XFxcIk1cXFwiIHYtbW9kZWw9XFxcImVtcGxveWVlLmdlbmRlclxcXCIgaWQ9XFxcImdlbmRlclsxXVxcXCI+IE1hbGVcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJyYWRpby1pbmxpbmUgaS1jaGVja3NcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgdHlwZT1cXFwicmFkaW9cXFwiIG5hbWU9XFxcImdlbmRlclxcXCIgdmFsdWU9XFxcIkZcXFwiIHYtbW9kZWw9XFxcImVtcGxveWVlLmdlbmRlclxcXCIgaWQ9XFxcImdlbmRlclsyXVxcXCI+IEZlbWFsZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcIm1hcml0YWxfc3RhdHVzX2lkXFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCI+TWFyaXRhbCBTdGF0dXM8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS00XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNob3NlbiBpZD1cXFwibWFyaXRhbF9zdGF0dXNfaWRcXFwiIGRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgY2xhc3M9XFxcInZ1ZS1jaG9zZW5cXFwiIDpvcHRpb25zPVxcXCJtYXJpdGFsX3N0YXR1c2VzX2Nob3NlblxcXCIgOnYtbW9kZWwuc3luYz1cXFwibWFyaXRhbF9zdGF0dXNfb2JqXFxcIiA6Y2hvc2VuPVxcXCJ7IHdpZHRoOicxMDAlJyB9XFxcIiBwbGFjZWhvbGRlcj1cXFwiLS0tIFNlbGVjdCAtLS1cXFwiIHRleHQta2V5PVxcXCJuYW1lXFxcIj48L2Nob3Nlbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPCEtLSBFbmQgLSBHZW5kZXIgJiBNYXJpdGFsIFN0YXR1cyAtLT5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gU3RhcnQgLSBOYXRpb25hbGl0eSAmIERPQiAtLT5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcIm5hdGlvbmFsaXR5X2lkXFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCI+TmF0aW9uYWxpdHk8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS00XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNob3NlbiBpZD1cXFwibmF0aW9uYWxpdHlfaWRcXFwiIGRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgY2xhc3M9XFxcInZ1ZS1jaG9zZW5cXFwiIDpvcHRpb25zPVxcXCJuYXRpb25hbGl0aWVzX2Nob3NlblxcXCIgOnYtbW9kZWwuc3luYz1cXFwibmF0aW9uYWxpdHlfb2JqXFxcIiA6Y2hvc2VuPVxcXCJ7IHdpZHRoOicxMDAlJyB9XFxcIiBwbGFjZWhvbGRlcj1cXFwiLS0tIFNlbGVjdCAtLS1cXFwiIHRleHQta2V5PVxcXCJuYW1lXFxcIj48L2Nob3Nlbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJiaXJ0aF9kYXRlXFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCI+RGF0ZSBvZiBCaXJ0aDwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTRcXFwiIGlkPVxcXCJkYXRlcGlja2VyX2JpcnRoX2RhdGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cCBkYXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC1hZGRvblxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWNhbGVuZGFyXFxcIj48L2k+PC9zcGFuPjxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBkYXRhLW1hc2s9XFxcIjk5OTktOTktOTlcXFwiIGRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgbmFtZT1cXFwiYmlydGhfZGF0ZVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgdi1tb2RlbD1cXFwiZW1wbG95ZWUuYmlydGhfZGF0ZVxcXCIgaWQ9XFxcImJpcnRoX2RhdGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPCEtLSBFbmQgLSBOYXRpb25hbGl0eSAmIERPQiAtLT5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhyLWxpbmUtZGFzaGVkXFxcIj48L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gU3RhcnQgLSBTb2NpYWwgU2VjdXJpdHkgJiBUYXggSWRlbnRpZmljYXRpb24gLS0+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJzb2NpYWxfc2VjdXJpdHlcXFwiIGNsYXNzPVxcXCJjb2wtbWQtMiBjb250cm9sLWxhYmVsXFxcIj5Tb2NpYWwgU2VjdXJpdHk8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS00XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGRhdGEtbWFzaz1cXFwiOTktOTk5OTk5OS05XFxcIiBkaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIHR5cGU9XFxcInRleHRcXFwiIHYtbW9kZWw9XFxcImVtcGxveWVlLnNvY2lhbF9zZWN1cml0eVxcXCIgaWQ9XFxcInNvY2lhbF9zZWN1cml0eVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwidGF4X2lkZW50aWZpY2F0aW9uXFxcIiBjbGFzcz1cXFwiY29sLW1kLTIgY29udHJvbC1sYWJlbFxcXCI+VGF4IElkZW50aWZpY2F0aW9uPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBkYXRhLW1hc2s9XFxcIjk5OS05OTktOTk5XFxcIiBkaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIHR5cGU9XFxcInRleHRcXFwiIHYtbW9kZWw9XFxcImVtcGxveWVlLnRheF9pZGVudGlmaWNhdGlvblxcXCIgaWQ9XFxcInRheF9pZGVudGlmaWNhdGlvblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gRW5kIC0gU29jaWFsIFNlY3VyaXR5ICYgVGF4IElkZW50aWZpY2F0aW9uIC0tPlxcblxcbiAgICAgICAgICAgICAgICAgICAgPCEtLSBTdGFydCAtIFBoaWxIZWFsdGggJiBQYWdJYmlnIC0tPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwicGhpbGhlYWx0aFxcXCIgY2xhc3M9XFxcImNvbC1tZC0yIGNvbnRyb2wtbGFiZWxcXFwiPlBoaWxIZWFsdGg8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS00XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGRhdGEtbWFzaz1cXFwiOTktOTk5OTk5OTk5LTlcXFwiIGRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgdi1tb2RlbD1cXFwiZW1wbG95ZWUucGhpbGhlYWx0aFxcXCIgaWQ9XFxcInBoaWxoZWFsdGhcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImhkbWZfcGFnaWJpZ1xcXCIgY2xhc3M9XFxcImNvbC1tZC0yIGNvbnRyb2wtbGFiZWxcXFwiPkhETUYgLyBQYWdJYmlnPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBkYXRhLW1hc2s9XFxcIjk5OTkgOTk5OSA5OTk5XFxcIiBkaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiIHR5cGU9XFxcInRleHRcXFwiIHYtbW9kZWw9XFxcImVtcGxveWVlLmhkbWZfcGFnaWJpZ1xcXCIgaWQ9XFxcImhkbWZfcGFnaWJpZ1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gRW5kIC0gUGhpbEhlYWx0aCAmIFBhZ0liaWcgLS0+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoci1saW5lLWRhc2hlZFxcXCI+PC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8IS0tIFN0YXJ0IC0gQ29udHJvbCBCdXR0b25zIC0tPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCBzYXZlLWZvcm1cXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNCBjb2wtc20tb2Zmc2V0LTJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLXdoaXRlIGJ0bi14cyBjYW5jZWwtZm9ybVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBAY2xpY2sucHJldmVudD1cXFwiY2FuY2VsRm9ybVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW5jZWxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeSBidG4teHNcXFwiIHR5cGU9XFxcInN1Ym1pdFxcXCIgQGNsaWNrPVxcXCJzdWJtaXRGb3JtXFxcIj5TYXZlIGNoYW5nZXNcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiIHYtaWY9XFxcImhhc19hY2Nlc3MgJmFtcDsmYW1wOyBoYXNfYWNjZXNzW3Blcm1pc3Npb24gKyAnLnVwZGF0ZSddXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNCBjb2wtc20tb2Zmc2V0LTJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnkgYnRuLXhzIG1vZGlmeS1mb3JtXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIEBjbGljay5wcmV2ZW50PVxcXCJtb2RpZnlGb3JtXFxcIj5Nb2RpZnlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gRW5kIC0gQ29udHJvbCBCdXR0b25zIC0tPlxcbiAgICAgICAgICAgICAgICA8L2Zvcm0+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL2JraW50YW5hci9TaXRlcy9ocmlzL3dlYi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL3Byb2ZpbGUvcGVyc29uYWwtZGV0YWlscy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHByb3BzOiBbJ2VtcGxveWVlJywgJ2pvYl90aXRsZXMnLCAnZW1wbG95bWVudF9zdGF0dXNlcyddLFxuICAgIHJvdXRlOiB7XG4gICAgICAgIGNhblJldXNlOiBmYWxzZVxuICAgIH1cbn07XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImNvbC1zbS02XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicHJvZmlsZS1pbWdcXFwiPlxcblxcbiAgICAgICAgPGltZyBpZD1cXFwicHJvZmlsZS1pbWFnZVxcXCIgYWx0PVxcXCJhdmF0YXJcXFwiIHNyYz1cXFwiL2ltYWdlcy9wcm9maWxlL2RlZmF1bHQvMC5wbmdcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvZmlsZS1kZXRhaWxzXFxcIj5cXG5cXG4gICAgICAgICAgICA8aDIgdi1pZj1cXFwiZW1wbG95ZWVcXFwiPnt7ZW1wbG95ZWUuZmlyc3RfbmFtZX19IHt7ZW1wbG95ZWUubGFzdF9uYW1lfX08L2gyPlxcbiAgICAgICAgICAgIDxoMyB2LWlmPVxcXCJqb2JfdGl0bGVzXFxcIj57e2pvYl90aXRsZXNbZW1wbG95ZWUuam9iX2hpc3RvcnkuZGF0YS5qb2JfdGl0bGVfaWRdfX08L2gzPlxcblxcbiAgICAgICAgICAgIDxoNCBjbGFzcz1cXFwiYXZhdGFyXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBpZD1cXFwiYWRkX2F2YXRhclxcXCIgY2xhc3M9XFxcImxhYmVsIGxhYmVsLXByaW1hcnlcXFwiPkVkaXQgQXZhdGFyPC9zcGFuPlxcbiAgICAgICAgICAgIDwvaDQ+XFxuICAgICAgICAgICAgPGg0IHYtaWY9XFxcImVtcGxveW1lbnRfc3RhdHVzZXNcXFwiIGNsYXNzPVxcXCJqb2ItdGl0bGVcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiB2LWlmPVxcXCJlbXBsb3ltZW50X3N0YXR1c2VzW2VtcGxveWVlLmpvYl9oaXN0b3J5LmRhdGEuZW1wbG95bWVudF9zdGF0dXNfaWQtMV1cXFwiIGNsYXNzPVxcXCJsYWJlbCB7e2VtcGxveW1lbnRfc3RhdHVzZXNbZW1wbG95ZWUuam9iX2hpc3RvcnkuZGF0YS5lbXBsb3ltZW50X3N0YXR1c19pZC0xXS5jbGFzc319XFxcIj57e2VtcGxveW1lbnRfc3RhdHVzZXNbZW1wbG95ZWUuam9iX2hpc3RvcnkuZGF0YS5lbXBsb3ltZW50X3N0YXR1c19pZC0xXS5uYW1lfX1cXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgIDwvaDQ+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL2JraW50YW5hci9TaXRlcy9ocmlzL3dlYi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhcnRpYWxzL2FjdGlvbi1hcmVhLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5naW5nOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgICBqRGF0YTogZnVuY3Rpb24gakRhdGEodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICAgICAgICAkKGVsKS5kYXRhKCdjaG9zZW4nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIG9wdGlvbnM6IG51bGwsXG4gICAgICAgICd2LW1vZGVsJzogeyB0d29XYXk6IHRydWUsICdkZWZhdWx0JzogbnVsbCB9LFxuICAgICAgICAnc2VsZWN0ZWQtb3B0aW9ucyc6IHtcbiAgICAgICAgICAgIHR3b1dheTogdHJ1ZSwgJ2RlZmF1bHQnOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9LCB0eXBlOiBBcnJheVxuICAgICAgICB9LFxuICAgICAgICBjaG9zZW46IG51bGwsXG4gICAgICAgICd0ZXh0LWtleSc6IG51bGwsXG4gICAgICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgICAgICBtdWx0aXBsZTogeyB0eXBlOiBCb29sZWFuLCByZXF1aXJlZDogZmFsc2UgfVxuICAgIH0sXG4gICAgZmlsdGVyczoge1xuICAgICAgICB0b09wdGlvbkRhdGE6IGZ1bmN0aW9uIHRvT3B0aW9uRGF0YSh2YWwpIHtcbiAgICAgICAgICAgIGlmICghdmFsKSByZXR1cm4gdmFsO1xuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMudGV4dEtleTtcbiAgICAgICAgICAgIGlmICghKHZhbCBpbnN0YW5jZW9mIEFycmF5KSkgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIHJldHVybiB2YWwubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSkgcmV0dXJuIHsgdGV4dDogeFtrZXldLCB2YWx1ZTogeCB9O2Vsc2UgcmV0dXJuIHsgdGV4dDogKHggPyB4IDogJycpLnRvU3RyaW5nKCksIHZhbHVlOiB4IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChvYmpzKSB7XG4gICAgICAgICAgICBpZiAoIW9ianMpIHZhciBvYmpzID0gW107XG4gICAgICAgICAgICB0aGlzLmNoYW5naW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLiRlbCkuZmluZCgnb3B0aW9uJykuZWFjaChmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9ICQoZSkuZGF0YSgnY2hvc2VuJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpzLmluZGV4T2YoZGF0YS52YWx1ZSkgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZSkuYXR0cignc2VsZWN0ZWQnLCAnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZSkucmVtb3ZlQXR0cignc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICQodGhpcy4kZWwpLnRyaWdnZXIoXCJjaG9zZW46dXBkYXRlZFwiKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGluaXRpYWxpemVcbiAgICAgICAgdmFyIGNvcHRpb25zID0gJC5leHRlbmQoe30sIHsgd2lkdGg6ICcxMGVtJyB9LCB0aGlzLmNob3Nlbik7XG4gICAgICAgICQodGhpcy4kZWwpLmNob3Nlbihjb3B0aW9ucyk7XG4gICAgICAgIC8vIGluaXRpYWxpemUgc2VsZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLnZNb2RlbCkgdGhpcy5zZWxlY3QoW3RoaXMudk1vZGVsXSk7ZWxzZSB0aGlzLnNlbGVjdCh0aGlzLnNlbGVjdGVkT3B0aW9ucyk7XG4gICAgICAgIC8vIHRyYWNrIGNoYW5nZXNcbiAgICAgICAgJCh0aGlzLiRlbCkub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jaGFuZ2luZykgcmV0dXJuO1xuICAgICAgICAgICAgX3RoaXMuY2hhbmdpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX3RoaXMuc2VsZWN0ZWRPcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWxlY3RlZE9wdGlvbnMgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldC5zcGxpY2UoMCwgdGFyZ2V0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgJChfdGhpcy4kZWwpLmZpbmQoJzpzZWxlY3RlZCcpLmVhY2goZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSAkKGUpLmRhdGEoJ2Nob3NlbicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkgdGFyZ2V0LnB1c2goZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMudk1vZGVsID0gdGFyZ2V0Lmxlbmd0aCA+IDAgPyB0YXJnZXRbMF0gOiBudWxsO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgICd2TW9kZWwnOiBmdW5jdGlvbiB2TW9kZWwodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5naW5nKSByZXR1cm47XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChbdmFsdWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB0aGlzLnNlbGVjdChbXSk7XG4gICAgICAgIH0sXG4gICAgICAgICdzZWxlY3RlZE9wdGlvbnMnOiBmdW5jdGlvbiBzZWxlY3RlZE9wdGlvbnModmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5naW5nKSByZXR1cm47XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgdGhpcy5zZWxlY3QoW10pO1xuICAgICAgICB9XG4gICAgfVxufTtcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPHNlbGVjdCB2LWJpbmQ6ZGF0YS1wbGFjZWhvbGRlcj1cXFwicGxhY2Vob2xkZXJcXFwiIHYtYmluZDptdWx0aXBsZT1cXFwibXVsdGlwbGVcXFwiIGNsYXNzPVxcXCJjaG9zZW4tc2VsZWN0XFxcIj5cXG4gICAgPG9wdGlvbiB2LWlmPVxcXCJwbGFjZWhvbGRlclxcXCI+PC9vcHRpb24+XFxuICAgIDxvcHRpb24gdi1mb3I9XFxcIml0ZW0gaW4gb3B0aW9ucyB8IHRvT3B0aW9uRGF0YVxcXCIgdi1qLWRhdGE9XFxcIml0ZW1cXFwiIHZhbHVlPVxcXCJ7e2l0ZW0uaWR9fVxcXCI+e3tpdGVtLnRleHR9fTwvb3B0aW9uPlxcbjwvc2VsZWN0PlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9ia2ludGFuYXIvU2l0ZXMvaHJpcy93ZWIvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYXJ0aWFscy9jaG9zZW4udnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48IS0tXFxuIF9fXy4gICBfX19fX19fX1xcbiBcXFxcXFxcXF8gfF9fIFxcXFxcXFxcX19fX18gIFxcXFxcXFxcX19fX19fX19fXyAgX19fXFxuICAgfCBfXyBcXFxcXFxcXCAgXyhfXyAgPF8gIF9fIFxcXFxcXFxcICBcXFxcXFxcXC8gIC9cXG4gICB8IFxcXFxcXFxcX1xcXFxcXFxcIFxcXFxcXFxcLyAgICAgICBcXFxcXFxcXCAgfCBcXFxcXFxcXC8+ICAgIDxcXG4gICB8X19fICAvX19fX19fICAvX198ICAvX18vXFxcXFxcXFxfIFxcXFxcXFxcXFxuICAgICAgIFxcXFxcXFxcLyAgICAgICBcXFxcXFxcXC8gU3R1ZGlvcyAgICBcXFxcXFxcXC9cXG4tLT5cXG5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvYmtpbnRhbmFyL1NpdGVzL2hyaXMvd2ViL3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFydGlhbHMvY29weWxlZnQudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJjb2wtbGctMTIgdG9wLW5hdi1iXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYnRuLWdyb3VwIHRvcC1uYXYtbGlcXFwiPlxcbiAgICAgICAgPHVsPlxcbiAgICAgICAgICAgIDxsaSA6Y2xhc3M9XFxcInsnYWN0aXZlJzogJHJvdXRlLnBhdGguaW5kZXhPZignL3Byb2ZpbGUvcGVyc29uYWwtZGV0YWlscycpID4gLTEgfHwgJHJvdXRlLnBhdGguaW5kZXhPZignL3BpbS9lbXBsb3llZS1saXN0LycrJHJvdXRlLnBhcmFtcy5lbXBsb3llZV9pZCsnL3BlcnNvbmFsLWRldGFpbHMnKSA+IC0xLCAnbmF2eSc6ICRyb3V0ZS5wYXRoLmluZGV4T2YoJy9waW0nKSA+IC0xIH1cXFwiPlxcbiAgICAgICAgICAgICAgICA8YSB2LWlmPVxcXCIkcm91dGUucGF0aC5pbmRleE9mKCcvcHJvZmlsZScpID4gLTFcXFwiIHYtbGluaz1cXFwie25hbWUgOiAncHJvZmlsZS1wZXJzb25hbC1kZXRhaWxzJ31cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWZpbGUtdGV4dC1vICBtLXJpZ2h0LWFcXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgICAgIFBlcnNvbmFsIERldGFpbHNcXG4gICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICA8YSB2LWlmPVxcXCIkcm91dGUucGF0aC5pbmRleE9mKCcvcGltJykgPiAtMVxcXCIgdi1saW5rPVxcXCJ7bmFtZSA6ICdwaW0tZW1wbG95ZWUtbGlzdC1wZXJzb25hbC1kZXRhaWxzJywgcGFyYW1zOiB7ZW1wbG95ZWVfaWQ6ICRyb3V0ZS5wYXJhbXMuZW1wbG95ZWVfaWR9fVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtZmlsZS10ZXh0LW8gIG0tcmlnaHQtYVxcXCI+PC9pPlxcbiAgICAgICAgICAgICAgICAgICAgUGVyc29uYWwgRGV0YWlsc1xcbiAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICA8bGkgOmNsYXNzPVxcXCJ7J2FjdGl2ZSc6ICRyb3V0ZS5wYXRoLmluZGV4T2YoJy9wcm9maWxlL2NvbnRhY3QtZGV0YWlscycpID4gLTEgfHwgJHJvdXRlLnBhdGguaW5kZXhPZignL3BpbS9lbXBsb3llZS1saXN0LycrJHJvdXRlLnBhcmFtcy5lbXBsb3llZV9pZCsnL2NvbnRhY3QtZGV0YWlscycpID4gLTEsICduYXZ5JzogJHJvdXRlLnBhdGguaW5kZXhPZignL3BpbScpID4gLTEgfVxcXCI+XFxuICAgICAgICAgICAgICAgIDxhIHYtaWY9XFxcIiRyb3V0ZS5wYXRoLmluZGV4T2YoJy9wcm9maWxlJykgPiAtMVxcXCIgdi1saW5rPVxcXCJ7bmFtZSA6ICdwcm9maWxlLWNvbnRhY3QtZGV0YWlscyd9XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1waG9uZS1zcXVhcmUgbS1yaWdodC1hXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgICAgICBDb250YWN0IERldGFpbHNcXG4gICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICA8YSB2LWlmPVxcXCIkcm91dGUucGF0aC5pbmRleE9mKCcvcGltJykgPiAtMVxcXCIgdi1saW5rPVxcXCJ7bmFtZSA6ICdwaW0tZW1wbG95ZWUtbGlzdC1jb250YWN0LWRldGFpbHMnLCBwYXJhbXM6IHtlbXBsb3llZV9pZDogJHJvdXRlLnBhcmFtcy5lbXBsb3llZV9pZH19XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1waG9uZS1zcXVhcmUgbS1yaWdodC1hXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgICAgICBDb250YWN0IERldGFpbHNcXG4gICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPGxpIDpjbGFzcz1cXFwieydhY3RpdmUnOiAkcm91dGUucGF0aC5pbmRleE9mKCcvcHJvZmlsZS9lbWVyZ2VuY3ktY29udGFjdHMnKSA+IC0xIHx8ICRyb3V0ZS5wYXRoLmluZGV4T2YoJy9waW0vZW1wbG95ZWUtbGlzdC8nKyRyb3V0ZS5wYXJhbXMuZW1wbG95ZWVfaWQrJy9lbWVyZ2VuY3ktY29udGFjdHMnKSA+IC0xLCAnbmF2eSc6ICRyb3V0ZS5wYXRoLmluZGV4T2YoJy9waW0nKSA+IC0xIH1cXFwiPlxcbiAgICAgICAgICAgICAgICA8YSB2LWlmPVxcXCIkcm91dGUucGF0aC5pbmRleE9mKCcvcHJvZmlsZScpID4gLTFcXFwiIHYtbGluaz1cXFwie25hbWUgOiAncHJvZmlsZS1lbWVyZ2VuY3ktY29udGFjdHMnfVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtcGx1cy1zcXVhcmUgIG0tcmlnaHQtYVxcXCI+PC9pPlxcbiAgICAgICAgICAgICAgICAgICAgRW1lcmdlbmN5IENvbnRhY3RzXFxuICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgPGEgdi1pZj1cXFwiJHJvdXRlLnBhdGguaW5kZXhPZignL3BpbScpID4gLTFcXFwiIHYtbGluaz1cXFwie25hbWUgOiAncGltLWVtcGxveWVlLWxpc3QtZW1lcmdlbmN5LWNvbnRhY3RzJywgcGFyYW1zOiB7ZW1wbG95ZWVfaWQ6ICRyb3V0ZS5wYXJhbXMuZW1wbG95ZWVfaWR9fVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtcGx1cy1zcXVhcmUgIG0tcmlnaHQtYVxcXCI+PC9pPlxcbiAgICAgICAgICAgICAgICAgICAgRW1lcmdlbmN5IENvbnRhY3RzXFxuICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDxsaSA6Y2xhc3M9XFxcInsnYWN0aXZlJzogJHJvdXRlLnBhdGguaW5kZXhPZignL3Byb2ZpbGUvZGVwZW5kZW50cycpID4gLTEgfHwgJHJvdXRlLnBhdGguaW5kZXhPZignL3BpbS9lbXBsb3llZS1saXN0LycrJHJvdXRlLnBhcmFtcy5lbXBsb3llZV9pZCsnL2RlcGVuZGVudHMnKSA+IC0xLCAnbmF2eSc6ICRyb3V0ZS5wYXRoLmluZGV4T2YoJy9waW0nKSA+IC0xIH1cXFwiPlxcbiAgICAgICAgICAgICAgICA8YSB2LWlmPVxcXCIkcm91dGUucGF0aC5pbmRleE9mKCcvcHJvZmlsZScpID4gLTFcXFwiIHYtbGluaz1cXFwie25hbWUgOiAncHJvZmlsZS1kZXBlbmRlbnRzJ31cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWNoaWxkIG0tcmlnaHQtYVxcXCI+PC9pPlxcbiAgICAgICAgICAgICAgICAgICAgRGVwZW5kZW50c1xcbiAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgIDxhIHYtaWY9XFxcIiRyb3V0ZS5wYXRoLmluZGV4T2YoJy9waW0nKSA+IC0xXFxcIiB2LWxpbms9XFxcIntuYW1lIDogJ3BpbS1lbXBsb3llZS1saXN0LWRlcGVuZGVudHMnLCBwYXJhbXM6IHtlbXBsb3llZV9pZDogJHJvdXRlLnBhcmFtcy5lbXBsb3llZV9pZH19XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1jaGlsZCBtLXJpZ2h0LWFcXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgICAgIERlcGVuZGVudHNcXG4gICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPGxpIDpjbGFzcz1cXFwieydhY3RpdmUnOiAkcm91dGUucGF0aC5pbmRleE9mKCcvcHJvZmlsZS9qb2InKSA+IC0xIHx8ICRyb3V0ZS5wYXRoLmluZGV4T2YoJy9waW0vZW1wbG95ZWUtbGlzdC8nKyRyb3V0ZS5wYXJhbXMuZW1wbG95ZWVfaWQrJy9qb2InKSA+IC0xLCAnbmF2eSc6ICRyb3V0ZS5wYXRoLmluZGV4T2YoJy9waW0nKSA+IC0xIH1cXFwiPlxcbiAgICAgICAgICAgICAgICA8YSB2LWlmPVxcXCIkcm91dGUucGF0aC5pbmRleE9mKCcvcHJvZmlsZScpID4gLTFcXFwiIHYtbGluaz1cXFwie25hbWUgOiAncHJvZmlsZS1qb2InfVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtYnJpZWZjYXNlIG0tcmlnaHQtYVxcXCI+PC9pPlxcbiAgICAgICAgICAgICAgICAgICAgSm9iXFxuICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgPGEgdi1pZj1cXFwiJHJvdXRlLnBhdGguaW5kZXhPZignL3BpbScpID4gLTFcXFwiIHYtbGluaz1cXFwie25hbWUgOiAncGltLWVtcGxveWVlLWxpc3Qtam9iJywgcGFyYW1zOiB7ZW1wbG95ZWVfaWQ6ICRyb3V0ZS5wYXJhbXMuZW1wbG95ZWVfaWR9fVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtYnJpZWZjYXNlIG0tcmlnaHQtYVxcXCI+PC9pPlxcbiAgICAgICAgICAgICAgICAgICAgSm9iXFxuICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDxsaSA6Y2xhc3M9XFxcInsnYWN0aXZlJzogJHJvdXRlLnBhdGguaW5kZXhPZignL3Byb2ZpbGUvd29yay1zaGlmdHMnKSA+IC0xIHx8ICRyb3V0ZS5wYXRoLmluZGV4T2YoJy9waW0vZW1wbG95ZWUtbGlzdC8nKyRyb3V0ZS5wYXJhbXMuZW1wbG95ZWVfaWQrJy93b3JrLXNoaWZ0cycpID4gLTEsICduYXZ5JzogJHJvdXRlLnBhdGguaW5kZXhPZignL3BpbScpID4gLTEgfVxcXCI+XFxuICAgICAgICAgICAgICAgIDxhIHYtaWY9XFxcIiRyb3V0ZS5wYXRoLmluZGV4T2YoJy9wcm9maWxlJykgPiAtMVxcXCIgdi1saW5rPVxcXCJ7bmFtZSA6ICdwcm9maWxlLXdvcmstc2hpZnRzJ31cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWNsb2NrLW8gbS1yaWdodC1hXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgICAgICBXb3JrIFNoaWZ0c1xcbiAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgIDxhIHYtaWY9XFxcIiRyb3V0ZS5wYXRoLmluZGV4T2YoJy9waW0nKSA+IC0xXFxcIiB2LWxpbms9XFxcIntuYW1lIDogJ3BpbS1lbXBsb3llZS1saXN0LXdvcmstc2hpZnRzJywgcGFyYW1zOiB7ZW1wbG95ZWVfaWQ6ICRyb3V0ZS5wYXJhbXMuZW1wbG95ZWVfaWR9fVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtY2xvY2stbyBtLXJpZ2h0LWFcXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgICAgIFdvcmsgU2hpZnRzXFxuICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDxsaSA6Y2xhc3M9XFxcInsnYWN0aXZlJzogJHJvdXRlLnBhdGguaW5kZXhPZignL3Byb2ZpbGUvc2FsYXJ5JykgPiAtMSB8fCAkcm91dGUucGF0aC5pbmRleE9mKCcvcGltL2VtcGxveWVlLWxpc3QvJyskcm91dGUucGFyYW1zLmVtcGxveWVlX2lkKycvc2FsYXJ5JykgPiAtMSwgJ25hdnknOiAkcm91dGUucGF0aC5pbmRleE9mKCcvcGltJykgPiAtMSB9XFxcIj5cXG4gICAgICAgICAgICAgICAgPGEgdi1pZj1cXFwiJHJvdXRlLnBhdGguaW5kZXhPZignL3Byb2ZpbGUnKSA+IC0xXFxcIiB2LWxpbms9XFxcIntuYW1lIDogJ3Byb2ZpbGUtc2FsYXJ5J31cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLW1vbmV5IG0tcmlnaHQtYVxcXCI+PC9pPlxcbiAgICAgICAgICAgICAgICAgICAgU2FsYXJ5XFxuICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgPGEgdi1pZj1cXFwiJHJvdXRlLnBhdGguaW5kZXhPZignL3BpbScpID4gLTFcXFwiIHYtbGluaz1cXFwie25hbWUgOiAncGltLWVtcGxveWVlLWxpc3Qtc2FsYXJ5JywgcGFyYW1zOiB7ZW1wbG95ZWVfaWQ6ICRyb3V0ZS5wYXJhbXMuZW1wbG95ZWVfaWR9fVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtbW9uZXkgbS1yaWdodC1hXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgICAgICBTYWxhcnlcXG4gICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPGxpIDpjbGFzcz1cXFwieydhY3RpdmUnOiAkcm91dGUucGF0aC5pbmRleE9mKCcvcHJvZmlsZS9xdWFsaWZpY2F0aW9ucycpID4gLTEgfHwgJHJvdXRlLnBhdGguaW5kZXhPZignL3BpbS9lbXBsb3llZS1saXN0LycrJHJvdXRlLnBhcmFtcy5lbXBsb3llZV9pZCsnL3F1YWxpZmljYXRpb25zJykgPiAtMSwgJ25hdnknOiAkcm91dGUucGF0aC5pbmRleE9mKCcvcGltJykgPiAtMSB9XFxcIj5cXG4gICAgICAgICAgICAgICAgPGEgdi1pZj1cXFwiJHJvdXRlLnBhdGguaW5kZXhPZignL3Byb2ZpbGUnKSA+IC0xXFxcIiB2LWxpbms9XFxcIntuYW1lIDogJ3Byb2ZpbGUtcXVhbGlmaWNhdGlvbnMnfVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtYm9va21hcmsgbS1yaWdodC1hXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgICAgICBRdWFsaWZpY2F0aW9uc1xcbiAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgIDxhIHYtaWY9XFxcIiRyb3V0ZS5wYXRoLmluZGV4T2YoJy9waW0nKSA+IC0xXFxcIiB2LWxpbms9XFxcIntuYW1lIDogJ3BpbS1lbXBsb3llZS1saXN0LXF1YWxpZmljYXRpb25zJywgcGFyYW1zOiB7ZW1wbG95ZWVfaWQ6ICRyb3V0ZS5wYXJhbXMuZW1wbG95ZWVfaWR9fVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtYm9va21hcmsgbS1yaWdodC1hXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgICAgICBRdWFsaWZpY2F0aW9uc1xcbiAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgPC9saT5cXG4gICAgICAgIDwvdWw+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9ia2ludGFuYXIvU2l0ZXMvaHJpcy93ZWIvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYXJ0aWFscy9uYXZiYXItc3RhdGljLXByb2ZpbGUtdG9wLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hdmxpbmtzOiAnJyxcbiAgICAgICAgICAgIGVtcGxveW1lbnRfc3RhdHVzOiB7fSxcbiAgICAgICAgICAgIGpvYl90aXRsZXM6IHt9LFxuICAgICAgICAgICAgZW1wbG95ZWU6IHt9XG4gICAgICAgIH07XG4gICAgfSxcbiAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLiRvbignc2V0LXNpZGViYXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm5hdmxpbmtzID0gSlNPTi5wYXJzZShhdG9iKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzaWRlYmFyJykpKTtcbiAgICAgICAgICAgICQoJyNzaWRlLW1lbnUnKS5tZXRpc01lbnUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPGxpIHYtZm9yPVxcXCJuYXZsaW5rIGluIG5hdmxpbmtzXFxcIiB2LWJpbmQ6Y2xhc3M9XFxcInsgJ2FjdGl2ZSc6ICRyb3V0ZS5wYXRoLmluZGV4T2YoJy8nK25hdmxpbmsuaHJlZikgPT0gMCwgJ25hdnknOiBuYXZsaW5rLmhyZWYuaW5kZXhPZigncGltJykgPT0gMCB8fCBuYXZsaW5rLmhyZWYuaW5kZXhPZignYWRtaW4nKSA9PSAwIH1cXFwiPlxcbiAgICA8YSB2LWxpbms9XFxcIntuYW1lOiBuYXZsaW5rLnJvdXRlfVxcXCI+XFxuICAgICAgICA8aSBjbGFzcz1cXFwiZmEge3tuYXZsaW5rLmljb259fVxcXCI+PC9pPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5hdi1sYWJlbFxcXCI+e3tuYXZsaW5rLm5hbWV9fTwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIHYtaWY9XFxcIm5hdmxpbmsuY2hpbGRyZW4ubGVuZ3RoXFxcIiBjbGFzcz1cXFwiZmEgYXJyb3dcXFwiPjwvc3Bhbj5cXG4gICAgPC9hPlxcbiAgICA8dWwgY2xhc3M9XFxcIm5hdiBuYXYtc2Vjb25kLWxldmVsIGNvbGxhcHNlXFxcIiB2LWJpbmQ6Y2xhc3M9XFxcInsgJ2luJzogJHJvdXRlLnBhdGguaW5kZXhPZignLycrbmF2bGluay5ocmVmKSA9PSAwIH1cXFwiIHYtaWY9XFxcIm5hdmxpbmsuY2hpbGRyZW4ubGVuZ3RoXFxcIj5cXG4gICAgICAgIDxsaSB2LWZvcj1cXFwiY2hpbGQgaW4gbmF2bGluay5jaGlsZHJlblxcXCIgdi1iaW5kOmNsYXNzPVxcXCJ7ICdhY3RpdmUnOiAkcm91dGUucGF0aC5pbmRleE9mKCcvJytjaGlsZC5ocmVmKSA9PSAwLCAnbmF2eSc6IGNoaWxkLmhyZWYuaW5kZXhPZigncGltJykgPT0gMCB8fCBjaGlsZC5ocmVmLmluZGV4T2YoJ2FkbWluJykgPT0gMCB9XFxcIj5cXG4gICAgICAgICAgICA8YSB2LWxpbms9XFxcIntuYW1lIDogY2hpbGQucm91dGV9XFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIHt7Y2hpbGQuaWNvbn19XFxcIj48L2k+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJuYXYtbGFiZWxcXFwiPnt7Y2hpbGQubmFtZX19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8c3BhbiB2LWlmPVxcXCJjaGlsZC5jaGlsZHJlbi5sZW5ndGhcXFwiIGNsYXNzPVxcXCJmYSBhcnJvd1xcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8dWwgY2xhc3M9XFxcIm5hdiBuYXYtdGhpcmQtbGV2ZWwgY29sbGFwc2VcXFwiIHYtYmluZDpjbGFzcz1cXFwieyAnaW4nOiAkcm91dGUucGF0aC5pbmRleE9mKCcvJytjaGlsZC5ocmVmKSA9PSAwIH1cXFwiIHYtaWY9XFxcImNoaWxkLmNoaWxkcmVuLmxlbmd0aFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsaSB2LWZvcj1cXFwiZ3JhbmRjaGlsZCBpbiBjaGlsZC5jaGlsZHJlblxcXCIgdi1iaW5kOmNsYXNzPVxcXCJ7ICdhY3RpdmUnOiAkcm91dGUucGF0aC5pbmRleE9mKCcvJytncmFuZGNoaWxkLmhyZWYpID09IDAsICduYXZ5JzogZ3JhbmRjaGlsZC5ocmVmLmluZGV4T2YoJ3BpbScpID09IDAgfHwgZ3JhbmRjaGlsZC5ocmVmLmluZGV4T2YoJ2FkbWluJykgPT0gMCB9XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxhIHYtbGluaz1cXFwie25hbWUgOiBncmFuZGNoaWxkLnJvdXRlfVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIHt7Z3JhbmRjaGlsZC5pY29ufX1cXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibmF2LWxhYmVsXFxcIj57e2dyYW5kY2hpbGQubmFtZX19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtaWY9XFxcImdyYW5kY2hpbGQuY2hpbGRyZW4ubGVuZ3RoXFxcIiBjbGFzcz1cXFwiZmEgYXJyb3dcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgPC9saT5cXG4gICAgPC91bD5cXG48L2xpPlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9ia2ludGFuYXIvU2l0ZXMvaHJpcy93ZWIvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYXJ0aWFscy9uYXZiYXItc3RhdGljLXNpZGUudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGRvTG9nb3V0OiBmdW5jdGlvbiBkb0xvZ291dCgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgY2xpZW50KHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnL2xvZ291dCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdqd3QtdG9rZW4nKSB9XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdmF0YXInKTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnZW1wbG95ZWVfaWQnKTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnand0LXRva2VuJyk7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2xvZ2dlZCcpO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwZXJtaXNzaW9ucycpO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdzaWRlYmFyJyk7XG4gICAgICAgICAgICAgICAgc2VsZi4kcm91dGUucm91dGVyLmdvKHsgbmFtZTogJ2xvZ2luJyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPG5hdiBjbGFzcz1cXFwibmF2YmFyIG5hdmJhci1zdGF0aWMtdG9wICBcXFwiIHJvbGU9XFxcIm5hdmlnYXRpb25cXFwiIHN0eWxlPVxcXCJtYXJnaW4tYm90dG9tOiAwXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWhlYWRlclxcXCI+XFxuICAgICAgICA8YSBjbGFzcz1cXFwibmF2YmFyLW1pbmltYWxpemUgbWluaW1hbGl6ZS1zdHlsLTIgYnRuIGJ0bi1naG9zdFxcXCIgaHJlZj1cXFwiI1xcXCI+XFxuICAgICAgICAgICAgPHNwYW4+PC9zcGFuPlxcbiAgICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cXG4gICAgICAgICAgICA8c3Bhbj48L3NwYW4+XFxuICAgICAgICA8L2E+XFxuICAgICAgICA8Zm9ybSByb2xlPVxcXCJzZWFyY2hcXFwiIGNsYXNzPVxcXCJuYXZiYXItZm9ybS1jdXN0b21cXFwiIG1ldGhvZD1cXFwicG9zdFxcXCIgYWN0aW9uPVxcXCJzZWFyY2hfcmVzdWx0cy5odG1sXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJTZWFyY2ggZm9yIHNvbWV0aGluZy4uLlxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgbmFtZT1cXFwidG9wLXNlYXJjaFxcXCIgaWQ9XFxcInRvcC1zZWFyY2hcXFwiPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9mb3JtPlxcbiAgICA8L2Rpdj5cXG4gICAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2YmFyLXRvcC1saW5rcyBuYXZiYXItcmlnaHRcXFwiPlxcbiAgICAgICAgPGxpPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJtLXItc20gdGV4dC1tdXRlZCB3ZWxjb21lLW1lc3NhZ2UgdmlzaWJsZS1tZC1ibG9jayB2aXNpYmxlLWxnLWJsb2NrXFxcIj5XZWxjb21lIHRvIEhSaXMuPC9zcGFuPlxcbiAgICAgICAgPC9saT5cXG4gICAgICAgIDxsaSBjbGFzcz1cXFwiZHJvcGRvd25cXFwiPlxcbiAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJkcm9wZG93bi10b2dnbGUgY291bnQtaW5mb1xcXCIgZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIiBocmVmPVxcXCIjXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWVudmVsb3BlXFxcIj48L2k+IDxzcGFuIGNsYXNzPVxcXCJsYWJlbCBsYWJlbC13YXJuaW5nXFxcIj4xNjwvc3Bhbj5cXG4gICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51IGRyb3Bkb3duLW1lc3NhZ2VzXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZHJvcGRvd24tbWVzc2FnZXMtYm94XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCJwcm9maWxlLmh0bWxcXFwiIGNsYXNzPVxcXCJwdWxsLWxlZnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tPGltZyBhbHQ9XFxcImltYWdlXFxcIiBjbGFzcz1cXFwiaW1nLWNpcmNsZVxcXCIgc3JjPVxcXCIvaW1nL2E3LmpwZ1xcXCI+LS0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1lZGlhLWJvZHlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiPjQ2aCBhZ288L3NtYWxsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPk1pa2UgTG9yZWlwc3VtPC9zdHJvbmc+IHN0YXJ0ZWQgZm9sbG93aW5nIDxzdHJvbmc+TW9uaWNhIFNtaXRoPC9zdHJvbmc+LiA8YnI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cXFwidGV4dC1tdXRlZFxcXCI+MyBkYXlzIGFnbyBhdCA3OjU4IHBtIC0gMTAuMDYuMjAxNDwvc21hbGw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJkaXZpZGVyXFxcIj48L2xpPlxcbiAgICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkcm9wZG93bi1tZXNzYWdlcy1ib3hcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcInByb2ZpbGUuaHRtbFxcXCIgY2xhc3M9XFxcInB1bGwtbGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS08aW1nIGFsdD1cXFwiaW1hZ2VcXFwiIGNsYXNzPVxcXCJpbWctY2lyY2xlXFxcIiBzcmM9XFxcIi9pbWcvYTQuanBnXFxcIj4tLT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibWVkaWEtYm9keSBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XFxcInB1bGwtcmlnaHQgdGV4dC1uYXZ5XFxcIj41aCBhZ288L3NtYWxsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPkNocmlzIEpvaG5hdGFuIE92ZXJ0dW5rPC9zdHJvbmc+IHN0YXJ0ZWQgZm9sbG93aW5nIDxzdHJvbmc+TW9uaWNhIFNtaXRoPC9zdHJvbmc+LlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cXFwidGV4dC1tdXRlZFxcXCI+WWVzdGVyZGF5IDE6MjEgcG0gLSAxMS4wNi4yMDE0PC9zbWFsbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcImRpdmlkZXJcXFwiPjwvbGk+XFxuICAgICAgICAgICAgICAgIDxsaT5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRyb3Bkb3duLW1lc3NhZ2VzLWJveFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwicHJvZmlsZS5odG1sXFxcIiBjbGFzcz1cXFwicHVsbC1sZWZ0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLTxpbWcgYWx0PVxcXCJpbWFnZVxcXCIgY2xhc3M9XFxcImltZy1jaXJjbGVcXFwiIHNyYz1cXFwiL2ltZy9wcm9maWxlLmpwZ1xcXCI+LS0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1lZGlhLWJvZHkgXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVxcXCJwdWxsLXJpZ2h0XFxcIj4yM2ggYWdvPC9zbWFsbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cm9uZz5Nb25pY2EgU21pdGg8L3N0cm9uZz4gbG92ZSA8c3Ryb25nPktpbSBTbWl0aDwvc3Ryb25nPi4gPGJyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XFxcInRleHQtbXV0ZWRcXFwiPjIgZGF5cyBhZ28gYXQgMjozMCBhbSAtIDExLjA2LjIwMTQ8L3NtYWxsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwiZGl2aWRlclxcXCI+PC9saT5cXG4gICAgICAgICAgICAgICAgPGxpPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidGV4dC1jZW50ZXIgbGluay1ibG9ja1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwibWFpbGJveC5odG1sXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWVudmVsb3BlXFxcIj48L2k+IDxzdHJvbmc+UmVhZCBBbGwgTWVzc2FnZXM8L3N0cm9uZz5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgPC9saT5cXG4gICAgICAgIDxsaSBjbGFzcz1cXFwiZHJvcGRvd25cXFwiPlxcbiAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJkcm9wZG93bi10b2dnbGUgY291bnQtaW5mb1xcXCIgZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIiBocmVmPVxcXCIjXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWJlbGxcXFwiPjwvaT4gPHNwYW4gY2xhc3M9XFxcImxhYmVsIGxhYmVsLXByaW1hcnlcXFwiPjg8L3NwYW4+XFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwiZHJvcGRvd24tbWVudSBkcm9wZG93bi1hbGVydHNcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCJtYWlsYm94Lmh0bWxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1lbnZlbG9wZSBmYS1md1xcXCI+PC9pPiBZb3UgaGF2ZSAxNiBtZXNzYWdlc1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicHVsbC1yaWdodCB0ZXh0LW11dGVkIHNtYWxsXFxcIj40IG1pbnV0ZXMgYWdvPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcImRpdmlkZXJcXFwiPjwvbGk+XFxuICAgICAgICAgICAgICAgIDxsaT5cXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcInByb2ZpbGUuaHRtbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXR3aXR0ZXIgZmEtZndcXFwiPjwvaT4gMyBOZXcgRm9sbG93ZXJzXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJwdWxsLXJpZ2h0IHRleHQtbXV0ZWQgc21hbGxcXFwiPjEyIG1pbnV0ZXMgYWdvPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcImRpdmlkZXJcXFwiPjwvbGk+XFxuICAgICAgICAgICAgICAgIDxsaT5cXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcImdyaWRfb3B0aW9ucy5odG1sXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtdXBsb2FkIGZhLWZ3XFxcIj48L2k+IFNlcnZlciBSZWJvb3RlZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicHVsbC1yaWdodCB0ZXh0LW11dGVkIHNtYWxsXFxcIj40IG1pbnV0ZXMgYWdvPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcImRpdmlkZXJcXFwiPjwvbGk+XFxuICAgICAgICAgICAgICAgIDxsaT5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRleHQtY2VudGVyIGxpbmstYmxvY2tcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIm5vdGlmaWNhdGlvbnMuaHRtbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJvbmc+U2VlIEFsbCBBbGVydHM8L3N0cm9uZz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWFuZ2xlLXJpZ2h0XFxcIj48L2k+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgIDwvbGk+XFxuXFxuXFxuICAgICAgICA8bGk+XFxuICAgICAgICAgICAgPGEgQGNsaWNrPVxcXCJkb0xvZ291dFxcXCI+XFxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1zaWduLW91dFxcXCI+PC9pPiBMb2cgb3V0XFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgPC9saT5cXG4gICAgPC91bD5cXG5cXG48L25hdj5cXG5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvYmtpbnRhbmFyL1NpdGVzL2hyaXMvd2ViL3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFydGlhbHMvbmF2YmFyLXN0YXRpYy10b3AudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJmb290ZXIgZml4ZWRcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0XFxcIj5cXG4gICAgICAgIDEwR0Igb2YgPHN0cm9uZz4yNTBHQjwvc3Ryb25nPiBGcmVlLlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdj5cXG4gICAgICAgIDxzdHJvbmc+Q29weXJpZ2h0PC9zdHJvbmc+IGIzIFN0dWRpb3MgwqkgMjAxNFxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvYmtpbnRhbmFyL1NpdGVzL2hyaXMvd2ViL3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFydGlhbHMvc3RhdGljLWZvb3Rlci52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCJ2YXIgY29uZmlnID0ge1xuICAgIGVudjogJ2RldmVsb3BtZW50JyxcbiAgICBhcGk6IHtcbiAgICAgICAgYmFzZV91cmw6ICdodHRwOi8vYXBpLmhyaXMuZGV2L2FwaScsXG4gICAgICAgIGRlZmF1bHRSZXF1ZXN0OiB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzb2NpYWw6IHtcbiAgICAgICAgZmFjZWJvb2s6ICcnLFxuICAgICAgICB0d2l0dGVyOiAnJyxcbiAgICAgICAgZ2l0aHViOiAnJ1xuICAgIH0sXG4gICAgZGVidWc6IHRydWVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29uZmlnO1xuIiwidmFyIGVudiA9IHByb2Nlc3MuZW52LkFQUF9FTlYgfHwgJ2RldmVsb3BtZW50JztcblxudmFyIGNvbmZpZyA9IHtcbiAgICBkZXZlbG9wbWVudDogcmVxdWlyZSgnLi9kZXZlbG9wbWVudC5jb25maWcnKSxcbiAgICBwcm9kdWN0aW9uOiByZXF1aXJlKCcuL3Byb2R1Y3Rpb24uY29uZmlnJyksXG4gICAgc3RhZ2luZzogcmVxdWlyZSgnLi9zdGFnaW5nLmNvbmZpZycpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZ1tlbnZdO1xuIiwidmFyIGNvbmZpZyA9IHtcbiAgZW52OiAncHJvZHVjdGlvbicsXG4gIGFwaToge1xuICAgIGJhc2VfdXJsOiAnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaScsXG4gICAgZGVmYXVsdFJlcXVlc3Q6IHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ1gtUmVxdWVzdGVkLVdpdGgnOiAncmVzdC5qcycsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNvY2lhbDoge1xuICAgIGZhY2Vib29rOiAnJyxcbiAgICB0d2l0dGVyOiAnJyxcbiAgICBnaXRodWI6ICcnXG4gIH0sXG4gIGRlYnVnOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb25maWc7XG4iLCJ2YXIgY29uZmlnID0ge1xuICAgIGVudjogJ3N0YWdpbmcnLFxuICAgIGFwaToge1xuICAgICAgICBiYXNlX3VybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9hcGknLFxuICAgICAgICBkZWZhdWx0UmVxdWVzdDoge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdYLVJlcXVlc3RlZC1XaXRoJzogJ3Jlc3QuanMnLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgc29jaWFsOiB7XG4gICAgICAgIGZhY2Vib29rOiAnJyxcbiAgICAgICAgdHdpdHRlcjogJycsXG4gICAgICAgIGdpdGh1YjogJydcbiAgICB9LFxuICAgIGRlYnVnOiB0cnVlXG59O1xubW9kdWxlLmV4cG9ydHMgPSBjb25maWc7XG4iLCIoZnVuY3Rpb24gKGRlZmluZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgICAgIHZhciBpbnRlcmNlcHRvcjtcblxuICAgICAgICBpbnRlcmNlcHRvciA9IHJlcXVpcmUoJ3Jlc3QvaW50ZXJjZXB0b3InKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXV0aGVudGljYXRlcyB0aGUgcmVxdWVzdCB1c2luZyBKV1QgQXV0aGVudGljYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtDbGllbnR9IFtjbGllbnRdIGNsaWVudCB0byB3cmFwXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge0NsaWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBpbnRlcmNlcHRvcih7XG4gICAgICAgICAgICByZXF1ZXN0OiBmdW5jdGlvbiAocmVxdWVzdCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuLCBoZWFkZXJzO1xuXG4gICAgICAgICAgICAgICAgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnand0LXRva2VuJyk7XG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycyB8fCAocmVxdWVzdC5oZWFkZXJzID0ge30pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBudWxsICYmIHRva2VuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNwb25zZTogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAmJiByZXNwb25zZS5zdGF0dXMuY29kZSA9PSA0MDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2p3dC10b2tlbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVycyAmJiByZXNwb25zZS5oZWFkZXJzLkF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2p3dC10b2tlbicsIHJlc3BvbnNlLmhlYWRlcnMuQXV0aG9yaXphdGlvbilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVudGl0eSAmJiByZXNwb25zZS5lbnRpdHkudG9rZW4gJiYgcmVzcG9uc2UuZW50aXR5LnRva2VuLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdqd3QtdG9rZW4nLCAnQmVhcmVyICcgKyByZXNwb25zZS5lbnRpdHkudG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbn0oXG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpO1xuICAgIH1cbiAgICAvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgY29uZmlnUm91dGVyOiBmdW5jdGlvbiAocm91dGVyKSB7XG5cbiAgICAgICAgcm91dGVyLm1hcCh7XG4gICAgICAgICAgICAnKic6IHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvNDA0LnZ1ZScpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2Vycm9yLTQwNCc6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnZXJyb3ItNDA0JyxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvNDA0LnZ1ZScpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy8nOiB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL2RlZmF1bHQtcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICBzdWJSb3V0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgJy9kYXNoYm9hcmQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZGFzaGJvYXJkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9kYXNoYm9hcmQudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICcvcHJvZmlsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwcm9maWxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wYWdlLnZ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlJvdXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvcGVyc29uYWwtZGV0YWlscyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb2ZpbGUtcGVyc29uYWwtZGV0YWlscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wcm9maWxlL3BlcnNvbmFsLWRldGFpbHMudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGg6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvY29udGFjdC1kZXRhaWxzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJvZmlsZS1jb250YWN0LWRldGFpbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcHJvZmlsZS9jb250YWN0LWRldGFpbHMudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGg6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvZW1lcmdlbmN5LWNvbnRhY3RzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJvZmlsZS1lbWVyZ2VuY3ktY29udGFjdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcHJvZmlsZS9lbWVyZ2VuY3ktY29udGFjdHMudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGg6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvZGVwZW5kZW50cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb2ZpbGUtZGVwZW5kZW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wcm9maWxlL2RlcGVuZGVudHMudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGg6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvam9iJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJvZmlsZS1qb2InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy93b3JrLXNoaWZ0cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb2ZpbGUtd29yay1zaGlmdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9zYWxhcnknOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwcm9maWxlLXNhbGFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wYWdlLnZ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3F1YWxpZmljYXRpb25zJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJvZmlsZS1xdWFsaWZpY2F0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wYWdlLnZ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnL3ByZXNlbmNlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wYWdlLnZ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnL3BlcmZvcm1hbmNlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3BlcmZvcm1hbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wYWdlLnZ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlJvdXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvbXktdHJhY2tlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3BlcmZvcm1hbmNlLW15LXRyYWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9lbXBsb3llZS10cmFja2VyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncGVyZm9ybWFuY2UtZW1wbG95ZWUtdHJhY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wYWdlLnZ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL2NvbmZpZ3VyYXRpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwZXJmb3JtYW5jZS1jb25maWd1cmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL3BhZ2UudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlJvdXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy90cmFja2Vycyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncGVyZm9ybWFuY2UtY29uZmlndXJhdGlvbi10cmFja2VycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL3BhZ2UudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnL3RpbWUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndGltZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJSb3V0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL2F0dGVuZGFuY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0aW1lLWF0dGVuZGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViUm91dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL2VtcGxveWVlLXJlY29yZHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RpbWUtYXR0ZW5kYW5jZS1lbXBsb3llZS1yZWNvcmRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9vdmVydGltZS1yZWNvcmRzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0aW1lLWF0dGVuZGFuY2Utb3ZlcnRpbWUtcmVjb3JkcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL3BhZ2UudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3JlcXVpc2l0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndGltZS1yZXF1aXNpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wYWdlLnZ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL2hvbGlkYXlzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndGltZS1ob2xpZGF5cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wYWdlLnZ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL2hvbGlkYXlzLWFuZC1ldmVudHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0aW1lLWhvbGlkYXlzLWFuZC1ldmVudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJy9waW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncGltJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wYWdlLnZ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlJvdXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvZW1wbG95ZWUtbGlzdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3BpbS1lbXBsb3llZS1saXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL3BhZ2UudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGg6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvZW1wbG95ZWUtbGlzdC86ZW1wbG95ZWVfaWQvcGVyc29uYWwtZGV0YWlscyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3BpbS1lbXBsb3llZS1saXN0LXBlcnNvbmFsLWRldGFpbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcHJvZmlsZS9wZXJzb25hbC1kZXRhaWxzLnZ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL2VtcGxveWVlLWxpc3QvOmVtcGxveWVlX2lkL2NvbnRhY3QtZGV0YWlscyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3BpbS1lbXBsb3llZS1saXN0LWNvbnRhY3QtZGV0YWlscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wcm9maWxlL2NvbnRhY3QtZGV0YWlscy52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9lbXBsb3llZS1saXN0LzplbXBsb3llZV9pZC9lbWVyZ2VuY3ktY29udGFjdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwaW0tZW1wbG95ZWUtbGlzdC1lbWVyZ2VuY3ktY29udGFjdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcHJvZmlsZS9lbWVyZ2VuY3ktY29udGFjdHMudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGg6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvZW1wbG95ZWUtbGlzdC86ZW1wbG95ZWVfaWQvZGVwZW5kZW50cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3BpbS1lbXBsb3llZS1saXN0LWRlcGVuZGVudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcHJvZmlsZS9kZXBlbmRlbnRzLnZ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL2VtcGxveWVlLWxpc3QvOmVtcGxveWVlX2lkL2pvYic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3BpbS1lbXBsb3llZS1saXN0LWpvYicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wYWdlLnZ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL2VtcGxveWVlLWxpc3QvOmVtcGxveWVlX2lkL3dvcmstc2hpZnRzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncGltLWVtcGxveWVlLWxpc3Qtd29yay1zaGlmdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9lbXBsb3llZS1saXN0LzplbXBsb3llZV9pZC9zYWxhcnknOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwaW0tZW1wbG95ZWUtbGlzdC1zYWxhcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9lbXBsb3llZS1saXN0LzplbXBsb3llZV9pZC9xdWFsaWZpY2F0aW9ucyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3BpbS1lbXBsb3llZS1saXN0LXF1YWxpZmljYXRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL3BhZ2UudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGg6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvY29uZmlndXJhdGlvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3BpbS1jb25maWd1cmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL3BhZ2UudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlJvdXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy90ZXJtaW5hdGlvbi1yZWFzb25zJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwaW0tY29uZmlndXJhdGlvbi10ZXJtaW5hdGlvbi1yZWFzb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9jdXN0b20tZmllbGQtc2VjdGlvbnMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3BpbS1jb25maWd1cmF0aW9uLWN1c3RvbS1maWVsZC1zZWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL3BhZ2UudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnL2FkbWluJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2FkbWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wYWdlLnZ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlJvdXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvdXNlci1tYW5hZ2VtZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRtaW4tdXNlci1tYW5hZ2VtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL3BhZ2UudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGg6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvam9iJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRtaW4tam9iJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL3BhZ2UudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlJvdXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy90aXRsZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2FkbWluLWpvYi10aXRsZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9wYWdlLnZ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGg6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3BheS1ncmFkZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2FkbWluLWpvYi1wYXktZ3JhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9lbXBsb3ltZW50LXN0YXR1cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRtaW4tam9iLWVtcGxveW1lbnQtc3RhdHVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9jYXRlZ29yaWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhZG1pbi1qb2ItY2F0ZWdvcmllcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL3BhZ2UudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvd29yay1zaGlmdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2FkbWluLWpvYi13b3JrLXNoaWZ0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL3BhZ2UudnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3F1YWxpZmljYXRpb25zJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRtaW4tcXVhbGlmaWNhdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViUm91dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3NraWxscyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRtaW4tcXVhbGlmaWNhdGlvbnMtc2tpbGxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9lZHVjYXRpb25zJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhZG1pbi1xdWFsaWZpY2F0aW9ucy1lZHVjYXRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGFnZS52dWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy9sb2dpbic6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnbG9naW4nLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9hdXRoL2xvZ2luLnZ1ZScpLFxuICAgICAgICAgICAgICAgIGd1ZXN0OiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJvdXRlci5yZWRpcmVjdCh7XG4gICAgICAgICAgICAnLyc6ICcvZGFzaGJvYXJkJyxcbiAgICAgICAgICAgICcvcHJvZmlsZSc6ICcvcHJvZmlsZS9wZXJzb25hbC1kZXRhaWxzJyxcbiAgICAgICAgICAgICcvcGltJzogJy9waW0vZW1wbG95ZWUtbGlzdCcsXG4gICAgICAgICAgICAnL2FkbWluL2pvYic6ICcvYWRtaW4vam9iL3RpdGxlcycsXG4gICAgICAgICAgICAnL2FkbWluL3F1YWxpZmljYXRpb25zJzogJy9hZG1pbi9xdWFsaWZpY2F0aW9ucy9za2lsbHMnLFxuICAgICAgICAgICAgJy90cmFuc2xhdG9yJzogJy90cmFuc2xhdG9yL3RyYW5zbGF0aW9ucydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcm91dGVyLmJlZm9yZUVhY2goZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcblxuICAgICAgICAgICAgdmFyIGF1dGggPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnand0LXRva2VuJyk7XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uLnRvLmF1dGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0aCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnL2F1dGgvcmVmcmVzaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeydBdXRob3JpemF0aW9uJzogbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2p3dC10b2tlbicpfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudChwYXJhbXMpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHJlc3BvbnNlLnJlcXVlc3QuaGVhZGVycy5BdXRob3JpemF0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2p3dC10b2tlbicsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLnJlZGlyZWN0KCcvbG9naW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLnJlZGlyZWN0KCcvbG9naW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uLnRvLnBhdGggPT0gJy9sb2dpbicgJiYgYXV0aCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLnJlZGlyZWN0KCcvZGFzaGJvYXJkJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cbjtcbiJdfQ==\n"],"file":"app.js","sourceRoot":"/source/"}